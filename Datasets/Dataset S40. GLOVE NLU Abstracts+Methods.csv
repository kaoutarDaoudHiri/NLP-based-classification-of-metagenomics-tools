,Unnamed: 0,text,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,Category,Category_Code
0,0,"gap blast  psiblast  new generation  protein database search programs
 blast program  widely use tool  search protein  dna databases  sequence similarities  protein comparisons  variety  definitional algorithmic  statistical refinements describe  permit  execution time   blast program   decrease substantially  enhance  sensitivity  weak similarities  new criterion  trigger  extension  word hit combine   new heuristic  generate gap alignments yield  gap blast program  run  approximately three time  speed   original  addition  method  introduce  automatically combine statistically significant alignments produce  blast   positionspecific score matrix  search  database use  matrix  result positionspecific iterate blast psiblast program run  approximately   speed per iteration  gap blast   many case  much  sensitive  weak  biologically relevant sequence similarities psiblast  use  uncover several new  interest members   brct superfamily
 central idea   blast algorithm    statistically significant alignment  likely  contain  highscoring pair  align word blast first scan  database  word typically  length three  proteins  score  least   align   word within  query sequence  align word pair satisfy  condition  call  hit  second step   algorithm check whether  hit lie within  alignment  score sufficient   report     extend  hit   directions   run alignments score  drop      maximum score yet attain  extension step  computationally quite costly      parameters necessary  attain reasonable sensitivity  weak alignments  extension step typically account    blast execution time   therefore desirable  reduce  number  extensions perform  refine algorithm  base upon  observation   hsp  interest  much longer   single word pair  may therefore entail multiple hit    diagonal  within  relatively short distance  one another  diagonal   hit involve word start  position     database  query sequence may  define      distance  two hit    diagonal   difference   first coordinate  signature may  use  locate hsps  efficiently specifically  choose  window length   invoke  extension   two nonoverlapping hit  find within distance   one another    diagonal  hit  overlap   recent one  ignore efficient execution require  array  record   diagonal  first coordinate    recent hit find since database sequence  scan sequentially  coordinate always increase  successive hit  idea  seek multiple hit    diagonal  first use   context  biological database search  wilbur  lipman    require two hit rather  one  invoke  extension  threshold parameter  must  lower  retain comparable sensitivity  effect   many  single hit  find    small fraction   associate second hit    diagonal  trigger  extension  great majority  hit may  dismiss   minor calculation  look    appropriate diagonal  coordinate    recent hit check whether   within distance    current hit coordinate  finally replace  old   new coordinate empirically  computation save  require fewer extensions   offset  extra computation require  process  larger number  hit  study  relative abilities   onehit  twohit methods  detect hsps  vary score  model proteins use  background amino acid frequencies  robinson  robinson   use  blosum substitution matrix   sequence comparison give    sij  statistical parameters  ungapped local alignments  calculate          use equation    may calculate  qij    score system  optimize  employ  target frequencies  generate model hsps finally  evaluate  sensitivity   onehit  twohit blast heuristics use  hsps  onehit method  detect  hsp   somewhere contain  lengthw word  score  least          figure  show  empirically estimate probability   hsp  miss   method   function   normalize score  twohit method  detect  hsp   contain two nonoverlapping lengthw word  score  least   start position  differ      residues            figure  show  estimate probability   hsp  miss   method   function   normalize score  hsps  score  least  bits  twohit heuristic   sensitive  analyze  relative speed   onehit  twohit methods use  parameters study   note   twohit method generate  average  time  many hit    time  many hit extensions fig    take approximately one ninth  long  decide whether  hit need  extend  actually  extend   hitprocessing component   twohit method  approximately twice  rapid    component   onehit method figure  show  even  use  original onehit method  threshold parameter      generally  greater    chance  miss  hsp  score  bits   would appear sufficient   purpose  onehit default  parameter  typically  set  low   yield  execution time nearly three time       pay  price   appear  best marginal gain  sensitivity  reason    original blast program treat gap alignments implicitly  locate  many case several distinct hsps involve   database sequence  calculate  statistical assessment   combine result   mean  two   hsps  score well   bits   combination rise  statistical significance   one   hsps  miss  may   combine result  approach take  allow blast  simultaneously produce gap alignments  run significantly faster  previously  central idea   trigger  gap extension   hsp  exceed  moderate score  choose       one extension  invoke per  database sequence  equation    typicallength protein query    set   bits  gap extension take much longer  execute   ungapped extension   perform      fraction   total run time  consume   keep relatively low  seek  single gap alignment rather   collection  ungapped ones  one   constituent hsps need  locate   combine result   generate successfully  mean   may tolerate  much higher chance  miss  single moderately score hsp  example consider  result involve two hsps     probability    miss   hitstage   blast algorithm  suppose   desire  find  combine result  probability  least   original algorithm need  find  hsps require    ≤    less    contrast  new algorithm require    ≤   thus  tolerate   high    permit   parameter   hitstage   algorithm   raise substantially  retain comparable sensitivity—          onehit heuristic  twohit heuristic describe  lower  back      discuss   result increase  speed   compensate   extra time require   rare gap extension  summary  new gap blast algorithm require two nonoverlapping hit  score  least  within  distance   one another  invoke  ungapped extension   second hit   hsp generate  normalize score  least  bits   gap extension  trigger  result gap alignment  report      evalue low enough    interest  example   pairwise comparison  figure   ungapped extension invoke   hit pair   leave produce  hsp  score  bits calculate use      sufficient  trigger  gap extension  generate  alignment  score  bits calculate use     evalue   fig   original blast program locate   first  last ungapped segment   alignment fig   assign   combine evalue  time greater  standard dynamic program algorithms  pairwise sequence alignment perform  fix amount  computation per cell   path graph whose dimension   lengths   two sequence  compare   order  gain speed database search algorithms   fasta    earlier gap version  blast  sacrifice rigor  confine  dynamic program   band section   full path graph  choose  include  region  already identify similarity one problem   approach    optimal gap alignment may stray beyond  confine   band explore   width   band  increase  reduce  possibility  speed advantage   algorithm  vitiate   accordingly take  different heuristic approach  construct gap local alignments    simple generalization  blast method  construct hsps  central idea   consider  cells    optimal local alignment score fall       best alignment score yet find start   single align pair  residues call  seed  dynamic program proceed  forward  backward   path graph zheng zhang   manuscript  preparation figs     advantage   approach    region   path graph explore adapt   alignment  construct  alignment  wander arbitrarily many diagonals away   seed   number  cells expand   row tend  remain limit  may even shrink  zero   boundary   path graph  encounter fig    parameter serve  similar function   bandwidth parameter   earlier heuristic   region   path graph  implicitly specify  explore   general  productively choose  important element   heuristic   intelligent choice   seed give  hsp whose score  sufficiently high   trigger  gap extension   one choose  residue pair  force  alignment   sophisticate approach  possible  simple procedure   implement   locate along  hsp  length segment  highest alignment score  use  central residue pair   seed   hsp   shorter    central residue pair  choose  example  first ungapped region   alignment  figure  constitute  hsp  trigger  alignment  highestscoring length segment   hsp align leghemoglobin residues   βglobin residues  thus  alanine residues  respective position     use   seed   gap extension illustrate  figure   discuss   performance evaluation section   procedure  extremely good  select seed   fact participate   optimal alignment  gap extensions  trigger  chance similarities   therefore likely    limit extent  illustrate  figure   reverse extension   example explore  path graph cells    typical twoway gap extension    encounter  end  either sequence  expect  involve  cells    set    gap extension  invoke less   per  database sequence fewer   cells need  explore per database sequence  execution time require   gap extension   time    ungapped extension however  trigger gap extensions   manner describe  simultaneously raise    singlehit version  blast     approximately one gap extension  invoke  every  ungapped extensions avoid   number  ungapped extensions  reduce   two thirds  total time spend   extension stage  blast  cut  well  half  course  twohit strategy describe  reduce  time need   ungapped extensions still   program overhead  account   net speedup   factor   three   alignment actually report  gap extension  record traceback information  need   execute  increase blast accuracy  produce optimal local alignments  gap extensions use  default  substantially larger  parameter  employ   program search stage  time require  various step   blast algorithm vary substantially  one query  one database  another table  show typical relative time spend   original   gap blast program  various algorithmic stag  original blast program  represent      variant form  blastp version  modify    use   edgeeffect correction   background amino acid frequencies   gap blast  time represent  average  three different query   time   original blast program normalize   instance   units  concretely  search swissprot  release    sequence    residues   length influenza  virus hemagglutinin precursor   query  original blast program require     gap blast program    time experiment  others refer    run  one  mhz r10000 cpu processor   lightly load sgi power challenge  computer   gbytes  ram  machine run  operate system irix version     implementation  unix  use  standard sgi  compiler    flag  optimization  compile  versions   program  time report   user time give   time command     better  two identical run  closely relate type  gap extension routine   use   develop   myers   evaluation   original blast algorithm    include   publicly distribute code primarily    current strategy  extend every hit decrease  algorithms speed unduly   relatively small gain  sensitivity realize   discuss   statistical significance  gap alignments may  evaluate use  two statistical parameters     current version   fasta program  estimate  parameters   run  analyze  distribution  alignment score produce    sequence   database blast gain speed  produce alignments     database sequence likely   relate   query  therefore     option  estimate      fly instead  use estimate   parameters produce beforehand  random simulation   drawback   approach    program may  accept  arbitrary score system    simulation   perform  still produce accurate estimate  statistical significance  original blast program  contrast   deal   ungapped local alignments could derive     theory   score matrix ",-0.20133572986987427,0.20491735337247305,0.13105072219116834,0.16205891624002045,-0.02803262261266465,-0.026853463903203804,-0.1089579857366939,0.06762748744421147,-0.04289052975752817,0.13040867991846206,0.002586414999655709,-0.014828956401217694,0.16564756017266105,-0.13437961678323734,0.14860836206300254,-0.09067594140999556,-0.03747045668200996,0.20755485326840994,-0.07626493571047137,0.09629939661928552,0.08885089265168476,-0.2314816687414705,0.04093015084142661,-0.013395116223548971,-0.048908662604763606,-0.1652135122337125,0.003168880025557096,-0.2201869514806509,-0.04230298330408496,-0.05078944489985008,-0.001621965847536568,0.2962612508628491,-0.21224505134700908,-0.1045902886907738,0.19470678974612107,0.1494564047699354,0.06267675155892162,-0.03692560836048072,-0.06166645860280912,-0.11668109324887975,-0.09319013648620494,-0.15318001840348985,-0.04235652596552802,-0.1243921374359594,-0.11850963969062395,-0.006552950652719138,0.19245086914013212,-0.1618357070989419,-0.20948237764642025,-0.4353340957985318,0.1781160329241903,-0.02244565412919064,0.055564699985000326,0.6827646779732344,0.023082304645181267,-1.2741781524236735,0.05935583118017077,-0.21298958442153576,1.0799684546953259,0.21594063234776156,-0.15628338721028548,0.3548253714314625,-0.11846308710108347,0.0836026477048693,0.6236823257465318,0.019030614855287918,0.04372659392532958,0.022686159801610668,0.1924963140314793,-0.1639938209113308,-0.052676956797000095,-0.11123768110002746,0.10307912076433523,-0.11851141203426363,0.21550418854782985,-0.0552404440757845,-0.1966629737196844,-0.1787741697137995,-0.3685699754564243,-0.07681377602858643,0.2527712041212147,-0.030151911747173105,-0.4505246484608423,-0.07943112683246986,-0.9692447074561732,0.055545208995001635,0.23479472574757135,-0.1253136378397946,-0.1328487422288991,-0.06918529225493457,-0.20934954267684405,0.08168691755419348,-0.12931015226876,-0.14525039450608307,-0.18957203205088285,-0.0943323519764348,-0.08938018633671509,-0.3196221683311331,0.3458751341863933,0.059701033353414985,Alignment,0
1,1,"rapsearch  fast protein similarity search tool  short reads
next generation sequence ngs  produce enormous corpuses  short dna read affect emerge field like metagenomics protein similarity searcha key step  achieve annotation  proteincoding genes   short read  identification   biological functionsfaces daunt challenge     size   short read datasets  develop  fast protein similarity search tool rapsearch  utilize  reduce amino acid alphabet  suffix array  detect seed  flexible length  short read translate   frame  test rapsearch achieve ~ time speedup  compare  blastx rapsearch miss   small fraction ~  blastx similarity hit   also discover additional homologous proteins ~  blastx miss  contrast blat  tool   even slightly faster  rapsearch  significant loss  sensitivity  compare  rapsearch  blast  enable faster protein similarity search  application  rapsearch  metageomics  also  demonstrated
rapsearch adopt  seedextension approach  blast  identify  seed  maximal exact match mems   reduce alphabet sequence   query protein   reduce alphabet sequence   proteins   database follow  extend  evaluate    seed rapsearch employ  linear time algorithm  retrieve  mems  first build  suffix array   correspond longest common prefix lcp array  index  proteins   database    traverse  suffix array base   query protein  identify mems  subject   heuristic extension algorithm include  ungapped extension   gap extension similar  blast protein sequence seed use  reduce amino acid alphabet  first reduce amino acid alphabet  introduce  dill   hydrophobicpolar  model   study   fold  globular proteins  since       reduce alphabets  different size    propose  various purpose   recent study even demonstrate  reduce alphabet   sensitive  selective  identify remote homologous proteins   observations suggest  homologous proteins exhibit  higher sequence identity   reduce alphabet      alphabet indicate    possible  design efficient  sensitive seed base   reduce amino acid alphabet  select  appropriate reduce amino acid alphabet  rapsearch  carry   follow experiment use  balibase database   collect  pair  distant homologous proteins  share ~ sequence identify   pair  proteins  different families  serve  nonhomologous proteins   alphabet   length  compute  coverage  efficiency   correspond seed  coverage  define   fraction  homolog proteins contain  least one seed match   efficiency  define   log ratio   number  homologous  nonhomologous proteins contain  least one seed match seed identification  use suffix array  essential procedure  rapsearch   seedextension tool like blast  use hash table instead  suffix array    choose appropriate seed  extension    time consume  find  seed   commonly use strategy   define  cutoff   minimum seed sizea small cutoff may result   huge amount  seed   extend thus slow   similarity search whereas  large cutoff may miss  seed  otherwise may lead  significant alignments blast use minimum size   residues  proteins  also require    two seed    diagonal  span     certain length rapsearch  extend  single seed    identify  look    suffix array  target protein sequence  rapsearch use reduce alphabets  present proteins rapsearch  use longer seed cutoff thus achieve faster similarity search minimal seed selection algorithm rapsearch generate seed   minimal length   amino acids  longer seed  frequent word  shorter seed  rare word rapsearch decide  minimum length  seed start   particular query position base   frequency   mers start   position   minimum length   seed  select   particular position   seed   least  require length   retrieve  look    precomputed suffix array  protein similarity search database  minimum seed length selection algorithm  show  follow   give position    query sequence seed length selection algorithm position  minseed   addlen   hexmerf   frequency   mer start  position  medianf   median   frequencies   mers   protein database expectf  hexmerf  expectf  medianf # aacompk   frequency   correspond amino acid  position   expectf * aacompi  addlen    medianf addlen  addlen   expectf  expectf * aacompi  addlen   minseed  minseed  addlen return minseed seed  mismatch   consider seed  mismatch  mismatch     handle  reduce alphabets long seed  least    allow   one mismatch either  position         follow pattern oooxoooooo ooooooxooo ooooxooooo  oooooxoooo   indicate  mismatch   indicate exact match  replace  residue     position allow mismatch mark    one   reduce amino acids   reduce alphabet  turn  search  exact match achieve identification  seed  mismatch use suffix array ungapped  gap alignment  implement ungapped  gap extension procedures follow   approach use  blast  statistical significance evaluation  use  statistical evaluation method  blast  use   model  parameters  blosum62 substitution matrix  blast  evaluate  significance   result local alignment protein similarity search databases   datasets  test rapsearch  several public metagenomic datasets  various read lengths    nucleotide sequence  download   ncbi short read archive   mgrast server   protein similarity search databases  use include   nonredundant dataset prepare  use cdhit   protein sequence  prokaryotic genomes plasmid  viral genomes collect   img   eggnog database  sequence   cog annotations download    ncbi nonredundant  database download  ncbi ftp site  complete genomes escherichia coli k12 substr mg1655 nc_000913 salmonella typhi nc_003198  desulfococcus oleovorans hxd3 nc_009943   gene annotations  use   simulation study  download   ncbi ftp site  computational tool rapsearch  compare  blast blat  hmmer  blat source cod  download  ~kentsrcblatsrc34zip  default filter option  blast automatically mask low complexity regions  amino acids  use  seg approach  prior  similarity search  seg mask  also implement  rapsearch  comparison purpose seg  also apply   six frame translations   short read  protein blat similarity search",-0.20615484415911994,0.22256697474180587,0.07865561378809313,0.11346115601426432,-0.0311597096290262,-0.02701077547778065,-0.07883361661917575,0.041720045252614434,-0.041096767703706905,0.13825375371139556,-0.0052366892275001325,-0.048630482221524864,0.1347868243988376,-0.06625792320692055,0.18208968873276185,0.01700898077161539,0.05031725680085993,0.17696559574678614,0.021333262561506312,0.08204644293716502,-0.02610905271851354,-0.20510998000021252,0.005754136527696299,0.025529379154082446,0.004973558958671573,-0.13669322097289655,0.08667293335579054,-0.12968520749182927,-0.05536544453140185,-0.03246317660096028,0.002500200005883853,0.2779465050717431,-0.1319154297616998,-0.07591041192183241,0.22730563988304875,0.06286147623988135,0.02852057518422722,-0.038462513578789576,-0.04719458464773313,-0.07575619643191911,-0.046123207608673965,-0.16756801502035362,-0.0916258773714718,-0.12430292172653097,-0.11941183195375495,0.02547114076759686,0.10261230580434796,-0.1136332334176312,-0.22780852198401197,-0.3086665440513383,0.14496231121158906,0.011872489844256687,0.05298043056409658,0.5345766370909082,0.022577861464944563,-1.0417580060187783,-0.008094430239945058,-0.22111293622107792,0.9283353534985392,0.19600588077594275,-0.19894563403906346,0.34879109129154434,-0.008770375485191979,0.07660454849949078,0.5837041834990183,0.05816651437660709,0.00968194302422778,-0.03886267422967071,0.1987245678827758,-0.20594548140634,-0.10227816454735436,-0.02370099605879717,0.1267713597712351,-0.10453356784724054,0.17603507461691542,-0.01778859449957039,-0.11050099404085252,-0.1761141184030012,-0.34858814390941656,-0.06046174521195806,0.21788557415321333,-0.08431948401839548,-0.3866790728052221,-0.0877947489594272,-0.7938638998173355,0.09756563403107787,0.26673030551996024,-0.13817795192312804,-0.13461532690913405,0.0003796353829943294,-0.1995562532184912,0.15016334643513554,-0.10598691513037516,-0.09012895810255217,-0.10509907088634217,-0.12827110347884987,-0.08945807630403174,-0.34374533311523026,0.2906232362051332,0.07796826151436165,Alignment,0
2,2,"phenometer  metabolome database search tool use statistical similarity match  metabolic phenotypes  highconfidence detection  functional links
 article describe phenometer   new type  metabolomics database search  accept metabolite response pattern  query  search  metaphen database  reference pattern  responses   statistically significantly similar  inverse   purpose  detect functional link  identify  similarity measure  would detect functional link  reliably  possible  compare  performance  four statistics  correctly topmatching metabolic phenotypes  arabidopsis thaliana metabolism mutants affect  different step   photorespiration metabolic pathway  reference phenotypes  mutants affect    enzymes  independent mutations  best perform statistic   score   function   pearson correlation  fishers exact test  directional overlap  statistic outperform pearson correlation biweight midcorrelation  fishers exact test use alone  demonstrate general applicability  show    reliably retrieve   closely functionally link response   database  query  responses   wide variety  environmental  genetic perturbations attempt  match metabolic phenotypes  independent study  meet  vary success  possible reason    discuss overall  result suggest  integration  patternbased search tool  metabolomics databases  aid functional annotation  newly record metabolic phenotypes analogously   way sequence similarity search algorithms  aid  functional annotation  genes  proteins
plant genotypes  line use   wildtype reference  metabolomics   study   thaliana ecotype col analyze mutant line include gdcimpaired mtkas somerville  ogren  ewald    shmtimpaired shm1 somerville  ogren  voll    fdgogatimpaired gls1  gls1 somerville  ogren  coschigano    dit2impaired dct somerville  ogren  renné    rubisco activaseimpaired rca somerville    orozco    glykimpaired glyk boldt    sgatimpaired agt1  agt1 somerville  ogren  liepman  olsen  hpr1impaired hpr1 timm    peroxisomal catalase  cat2impaired cat2 queval    peroxisomal malate dehydrogenase  pmdh1impaired pmdh1  peroxisomal malate dehydrogenase  pmdh2impaired pmdh2 pmdh1  pmdh2impaired double mutant pmdh1pmdh2 pracharoenwattana    cousins    seed   line  obtain   arabidopsis biological resource center   exception   pmdh cat2  agt1 mutant line   kindly provide  pracharoenwattana    graham noctor queval     liepman  olsen  respectively plant growth  tissue harvest  metabolomics experiment arabidopsis thaliana seed  allow  imbibe  wet filter paper  stratify   days seed  germinate  grow   mixture  pot soil debco seed raise mix    osmocote  soil osmocote exact mini scotts australia five replicate plant   genotype  grow  high co2 condition     co2   control environment growth cabinet   irradiance   μmol quanta    air temperature  °   day  °  night   day length      weeks plant  transfer  high co2  ambient co2    co2  otherwise similar condition     leave  harvest  metabolomic analysis harvest  carry   rapidly excise  seal    leaf tissue cut   base   petiole     polypropylene roundbottom safelock eppendorf tube eppendorf cat    contain    diameter stainless steel ball qiagen cat    freeze  liquid nitrogen within   harvest sample  keep freeze  °  analysis  genotypes  analyze  three separate experiment     set  wildtype control plant metabolite extraction freeze leaf sample  pulverize   tissuelyser  bead mill qiagen cat     min    approximately     result tissue powder  transfer  accurately weigh without thaw   new cold   roundbottom safelock eppendorf tube eppendorf cat    tube  keep freeze   tube rack chill  liquid nitrogen  five volumes   per  fresh weight  tissue  room temperature extraction medium   hplc grade meoh sigma   untreated milliq h2o    ribitol  add   tube follow  brief vortexing  give thorough mix   solvent  tissue powder tube  place back  liquid nitrogen    sample   mix  extraction medium  tube   quickly transfer   eppendorf thermomixer comfort eppendorf cat    rapidly heat  °  shake   rpm   min  internal gas pressure  release  tube  momentarily open tube lids   min  heat tube   centrifuge      min  pellet insoluble material   supernatants transfer  new   roundbottom safelock eppendorf microfuge tube eppendorf cat     stock extract  centrifuge       min  ensure  complete absence  insoluble material    aliquots   supernatants  dry    amber crimpcap autosampler vials grace davison discovery sciences catalog number 31811e1232a fit  silanized glass   lowvolume insert grace davison discovery sciences cat   use  labconco centrivap acidresistant system labconco cat   operate  room temperature metabolite derivatization dry metabolite extract  chemically derivatized  methoximation  trimethylsilylation   gerstel mps2xl multipurpose sampler gerstel operate   prepahead mode  automate online derivatization  sample injection  derivatization procedure consist   follow step  addition        methoxyamine hydrochloride supelco cat #   anhydrous derivatizationgrade pyridine sigmaaldrich cat #   incubation  °   min  agitation   rpm  addition     derivatization grade nmethylntrimethylsilyltrifluoroacetamide mstfa sigmaaldrich cat    incubation  °   min  agitation   rpm  addition     alkane mix   ndodecane   npentadecane   nnonadecane   ndocosane   noctacosane   ndotriacontane    nhexatriacontane dissolve  anhydrous pyridine  incubation   min  °  agitation   rpm sample  inject   gcms instrument immediately  derivatization gas chromatographymass spectrometry metabolomic analysis derivatized metabolite sample  analyze   agilent  gcmsd system comprise   agilent   gas chromatograph agilent technologies palo alto  usa   inert msd quadrupole  detector agilent technologies palo alto  usa    fit        film thickness   varian factorfour   capillary column    integrate guard column varian inc palo alto  usa product  cp9013 sample  inject   splitsplitless injector operate  splitless mode   injection volume     initial septum purge flow    min increase    min   min   constant inlet temperature  ° helium carrier gas flow rate  hold constant    min   column oven  hold   initial temperature  °   min   increase  °  ° min   hold  °   min total run time   min transfer line temperature  °  source temperature  ° quadrupole temperature  ° electron impact ionization energy       detector  operate  full scan mode   range      scan rate     msd  pretuned  perfluorotributylamine pftba mass calibrant use  “atuneu” autotune method provide  agilent gcmsd productivity chemstation software revision  agilent technologies palo alto  usa product  g1701ea metabolomics data process  statistical analysis  gcms data  process use  online metabolomeexpress data process pipeline4 carroll    raw gcms file  export  netcdf format use agilent msd chemstation software revision  agilent technologies palo alto  usa product  g1701ea  netcdf file  upload   anu_badger metabolomeexpress data repository peak detection settings  slope threshold   min peak area   min peak height   min peak purity factor   min peak width scan   extract peak   peak  identify  msri library match  use retention index  massspectral similarity  identification criteria msri library match parameters   follow  window  ±   units mst centroid distance  ±   unit min peak area  peak import   qualifier ion ratio error tolerance   min number  correct ratio qualifier ions   max average  ratio error   remove qualifier ion  timecorrelated  quantifier ion   primary msri library  “carroll_2014_arabidopsis_photorespiration_mutantsmsri” add unidentified peak  custom msri library   use  calibration file specify  metadata file   carry  persample fine  calibration use internal  standards    carroll_2014_arabidopsis_photorespiration_mutantsmsri primary library contain entries derive manually  analyse  authentic metabolite standards run    gcms condition   biological sample  well  entries  unidentified peak   automatically generate  metabolomeexpress  process  data   reference photorespiration mutants library match result   use  construct  metabolite  sample data matrix  peak areas  normalize  internal standard  ribitol   quality control filter sample  check   presence   strong ribitol peak   peak area   least      deviation   median internal standard peak area   gcms batch sequence  less     median value statistical normalization  tissue mass   require  chemical normalization  tissue mass  already  carry   adjust extraction solvent volume proportionally  tissue mass  determination  metabolic phenotypes  mutantgenotype sir   metabolite  calculate  divide  mean normalize signal intensity   metabolite   set  mutant plant   mean normalize signal intensity   associate set  wildtype control plant statistical significances  calculate  twotailed welch ttests      metabolomeexpress comparative statistics tool  full dataset   upload   metabolomeexpress phenotype database metabolomeexpress dataset ids        make publicly accessible upon publication   article nextgeneration genome sequence genomic dna  extract use  qiagen dneasy plant mini kit follow  manufacturers instruction quality  check use spectrophotometer  agarose gel electrophoresis dna concentrations  determine   qubit invitrogen system genomic libraries  construct use  truseq™ dna sample preparation kit illumina follow  manufacturers lowthroughput protocol briefly    genomic dna  fragment  covaris shear  produce   fragment  repair  end   fragment  produce blunt end ′ adenylation  perform follow  ligate distinct dna adapter index  distinct genotypes  ligation products  enrich   cycle  pcr  size   products  analyze use  bioanalyzer  agilent technology  dna libraries  dilute  pool   equal amount  dna   genotype  sequence   lane   flow cell  seven libraries   single lane dna  sequence use  hiseq  illumina   pairedends read   biomolecular research facility   australian national university john curtin school  medical research jcsmr read    demultiplexed  filter use  instrument manufacturers software  supply   facility alignment  read   mutant   col reference genome assembly ftpftpjgipsforgpubcompgenphytozomev9athalianaannotationathaliana_167_proteinfagz available  phytozome goodstein     perform use bwa   durbin  single nucleotide polymorphisms snps  detect use samtools      script use  align read  detect snps  provide  data sheet   supplementary material snps within  close  know photorespiratory genes  retrieve  vcf file generate  samtools use  custom php script  retrieve  snps lie  1000bp upstream   start coordinate   end coordinate   know photorespiratory genes provide  table   supplementary material  effect  snps  protein sequence  predict use  ensembl plant variant effect predictor  conservation   affect amino acids across plant  assess use pipealign plewniak    protein extraction electrophoresis  immunodetection leaf total protein  extract  buffer contain   epps   edta     mgcl2  pvpp  triton     dtt protein    separate use   nupage® bistris precast gel inivitrogen  transfer onto pvdf membrane  fdgogat protein  detect  rabbit antifdgogat antibody agrisera  apconjugated goat antirabbit secondary antibody sigma  apconjugate substrate kit biorad  use  detection   primary antibody",-0.16591820063839022,0.1567738111864427,0.043585380632870256,0.049312018617266126,-0.04156551464349335,-0.058399377563390316,-0.007844194943022877,0.09732417444573976,-0.02609917074529898,0.12677230377685614,0.018164901154472488,-0.07781032440919282,0.06834985929977255,-0.005876706624105789,0.1423910448107182,0.0100791419553029,0.07029875741373384,0.10463711524597212,0.050897090221719,-0.037783999581564746,-0.04471901786238832,-0.17536874561952825,0.039359149740342866,0.0335561223845891,0.016670861272824942,-0.043660580126438725,0.08173041289296105,-0.0849617772192835,-0.05266829236846439,-0.003100038656284173,0.0039484588513766725,0.1943098855016044,-0.15355139840450946,-0.021154103360458976,0.12395377376772156,0.026427997223393947,0.10338234370215632,0.04060592163549763,-0.04846182188060105,-0.09179446972036183,-0.03384322291018433,-0.1712678055541272,-0.1565642227988276,-0.10683878394216703,-0.05171357458151084,0.03197344805490968,0.043478262232933634,-0.07786238381950805,-0.15020413961238502,-0.2437573350452599,0.12446915189841178,0.0039486869466409825,0.06481417537285124,0.4248299328150054,-0.007050667908113738,-0.8087306465022266,-0.016049809629103674,-0.1640242328757331,0.7176451919665343,0.13348221840317628,-0.033424363527067964,0.21402680125411705,-0.0097155303259104,0.1158501017784316,0.40285065382281465,0.0663218949980652,0.08156693375501567,-0.05875958285240136,0.20978944169744568,-0.1475885941349694,-0.04930421170214961,-0.019481749737552,0.15410201446426325,-0.017684529137663642,0.11762051558396833,-0.017384122779583056,-0.034655867541089735,-0.17098317086442136,-0.21416341031286973,-0.04924235294141866,0.15936150037146565,-0.009907827670801008,-0.3281983222100386,0.029787911149554036,-0.5366207014131062,0.08870661978695818,0.2991548880557719,-0.09822231227101223,-0.09063777881880902,0.024803123572107937,-0.14846095898957534,0.0826639528530968,-0.1169625550946664,-0.03638957032394818,-0.04592751854080382,-0.053901000889349834,-0.0029385478714979148,-0.2734481842963485,0.24711324978311175,0.04839837761399125,Alignment,0
3,3,"cublastp finegrained parallelization  protein sequence search   gpu
blast short  basic local alignment search tool   fundamental algorithm   life sciences  compare biological sequence however   advent  nextgeneration sequence ngs  increase  sequence readlengths whether   outset  downstream  ngs  exponential growth  sequence databases  arguably outstrip  ability  analyze  data though several recent study  utilize  graphics process unit gpu  speedup  blast algorithm  search protein sequence  blastp  study use coarsegrained parallel approach  one sequence alignment  map   one thread moreover due   irregular memory access pattern  blastp  remain significant challenge  map   timeconsuming phase  hit detection  ungapped extension   gpu use  finegrained multithreaded approach  address   issue  propose cublastp  efficient finegrained blastp implementation   gpu use cuda  cublastp realization encompass many research contributions include  memoryaccess reorder  reorder hit  columnmajor order  diagonalmajor order  positionbased index  map  hit   pack data structure   bin  aggressive hit filter  eliminate hit beyond  threshold distance along  diagonal  diagonalbased parallelism  hitbased parallelism  ungapped extension  extend sequence  different lengths  databases   hierarchical buffer  reduce memoryaccess overhead   core data structure  experimental result show    nvidia kepler gpu cublastp deliver    fold speedup  sequential fsablast   fold speedup  multithreaded ncbiblast   overall program execution  addition compare  gpublastp  fastest gpu implementation  blastp  date cublastp achieve    fold speedup   kernel execution   gpu   fold speedup   overall program execution
challenges  map blastp  gpus figure  illustrate  hit detection  ungapped extension phase   blastp algorithm   hit detection  subject sequence   database   scan  leave  right   word   compare   word   query sequence  similar word   tag  hit  hit detection    columnmajor order  nature  mean  hit  one column   tag    time  ungapped extension    diagonalmajor order  two   hit  one diagonal   check  trigger  extension along  diagonal   gap  encounter   diagonal  end algorithm  illustrate  algorithm use  exist blastp research  cpu  gpu  one hit  detect  correspond diagonal number   calculate   difference  hitsub pos  hitquery pos  show  line   previous hit   diagonal   obtain   lasthit arr array   distance  current hit  previous hit  shorter   threshold  ungapped extension  trigger  finish  extension  current column  algorithm  move   next word   subject sequence  algorithm illustrate  interleave execution   hit detection  ungapped extension due   heuristic nature  exist irregular execution paths  different word   subject sequence since  number  hit  able  trigger ungapped extension  different columns cannot  obtain  advance   hard  avoid  divergence branch  thread    warp  map  handle different sequence alignment another issue   random memory access mode  one thread since  current hit   previous hit could    place   diagonal  thread   warp  use  different sequence alignment   hard  organize  coalesce memory access since  thread    previous hit array  “finegrained” multithreaded mode  use multiple thread unfold  “” loop could also lead  severe branch divergence  gpu consider  uncertain hit number  different word   uncertain distance  previous hit  diagonals furthermore since  element   previous hit array may  access   iteration  “finegrained” mode may also lead  significant memory access conflict   irregular mode due   challenge    straightforward  design  finegrained blastp  fully utilize  capability  gpu  decouple  stag   blastp algorithm  use different strategies  optimize    hit detection  bin   finegrained hit detection  use multiple thread  detect hit position  current subject sequence  issue multiple thread   columnmajor order mean   successive thread  handle  consecutive word   subject sequence   way  memory access  word  efficient   coalesce pattern since  ungapped extension    execute along diagonals  output result  hit detection need   reorganize   diagonals   result  introduce  bin data structure  binbased algorithms  hit detection  ungapped extension  first allocate  consecutive buffer   global memory  organize  buffer  bin  hold  hit position although one bin   allocate  one diagonal consider  increase length  sequence  databases  allocate one bin  multiple diagonals  reduce memory usage illustrate  process  finegrained hit detection  one word comparison   subject sequence   query sequence   schedule  one thread  thread  get  word   correspond position column number   subject sequence search  word   dfa  get hit position row number  immediately calculate  correspond diagonal number   difference  row number  column number  example  thread   get  word “abc”   column    subject sequence search “abc”   dfa  get  hit position      calculate  diagonal number      since different thread  write hit position    bin simultaneously    use atomic operations  write hit position algorithm  describe  finegrained hit detection algorithm  variable num bin represent  number  bin    configurable parameter   finegrained blastp algorithm  set  number  bin     experimental evaluation  algorithm  schedule  warp  thread   specific sequence  word  current thread seqij  handle   thread  laneid    hit   word  diagonal number   calculate  map   bin  line   array name top  share memory  allocate  element   array  use  store current available position  correspond bin use atomic operation  top   avoid  heavy overhead  atomic operation directly  bin   allocate  global memory  warp  thread   schedule  next sequence   word  current sequence  detect  hit reorganization  sort  filter   hit detection hit  group  bin  diagonal number since multiple thread could write hit  different diagonals    bin simultaneously  sequence  hit   bin    order   ungapped extension  determine whether continue  extension base   distance  two   neighbor  hit reorganization   sort  hit  diagonal number   topleft  bottomright order since one hit  relate  row number column number diagonal number  sequence number  design  bin data structure   hit  unify  information  show  figure   pack sequence number diagonal number  subject position column number    bite length integer     sequence    recent ncbi  database  short   letter   longest sequence contain  letter   enough  use   bite length   subject position   represent  position use  pack data structure   sort hit   bin  rather  sort hit twice  diagonal number  subject position respectively another benefit  use  data structure       ungapped extension  need sequence number query position row number  subject position column number  query position   easily calculate  subject position  diagonal number   sequence number   obtain   shift operation   sort hit use  specific data structure  irregular memory access  ungapped extension   reduce significantly   finish sort  hit  bin  add  filter step  eliminate hit whose distance  neighbor  longer   threshold  mean  hit    use  trigger  ungapped extension base  two   hit   diagonal  warp  thread  use  eliminate hit   sequence  one bin  thread schedule  one hit compare  threshold   distance   neighbor  leave    distance   neighbor  right    distance  two neighbor  longer   threshold  hit   eliminate  overall performance   additional filter step  determine   ratio  overhead  hit filter   overhead   branch divergence   datasets use   experimental evaluation   observe     hit   hit detection stage   use  trigger  ungapped extension   result  overall performance  improve   hit filter  finegrained ungapped extension   hit reorganization  sort  filter  hit   bin  arrange  ascend order  diagonals   hit whose distance  neighbor  longer   threshold  eliminate base   order hit  design  diagonalbased ungapped extension algorithm   illustrate  algorithm   one diagonal   schedule  one thread   ungapped extension  show  line   line  different thread warp  schedule  different bin  thread   warp  schedule  different diagonals  get  sequence number seq   column number sub pos   row number query pos   bin data structure  call ungapped ext function  extend  diagonal   gap  encounter   diagonal  end  variable ext represent  extension result since  extension could cover  hit along  diagonal line   use  determine whether  hit  cover   previous extension    hit   cover   previous extension  trigger  extension   hit since   still divergence branch   diagonal base extension algorithm  design  hitbased ungapped extension  eliminate  divergence  algorithm  illustrate  hitbased ungapped extension  schedule one thread  one hit  start  extension per hit independently since  extension result  different hit could     hitbased extension may write duplication  line    redundant computation  leave  result deduplication   follow stag run  cpu  performance comparison   hitbased ungapped extension   diagonalbased ungapped extension depend   character   sequence     many hit    cover   extension   hit  diagonals  diagonalbased ungapped extension  perform better   result  use  configurable parameter  allow  user  select  ungapped extension algorithms  runtime compare  parallelism mode  different ungapped extension algorithms figure  illustrate  coarsegrained ungapped extension  exist research since  hit detection  ungapped extension  interleave  coarsegrained ungapped extension extend hit  different diagonals   sequence sequentially  warpbased algorithms  extend hit   sequence  parallel  hierarchical buffer  fully utilize memory bandwidth  propose  hierarchical buffer   core data structure dfa use   hit detection  show  figure  dfa consist   state   finite state machine   query position   state   state  query position  highly reuse  hit detection   word load dfa  share memory  improve  data access bandwidth however   number  query position depend   query length prefetching  position   share memory may affect  occupancy  gpu kernels  offset  improvement  higher data access bandwidth especially   long sequence thus  load  state  relatively fix  small size   share memory  store query position   constant memory   latest nvidia kepler gpu  48kb readonly cache  relax memory coalesce rule  introduce   reusable  randomly access data  allocate  query position   global memory  tag    keyword “const restrict”  load    readonly cache automatically figure  illustrate  hierarchical buffer architecture  dfa  kepler gpu  put  dfa state  “abb”  “abc”   share memory   first access  “abc”  thread   position  set  bin  load   readonly cache   follow access  “abc”  thread   position   obtain   cache pss matrix  score matrix  core data structure highly reuse   ungapped extension  number  column  pss matrix  equal   length   query sequence since  column contain  bytes  row   bytes    size  pss matrix increase quickly   query length  48kb share memory cannot hold  pss matrix   query sequence longer   furthermore  many share memory usage  degrade  performance due   degrade gpu occupancy    hand   score matrix  use  substitute  pss matrix  score matrix   fix 2kb size   always fit   share memory   memory access use score matrix could decrease  performance compare  use pss matrix  short sequence thus  provide  configurable parameter  select pss matrix  score matrix   pss matrix  put    share memory   threshold    put    global memory   score matrix  always put    share memory",-0.2118033183117708,0.2158663397943504,0.09666823014958936,0.10345116896435988,0.033442558715554085,-0.03237855503842487,-0.1361710016944926,0.07806073187293805,-0.009932685827758784,0.11809758696987653,0.06723853330477897,-0.03865967137123031,0.16884549587518904,-0.11828185871945608,0.12208214536535895,-0.029989011683937864,0.01084262380148478,0.20071483839440893,-0.05490513743469213,0.006105408449608754,0.035118376683991905,-0.23424041371921095,0.042833360764421485,0.04470289929364905,-0.00044247473185047664,-0.1583047622528587,0.01061434964064271,-0.13284618211461444,-0.018454624623056286,-0.06287720871826727,-0.04345501746653705,0.2776254865795333,-0.16133469420206425,-0.08784772668635317,0.1631579213369605,0.08814980692598813,0.017068501336022262,-0.03387284252827764,-0.0362315475425324,-0.11348126385473735,-0.0606906912720054,-0.16486049386636145,-0.05964265152185059,-0.04600745079824264,-0.1350732863502344,0.007994679679237985,0.1300623581551008,-0.13930477874131006,-0.1392334578245027,-0.3974300266375697,0.13136208699870622,0.004047730800872766,0.0618481791797952,0.6604231035328969,0.11280499708755087,-1.2135238502517798,0.09075239121132957,-0.16731224424999405,1.044375625308021,0.18738641593411864,-0.17926701075066376,0.28960286358566617,-0.07323079814417117,0.07395617806165926,0.573636067654661,0.052175370468830806,0.02330469236949284,-0.0004676826580786535,0.2426037507956001,-0.1272052635096467,-0.04092135718528312,-0.07027452457039847,0.08971932053926443,-0.1519676819431576,0.21209718552442305,-0.06501623140259956,-0.14184223713164099,-0.11460329929498887,-0.3575306581757711,-0.0829000683055104,0.2400861365642489,-0.04006637588630232,-0.4101050114689618,-0.03016804204692865,-0.888114632750027,0.07910673376500199,0.2194996668801347,-0.15970360788772572,-0.09934937905109108,-0.053625110998154916,-0.2072259757939416,0.16684261814498313,-0.1218453924836164,-0.06974931449318926,-0.12556399776561494,-0.11891064798085912,-0.0023416646636178484,-0.2733283826255501,0.3580574578181768,0.08545296565595588,Alignment,0
4,4,"mublastp databaseindexed protein sequence search  multicore cpus
 basic local alignment search tool blast   fundamental program   life sciences  search databases  sequence    similar   query sequence currently  blast algorithm utilize  queryindexed approach although many approach suggest  sequence search   database index  achieve much higher throughput  blat ssaha  cafe  cannot deliver   level  sensitivity   queryindexed blast  ncbi blast     support nucleotide sequence search  megablast due  different challenge  characteristics  query index  database index  exist techniques  queryindexed search cannot  use  database index search mublastp  novel databaseindexed blast  protein sequence search deliver identical hit return  ncbi blast  intel haswell multicore cpus   single query  singlethreaded mublastp achieve    fold speedup  alignment stag     fold endtoend speedup  singlethreaded ncbi blast   batch  query  multithreaded mublastp achieve    fold speedups  alignment stag     fold endtoend speedup  multithreaded ncbi blast   newly design index structure  protein database  associate optimizations  blastp algorithm  refactored blastp algorithm  modern multicore processors  achieve much higher throughput  acceptable memory footprint   database index
database index   challenge component  mublastp   design   database index  index  include  position  overlap word   subject sequence   database thus  position contain  information   sequence    offset   subject sequence  subject offset   protein sequence search  blastp algorithm use  small word size  large alphabet size  letter  neighbor word comparisons   factor may make  database index  large  design  database index   follow techniques index block sort  compression index block figure   illustrate  design  index block  first sort  database   sequence length partition  database  small block   block    number  letter   build  index   block separately   way  search algorithm     index block one  one  merge  highscoring result   block   final stage index block  enable  database index  fit  main memory especially  large databases whose total index size exceed  size  main memory  configure  size   index block   achieve better performance  example   index block  small enough  fit   cpu cache  hit detection  gap  ungapped extension may achieve better data locality another benefit  use index block   reduce  index size without index block  assume  total   sequence   database  need log2m bits  store sequence ids  divide  database   block  block contain  sequence  average thus   need log2⌈⌉ bits  store sequence ids  example     sequence   database  need  bits  represent  sequence ids   block   block contain  sequence    need  maximum   bits  store  sequence ids  addition   number  bits  store subject offset  determine   longest sequence   block  sort  database   sequence length   use fewer bits  subject offset   block  short  medium sequence   bits    block  extremely long sequence    reason   sort  database   sequence length furthermore index block allow   parallelize  blastp algorithm via  map  one block   thread   modern multicore processor   blockwise parallel method  achieve  ideal load balance  partition index block equally  make  block   similar number  letter instead   identical number  sequence  avoid cut  sequence   middle   sequence reach  cap   block size  put    next block   database  partition  block  block  index individually  show  fig    index consist  two part  lookup table   position array  lookup table contain   entries     alphabet size  amino acids     length   word  entry contain  offset   start position   correspond word   position array  position   word consist   sequence    subject offset  protein sequence search  blastp algorithm   search  hit  exactly match word   also search  neighbor word   similar word  query index use  exist blast tool  ncbi blast include  position  neighbor word   lookup table however   database index  mublastp   store  position   neighbor word  total size   index become extraordinarily large  address  problem instead  store position   neighbor word   index  put  offset  point   neighbor word  every word   lookup table  hit detection stage  go   position  neighbor via  offset  visit  current word   way  use additional stride memory access  reduce  total memory footprint   index index compression  show  fig    specific subject offset   word may  repeat  multiple sequence  example  word “abc” appear  position   sequence     light   repetition   possible  compress  index  optimize  storage  subject offset next  sort  position array   subject offset  group   subject offset together  show  fig      reduce  index size via merge  repeat subject offset   word  store  subject offset   number  position   store  correspond sequence ids sequentially  show  fig     index merge   need  small array   sort subject offset furthermore   index  sort  subject offset instead  store  absolute value  subject offset  store  incremental subject offset  note  fig     use eight  bits   incremental subject offset   number  position   specific subject offset  one block  generally less     also use eight  bits   number  position thus  total   need  bite integer  store  subject offset   number  position however  compress method present  challenge   use eight  bits    incremental subject offset   number  repeat position  still exist   case   increment subject offset   number  repeat position  larger     situations  encounter  split one position entry  multiple entries  make  value less    example  show  fig     increment subject offset     position   split  subject offset  two entries   first entry   incremental subject offset    number  repeat position    second entry   incremental subject offset     position similarly  show  fig     repeat number  position  subject offset  split  two entries   first entry   incremental subject offset    position   second   incremental subject offset    additional  position optimize blastp algorithm  database index   blastp search algorithm introduce   irregular memory access pattern  use  database index rather   query index  propose  realize hit reorder  twolevel bin  order  mitigate  irregular memory access pattern  irregular control flow especially   twohit ungapped extension hit reorder  twolevel bin  twohit ungapped extension  protein sequence search require search  twohit pair  two hit     diagonal  close together  trigger ungapped extensions  traditional method namely  lasthit arraybased method  commonly use  queryindexed blast  lasthit array method use  array  record  last hit   diagonal   new hit  detect  algorithm check  distance   newly find hit   last hit    diagonal   lasthit array  update  last hit   new hit although  algorithm scan  subject sequence   begin   end  diagonal access   new hit   random  random memory access  lasthit array   critical problem  databaseindexed blast  align  query  thousands  subject sequence   rather  align  subject sequence   single query     queryindexed blast therefore  improve  performance  find twohit pair  propose  new method  reorder hit  twolevel bin  show  fig   bin  map   diagonal   first level  bin   hit  group  bin  diagonal ids   calculate  subject offset minus query offset  query offset   calculate  subject offset minus diagonal ids   store  sequence ids  subject offset directly   index  order   minimize memory usage   firstlevel bin hit    diagonal ids  place    bin however   bin  hit  different sequence  interleave thus  design  second level  bin  reorder  hit  sequence ids  contrast  firstlevel bin   bin   equal   diagonal  secondlevel bin set  bin    sequence    scan  bin   firstlevel bin one  one  hit   secondlevel bin  sort naturally   diagonal   show  fig   hit   secondlevel bin contain  subject offset   diagonal    secondlevel bin hit  different sequence  put  different bin  sort  diagonal ids     quickly detect twohit pair  scan every secondlevel bin  improve  performance   twohit ungapped extension   filter   hit  cannot  use  trigger  ungapped extension instead  directly put   hit   secondlevel bin  optimization  capture  fig   dramatically reduce process overhead  reduce memory usage   turn improve performance specifically  write  hit   secondlevel bin  check  distance   last hit  lasthit array    distance   current hit   last hit satisfy  distance thresholds  less  threshold_a  greater   equal  overlap  hit   put   secondlevel bin   number  sequence   index block   adjust  configure  size   index block  size   lasthit array may  small enough  fit   cache     lastlevel cache llc   haswell cpu   evaluation  also    cache   result  optimization  ungapped extension exhibit excellent data locality  access  reorder hit thus improve performance moreover   optimization filter   majority  hit  also significantly reduce  time spend  memorywrite operations   turn improve performance    subject offset  unsorted   database index  show  fig    bin method  introduce random memory access  would adversely impact performance however sort  subject offset   database index  show   fig    resolve  problem   index sort  complete  show  fig     read   database index   write   firstlevel bin  contiguous thus improve  bin performance via better data locality optimizations via multithreading  blast algorithm  query sequence  align   subject sequence   database independently  iteratively thus   parallelize  blast algorithm  openmp multithreading   multicore processors   compute node   pair  core intel haswell cpus   core  total however achieve robust scalability   multicore processors  nontrivial particularly   datamemoryintensive program like blast  also introduce irregular memory access pattern  well  irregular control flow   high level two major challenge exist  parallelize blast within  compute node  cache  memory contention among thread  different core   load balance among  thread   alignment   query  independent  straightforward approach  parallelization map  alignment   query   thread however  approach result  different thread potentially access different index block    time  light   limit cache size  approach result  severe cache contention  thread  mitigate  cache contention  maximize cachesharing across thread  exchange execution order  show  algorithm     first two stag  hit detection  ungapped extension  share   database index access   database block   batch query sequence  line      apply  openmp pragma   inner loop  make different thread process different input query sequence     index block  thread  different core may share  database index   load  memory  even cache  align result   index block   merge together   final alignment  traceback  better load balance   turn better performance  leverage  fact   already   sort database  respect  sequence lengths   partition  database  block  equal size  leverage openmp dynamic schedule discussion  mublastp  use  compositionbased statistics present     also  default method use  ncbi blast   compositionbased statistics methods  ncbi blast     current code base   support   leave  work   future versions moreover  current version  mublastp   produce  identical result  ncbi blast   use  default output format  “pairwise” format   default compositionbased statistics method   result  software   generate  similar result  ncbi blast    parameter  set   future update   software   add  support  different format make mublastp    comprehensive tool  ncbi blast",-0.22119564008924966,0.22888120126220085,0.13212245218957186,0.11728121284285956,0.05453155532601465,-0.03192321635266342,-0.15183988965599393,0.06956313713943578,-0.026910713355121487,0.12776243369761245,0.032940893582100665,-0.04849954724477807,0.18224444671680676,-0.0855376575917863,0.11323311018328455,-0.06855244625136164,-0.004474614817178854,0.1597533135930345,-0.06820041715436312,0.046273280359000094,0.04847859089564772,-0.2156423217765232,0.059642427714345886,0.011544678014723845,-0.0029220225015426943,-0.1754445345255536,0.02979492863809049,-0.16231779172085226,-0.04533421369853728,-0.05981487753765893,0.003256717087622584,0.3001331539497835,-0.13704590108329176,-0.10722669015268536,0.1954887141851797,0.10733232914013696,0.07087092975812669,-0.005854722540041819,-0.0669354464418467,-0.12888665765173513,-0.07398463117139123,-0.20318176079441885,-0.0406837774957023,-0.110852843831699,-0.10821142995016568,-0.001063374374602477,0.16816870617812227,-0.13947590561984174,-0.1492803135431789,-0.4116292104533053,0.12322289015294405,-0.01062656617706116,0.05673292950317287,0.6864695006066306,0.03645598807770962,-1.3562323139648478,0.05998325682969045,-0.2149859108284374,1.1267960750368784,0.21368806313824346,-0.15967223865689195,0.3440856626814884,-0.11522642058613687,0.08010037193745652,0.5948532296426474,0.017440769991417887,0.06205296081301784,0.022520389964591967,0.22355352113908614,-0.1789624942125151,-0.06831413550707571,-0.05484490170798237,0.10110754237112896,-0.12250264705098833,0.21751481804899908,-0.017227112806326075,-0.1286139446610382,-0.13826915142264698,-0.3631396418815424,-0.06112888940301087,0.27199703820256804,-0.04110693374903997,-0.4196510075241106,-0.05125885807040567,-0.9491577842013476,0.07470335547425,0.201532712003094,-0.17478275875875607,-0.0992465549552615,-0.05408020888155241,-0.19324965722165025,0.13214133973440875,-0.14089430127889932,-0.1012548897493202,-0.17596295770902606,-0.08689198208255877,-0.050561862321118686,-0.3000460138278184,0.41526669743822403,0.10457061878134644,Alignment,0
5,5," poor man blastx—highthroughput metagenomic protein database search use pauda
  context  metagenomics  introduce  new approach  protein database search call pauda  run   time faster  blastx  achieve  onethird   assignment rate  read  kegg orthology group  produce gene  taxon abundance profile   highly correlate   obtain  blastx pauda require  cpu hours  analyze  dataset   million illumina dna read  permafrost soil    previous blastx analysis   subset   million read reportedly require   cpu hours lead    cluster  sample  functional profiles
 metagenomics study millions  dna  cdna read  sequence  environmental sample     analyze   attempt  determine  functional  taxonomic content   sample handelsman     important computational step   determine  genes  cod sequence present   usually   align  sequence   reference database  protein sequence   project blastx altschul       method  choice despite  fact  run blastx require thousands  cpu hours per million read   relate area  read map numerous methods   develop  solve  problem  align sequence read  dna reference sequence   highthroughput manner  example langmead  salzberg  use read map tool directly  analyze complex metagenomes  problematic  environmental read usually   match exist genome reference sequence moreover  underlie algorithms cannot easily  extend  protein sequence   article  present  new paradigm   alignment  environmental sequence read call pauda  acronym  protein alignment use  dna aligner  allow one  harness  high efficiency  dna read aligners  compute blastxlike alignments  key idea   convert  protein sequence  pseudo dna  pdna  short  map  amino acid alphabet onto  fourlettered alphabet  reflect  amino acids  likely  replace    significant blastx alignments  highthroughput sequence read aligner   bowtie2   use  compare pdna read   pdna database   match find  participate pdna sequence  translate back  protein sequence   correspond protein alignment  calculate    determine statistical significance  final output   file  statically significant protein alignments  blastx format   implement  approach   new software package call pauda  package provide two script paudabuild  paudarun  first script  run   protein reference database  build  appropriate index  second script  run   file  dna read  produce  blastx file  output  two script use  bowtie2 suite   number  new java program    write bowtie2  easily  replace    method  desire  overview   package  give  figure  use bowtie2   comparison engine pauda run   time faster  blastx  assign  onethird  many read   group    huge computational burden  run blastx   large dataset blastx  rarely run  completion therefore  key question   many read   assign per hour pauda assign   many read  blastx  per hour mackelprang    present  taxonomic  functional analysis   permafrost datasets reanalysis   data  comparison   million illumina read   kegg database kanehisa  goto  take     single workstation  core    main memory use pauda reproduce  main result   article  addition  apply  early version  pauda   unpublished dataset consist    billion read   whole hiseq2000 run   wastewaster sample require  days   core whereas rapsearch2 zhao    require  days  produce  benchmark dataset  compare  performance  pauda blastx  rapsearch2  take  first   good quality read      sample publish  mackelprang      run  three program      sample benchmark sample compare   kegg database run  sample  parallel   single workstation use  core  runtime range   min pauda   days blastx table   use  metagenome analysis program megan huson     assign read  kegg orthology  group base   alignments use pauda  rate  assignment      blastx   detail  alignments   protein identity         sensitivity       respectively  alignments  identity   sensitivity is58   read    blastx  pauda  able  assign   group  assignment differ     case assume  falsepositive error rate     assignment  read   group blastx identify  true  group   dataset  account     read  blastx hit pauda identify     number  read assign  individual  group  pauda  blastx  highly correlate  show  figure   pearson correlation    linear read count    logtransformed count use  lca assignment algorithm  implement  megan  also perform  taxonomic analysis   datasets   number  different taxonomic rank  result base  pauda  blastx  highly correlate   pearsons correlation coefficient   range     taxonomic rank  class    species  correspond range  logtransformed count     illustrate  accuracy  pauda  apply  program    permafrost sample   entirety  total compare  million read   kegg database  key result  mackelprang        one hand two different freeze sample take   active layer   permafrost  similar functional profile    change  little  thaw     days although    hand two freeze sample obtain   permafrost layer initially exhibit distinctive profile  gradually become  similar  thaw  pcoa analysis  braycurtis distance mitra    base   pauda comparison   data   kegg database deliver   result   small fraction   computational time",-0.19866541464823603,0.2483984378571314,0.12393203924571485,0.10869784315095612,0.022115097924716484,-0.02793272880542024,-0.06932682395208536,0.02530772720095669,-0.055213413662877485,0.13854480804210262,0.0447217417663476,-0.030277129605036063,0.14525799493588107,-0.10349155531730504,0.11300014571582034,-0.005945078353235297,0.08590519706595312,0.16122289531367734,-0.03187398107613693,0.09743814794460266,0.00935592452382169,-0.2282926604234474,0.0585940534359279,0.044633020968533374,-0.0189765950491269,-0.20507330773885035,0.04519980050236448,-0.14778179757602072,-0.0577586500885984,-0.02511177662612371,-0.016203417560371216,0.3132424927130017,-0.1937940390417024,-0.0530224014040146,0.18192164698676108,0.09698055461835997,0.0622476192162038,0.01932533912503449,-0.07495979414680869,-0.108929308404325,-0.1144608507390809,-0.1570424482367632,-0.06484438791260194,-0.06297326426732415,-0.12902704009705934,-0.0019407206156553914,0.11680096740191902,-0.14953382711700172,-0.19324136266540834,-0.3281898522649759,0.15074025829385915,-0.01697015102797769,0.1359549554434803,0.6036222683272295,0.011563777358746578,-1.2332335709835944,-0.004024234606855214,-0.2168509945916726,1.0246011214639068,0.20863108044873133,-0.14992211385679152,0.3829439553328326,-0.04894986062656232,0.029020158618604214,0.6096544555730742,0.03260350236807096,0.06569437228324937,0.02739697178575869,0.23792182506311144,-0.1484601707343752,-0.07629915203838351,0.010081686154746156,0.1216015387528279,-0.10868113884825636,0.181961997029232,-0.015346063005669815,-0.15125599262898445,-0.1554788955826416,-0.4039107249588916,-0.07267541602255538,0.1929808632184294,0.011957480862593921,-0.38981161353025,-0.09854584350595444,-0.8967236278002444,0.09487557320292546,0.22332671267558085,-0.20215117006290068,-0.12337302718061477,-0.032887572011316535,-0.15222588806568876,0.07467112257212273,-0.106560062523769,-0.08187106375255783,-0.1266208794324915,-0.07482843210503706,-0.13371061576199345,-0.3377361006739481,0.301682887985436,0.08799892165935404,Alignment,0
6,6,"fast  sensitive protein alignment use diamond
 alignment  sequence read   protein reference database   major computational bottleneck  metagenomics  dataintensive evolutionary project although recent tool offer improve performance   gold standard blastx  exhibit   modest speedup  low sensitivity  introduce diamond  opensource algorithm base  double index    time faster  blastx  short read    similar degree  sensitivity
overview  diamond diamond   highthroughput alignment program  compare  file  dna sequence read   file  protein reference sequence   ncbinr19  kegg3   implement     design  run  multicore servers  software   obtain   unituebingendesoftwarediamond diamond   order  magnitude faster  blastx4  compare short dna read   ncbinr database  maintain  comparable level  sensitivity  alignments   evalue   program  explicitly design  make use  modern computer architectures   large memory capacity  many core  follow  seedandextend approach additional algorithmic ingredients   use   reduce alphabet space seed  double index seed  extend  program  base   traditional seedandextend paradigm  sequence comparison   exact occurrences  seed   short word   give fix length contain  query sequence  locate   reference sequence   seed match   extend  possible  full alignments   query  reference  seed length use   alignment program   substantial impact  performance shorter seed increase sensitivity whereas longer seed increase speed reduce alphabet  increase speed without lose sensitivity one approach   use  reduce alphabet  compare seed use  rapsearch2 ref    time faster  blastx  minimal loss  sensitivity  diamond  investigate  use  publish reductions  four eight  ten letters12  analyze  large number  blastx alignments  develop  new reduction   alphabet  size   achieve slightly better sensitivity bracket indicate one letter kredqn    ilv      sta space seed  second improvement   seed step   use space seeds—  longer seed     subset  position  use  number  exact layout   position  call  weight  shape   space seed respectively theoretical analysis show   single space seed  perform better   contiguous seed    weight   shape  suitably chosen10 moreover sensitivity   increase   use additional seed shape  result    sublinear increase  run time10  default diamond use  set  four shapes11  length   weight  supplementary fig  seed index  main bottleneck  align  large number  read   large reference database   cpu performance  rather memory latency  bandwidth  limit factor   amount  time require  load seed locations  main memory  comparison move data  main memory   cache take hundreds  cpu clock cycle thus  fast algorithm  take  cache hierarchy  computers  account    maximize data locality  minimize  number  main memory access      decompose  problem  small subproblems  fit   cache   seedandextend program  index structure   hash table   index  build   reference sequence  facilitate  location  seed   reference query  process   order   occur   input file   give query  seed  determine   index   use  look   match locations   reference sequence  reference locations  load  main memory   cache  another read  later encounter  contain     seed  correspond index  sequence data  usually   evict   cache   data     load  main memory  hence use  single index   way   make good use   cache  problem  compound  use  fulltext index    suffix array   compress  index   require multiple individual memory access per index lookup double index diamond use  doubleindexing approach     query   reference  index  diamond index   list  seedlocation pair   lexicographically order   compress representation   seed  traverse  two index list linearly  parallel  match seed   query   reference  identify allow  local alignment computation   correspond seed locations  index memory access pattern   approach  linear    efficiently handle   hardware prefetcher   fill  cache   index information    need  doubleindexed approach also improve data locality  respect  access  sequence  see  let    denote  set  seed contain   set  query  reference respectively   give seed  let      number  occurrences   seed   query   reference use  standard index approach  number  memory access operations  approximately   ∈∩ msns    occurrence   reference seed   query  correspond reference locations   load  memory use  doubleindexing approach  number  memory access operations  approximately ′  ∈∩srms   assume   combine size  query  reference locations  one seed  small enough  fit   cache  number  much smaller   unless  sum  dominate  singleton seed  demonstrate  effect  real data  plot  ratio  memory access   two approach depend   length   query sequence  letter  observe   benchmark data supplementary fig   doubleindexing algorithm use  diamond  base   wellknown database sortmerge join algorithm apply   two seed set   query  reference  main computation  compilation  sort   two list  seed   efficiently address  parallel use  radix cluster step20  combination   fast sort algorithm  total amount  time require  sort   seed   give set  query  smaller    require  access  seed   hashtable approach  sort  seed   reference sequence   fly take much less time  load  precomputed index  example  complete seed index   current version   ncbinr database      size  take    generate  memory   six time  long  read  disk   typical read rate    per second  alignment program mrsfast use sort list   index structure21  author   tool spend  lot  effort  make  algorithm cache oblivious much   challenge discuss  stem   fact  short nonoverlapping seed  use  cause  set   occurrences   seed  exceed  cache capacity owe    elaborate seed strategy use  diamond   program  amount npg ©  nature america inc  right reserve nature methods doinmeth  data associate   give seed  always  small enough  fit   cache memory efficiency  drawback  use multiple space seed    use  lot  memory    main reason   approach    widely use despite  prove advantage  naïve implementation   multiple space seed index build  hashtable index     seed shape  one hash table index   ncbinr database      size four seed shape would consume     shape would consume    memory diamond construct  process  index  one shape   time free   memory use  one shape  move    next thus diamond  perform alignment task   sensitive shape configuration use   much memory  one shape index require    additional advantage   approach moreover use  radix cluster technique  seed space  decompose   disjoint partition  build  process index    subset   partition    time  memory usage   limit   size   subset index seed extension   seed match find diamond determine whether    extend   ungapped alignment  ten   amino acids     case   seed match trigger  extend phase   algorithm  involve compute  smithwaterman alignment13 diamond use   stream simd extension sseaccelerated smithwaterman implementation  extend previous algorithms22  allow  computation  band  anchor alignments  default  program use  blosum62 matrix23  gap score     extension score   however  blosum matrices  score parameters   use  program determine  bite score  expect value   compute alignment   blastx  default alignments   bite score    report  diamond proceed seed  seed rather  read  read  key issue    avoid compute   local alignment   read   reference     different time   search phase  address  diamond allow  seed match  trigger  extension      leftmost seed match   correspond ungapped alignment experimental study  download  ncbinr database  consist   million sequence   billion letter  may   use  reference database  download ten file  illumina read   human microbiome project website  cover sample   range  different humanassociated microbiomes sra srs011134 srs013687 srs013951 srs015578 srs042628 srs011239 srs013800 srs015369 srs016753  srs053335  extract  random read   file    obtain  total set   million read  average length   refer     illumina hmp data set  download  illumina data set associate  permafrost cores14    department  energy joint genome institute website  extract  random read   file    obtain  total set   million read  average length   use   benchmark set  read sequence  refer     illumina permafrost data set  download  single data set  ion torrent read   study entitle metagenome  artisanal cheese  tucuman  ncbi erp004234  download two data set   titanium read   study entitle microbial community gene content  expression   central north pacific gyre station aloha hot186  ncbi  accession number srr1298978  srr1298979  download  single data set  sanger read   sargasso sea project17  download  set  contigs   microbial assembly18  use metagenemark24  predict  total   open read frame orfs  data set  use  compare  performance  diamond version  rapsearch2 version   blastx version   three program  run    computer use  core    core amd opteron server     main memory run ubuntu   follow parameter settings  use   program blastx blastx _num_threads  evalue  max_target_seqs  comp_based_stats  diamondfast diamond blastx     minscore  diamondsensitive diamond blastx     sensitive minscore  rapsearch2fast rapsearch           rapsearch2default rapsearch          measure run time blastx  rapsearch2   run  three random subsets   data set   run time   extrapolate   full data set  average diamond  run   full data set fig   supplementary table   figure   consider  alignments   blastx evalue    supplementary table   also consider   subset   alignments   blastx evalue   alignments  poorer quality  usually  consider  metagenome analysis  report run time   total wallclock time require   core minus  program overhead time  overhead time   program  measure   wall clock time   program require  process  input file  contain  one read    constant contribution   run time   ignore   analysis  diamond  intend  run  data set   much larger   test data set  diamondfast    min   diamondsensitive    min  reason  test data set   small  practical standards   allow   run  full blastx analysis   data set   reasonable amount  time sensitivity   level  query percentage  query map  base   number  read   blastx   test method  find  least one common alignment   reference sequence divide   total number  read   blastx find  least one alignment sensitivity   level  match percentage  match recover  base   number  alignments find   blastx   test method divide   total number  alignments find  blastx principal coordinate pcoa analysis  illustrate  minor differences   output  blastx  diamond   affect  result  higherlevel analyse  use  random subsamples  contain  read   publish permafrost samples14  subsample  align  ncbinr use  blastx  diamondfast npg ©  nature america inc  right reserve doinmeth nature methods keep alignments   minimum bite score   read  map  kegg orthology  numbers3   read use  best alignment     number  know   compute braycurtis distance   result profile  use pcoa  generate diagram supplementary fig  memory usage  compatibility  memory management  diamond  design  allow   adaptable memory footprint    depend   total size   input diamond break   input query  reference data  fix size block   sequence letter   compare      time   seed index entry   bytes long   index  process   chunk  total memory usage   give    8bc  const  const represent  constant amount  overhead memory   default value      memory usage   program  bound    const irrespective   total size   database  query  block size    arbitrarily choose   user  fit  target machine  command line options         respectively  explore  effect   block size parameter   performance  align  query set   million illumina read  permafrost   ncbinr database contain  billion letter use different value   supplementary table   operation require  high memory server  maximum performance    efficiently handle   machine     memory   half  speed  amount  ram  readily available   price     standard desktop computer",-0.18540695431424956,0.22352296086961174,0.1321527032549485,0.12374491833116832,-0.015566939199869775,-0.058999165876207724,-0.1244782125168138,0.06344991605489488,-0.032513832334414294,0.1256612079272862,0.048390920761921925,-0.02063974736156908,0.14107238275029346,-0.09736776197438007,0.10380579238415406,-0.03500181507206275,0.026271043047439862,0.16360246945296944,-0.04208855910897983,0.06601154768282158,0.020425516981075014,-0.1807805686345756,0.011966459042276459,0.005246107770753647,0.0005861289935474577,-0.1366975986380752,0.040006608434323465,-0.15715887621724373,-0.04614612094645498,-0.03954346812183286,-0.022523131784172774,0.24852949501361424,-0.14980670051716322,-0.07736245559914952,0.1718781319202267,0.09291221855289296,0.05285787208620393,0.010013681189697202,-0.03392218410688893,-0.12090131650889137,-0.054218290020856576,-0.18430086286412287,-0.0554452865886394,-0.07780562302196703,-0.10527580304837317,0.0037607754898721577,0.11405220800104085,-0.14583959131786414,-0.17308710640251734,-0.3051264669763756,0.15053857073442756,-0.02534205095688215,0.05394316706331758,0.5603361499091931,0.03622284581392074,-1.1483233001865512,0.034200548123558466,-0.20499769714978067,1.0159331975629151,0.18305376268661105,-0.1314017745277575,0.27601120063041945,-0.10660191655104984,0.07069957588622526,0.5401741223101241,0.025557843855948816,0.03975663122611865,0.0143559173912445,0.2307223518516521,-0.1530436523214084,-0.04670138380684022,-0.04392628654140344,0.09704100016672501,-0.1197100437284318,0.17021437317674312,-0.037077603648090984,-0.09384615308939036,-0.13236056633030924,-0.3235946459734979,-0.04134566129993875,0.2270421715866961,-0.03312924204167938,-0.36317622002381145,-0.051226501372624,-0.8083654410971074,0.07381161568814852,0.21327353039447888,-0.14467056936122846,-0.06664806888242349,-0.031481188613876804,-0.1486794381780527,0.11664147181070192,-0.1081266991453661,-0.11708172369520845,-0.13090620543324896,-0.09618159528655576,-0.05046753963381494,-0.2751143707533495,0.36459672200368304,0.07779116237415158,Alignment,0
7,7,"minimap2 pairwise alignment  nucleotide sequences
recent advance  sequence technologies promise ultralong read     average fulllength mrna  cdna read  high throughput  genomic contigs     length exist alignment program  unable  inefficient  process  data  scale  press   development  new alignment algorithms minimap2   generalpurpose alignment program  map dna  long mrna sequence   large reference database  work  accurate short read     length   genomic read  error rate  fulllength noisy direct rna  cdna read  assembly contigs  closely relate full chromosomes  hundreds  megabases  length minimap2  splitread alignment employ concave gap cost  long insertions  deletions  introduce new heuristics  reduce spurious alignments    time  fast  mainstream shortread mappers  comparable accuracy    time faster  longread genomic  cdna mappers  higher accuracy surpass  aligners specialize  one type  alignment
minimap2 follow  typical seedchainalign procedure   use   fullgenome aligners  collect minimizers roberts      reference sequence  index    hash table   key   hash   minimizer   value   list  locations   minimizer copy    query sequence minimap2 take query minimizers  seed find exact match  anchor   reference  identify set  colinear anchor  chain  baselevel alignment  request minimap2 apply dynamic program   extend   end  chain   close regions  adjacent anchor  chain minimap2 use index  seed algorithms similar  minimap      predecessor   accurate chain  ability  produce baselevel alignment   support  splice alignment  chain  chain  anchor   tuple    indicate interval         reference match interval         query give  list  anchor sort  end reference position  let    maximal chain score    ith anchor   list    calculate  dynamic program   max  max ≥ {      }       min  min{      }    number  match base   two anchor       gap cost  equal ∞   ≥   max{      }     distance  two anchor   large otherwise                 implementation  gap  length  cost γcl     ¯     log2          ¯   average seed length   anchor directly compute      take on2  time although theoretically faster chain algorithms exist abouelhoda  ohlebusch    inapplicable  generic gap cost complex  implement  usually associate   large constant  introduce  simple heuristic  accelerate chain  note   anchor   chain   chain    predecessor    likely  yield  lower score  evaluate    start  anchor   stop  process   cannot find  better score     iterations  approach reduce  average time  ohn  practice   almost always find  optimal chain     even   heuristic fail  optimal chain  often close  backtrack let    index   best predecessor  anchor   equal       argmaxj{      } otherwise   anchor    descend order    apply  repeatedly  find  predecessor  mark  visit   use       reach  arxiv01492v5 qbiogn  mar    already use   way  find  chain   anchor use    one chain  identify primary chain   absence  copy number change  query segment    map  two place   reference however chain find   previous step may  significant  complete overlap due  repeat   reference   durbin  minimap2 use  follow procedure  identify primary chain    greatly overlap   query let    empty set initially   chain   best   worst accord   chain score    query  chain overlap   chain      higher percentage   shorter chain mark  chain  secondary   chain   otherwise add  chain     end  contain   primary chain    choose   sophisticate data structure  range tree   tree   step    performance bottleneck   primary chain minimap2 estimate  map quality   empirical formula mapq      f2f1  min{ }  log   log denote natural logarithm    number  anchor   primary chain    chain score   ≤    score   best chain   secondary   primary chain intuitively  chain  assign   higher map quality    long   best secondary chain  weak  estimate perbase sequence divergence suppose  query sequence harbor  seed  length      present   chain  want  estimate  sequence divergence    query   reference sequence   chain   useful  baselevel alignment   expensive  perform   model substitutions   homogeneous poisson process along  query sequence  probablity  see  consecutive base without substitutions     assumption   kmers  independent     likelihood function               maximum likelihood estimate        log    reality sequence errors  sometimes cluster  kmers   independent    especially   take minimizers  seed  violate  assumptions   derivation    result    approximate    bias  also ignore long deletions   reference sequence  practice fortunately   often close   strongly correlate   sequence divergence estimate  baselevel alignments   several datasets use  section   spearman correlation coefficient  around   index  homopolymer compress kmers smartdenovo   ruan personal communication index read  homopolymercompressed hpc kmers  find  strategy improve overlap sensitivity  smrt read minimap2 adopt   heuristic  hpc string   string  denote  hpcs  construct  contract homopolymers     single base  hpc kmer     klong substring  hpcs  example suppose   ggattttcca hpcs  gatca   first hpc mer  gatc  demonstrate  effectiveness  hpc kmers  perform read overlap   example  coli smrt read  pbcr berlin    use different type  kmers  normal 15bp minimizers per 5bp window minimap2 find   ≥2kb overlap infer   readtoreference alignment  hpc mers per 5bp window minimap2 find   overlap  achieve  higher sensitivity  index  fewer minimizers   help performance hpcbased index reduce  sensitivity  current ont read though  align genomic dna  alignment  piece affine gap cost minimap2 perform dpbased global alignment  adjacent anchor   chain  use  piece affine gap cost gotoh  γal  min{     ˜   ˜}  without lose generality  always assume   ˜˜   condition    ˜  apply cost       gap shorter  ˜    ˜  apply ˜    ˜  longer gap  scheme help  recover longer insertions  deletions indels  equation  compute  optimal alignment       hij  max{hij    eij  fij  ˜   ˜ } eij  max{hij   eij}   fij  max{hij   fij}   ˜   max{hij   ˜ ˜ }  ˜ ˜   max{hij   ˜ ˜ }  ˜       score   ith reference base  jth query base     natural extension   equation  affine gap cost gotoh  altschul  erickson    suzukikasahara formulation   allow gap longer  several hundred base pair nucleotidelevel alignment  much slower  chain sse acceleration  critical   performance  minimap2 traditional sse implementations farrar  base     achieve way parallelization  short sequence   way parallelization   peak alignment score reach  long sequence alignment may exceed  threshold inspire        follow work suzuki  kasahara  propose  differencebased formulation  lift  limitation  case  piece gap cost define    uij  hij  hij vij  hij  hij xij  eij  hij ˜  ˜   hij yij  fij  hij ˜  ˜   hij   transform       zij  max{  xij  vij  yij  uij ˜  vij  ˜  uij} uij  zij  vij vij  zij  uij xij  max{ xij  vij  zij  }     yij  max{ yij  uij  zij  }     ˜  max{ ˜  vij  zij  ˜}  ˜ ˜ ˜  max{ ˜  uij  zij  ˜}  ˜ ˜   zij   temporary variable    need   store  important property       value  bound  score parameters  see  xij  eij  hij  max{ eij  hij}    eij ≤ hij       ≤ xij ≤ max{ }      similar inequations  yij  ˜  ˜   addition uij  zij  vij ≥ max{xij  ˜} ≥      maximum value  zij  hij  hij    maximal match score   derive uij ≤   vij ≤       conclusion        bound      ˜  ˜  ˜   ˜ ˜                ≤          ≤       store   bite integer  align nucleotide sequence  minimap2  enable way sse vectorization regardless   peak score   alignment    efficient sse implementation  transform  rowcolumn coordinate   diagonalantidiagonal coordinate  let            become    zrt  max{    xrt  vrt yrt urt ˜  vrt ˜  urt} urt  zrt  vrt vrt  zrt  urt xrt  max{ xrt  vrt  zrt  }     yrt  max{ yrt  urt  zrt  }     ˜  max{ ˜  vrt  zrt  ˜}  ˜ ˜ ˜  max{ ˜  urt  zrt  ˜}  ˜ ˜   formulation cells    diagonal index   independent     allow   fully vectorize  computation   cells    antidiagonal  one inner loop  also simplify band alignment 500bp band width  default  would  difficult  strip vectorization farrar    condition      ˜  ˜    ˜  initial value   diagonalantidiagonal formuation       yrr     ˜  ˜yrr  ˜ ˜ urr                     ˜ ˜       ˜  ˜    ˜    ˜ ˜   ˜    ˜ ˜      derive   initial value     perform global alignment    need  compute hrt   cell  use way vectorization throughout  alignment process  extend alignments  end  chain  need  find  cell    hrt reach  maximum  resort  way vectorization  compute hrt  hrt urt   computation  simple    still  dominant performance bottleneck  practice  way vectorized implementation  global alignment  three time  fast  parasails way vectorization daily  without band  implementation  slower  edlib soˇ siˇ   ´ sikic      1000bp band   considerably faster  perform global alignment  anchor  expect  alignment  stay close   diagonal    matrix band  applicable    time   zdrop heuristic  global alignment minimap2 may force  align unrelated sequence  two adjacent anchor  avoid   artifact  compute accumulative alignment score along  alignment path  break  alignment   score drop  fast   diagonal direction  precisely let     alignment score along  alignment path end  cell      matrix  break  alignment   exist                                                gap extension cost     arbitrary threshold  strategy  first use  bwamem   similar  xdrop employ  blast altschul     unlike xdrop  would  break  alignment   presence   single long gap  minimap2 break  global alignment  two anchor  perform local alignment   two subsequences involve   global alignment   time   one subsequence reverse complement  additional alignment step may identify short inversions   miss  chain  filter  misplace anchor due  sequence errors  local homology  anchor   chain may  wrong   blindly align regions  two misplace anchor   produce  suboptimal alignment  reduce  artifact  filter  anchor  lead   10bp insertion   10bp deletion    time  filter  terminal anchor  lead   long gap towards  end   chain  heuristics greatly alleviate  issue  misplace anchor    unable  fix   errors local misalignment   limitation  minimap2   hope  address  future  align splice sequence  algorithm describe    adapt  splice alignment   mode  chain gap cost distinguish insertions   deletions   reference γcl    take  form  γcl     ¯     log2     min{  ¯   log2 }    similarly  gap cost function use  dpbased alignment  change  γal           min{     ˜}     alignment  deletion  shorter  ˜ qee  regard   intron  pay  cost  gap extensions  pinpoint precise splice junctions minimap2 introduce referencedependent cost  penalize noncanonical splice    hij  max{hij    eij  fij  ˜   } eij  max{hij   eij}   fij  max{hij   fij}   ˜   max{hij     ˜ ˜ }  let    reference sequence   compute                gta  gtg          gtc  gtt  otherwise    extract  substring       inclusively  penalize noncanonical donor sit    less frequent eukaryotic splice signal gtct   irimia  roy  similarly             cag  tag        aag  gag  otherwise model  acceptor signal    close   equation  zhang  gish  except   allow insertions immediately follow  deletions  vice versa  addition  use  suzukikasahara diagonal formulation  actual implementation  rnaseq read   sequence  strand libraries  read strand relative   underlie transcript  unknown  default minimap2 align  chain twice first assume gtag   splice signal   assume ctac  reverse complement  gtag   splice signal  alignment   higher score  take   final alignment  procedure also infer  relative strand  read  span canonical splice sit   splice alignment mode minimap2  increase  density  minimizers  disable band alignment together   tworound dpbased alignment splice alignment  several time slower  genomic dna alignment  align short pairedend read  chain minimap2 take  pair  read  one fragment   gap  unknown length   middle  apply  normal gap cost  seed    read     permissive gap cost  seed  different read  precisely  gap cost  chain     γcl     ¯     log2   two seed    read min{  ¯   log2 } otherwise",-0.15453287218584028,0.12694422158375368,0.08229826462417443,0.14172207357276614,-0.05159588584391302,-0.030130533116240293,-0.11158978134397918,0.0665101714556339,-0.004414952038126465,0.08115982829682257,0.003342553676204393,0.006373047794863926,0.12779564756213346,-0.05621881230672143,0.1358214219098564,-0.033164007138928066,-0.03186402230127023,0.15245487979054606,-0.009272567226896108,0.05315155140412418,0.06790287323601901,-0.16096783704477866,0.002944337841885613,0.017477237085024938,0.018487083802376986,-0.12145538678893775,0.061256228134699976,-0.15532253133847682,0.0053535328809423185,-0.06906807224491762,-0.004727055992748244,0.209974116988852,-0.11728363522536292,-0.06106853788517256,0.1399438951394337,0.08101692487329717,0.05025008777210262,-0.00925285246441442,-0.04398496210803324,-0.060596176944311915,-0.045584871737392486,-0.11329630503396193,-0.04136651387975975,-0.0592354705310661,-0.09036912451645747,-0.019269132710802724,0.13174405745299772,-0.09367832117193384,-0.1656383764313414,-0.2736327382901118,0.13768260719380634,-0.02473285432827925,0.06183748384263357,0.4837761196191038,0.03716780382850923,-0.9567261038723835,0.04922298312847266,-0.14159351969237682,0.7936011359820576,0.15800402328171936,-0.1640134287536357,0.2091036145631055,-0.06953409369212726,0.043724156672168814,0.4575218588779234,0.04584493048543075,0.023526221023497502,0.0036935484638666617,0.1436356606149989,-0.17035739344971948,-0.07847987881952108,-0.07150242879768533,0.098905287213987,-0.11328242911470028,0.181907863688898,-0.08100937167854931,-0.09020646180816937,-0.13327634724882115,-0.28199891963908663,-0.08027443596951067,0.1506217148962245,-0.053513825842090613,-0.3389269271465489,-0.05893732359809802,-0.7020795749786245,0.08307956267452166,0.14828775223010687,-0.11989734290212258,-0.0969768946117448,-0.04624318473248338,-0.17728012990899594,0.1208607431805828,-0.1100179314783931,-0.08675200607521588,-0.10173562109217654,-0.09266823729236608,-0.03331942103569559,-0.23165632699571684,0.23960194952567734,0.08296847475286137,Alignment,0
8,8,"ultrafast  memoryefficient alignment  short dna sequence   human genome
bowtie   ultrafast memoryefficient alignment program  align short dna sequence read  large genomes   human genome burrowswheeler index allow bowtie  align    million read per cpu hour   memory footprint  approximately  gigabytes bowtie extend previous burrowswheeler techniques   novel qualityaware backtrack algorithm  permit mismatch multiple processor core   use simultaneously  achieve even greater alignment speeds
bowtie index  reference genome use  scheme base   burrowswheeler transform bwt     index    bowtie index   human genome fit     disk    memory footprint   little     alignment time allow    query   workstation      ram  common method  search    index   exactmatching algorithm  ferragina  manzini  bowtie   simply adopt  algorithm  exact match   allow  sequence errors  genetic variations  introduce two novel extensions  make  technique applicable  short read alignment  qualityaware backtrack algorithm  allow mismatch  favor highquality alignments  'double indexing'  strategy  avoid excessive backtrack  bowtie aligner follow  policy similar  maq'    allow  small number  mismatch within  highquality end   read   place  upper limit   sum   quality value  mismatch alignment position burrowswheeler index  bwt   reversible permutation   character   text although originally develop within  context  data compression bwtbased index allow large texts   search efficiently   small memory footprint    apply  bioinformatics applications include oligomer count  wholegenome alignment  tile microarray probe design   smithwaterman alignment   humansized reference   burrowswheeler transformation   text  bwtt  construct  follow  character   append           lexicographically less   character    burrowswheeler matrix    construct   matrix whose row comprise  cyclic rotations    row   sort lexicographically bwtt   sequence  character   rightmost column   burrowswheeler matrix figure  bwtt    length   original text   matrix   property call 'last first  mapping'  ith occurrence  character    last column correspond    text character   ith occurrence     first column  property underlie algorithms  use  bwt index  navigate  search  text figure  illustrates unpermute  algorithm  apply   map repeatedly  recreate   bwtt   map  also use  exact match   matrix  sort lexicographically row begin   give sequence appear consecutively   series  step  exactmatch algorithm figure  calculate  range  matrix row begin  successively longer suffix   query   step  size   range either shrink  remain     algorithm complete row begin    entire query correspond  exact occurrences   query   text   range  empty  text   contain  query unpermute  attributable  burrow  wheeler   exactmatch  ferragina  manzini  see additional data file  supplementary discussion   detail search  inexact alignments exactmatch  insufficient  short read alignment  alignments may contain mismatch  may  due  sequence errors genuine differences  reference  query organisms    introduce  alignment algorithm  conduct  backtrack search  quickly find alignments  satisfy  specify alignment policy  character   read   numeric quality value  lower value indicate  higher likelihood   sequence error  alignment policy allow  limit number  mismatch  prefer alignments   sum   quality value   mismatch position  low  search proceed similarly  exactmatch calculate matrix range  successively longer query suffix   range become empty  suffix   occur   text   algorithm may select  alreadymatched query position  substitute  different base  introduce  mismatch   alignment  exactmatch search resume     substitute position  algorithm select   substitutions   consistent   alignment policy   yield  modify suffix  occur  least    text    multiple candidate substitution position   algorithm greedily select  position   minimal quality value backtrack scenarios play  within  context   stack structure  grow   new substitution  introduce  shrink   aligner reject  candidate alignments   substitutions currently   stack see figure    illustration    search might proceed  short bowtie conduct  qualityaware greedy randomize depthfirst search   space  possible alignments   valid alignment exist  bowtie  find  subject   backtrack ceiling discuss   follow section   search  greedy  first valid alignment encounter  bowtie   necessarily   'best'  term  number  mismatch   term  quality  user may instruct bowtie  continue search    prove   alignment  report  'best'  term  number  mismatch use  option best   experience  mode  two  three time slower   default mode  expect   faster default mode   prefer  large resequencing project  user may also opt  bowtie  report  alignments    specify number option    alignments   limit   number option    give read    course   search bowtie find  possible alignments   give set  substitutions   user  request   alignments     bowtie  report     alignments select  random note   modes   much slower   default   experience  example      twice  fast    excessive backtrack  aligner  describe  far    case encounter sequence  cause excessive backtrack  occur   aligner spend    effort fruitlessly backtrack  position close   ' end   query bowtie mitigate excessive backtrack   novel technique  'double indexing' two indices   genome  create one contain  bwt   genome call  'forward' index   second contain  bwt   genome   character sequence reverse  reverse complement call  'mirror' index  see   help consider  match policy  allow one mismatch   alignment  valid alignment  one mismatch fall  one  two case accord   half   read contain  mismatch bowtie proceed  two phase correspond   two case phase  load  forward index  memory  invoke  aligner   constraint   may  substitute  position   query' right half phase  use  mirror index  invoke  aligner   reverse query   constraint   aligner may  substitute  position   reverse query' right half  original query' leave half  constraints  backtrack   right half prevent excessive backtrack whereas  use  two phase  two indices maintain full sensitivity unfortunately    possible  avoid excessive backtrack fully  alignments  permit   two   mismatch   experiment   observe  excessive backtrack  significant    read  many lowquality position    align  align poorly   reference  case  trigger  excess   backtrack per read    many legal combinations  lowquality position   explore   possibilities  exhaust  mitigate  cost  enforce  limit   number  backtrack allow   search  terminate default   limit prevent  legitimate lowquality alignments   report   expect     desirable tradeoff   applications phase maqlike search bowtie allow  user  select  number  mismatch permit default two   highquality end   read default  first  base  well   maximum acceptable quality distance   overall alignment default  quality value  assume  follow  definition  phred      probability  error    10log    read   reverse complement  candidates  alignment   reference  clarity  discussion consider   forward orientation see additional data file  supplementary discussion    explanation    reverse complement  incorporate  first  base   highquality end   read  term  eed'  seed consist  two halve      highquality end usually  ' end       lowquality end term  'hihalf'   'lohalf' respectively assume  default policy two mismatch permit   seed  reportable alignment  fall  one  four case  mismatch  seed case   mismatch  hihalf one  two mismatch  lohalf case   mismatch  lohalf one  two mismatch  hihalf case   one mismatch  hihalf one mismatch  lohalf case   case allow  number  mismatch   nonseed part   read   case  also subject   quality distance constraint  bowtie algorithm consist  three phase  alternate  use  forward  mirror indices  illustrate  figure  phase  use  mirror index  invoke  aligner  find alignments  case    phase    cooperate  find alignments  case  phase  find partial alignments  mismatch    hihalf  phase  attempt  extend  partial alignments  full alignments finally phase  invoke  aligner  find alignments  case  performance result  evaluate  performance  bowtie use read    genomes project pilot national center  biotechnology information ncbi short read archivesrr001115  total   million read  one lane  data   illumina instrument  trim     align   human reference genome ncbi build  unless specify otherwise read data   filter  modify besides trim    appear   archive  lead       read align somewhere   genome   experience   typical  raw data   archive  aggressive filter lead  higher alignment rat  faster alignment  run  perform   single cpu bowtie speedups  calculate   ratio  wallclock alignment time  wallclock  cpu time  give  demonstrate  inputoutput load  cpu contention   significant factor  time require  build  bowtie index   include   bowtie run time unlike compete tool bowtie  reuse  precomputed index   reference genome across many alignment run  anticipate  users  simply download  indices   public repository  bowtie site  provide indices  current build   human chimp mouse dog rat  arabidopsis thaliana genomes  well  many others result  obtain  two hardware platforms  desktop workstation   ghz intel core  processor     ram   largememory server   fourcore  ghz amd opteron processor     ram   denote ''  erver' respectively    server run red hat enterprise linux  release  comparison  soap  maq maq   popular aligner        among  fastest compete open source tool  align millions  illumina read   human genome soap  another open source tool    report  use  shortread project   table  presents  performance  sensitivity  bowtie  soap   maq  soap could   run     soap' memory footprint exceed  ' physical memory  oapcontig' version   soap binary  use  comparison  soap bowtie  invoke  ' '  mimic soap' default match policy  allow   two mismatch   alignment  disregard quality value   'maxns '  simulate soap' default policy  filter  read  five   noconfidence base   maq comparison bowtie  run   default policy  mimic maq' default policy  allow   two mismatch   first  base  enforce  overall limit     sum   quality value   mismatch read position  make bowtie' memory footprint  comparable  maq' bowtie  invoke   '' option   experiment  ensure    forward  mirror index  resident  memory  one time  number  read align indicate  soap   bowtie     comparable sensitivity   read align  either soap  bowtie   align     align  bowtie   soap    align  soap   bowtie maq   bowtie  also  roughly comparable sensitivity although bowtie lag     read align  either maq  bowtie   align     align  bowtie   maq    align  maq   bowtie   read map  maq   bowtie almost   due   flexibility  maq' alignment algorithm  allow  alignments   three mismatch   seed  remainder   read map  maq   bowtie  due  bowtie' backtrack ceiling maq' documentation mention  read contain 'polya artifacts'  impair maq' performance table  presents performance  sensitivity  bowtie  maq   read set  filter use maq' 'catfilter' command  eliminate polya artifacts  filter eliminate     read  experimental parameters  identical     experiment  table     observations   relative sensitivity  bowtie  maq apply  read length  performance  sequence technology improve read lengths  grow beyond     commonly see  public databases today bowtie maq  soap support read  lengths        respectively  maq versions   later support read lengths     table  shows performance result   three tool   use  align three set    untrimmed read   set   set    set   human genome   server platform  set     randomly sample   larger set ncbi short read archive srr003084   srr003092   srr003196   read  sample    three set     uniform perbase error rate  calculate  perbase phred qualities  read pass  maq' 'catfilter' bowtie  run    maqlike default mode    soaplike ' ' mode bowtie  also give  '' option  ensure    forward  mirror index  resident  memory  one time maq   use instead  maq     set   cannot align read longer    soap   run    set     support read longer     result show  maq' algorithm scale better overall  longer read lengths  bowtie  soap however bowtie  soaplike ' ' mode also scale  well bowtie   default maqlike mode scale well     read   substantially slower   read although   still    order  magnitude faster  maq parallel performance alignment   parallelize  distribute read across concurrent search thread bowtie allow  user  specify  desire number  thread option  bowtie  launch  specify number  thread use  pthreads library bowtie thread synchronize     fetch read output result switch  indices  perform various form  global bookkeeping   mark  read  'done' otherwise thread  free  operate  parallel substantially speed  alignment  computers  multiple processor core  memory image   index  share   thread    footprint   increase substantially  multiple thread  use table  shows performance result  run bowtie    fourcore server  one two  four thread index build bowtie use  flexible index algorithm     configure  trade   memory usage  run time table  illustrates  tradeoff  index  entire human reference genome ncbi build  contigs run  perform   server platform  indexer  run four time  different upper limit  memory usage  report time compare favorably  alignment time  compete tool  perform index  alignment less   hours  require  bowtie   build  query  wholehuman index   million read    genome project ncbi short read archivesrr001115   server   sixfold faster   equivalent maq run  bottommost row illustrate   bowtie indexer  appropriate arguments  memoryefficient enough  run   typical workstation     ram additional data file  supplementary discussions    explain  algorithm   content   result index",-0.16775896142809416,0.20648380308363254,0.12222479013575772,0.11933002604282004,0.01729326925576091,-0.021389506999232574,-0.10937079332767292,0.06767177103691935,-0.01998867189863544,0.09852392912840707,0.013351318126960443,0.0030274316983421,0.14220668473302298,-0.12774513853266087,0.12839807012853055,-0.07422406050981223,0.02814086258272644,0.2163904367702642,-0.06487539325646542,0.06901963716994541,0.03415218970200362,-0.2120277773097788,0.041490247425985685,0.013634852568064713,0.024569009828509642,-0.1741245541595923,0.02156872548218605,-0.19566989876411167,-0.056169549584378815,-0.042189214564519566,0.002294714495346249,0.2767163842825469,-0.20675526568627495,-0.09132885408667396,0.19660104549231688,0.14055965852407235,0.028676333190323894,-0.04420658337183128,-0.06339541025419945,-0.11372481255532432,-0.06676604790619861,-0.1635357243648434,-0.057989337903614664,-0.06359534452114267,-0.1459971154098485,-0.030472293736479764,0.13691613263294936,-0.1609068520392135,-0.15157787599099026,-0.3906362293855764,0.14683359791677086,0.00914253187129139,0.0571289527316108,0.6133402663187155,0.033608039482261,-1.2003972626063262,0.05925408248662833,-0.1980204670050021,1.0389852273660098,0.1904107193883312,-0.1467832385160189,0.3305103239640114,-0.09976222072841752,0.06498700175897575,0.5572581888655165,0.029994127365045763,0.07810689670961825,0.010109290417123678,0.17624821030432408,-0.18391477611800897,-0.03809888840330575,-0.046188486085588634,0.08541631117786352,-0.1376370657988122,0.15819911844743964,-0.016161997013425262,-0.12499203268246785,-0.09720400448237744,-0.34893449016214456,-0.07597859732140139,0.2427624365977347,-0.03219517047143579,-0.3665573372563305,-0.04000751516973945,-0.892821221053072,0.06780553362314,0.23281342520587384,-0.11108267814754776,-0.08799882044298102,-0.05076570834217465,-0.1650607762504759,0.1001244291340031,-0.0967167371979071,-0.10519519091557784,-0.12394254436260528,-0.09746617906569237,-0.0749173639646941,-0.28363903724179274,0.3740628537875121,0.06284066962413848,Alignment,0
9,9,"graphbased genome alignment  genotyping  hisat2  hisatgenotype
 human reference genome represent   small number  individuals  limit  usefulness  genotyping  present  method name hisat2 hierarchical index  splice alignment  transcripts    align  dna  rna sequence use  graph ferragina manzini index  use hisat2  represent  search  expand model   human reference genome     million genomic variants  combination  haplotypes  incorporate   data structure use  search  alignment  benchmark hisat2 use simulate  real datasets  demonstrate   strategy  represent  population  genomes together   fast memoryefficient search algorithm provide  detail  accurate variant analyse   methods  apply hisat2  hla type  dna fingerprint  applications form part   hisatgenotype software  enable analysis  haplotyperesolved genes  genomic regions hisatgenotype outperform  computational methods  match  exceed  performance  laboratorybased assays
gfm index  sequence search   index  perform   map  number  time   last column label   give row  occurs    including  needs   identify  involve count occurrences   top   table   row   count would  prohibitively timeconsuming    human genome  accelerate  process  table  partition  small block     hundred row  additional number  store within  block record  number  occurrences   specific base  appear    block  also optimize  local count process   count  number  time  specific base appear within  block  overall index scheme  call  gfm index supplementary fig  supplementary figure  illustrates   read  contain  know onebase insertion  align   genome use  gfm index repeat sequence hisat2 give  read length   example    first build  kmer table   reference genome sequence   reverse complement together    set     kmer must appear  least  time  example five time   include note   use  strand   genome   read  map   reference andor  reverse complement although   directly use  kmer table  align read  length   would require  large amount  memory  store  sequence   kmers   correspond genomic coordinate  reduce  memory use  combined kmers  originate    regions  possible  example suppose     identical regions    length   reference genome  region   mers   mer present    regions     store  coordinate   kmer  number   coordinate would   however    combine kmers occur    region  one sequence  simply need  store one coordinate per region thus  number  coordinate would drop    practice real genomes  identical sequence  vary length supplementary figure  illustrates   merge kmers  repeat sequence    use     initial value  approach substantially reduce  number  coordinate  store  example  number  mers  occur   five time   human reference genome     average number  coordinate correspond   mer    amount   total   coordinate   would store use  naive approach   allow kmers   extend     certain length  example    reduce  number  coordinate    refer   kmers  extended kmers  repeat sequence  kmers  extend      number  repeat sequence  reduce      strategy guarantee   read whose sequence  present ≥ times   genome  map    locations similarly  read pair      sequence  present ≥ times   genome  map  specifically  read whose sequence  present  times  ≥   map   one repeat sequence  portion   repeat sequence match  read exactly includes  coordinates  approach work perfectly   fix read length    typical  experiment use illumina sequencers although read   length close    also  handle  slightly decrease alignment sensitivity hisat2 also allow  build index  various read length  use  one        actual run    require   small amount  additional memory  build  bwtfm index   minimizerbased kmer table32   window size  five       repeat sequence  enable rapid alignment   read    three mismatch hisatgenotypes type algorithm  allele sequence may   partially available  example exons  hisatgenotype first identify two alleles   basis   sequence commonly available   alleles  example exons  example  imgthla database include many sequence   key exons  hla genes   contain far fewer complete sequence comprise  exons introns  utrs   genes  far  alleles   classify  hlaa although  alleles  hlaa  know sequence  exons      alleles  fulllength sequence available  sequence   remain  alleles include either  eight exons   subset   hlab   alleles     full sequence available hlac   alleles    fully sequenced hladqa1   alleles   fully sequenced hladqb1   alleles   fully sequence  hladrb1   alleles    fully sequence   step hisatgenotype first choose representative alleles  group  alleles     exon sequence next  identify alleles   representative alleles   highly likely   present   sequence sample    alleles   group    exons   representatives  select  assessment   next step second hisatgenotype  identify candidate alleles   basis   exons  introns hisatgenotype apply  follow statistical model     two step  find maximum likelihood estimate  abundance    algorithm33  previously implement   solution   centrifuge system34   use  similar algorithm  hisatgenotype  modifications   variable definitions  follow  likelihood   particular composition  allele abundance      number  reads    number  alleles    abundance  allele    sum      alleles    length  allele   cij    read   align  allele    otherwise expectation estep     estimate number  read assign  allele  maximization mstep   ′    ′   update estimate   abundance  allele  ′   use   next iteration hisatgenotype find  abundances   best reflect  give read alignments    abundances  maximize  likelihood function lαc   repeat   procedure     time    difference   previous  current estimate  abundances",-0.18178182052284253,0.21022498001751594,0.1294310636231271,0.16268923388279233,-0.011949190227112369,-0.0192777772619073,-0.04542836382162977,0.09518058207471744,-0.06141772266529408,0.13367778688209328,0.002010500584931477,-0.01197092117082258,0.16895034534446152,-0.09086357031823047,0.1378644188917177,-0.011653155079747764,0.020197032380311158,0.16819207258095895,-0.03708575111134151,0.09255505768366748,0.02510501842393384,-0.20776314657616796,0.057925259166611176,0.03774072782581915,-0.05048631582487236,-0.2478139734326613,0.09785772739748344,-0.159504183734368,-0.058674228413071,-0.0615676819642945,0.04681820246197214,0.2270150627052955,-0.172549208059711,-0.0811677114708676,0.2127790453548938,0.0962209667119643,0.08025232727729037,0.011915775303373123,-0.08479894443468614,-0.0922456205770466,-0.044898130474879665,-0.16456696141933475,-0.05676849501410655,-0.08391234747413256,-0.11391686663658485,-0.018022550649305386,0.0871429464682902,-0.16126710164229824,-0.2312590932818448,-0.3437923449695382,0.13394368993644806,0.016291969980009084,0.08840498329058538,0.548103091142123,-0.030208523623841983,-1.096607905344008,-0.007070942313312003,-0.22297836313066105,0.9233291107750504,0.2275428830507509,-0.14684888678474528,0.30839386225247073,-0.02913107239837926,0.07822935021050731,0.562280336732402,0.061145789445499366,-0.010210409946667366,0.06376056393835497,0.2195921709669916,-0.15604462094517474,-0.06824568097995919,-0.02962542287369045,0.05527261158034584,-0.11318670172296373,0.19478797766246966,-0.042153996781312986,-0.12243427933983345,-0.1281245649547854,-0.3701150845627804,-0.08471694266216513,0.20771376712656991,-0.0408465905423762,-0.3501477340563137,-0.07712595933695432,-0.8347853987202227,0.06712775785217108,0.20079622932320013,-0.1664551128582705,-0.08179334229344982,-0.01251059299635322,-0.1869110385981325,0.08235360063852523,-0.11870110894319084,-0.11346044207479145,-0.14817242576602033,-0.06776743468695454,-0.11209632349838662,-0.3004636758828524,0.30576271496666885,0.045182354797418264,Alignment,0
10,10,"star ultrafast universal rnaseq aligner
accurate alignment  highthroughput rnaseq data   challenge  yet unsolved problem    noncontiguous transcript structure relatively short read lengths  constantly increase throughput   sequence technologies currently available rnaseq aligners suffer  high map error rat low map speed read length limitation  map bias  align  large  billon read encode transcriptome rnaseq dataset  develop  splice transcripts alignment   reference star software base   previously undescribed rnaseq alignment algorithm  use sequential maximum mappable seed search  uncompress suffix array follow  seed cluster  stitch procedure star outperform  aligners   factor of450  map speed align   human genome  million    pairedend read per hour   modest core server     time improve alignment sensitivity  precision  addition  unbiased  novo detection  canonical junctions star  discover noncanonical splice  chimeric fusion transcripts   also capable  map fulllength rna sequence use roche  sequence  reverse transcription polymerase chain reaction amplicons  experimentally validate  novel intergenic splice junctions    success rate corroborate  high precision   star map strategy
many previously describe rnaseq aligners  develop  extensions  contiguous dna short read mappers   use  either align short read   database  splice junctions  align splitread portion contiguously   reference genome   combination thereof  contrast   approach star  design  align  noncontiguous sequence directly   reference genome star algorithm consist  two major step seed search step  clusteringstitchingscoring step  seed search  central idea   star seed find phase   sequential search   maximal mappable prefix mmp mmp  similar   maximal exact unique match concept use   largescale genome alignment tool mummer delcher     kurtz    mauve darling     given  read sequence  read location    reference genome sequence   mmprig  define   longest substring    …  rimml   match exactly one   substrings    mml   maximum mappable length   explain  concept use  simple example   read  contain  single splice junction   mismatch fig    first step  algorithm find  mmp starting   first base   read   read   example comprise  splice junction  cannot  map contiguously   genome  thus  first seed   map   donor splice site next  mmp search  repeat   unmapped portion   read    case   map   acceptor splice site note   sequential application  mmp search    unmapped portion   read make  star algorithm extremely fast  distinguish   mummer  mauve  find  possible maximal exact match  approach represent  natural way  find precise locations  splice junctions   read sequence   advantageous   arbitrary split  read sequence use   splitread methods  splice junctions  detect   single alignment pass without   priori knowledge  splice junctions loci  properties  without  preliminary contiguous alignment pass need   junction database approach  mmp  star search  implement  uncompress suffix array sas manber  myers  notably finding mmp   inherent outcome   standard binary string search  uncompress sas    require  additional computational effort compare   fulllength exact match search  binary nature    search result   favorable logarithmic scale   search time   reference genome length allow fast search even  large genomes advantageously   mmp   search  find  distinct exact genomic match  little computational overhead  facilitate  accurate alignment   read  map  multiple genomic loci “multimapping” read  addition  detect splice junctions  mmp search implement  star enable find multiple mismatch  indels  illustrate  figure    mmp search   reach  end   read    presence  one   mismatch  mmps  serve  anchor   genome    extend allow  alignments  mismatch   case  extension procedure   yield  good genomic alignment  allow identification  polya tail library adapter sequence  poor sequence quality tail fig   mmp search  perform   forward  reverse directions   read sequence    start  userdefined search start point throughout  read sequence  facilitate find anchor  read  errors near  end  improve map sensitivity  high sequence error rate condition besides  efficient mmp search algorithm uncompress sas also demonstrate  significant speed advantage   compress sas implement  many popular short read aligners supplementary section   speed advantage  trade    increase memory usage  uncompress array   assess   section   cluster stitch  score   second phase   algorithm star build alignments   entire read sequence  stitch together   seed   align   genome   first phase first  seed  cluster together  proximity   select set  anchor seed  find   optimal procedure  anchor selection   limit  number  genomic loci  anchor align    seed  map within userdefined genomic windows around  anchor  stitch together assume  local linear transcription model  size   genomic windows determine  maximum intron size   splice alignments  frugal dynamic program algorithm see supplementary section   detail  use  stitch  pair  seed allow   number  mismatch   one insertion  deletion gap importantly  seed   mat  pairedend rnaseq read  cluster  stitch concurrently   pairedend read represent   single sequence allow   possible genomic gap  overlap   inner end   mat    principled way  use  pairedend information   reflect better  nature   pairedend read namely  fact   mat  piece end    sequence  approach increase  sensitivity   algorithm   one correct anchor  one   mat  sufficient  accurately align  entire read   alignment within one genomic window   cover  entire read sequence star  try  find two   windows  cover  entire read result   chimeric alignment  different part   read map  distal genomic loci  different chromosomes  different strand supplementary fig  star  find chimeric alignments    mat  chimeric      chimeric junction locate   unsequenced portion   rna molecule  two mat star  also find chimeric alignments   one   mat  internally chimerically align thus pinpoint  precise location   chimeric junction   genome  example   bcrabl fusion transcript detection   k562 erythroleukemia cell line  give   supplementary section  supplementary fig   stitch  guide   local alignment score scheme  userdefined score penalties  match mismatch insertions deletions  splice junction gap allow   quantitative assessment   alignment qualities  rank see supplementary section   detail  stitch combination   highest score  choose   best alignment   read  multimapping read  alignments  score within  certain userdefined range   highest score  report although  sequential mmp search  find  seed exactly match  genome  subsequent stitch procedure  capable  align read   large number  mismatch indels  splice junctions scalable   read length  characteristic  become ever  important   emergence   thirdgeneration sequence technologies   pacific biosciences  ion torrent  produce longer read  elevate error rat",-0.18150424645938648,0.16766699080204597,0.1183349608449023,0.16653834680619184,0.006071427478130373,-0.035113512299751765,-0.04791777208165327,0.04854329004147261,-0.03816873645017931,0.13678051595343274,-0.001738207467756833,-0.015252900573577047,0.12883876474422454,-0.0722690231448315,0.1990244180161259,0.002266754912407309,0.04790610921859019,0.14936359783091668,-0.007449802751320281,0.06415858321908709,0.016722868838732374,-0.17451008487842046,-0.001096242943592132,-0.00884754420243256,0.042288119393598035,-0.14795038849234166,0.10664182359293906,-0.11303967834427735,-0.08276956738930549,-0.04814202379499448,-0.005072055532411691,0.22120071675839872,-0.13912694963949676,-0.0820604036704694,0.2379346581774185,0.03869438768490408,0.03065827310148256,0.007074269679332228,-0.042921962080629095,-0.07054465483548594,-0.016775385452222378,-0.1094034992761872,-0.05123079727921749,-0.07934295649940802,-0.1107142343962736,0.005189413899123403,0.16483865645642828,-0.11951154368342735,-0.1951134632854148,-0.2809094850731805,0.14928931630931067,0.023606045197604026,0.07871221783567975,0.5610361697071479,0.05234570951751619,-1.1285388317880962,0.0340229782135682,-0.18373099263794293,0.94887764150234,0.17803654513782208,-0.1881245454178312,0.3238035572023958,-0.011860073628426738,0.0924601801481022,0.559223224443968,-0.003355082810713259,0.024753178194241256,0.021882642883740897,0.1822873709701971,-0.157951187178919,-0.07323932512662748,-0.015291920888038088,0.15371768969390007,-0.12861177563647694,0.2140193797406807,-0.06417360505304028,-0.10488622085392066,-0.13621133263698038,-0.2950380942701096,-0.05437101671093248,0.20037107157422354,-0.007427615002857888,-0.3571609506322361,-0.028641468741365576,-0.8225090802286048,0.09471890901135784,0.21426145484129308,-0.13485516775435086,-0.10287650950949126,-0.028858583217771988,-0.17891626310183156,0.11480449749173464,-0.13722890271503496,-0.08947538789741848,-0.08154682897991139,-0.08831442431047824,-0.09265509275279996,-0.3398381759494553,0.3051562563980079,0.11808160134788355,Alignment,0
11,11,"tophat2 accurate alignment  transcriptomes   presence  insertions deletions  gene fusions
tophat   popular splice aligner  rnasequence rnaseq experiment   paper  describe tophat2  incorporate many significant enhancements  tophat tophat2  align read  various lengths produce   latest sequence technologies  allow  variablelength indels  respect   reference genome  addition   novo splice alignment tophat2  align read across fusion break   occur  genomic translocations tophat2 combine  ability  identify novel splice sit  direct map  know transcripts produce sensitive  accurate alignments even  highly repetitive genomes    presence  pseudogenes
given rnaseq read  input tophat2 begin  map read   know transcriptome   annotation file  provide  transcriptome map improve  overall sensitivity  accuracy   map  also give  whole pipeline  significant speed increase owe   much smaller size   transcriptome compare     genome   transcriptomemapping step  read remain unmapped    derive  unknown transcripts  present   annotation    contain many miscall base  addition  may  poorly align read    map   wrong location tophat2 align  unmapped  potentially misalign read   genome figure  step   read contain entirely within exons   map whereas  span introns may   use unmapped read  step  tophat2 try  find novel splice sit   base  know junction signal gtag gcag  atac tophat2 also provide  option  allow users  remap    map read depend   edit distance value   read    read whose edit distance  greater   equal   userprovided threshold   treat  unmapped read  accomplish   unmapped read  previously map read  low alignment score  split  smaller nonoverlapping segment     default    align   genome figure  step  tophat2 examine  case    leave  right segment    read  map within  userdefined maximum intron size usually        pattern  detect tophat2 realign  entire read sequence   genomic region  order  identify   likely locations   splice sit figure  use  similar approach indels  fusion breakpoints  also detect   step  genomic sequence flank  splice sit  concatenate   result splice sequence  collect   set  potential transcript fragment  read  map   previous stag  map  poorly   realign  bowtie2    novel transcriptome   step    read may   align incorrectly  extend  exonic alignment   base   adjacent intron figure  figure  step    tophat2 check   alignments extend   introns identify   splitalignment phase     realign  read   adjacent exons instead   final stage tophat2 divide  read    unique alignments    multiple alignments   multimapped read tophat2 gather statistical information  example  number  support read   relevant splice junctions insertions  deletions   use  recalculate  alignment score   read base   new alignment score tophat2 report   likely alignment locations   multimapped read  pairedend read tophat2 process  two read separately    map stag describe    final stage  independently align read  analyze together  produce pair alignments take  consideration additional factor include fragment length  orientation   experiment describe   study  program version number  tophat2  tophat1  gsnap  rum 12_01 mapsplice   star    specific parameters   program see additional file  table     source code  tophat ",-0.2068003848811548,0.14932578061918986,0.1460971762018744,0.13741318783193654,0.03885706293248487,-0.010948997572135835,-0.06906096733397465,0.0789594081574416,-0.004466916764663024,0.10890135970178316,-0.014188155977965588,0.02039615203744192,0.16062408120540733,-0.06604040433568033,0.1428557300728492,-0.029995838420423256,0.058744197834113776,0.1484788074106539,-0.0720633258619769,0.08731049294266004,0.03218927718487314,-0.18736954147144305,0.02737745889363313,-0.020838319688019427,-0.047445432963352435,-0.2199407766276801,0.08540426179983611,-0.1049871840577742,0.008299806380686774,-0.07384644640419125,0.06295491270773874,0.24684533219022506,-0.135562027387575,-0.06829535208737733,0.2087836372408095,0.05609959920190952,0.061579844864635636,-0.009148953041188757,-0.11937852092828095,-0.04229588687568056,-0.07562380984362045,-0.17303337413111214,-0.08223229705948723,-0.11408152365474962,-0.1377253867897459,-0.022179933093932708,0.09223558752776376,-0.1701063739114695,-0.19939223905940626,-0.3280123586311344,0.18245605297799392,0.06499876036369559,0.06363356861772693,0.5813424240728967,0.036357039577243004,-1.2192174660719253,0.011174907655963169,-0.2291145030753052,1.0179270088926635,0.24563422606072646,-0.1690185275210586,0.4541353318586268,0.030822322463659062,0.04118118426677855,0.6120763815643097,0.03335002226839689,0.03310385040769523,0.051708008743695584,0.15392243293198676,-0.15268463463157372,-0.03451992628820748,-0.030586616177672776,0.13149275720206788,-0.1502112488241189,0.195441694225354,-0.043160013844449584,-0.12325595425314866,-0.1377673010394739,-0.3184189485894008,-0.044411068625578816,0.20576995896335576,-0.03791332702914423,-0.35331982333551754,-0.03667451477905905,-0.8921900427445176,0.07535906133548864,0.2124219823882661,-0.10690219355958767,-0.11110834893770516,-0.0013471154411408034,-0.2131337550468743,0.0700597357608124,-0.17750591749579392,-0.12163652445782315,-0.18257041488964615,-0.08502945736717347,-0.09169953061077236,-0.30838727253378073,0.3520322365262969,0.1088600072734566,Alignment,0
12,12,"lordfast sensitive  fast alignment search tool  long noisy read sequence data
recent advance  genomics  precision medicine   make possible   application  high throughput sequence hts  large collections  human genomes although hts technologies  prove  use  catalog human genome variation computational analysis   data  generate  still far   perfect  main limitation  illumina   popular sequence technologies   short read length relative   lengths  common genomic repeat newer single molecule sequence  sms technologies   pacific biosciences  oxford nanopore  produce longer read make  theoretically possible  overcome  difficulties impose  repeat regions unfortunately    high sequence error rate read generate   technologies   difficult  work   cannot  use  many   standard downstream analysis pipelines note      difficult  find  correct map locations   read   reference genome  also  establish  correct alignment    differentiate sequence errors  real genomic variants furthermore especially since newer sms instrument provide higher throughput map  alignment need   perform much faster   maintain high sensitivity  introduce lordfast  novel 
longread mapper   specifically design  align read generate  pacbio  potentially  sms technologies   reference lordfast    higher sensitivity   available alternatives   also among  fastest     low memory footprint
overview lordfast   heuristic anchorbased aligner  long read generate  third generation sequence technologies lordfast aim  find  set  candidate locations ideally  one per read   costly step  basetobase alignment   reference genome lordfast work  two main stag  stage one  build  index   reference genome   use  find short exact match  index   combination   lookup table   uncompress  index  stage two  map  long read   reference genome  four step    read  identify  fix number  evenly spaced kmers      default settings   match   reference genome   use   index    match  obtain  longest exact match prefix extension among  extend match   kmer identify   read  finally choose  longest  could    one  act  anchor match    read   split  reference genome  overlap windows  length twice    read  identify   window   candidate region   number  anchor match   window    threshold value iii   candidate region  identify  longest chain  concordant anchor match  chain  anchor match   equal respective space   read   reference genome   obtain  basetobase alignment  perform dynamic program  consecutive anchor match   select chain  provide   detail description   step   stage one reference genome index  order  build  substring index   reference genome  use  combination   simple lookup table  initial short match   uncompress  index  extend  initial match  combine index benefit   speed  lookup table   compactness   burrowswheeler transform bwt representation   reference genome  lookup table   entries   possible hmers provide  constant time search capability   hmers position   uncompress  index ferragina  manzini    default setting      user  give  option  pick  value   well know   index provide  compact representation   suffix array manber  myers    use  find exact match extensions  initial hmer match note   order   able  perform efficient search   strand   reference genome  use  extension    index implement  fermi    combine index provide   speed    standard uncompress  index see supplementary figs     speed gain  extra memory usage  stage two read map give  set  long read lordfast align one read   time  follow  step  sparse extraction  anchor match   give read  length  lordfast identifies  user define default  evenly space anchor position   read   anchor position  find  longest prefix match  length  least      genome  follow first  extract  first hmer start   anchor position  use  lookup table   genome index  obtain  interval  represent  initial set  match locations    index   use  lfmapping operation    index  extend  initial set  match  identify  longest match note  use longest match reduce  total number  anchor match significantly  longest match   add   set  anchor    triplets        anchor position   read    start location   longest match   genome     length   match   end   step   partition       base   strand   match location   genome note   read    short        use      anchor position instead   anchoring position  step  candidate region selection  order  select  candidate regions  alignment lordfast split  reference genome  overlap windows  size   illustrate  fig    window  calculate two score   forward  reverse strand  anchor match   respective strand          anchor match fall   window  adds        score   window lordfast keep   windows  score scoremax∕     factor define  significance   window score default   scoremax   maximum window score   word lordfast keep  windows whose score   significantly worse   maximum window score  case  two overlap windows  meet  minimum window score requirement lordfast  keep  one  higher window score   final list tie  break  choose  window  smaller reference coordinate figure  depicts  example   selection process step  chain  anchor selection among   anchor match   candidate region lordfast choose  set  concordant anchor use local chain  best local chain   set  colinear nonoverlapping anchor   reference genome    highest score among   set ohlebusch  abouelhoda   calculate  best local chain lordfast assign  weight   anchor match equal   length   match lordfast support two chain algorithms  default  obtain  best chain use  dynamic program base chain algorithm ohlebusch  abouelhoda  note   time complexity   chain algorithm  quadratic   practice   fast due   small number  anchor match per read   also possible   user  select  alternative chain algorithm base  clasp otto     anchor match   best local chain form  basis   alignment   region  step  alignment lordfast prioritize  candidate regions base   best chain score  perform  final alignment   top  regions default value      order  generate  basetobase alignment   region  use anchor match   top score chain  perform band global alignment  gap  pair  consecutive anchor match furthermore  alignment   prefix   read   reference prior   first anchor   perform   use   anchor globaltolocal alignment   alignment   suffix   read   reference follow  last anchor   compute   identical fashion  strategy   widely use technique  avoid compute  full alignment  long sequence   need huge memory  computational time lordfast uses edlib šošić  šikić   compute  global alignments  ksw library   compute  globaltolocal alignments edlib   library implement  fast bitvector algorithm devise  myers  ksw    hand provide alignment extension base  affine gapcost model   worth mention  lordfast support clip  follow   prefix   read   first anchor  respectively suffix   read   last anchor   alignment scoresimilarity   lower   threshold thclip lordfast perform clip   prefix  respectively suffix     use ksw library  extend  alignment  long   significant drop   alignment scoresimilarity   observe use  parameter similar  blast xdropoff  addition lordfast support split alignment  follow let sij denote  substring    start  position   end  position  suppose   map  long read    reference genome  consider two consecutive anchors             per  definition    best chain choose   candidate window   alignment                 score lower   threshold thsplit  split  alignment  report one alignment  primary  another  supplementary   definition   sam format specification one alignment correspond   substring  anchor     alignment correspond   substring  anchor  furthermore since  drop  alignment scoresimilarity could  due   presence   inversion  check   alignment   reverse complement                 score higher  thsplit   case   alignment   also report  another supplementary alignment",-0.17644504591298754,0.21192105806640987,0.13485139932232226,0.1455510740928156,0.0249639054515252,-0.06651049559889208,-0.07933436049007518,0.045838433975893024,-0.07205862341399648,0.12105375172165958,0.013124881582763537,-0.07127950168092195,0.0864190333985454,-0.07977960438553341,0.13350713299870748,-0.056025462900901116,0.047120456564803855,0.16784644502400434,-0.02622509362355279,0.0447945260271234,0.028597043052095136,-0.17916762613182838,0.03978265084155474,0.015475364247226698,0.05704177970274989,-0.15457205893471834,0.02435114882766931,-0.19401934460222134,-0.05711973565331916,-0.07795299225824573,-0.03582764955874729,0.23751418724362006,-0.14578185837385,-0.07801622782074111,0.20689014859174346,0.09634668823258068,0.019599858036656908,0.007435274204410809,-0.05963939138577859,-0.10527142859554213,-0.056898413722841434,-0.16025194532213438,-0.0018278698277610695,-0.10627969919648757,-0.1006795327018297,-0.015523774893479544,0.14957983019626944,-0.15064196093314278,-0.1437875294288939,-0.349234482227506,0.12767612174839565,0.0025206570504355784,0.05154666082418867,0.6172048426625368,0.03161726865525308,-1.2490500132504263,0.0124997555296623,-0.1566547157466534,1.005203445564563,0.2102929516304836,-0.17087077092000982,0.2664353001320514,-0.08823169463828794,0.07402065668169311,0.5455024503312368,0.004512797058314868,0.017997342643426045,0.019798845257365,0.20314471931441835,-0.1582595252271092,-0.0768135479976129,-0.014622760385176852,0.07091449036869514,-0.1215763518571437,0.18482215946883354,-0.015399441228395231,-0.1406199559024045,-0.13294127298286185,-0.347352645816404,-0.07134992557244244,0.22819497519694296,-0.0498551430458687,-0.3364342316292765,-0.056032552293158684,-0.8426191570283232,0.04306258601534769,0.18892077104139485,-0.1673595120058101,-0.07908472876603666,-0.046432026266120384,-0.1768747611547281,0.10624755815707,-0.0951447230285818,-0.08038614696339018,-0.17909643944574208,-0.08595363431316065,-0.07554810093440066,-0.2706735209304545,0.3470514524939445,0.09471864124796794,Alignment,0
13,13,"align sequence read clone sequence  assembly contigs  bwamem
bwamem   new alignment algorithm  align sequence read  assembly contigs   large reference genome   human  automatically choose  local  endtoend alignments support pairedend read  perform chimeric alignment  algorithm  robust  sequence errors  applicable   wide range  sequence lengths  70bp    megabases  map 100bp sequence bwamem show better performance  several stateofart read aligners  date
aligning  single query sequence  seed  reseed bwamem follow  canonical seedandextend paradigm  initially seed  alignment  supermaximal exact match smems use  algorithm  find previously   algorithm   essentially find   query position  longest exact match cover  position however occasionally  true alignment may  contain  smems  reduce mismappings cause  miss seed  introduce reseed suppose    smem  length    occurrences   reference genome     large  28bp  default  reseed   longest exact match  cover  middle base   smem  occur  least    time   genome  seed   find  require  minimum occurrence   original smem algorithm  chain  chain filter  call  group  seed   colinear  close      chain  greedily chain  seed  seed   filter  short chain   largely contain   long chain   much worse   long chain  default    38bp shorter   long chain chain filter aim  reduce unsuccessful seed extension   later step  chain may  always correspond   final hit chain detect    need   accurate  seed extension  rank  seed   length   chain  belong      seed length   seed   rank list   best   worst  drop  seed    already contain   alignment find   extend  seed   band affinegappenalty dynamic program    potentially lead   new alignment bwamems seed extension differ   standard seed extension  two aspects firstly suppose   certain extension step  come  reference position    best extension score achieve  query position  bwamem  stop extension   difference   best extension score   score     larger  zxypgapext  pgapext   gap extension penalty     arbitrary cutoff  heuristic avoid extension   poorly align region  good flank alignment   similar   xdropoff heuristic  blast altschul       penalize long gap  one   reference   query sequence secondly  extend  seed bwamem try  keep track   best extension score reach  end   query sequence   difference   best score reach  end   best local alignment score    threshold  local alignment   reject even     higher score bwamem use  strategy  automatically choose  local  endtoend alignments  may align  true variations towards  end   read  thus reduce reference bias  avoid introduce excessive mismatch  gap  may happen   force  chimeric read   endtoend alignment percent map read   function   false alignment rate  different map quality cutoff alignments  map quality   lower  exclude  alignment  wrong   correct clip  start position  within 20bp   simulate position  pair  101bp read  simulate   human reference genome use wgsim    substitution errors   indel variants  insert size follow  normal distribution     read  align back   genome either  single end  top panel   pair end  bottom panel gem  configure  allow    gap   output suboptimal alignments option              gem   compute map quality  map quality  estimate   bwalike algorithm  suboptimal alignments available  mappers  run   default set except  specify  insert size distribution  run time  second   single cpu core  show   parentheses  pairedend map  rescue miss hit like bwa   durbin  bwamem process  batch  read   time   batch  estimate  mean    variance     insert size distribution  reliable singleend hit   top  hit  default  either end   mate  unmapped   window         hit bwamem perform sse2based smithwaterman alignment  farrar    mate within  window  second best  score  record  detect potential mismapping   long tandem repeat hit find    singlesequence alignment   rescue   use  pair  pair give  ith hit   first read  jth hit   second bwamem compute  distance dij   two hit    right orientation  set dij  infinity otherwise  score  pair    sij      min{ log4 pdij  }        score   two hit respectively    match score   give  probability  observe  insert size larger   assume  normal distribution log4  arise   interpret  score  odds ratio durbin       threshold  control pair  dij  small enough    log4 pdij    bwamem prefer  pair  two end otherwise  prefer  unpaired alignments bwamem choose  pair    maximize sij   final alignments   end  pair strategy jointly consider  alignment score  insert size   possibility  chimeric read pair",-0.17843832136682605,0.16862313635647294,0.1911160760057596,0.1036084507868248,-0.04903203551073335,0.005028483893481954,-0.10756958801842603,0.0906857999014972,-0.06045095659759042,0.08003769951161517,0.0365555950784288,0.024141271749632785,0.14376132834642644,-0.08122571650224883,0.14441163016242847,-0.07979859139997257,-0.042272891689886384,0.15065097255385265,-0.0672749714187545,0.07007078396024577,0.11283391420178675,-0.1767153166439785,0.050132030269004216,0.0062133110988731605,0.05727698896614347,-0.12959422325334882,-0.02069986335712896,-0.21569762237208956,0.01714041547876479,-0.06911149200203905,0.028127941610892455,0.23894498537471484,-0.12016293028282755,-0.0932403048129058,0.18231712411179485,0.1008399483684357,0.009968370391142732,0.0002790173540400061,-0.06731523949933309,-0.082137869801172,-0.08125918222162339,-0.08666681243213332,-0.027380797005171712,-0.09836021339058487,-0.10449713247237348,-0.062121112128272385,0.14983152077653475,-0.1681278177760675,-0.21215258376054488,-0.4535912475127253,0.13859676196837406,0.013430807435627206,0.023106739446554187,0.6121812467212959,0.0209979364937622,-1.3047001770760958,0.044689571555022914,-0.1497152123327357,1.000568233308546,0.2419821484163353,-0.1940744259444985,0.2680745531611252,-0.09651643878907153,0.09587513904611324,0.5851547370955188,0.029414052843019418,0.06433500541961587,0.05849927161589906,0.10777107391115877,-0.16791435568422367,-0.056233492483782135,-0.06509025369839255,0.04163981520480687,-0.11683805141511194,0.19665513813118435,-0.0578460427177202,-0.1372053340339439,-0.15306435968546614,-0.3140396140065164,-0.08725789821861933,0.2195743110842876,-0.053207840364907055,-0.4003007134195671,-0.056192296207465214,-0.8747283364896492,-0.028197098195829887,0.1655208380172266,-0.09876611682429484,-0.06564649662393476,-0.0399750714860214,-0.2326682985236194,0.09698003737880152,-0.13045713665797526,-0.08536953919343516,-0.2400024842200605,-0.06910171932257098,-0.1016922273896768,-0.18870832053794254,0.3071574188562738,0.04720368658569658,Alignment,0
14,14,"kart  divideandconquer algorithm  ngs read alignment 
nextgeneration sequence ngs provide  great opportunity  investigate genomewide variation  nucleotide resolution due   huge amount  data ngs applications require  fast  accurate alignment algorithms  exist algorithms  read map basically adopt seedandextend strategy   sequential  nature  take much longer time  longer read  develop  divideandconquer algorithm call kart   process long read  fast  short read  divide  read  small fragment    align independently  experiment result indicate   average size  fragment require   timeconsuming gap alignment  around   regardless   original read length furthermore   tolerate much higher error rat  experiment show  kart spend much less time  longer read   aligners  still produce reliable alignments even   error rate   high  
overview   algorithms  suffixbwt array base aligners  follow  canonical seedandextend methodology initiate  alignment   mem seed  extend  alignment  different dynamic program strategies therefore  performance   aligner  greatly affect   algorithms  seed exploration   strategies  handle inexact match  aligners  sequential  nature  adopt  divideandconquer strategy  reduce  timeconsuming gap alignment step use dynamic program   suitable  map highly similar fragment sequence  read  essentially  copy   specific genome fragment except   small percentage  sequence errors  simple pair  normal pair since ungapped without indels alignment  much faster  gap alignment   map candidate region   reference genome  separate  give read sequence   candidate regions  two group simple region pair abbreviate  simple pair  normal region pair normal pair   simple pair  perfect alignment exact match  normal pair require ungappedgapped alignment   simple  normal pair  identify    process  align independently   final map result   candidate region  simply  concatenation   alignment   simple  normal pair consider  read sequence   reference genome    bwt array construct     reverse sequence   simplicity  without lose generality  assume    concatenation       remainder   paper let ri1   i1th nucleotide    ri1    subsequence  ri1  ri2 similarly let gj1   j1th nucleotide    gj1    subsequence  gj1  gj2  locally maximal exact matches lmems   give bwt array  length   define   maximal exact match  ri1  call  read block  gj1  call  genome block               denote   tuple      use δpos     represent  position difference   read  genome block  find  lmems   give read sequence since  lmem represent  identical fragment pair       consider   simple pair   study kart find  lmems via traverse  bwt array  lmem exploration start  ri1  stop  ri2   exact match extension reach  mismatch  ri2   case  next lmem exploration  skip ri2  start  ri2  ri2   likely  sequence error  sequence variation kart  consider  lmem       qualify simple pair   length   less   predefined threshold    occurrence  less    value   typically       determine base   size   reference genome intuitively  short lmem    might contain erroneous base  would less likely include  true coordinate  larger genome need  larger    compromise  specificity  sensitivity figure  shows  algorithm   lmem exploration procedure  function bwt_search   general bwt traversal method  take  read sequence   input  return desirable lmems  well   occurrences   reference genome     sequence errors  variations     one lmem  cover  whole read sequence  lmemlen   however  reality sequence errors  variations happen  lot   break  read  several lmems  variable lengths kart consider  qualify lmems  simple pair  identify normal pair accord   distribution  simple pair  create one   candidate alignments  algorithm  explore  lmems  length ≥  bwt_search   function  search   occurrences   maximal exact match  rstart stop   give bwt array  return desirable lmems  well   occurrences   reference genome  identify simple pair  normal pair since   read   map  multiple genome regions   originate   repetitive sequence  simple pair  also spread    genome  candidate alignment  define   alignment   read   specific region   reference genome  identify  candidate alignments   read  cluster  adjacent simple pair whose δpos differences  smaller   predefined threshold   default value   therefore neighbor simple pair whose δpos differences    cluster together  form  candidate alignment note  two simple pair   candidate alignment could overlap due  tandem repeat sequence variations  overlap lmems   lmems  explain  section   two simple pair overlap   candidate alignment say   genome portion   go   read portion  chop   overlap portion   genome   correspond read portion   shorter pair  ensure   simple pair  nonoverlapping figure  illustrates  example  two overlap simple pair   simple pair  overlap  simple pair  due  sequence variation   correspond region kart remove  overlap  shrink  shorter simple pair say    way  two simple pair    candidate alignment   share  nucleotide   create normal pair fill  gap  adjacent simple pair  make  complete alignment  follow suppose two neighbor simple pair  i2q i2q j2q j2q  i2q i2q j2q j2q respectively   must  i2q  i2q   j2q  j2q  kart insert  normal pair  fill  gap   two regions   case  normal pair      insert   i2q i2q      i2q  i2q   otherwise let       null base likewise  j2q j2q      j2q  j2q  otherwise let        hand   first   last simple region   candidate alignment   cover  first   last nucleotide   read sequence  normal pair would also  create  fill  gap figure  gives  example illustrate  concept  simple  normal pair   example  read sequence contain three substitution errors  well   insertion error  size two   lmem exploration   identify four simple pair labelled      however  four simple pair   cover  whole read sequence thus  check every adjacent simple pair  generate  correspond normal pair accord   gap    generate  normal pair      simple pairs    likewise  generate  normal pair      simple pairs      normal pair      simple pairs    thus    simple pair  normal pair together form  complete alignment candidate four type  normal pair simple pair  form  lmems  perfect match  partition  read sequence  interlace simple  normal region pair    independently align   final alignment  simply  concatenation   alignment   simple  normal pair  closer look   normal pair indicate   substantial portion  normal pair   require gap alignment either    read block   genome block   normal pair      long  perform  second round  sequence partition operation   divide   reduce  portion  need gap alignment  time  look  lmems  size ≥   within  normal pair since  size   normal pair  much smaller   whole genome mer index   hash table construct   fly  use  identify match mer seed   read block   genome block  seed  extend  lmems refer   lmems  lmems could  separate  longer normal pair  shorter ones  process pacbio read   normal pair without lmems   end   read  length      correspond read block  simply clip   consideration    perform  local alignment   read  avoid make  alignment   poor quality region  process illumina read  find    read block  genome block   normal pair  equal size     likely  normal pair  contain substitution errors   ungapped alignment give rise   best alignment   pair however   normal pair contain indel errors  ungapped alignment  result  low sequence identity   check  percentage  mismatch   linear scan   determine whether  normal pair require gap alignment   moreover illumina read could contain adaptor sequence  become chimera   tiny probability  check  sequence identity   normal block   end   read  remove  one whose sequence identity      case kart clip  correspond read block  report  local alignment instead summarize   discussion  divide  normal pair   follow four type  normal pair   npclip       end   pacbio read   length           end   illumina read   sequence identity     normal pair   npgap free   read block  genome block  equal size   number  mismatch   linear scan  less     block size  normal pair   npindel  one   fragment either  read block  genome block   empty string    contain  least one nucleotide  remain normal pair  refer   npnws  require needlemanwunsch algorithm  gap alignment disregard  npclips one  see  table    npnws require gap alignment  sufficiently separate    average lengths  around   different datasets    process much faster   original read pairedend read map pairedend read  two read   physically associate within  certain distance      help reduce map ambiguity  increase map reliability kart support pairedend read map  follow  align pairedend read kart find  candidate alignments   read separately   compare  two group  map result  see     pair  alignments one   group  satisfy  pairedend distance constraints      pair  imply   pairedend read contain  sequence errors    least one     map properly   case kart  initiate  rescue procedure try  find  proper pair  alignments base   candidate alignments   opposite read  implementation   rescue procedure  describe  detail  suppose      two group  candidate alignments correspond  pairedend reads    let   {  … }    {  … }    …   represent candidate alignments     …   represent candidate alignments     alignment      coordinate  kart try  map  onto  downstream region   according   map procedure describe    lmem length threshold  set    increase  sensitivity   map    kart  able  compromise  noise    identify  best alignment    downstream region  r1s alignment kart repeat   procedure use  alignment     find  best alignment      upstream region     moment   pair         meet  pairedend constraint   select  pair   highest sequence identity   alignments  map quality score maq    2008ab introduce  idea  map quality  estimate  reliability   read alignment    convert   probability   query sequence  align incorrectly  map quality  estimate base   optimal  suboptimal alignments  adopt  score scheme  estimate  map quality  map quality score mapq  estimate   formula mapq          *log                         *             optimal alignment score     suboptimal alignment score mapq  limit          multiple alignments   optimal score  repeat mapq    kart report  first best alignment  summary   algorithms give  read sequence  kart identify  lmems  variable lengths along  read sequence   bwt search   reference sequence  lmem  turn   simple pair     appear multiple time   reference adjacent simple pair   cluster accord   δpos  remove overlap  adjacent simple pair kart fill   gap  simple pair  normal pair  make  cluster  complete candidate alignment    read block   genome block   normal pair      long  perform  second round  sequence partition   divide   reduce  portion  need gap alignment  final read alignment   concatenation  simplenormal pair    candidate alignment finally kart report  alignment   highest alignment score  pair alignments  pairedend read",-0.17045632424651952,0.1805108763071914,0.14123313123782594,0.13893813295546895,-0.03202237127710625,-0.0017527141840120546,-0.10392940592147244,0.09355582023499072,-0.010313918437099171,0.0706749841103681,-0.005387350288925298,0.02538947321376784,0.14141244782873888,-0.08290724007808906,0.11953677631006475,-0.05794750310498738,-0.0012100233133979046,0.16381074085988376,-0.06331471870362293,0.06551595078277285,0.046296589603663715,-0.13898042459756507,0.025962469673985657,-0.0262839888324316,0.00923747018743629,-0.16072405109707885,0.019902887912134508,-0.17373161020515349,-0.01416821209949419,-0.08261273848938602,-0.012637174604621866,0.22000399705736184,-0.11768104369860208,-0.10208368677725548,0.16287646598357242,0.08891415476833785,0.05177250228977452,-0.01080280765906194,-0.06731880845872935,-0.10724602798826477,-0.08293507690516247,-0.14168642264889988,-0.03818158661186679,-0.1205811035157649,-0.13529215596320945,-0.034444995150684735,0.1131421575419508,-0.11197223602247312,-0.1785305757372886,-0.386800392779312,0.13750551765516514,0.016824769868502332,0.08202842121199982,0.589183215043826,0.031159439021862592,-1.1729964748129764,0.055461589523159716,-0.16617554289795805,0.9276594066956116,0.20981171533721898,-0.1677438448538154,0.2966583617554687,-0.09402874237111894,0.02864628816346005,0.5647863804965453,0.030956449765496327,0.056434280395368464,0.06265151266686947,0.13212844996624404,-0.18600587798743629,-0.07764187036391614,-0.0635732429225408,0.07265729837795393,-0.12284262099069465,0.2117858438271812,-0.025966267572923512,-0.13014211088874542,-0.12779710933745506,-0.3351789142506084,-0.0574283289647,0.1985644284623246,-0.01888577884837463,-0.3634547900453359,-0.06813882049592193,-0.8050972751048958,0.01865229884125252,0.1706699256849973,-0.11555809197086615,-0.08817380509899679,-0.0500863326898775,-0.18804749815993907,0.06915348781992428,-0.12015170262681996,-0.08844362227528384,-0.16764389631317378,-0.0786859322532314,-0.09569663115125956,-0.2518562360780588,0.2806102922541549,0.06525208233947385,Alignment,0
15,15,"accurate detection  complex structural variations use single molecule sequencing
structural variations svs   largest source  genetic variation  remain poorly understand   limit genomics technology single molecule longread sequence  pacific biosciences  oxford nanopore   potential  dramatically advance  field although  high error rat challenge exist methods address  need  introduce opensource methods  longread alignment ngmlr    identification sniffle   enable unprecedented  sensitivity  precision include within repeatrich regions   complex nest events    significant impact  human disorder examine several datasets include healthy  cancerous human genomes  discover thousands  novel variants use longreads  categorize systematic errors  shortread approach ngmlr  sniffle   able  automatically filter false events  operate  low amount  coverage  address  cost factor   hinder  application  longreads  clinical  research settings
ngmlr fast accurate map  long single molecule read ngmlr  design  accurately map long single molecule sequence read  either pacific biosciences  oxford nanopore   reference genome   goal  enable precise structural variation call  follow  terminology use   sam specification47   read map consist either  one linear alignment cover  full read length  multiple linear alignments cover nonoverlapping segment   read  split read  main challenge  map high error longreads   evaluate whether  read   map   reference genome  one linear alignment  must  split  example  correct map   read  span  inversion    find  split  read  three segment conversely read    span  structural variation  always  map   single linear alignment however error rat  high    always uniform   regions   error rate     segment  cause read mappers  falsely split  read furthermore  high insertion  deletion sequence error  longread technologies cause current read aligners  falsely split  large svs  several smaller ones  make  difficult  detect exact break point  address  challenge ngmlr implement  follow workflow figure  ngmlr identify subsegments   read    reference genome  show high similarity    align   single linear alignment  segment  contain small insertions  deletions  must  span  larger structural variation breakpoint  reference  blast highscoring segment pair hsps  call  segment linear map pair lmps   lmp ngmlr extract  read sequence   reference sequence  use  smithwaterman algorithm  compute  pairwise sequence alignment use  convex gap cost model  account  sequence error  svs    time ngmlr scan  sequence alignments  regions  low sequence identity  identify small svs   miss  step    finally ngmlr select  set  linear alignments   highest joint score compute  map quality   alignment  report    final read map   sambam file convex score model  align high error longreads   crucial  choose  appropriate gap model    two source  insertions  deletions indels sequence error predominantly cause  short randomly distribute indels 5bp  longer indels 20bp  cause  genomic structural variations  linear gap model appropriately model indels originate  sequence error  cannot account  longer indels  genomic variation   large block occur   single unit    combination  multiple single base insertions  deletions  affine gap model  gapopen penalty falsely cause short indels  sequence error  cluster together  noisy longreads    little effect  longer indels especially  repetitive regions   genome   convex score model  ngmlr extend  indel  penalize proportionally less  longer  indel  therefore  convex score model encourage large alignment gap    occur   structural variation   group together  contiguous stretch extend  large indel  relatively low cost  small indels  commonly occur  sequence errors remain separate extend    gap  almost   cost  open  new gap use  convex gap model  compute optimal alignments increase computation time substantially   cell   alignment matrix   depend  three  cells    full row  column   locate    would make  infeasible  use convex gap cost  align large longread datasets   adapt  heuristic implementation   convex gap cost algorithm find   swalign library  instead  scan  full cell  row  fill  alignment matrix  use two additional matrixes  store indel length estimations   cell furthermore  use  initial subsegment alignments  identify  part   alignment matrix    likely  contain  correct alignment  skip   cells   matrix  alignment computation supplementary note  sniffle robust detection  structural variations  longread alignments sniffle operate within    longread alignments  infer svs  apply five major step figure  sniffle first estimate  parameters  adapt    underlie data set    distribution  alignment score  distance  indels  mismatch   read  well   ratios   best  second best alignments score sniffle  scan  read alignments  segment  determine   potentially represent svs putative svs  cluster  score base   number  support read  type  length    consistency    composition   feature sniffle optionally genotypes  variant call  identify homozygous  heterozygous svs sniffle optionally provide  cluster  svs base   overlap    read especially  detect nest variants  detail   step see supplementary note    follow  focus   methods   unique  sniffle    detection  analysis  alignment artifacts  reduce falsely call variants   cluster  variants putative variant score  high error rate   longreads induce many alignments  falsely appear  svs sniffle address   score  putative variant use several characteristics    determine     relevant  detect svs  two main user thresholds   number  high quality read support  variant set use   parameter  well   standard deviation   coordinate   start  stop breakpoint across  support read  minimum variant size report default  50bp   also  adjust use   parameter  account  additional noise   data  imprecision   breakpoints  use  quantile filter  ignore outliers give  coverage     read  compute standard deviations   breakpoints  compare   standard deviation   uniform distribution represent spurious  breakpoints report   region svs   report   breakpoints    threshold   standard deviation   breakpoints   5bp  coordinate  mark  precise   vcf file see supplementary note  variant score  genotyping   start   program  user may specify   vcf output   genotyped   case sniffle store summary information coordinate  orientation   high quality read    include  svs   binary file  include  read  support  reference sequence  pass  thresholds    alignment score ratio   detection  svs  vcf file  read   sniffle construct  selfbalancing tree   variants   information sniffle  compute  fraction  read  support  variant versus   support  reference variants   minimum allele frequency default    consider unreliable variants  high allele frequency default    consider homozygous  variants   intermediate allele frequency  consider heterozygous note sniffle   currently consider higher ploidy however     focus  future work see supplementary note  cluster  nest svs  enable  study  closely position  nest svs sniffle optionally cluster svs   support    set  read note  sniffle   fully phase  haplotypes     consider snps  small indels  rather identify svs  occur together   option  enable sniffle store  name   read  support  svs   hash table key   read name   list  svs associate   read name   value  hash table  use  find read  span   one event  later  cluster read  span  one      variants   way sniffle  cluster two   events even   distance   events  larger   read length future work  include  full phase  hapolotypes include svs snps   small variants see supplementary note  map   evaluation simulation    read  describe  svs  randomly simulate  chromosome      human genome grch37 data set  generate   variants   type   tandem duplication indel inversion translocation  nest  size   events    1kb 5kb 10kb  50kb illumina read  simulate  100bp pair end read use  default parameters  dwgsim  pacbio  oxford nanopore  scan  alignments  hg002 giab  na12878 respectively  measure  error profile use surivor option   measure error profile  read lengths   use  simulate  read   simulate  data set supplementary note  modify reference analysis  allow    realistic scenario  also modify  human reference grch37  analyze real read  assess  introduce svs   could  simulate  subset   type   insertions deletions inversions  translocations  simulate  variants   type   human genome grch37 use survivor option  supplementary note  evaluation  longread mappings  simulate read  map   human reference genome grch37 use bwamem26 blasr25 graphmap27 mecat28 last24 minimap229  ngmlr read  overlap  map  close proximity   simulate   extract   bam file  use  evaluation   genuine datasets  first map  read   unmodified reference genome without  use bwamem  extract  read  would span  simulate    least     read   map   modify reference genome use  four read mappers  use  evaluation  simulate  genuine read   divide  six categories supplementary figure  read mappings  consider “precise”   fully identify    cover  fall   category read mappings   cover  part      require  identification   read map   inversion   cover  invert part   genome  well   noninverted sequence flank  inversion furthermore correct mappings    split   simulate breakpoints  10bp    read mappings  consider “indicated”   show  presence   correct     wrong type   duplication   represent   insertion  show  correct     show  exact border 10bp away read mappings  consider “forced”   indicate  wrong number  svs  several small instead   single long insertion  contain  significant portion  map artifacts   simulate mismatch       length  include mappings    read   align   deletion  inversion figure  top read mappings  consider “trimmed”     softclipped  otherwise trim    cannot indicate      contain randomly align base pair  noisy regions read mappings   split   part  require  cover  underlie   classify  “fragmented” read mappings   suppose  map across      map  consider “unaligned”   simulate  type  size   mappers  count  many read fall    categories normalize   number  simulate read  visualize  result  barplots evaluation   callers    call  vcf file  evaluate use survivor   appropriate parameter set  compare  variants   truth set    consider precise   start  stop coordinate  within 10bp   simulate start  stop coordinate   caller predict  correct type    consider indicate   start  stop coordinate     within 1kb   simulate event regardless   infer type    simulate   consider  detect     call  fulfill  two previous criteria    consider falsepositive   event   simulate",-0.20004562084171407,0.20273475507194147,0.11421140024487045,0.1326293908269333,-0.04371791812360309,-0.010004364940062587,-0.07316596924620944,0.06769296248313343,-0.004402613552920671,0.12204014061458092,0.007066292215048182,0.0022326405201663893,0.1558090049930698,-0.08071680049537322,0.1809692427427376,-0.006965984819411688,0.04648817985823853,0.18730968998085595,-0.004775076745719429,0.04712464195734591,0.014628719184491103,-0.21570282754983644,0.03526775504149754,-0.0018651919427180761,-0.006168446104079466,-0.1833523058262748,0.0779904424928568,-0.16150682898679455,-0.06881061448340459,-0.07407391870967941,0.015132396448232038,0.2275781570137233,-0.14762184766458436,-0.07323806596635217,0.22658562081516484,0.050164840215730366,0.047926688170897576,0.021542871070446952,-0.08888503173007987,-0.06854226940918548,-0.09615176367367946,-0.13071985932214678,-0.08639780022870835,-0.08555777406349198,-0.14433535460857788,0.0021086860188779797,0.15375260387508194,-0.11879890265771816,-0.2547320567935362,-0.3437754906186559,0.18152817213334715,0.004349114970661801,0.054264560624743115,0.5765934949099776,0.06604327275634551,-1.1412834717726206,0.06746106529853453,-0.2085282071307396,0.9678271469485245,0.2270778024307337,-0.19749408197356624,0.3522036004993453,-0.02574843982930261,0.0584968826932661,0.590922051937949,0.03900021980120706,0.0008136525341056981,0.02640346346952319,0.20427480392555825,-0.17379422408850534,-0.08797201461975751,-0.06824536881513747,0.09646357839620956,-0.11429768970880945,0.20504641603689774,-0.0651793579958843,-0.10516822535256187,-0.16271399606352951,-0.3285765633875927,-0.07118841503470616,0.21485280991236866,-0.044001901990767985,-0.38015055269263787,-0.04798235265049812,-0.872610868804811,0.0335086097610645,0.2267054093888299,-0.12098295621735115,-0.10027564754193508,-0.038641738635994516,-0.21898906942464505,0.10193069488977116,-0.1169991936663784,-0.11246251526122784,-0.1345457255746097,-0.05740813019277818,-0.07151970403301748,-0.299391821628674,0.3116074660649195,0.03939462868663622,Alignment,0
16,16,"bfast  alignment tool  large scale genome resequencing
 new generation  massively parallel dna sequencers combine   challenge  whole human genome resequencing result   need  rapid  accurate alignment  billions  short dna sequence read   large reference genome speed  obviously  great importance  equally important  maintain alignment accuracy  short read    base range   presence  errors  true biological variation  introduce  new algorithm specifically optimize   task  well   freely available implementation bfast   align data produce    current sequence platforms allow  usercustomizable level  speed  accuracy support pair end data  provide  efficient parallel  multithreaded computation   computer cluster  new method  base  create flexible efficient whole genome index  rapidly map read  candidate alignment locations  arbitrary multiple independent index allow  achieve robustness  read errors  sequence variants  final local alignment use  smithwaterman method  gap  support  detection  small indels  compare bfast   selection  largescale alignment tool  blat maq shrimp  soap   term   speed  accuracy use simulate  realworld datasets  show bfast  achieve substantially greater sensitivity  alignment   context  errors  true variants especially insertions  deletions  minimize false mappings  maintain adequate speed compare   current methods  show bfast  align  amount  data need  fully resequence  human genome one billion read  high sensitivity  accuracy   modest computer cluster  less   hours
simulated variant class simulation strategy  better reflect  real alignment problems  interest simulate read  derive   human genome ncbi build  rather  construct  artificial random genome  permit  assessment   sensitivity  accuracy  alignment  short read  contain variants include errors single base mismatch insertions  deletions  well  combinations  single base mismatch   error mode common   technologies  investigate high mismatch rat  well  mismatch  combination  insertions  deletions  might occur  read  contain   real variant  errors  occur frequently  practice  evaluate  different variant state separately  order  obtain accuracy measure   type  event   differ   degree  alignment difficulty  examine   true positive rate   sensitivity  assess  fraction  read   locate back   appropriate location   assess  mismapping rate   determine   fraction   read   map   genome   map   incorrect location ideally  method  maximize true positives  minimize mismapping   comparisons    require   exact edit mismatch insertions  deletions introduce   simulate read  observe  rather   read  place approximately   correct location since  methods  align  read   indel   approximate location  never call  specify  indel since  perform ungapped alignments  tally  result   manner    perform   reasonable comparison   core alignment aspects   context   whole human genome   methods  simulate read   human genome  create set  read   fix number  variants  produce  synthetic dataset  randomly choose   letter long substring   human genome  select string  randomly alter  contain  specify number  mismatch insertions  deletions  produce  final read   variant class  read  generate  read   variant class  number  read  sufficient  obtain robust performance statistics  total  different variantspecific nucleotide datasets  create read  exactly  mismatch ≤≤ read  one contiguous  letter insertion ≤≤   mismatch ≤≤ read  one contiguous  letter deletion ≤≤   mismatch ≤≤ similarly  also generate    variant class  abi solid color space read  one snp   color errors ≤≤ read  one snp    deletion   color errors ≤≤ read  one snp    insertion   color errors ≤≤  mismatch  insertion  deletion break point  color errors abi solid data   uniformly distribute within  read   nucleotide data  high number  mismatch    color space data  high number  color errors  mean  represent read confound   impact  sequence errors   snp  indel detection   especially important  abi solid color space data due   higher error rate   correct   successful genomic alignment additionally  high number  mismatch  nucleotide data consider might correspond   read   variant dense region  several single base variants   confound  several read errors since bwa  maq rely   color qualities  abi solid data  detect errors  give color errors  color quality     otherwise  simulate datasets  available    call  read correctly align   read  align uniquely within  base   original location  two alignments  find    best score  read   call correctly align   simulations    require   errors snps  indels  place correctly  even find   methods  instead require   read  place within  base   true location thus assess global alignment rather  local alignment  evaluate  algorithm use one compute node  two dualcore amd64 processors  0ghz   32gb  ram  algorithm  run   single process  thus   take advantage   multithreading  parallel process capabilities   algorithms include   bfast  comparison     evaluate  relative speed   various algorithms  comparable hardware architecture since many processors typically would  use  practice    practical solution implement  bfast  practice  precise settings   algorithm include bfast  describe   supplemental materials  section algorithm settings  simulations illumina datasets  demonstration purpose  use   million  base read data set   human genome  total  different regions  know mutations across  genes  pcr amplify individually  pool amplicon size range        purify  amplicon  qiagen pcr purification kit  amplicons  pool  one tube  create  equal mixture   products  sequence library   genomic fragment  prepare use manufacturer provide genomic library preparation protocol version  illumina  jolla  specifically  dataset consist  sequence  pcr products know  contain  mismatch  well   small insertions   small deletions  sequence   depth  coverage generally exceed fold  also analyze  million  base pairedend read  human genomic sequence   illumina gaii sequencer libraries  generate  genomic dna   select   first end   pair give   million  base pair singleend read  alignment abi solid datasets one million read  two different run   house generate abi solid sequencer data  use   comparisons     sufficient dataset  offer reasonable comparison  datasets consist  sequence  human genomic dna generate  use standard  base   base manufacturer supply protocols support  pairedend data bfast support pairedend data  find cals   end separately  local alignment  user   option  mirror cals  one end use    specify  estimate pairedend insert length  pairedend insert length   infer  examine pairedend read    end   one cal  option  mirror  rescue one end   read  help either  improve accuracy   use one end   pair  anchor     cal   end   locally align independently  criteria  choose  best pair  alignments   end   dictate   user    base  bestcombined score uniqueness  well   postalignment filter criteria  detail  pairedend support   find   supplemental materials  support  abi solid color space  support abi solid color space read   first convert  reference sequence  color space    genomic read offset  artificially start    base  mimic  process  decode within  solid system  always generate   terminal base   ligate oligo  library creation cals  identify  color space   assumption  errors   common  variants  therefore  color errors  occur  variants encode  color space  find cals   read  use  modify local alignment algorithm previously describe  color space read  homer    rumble     local alignment algorithm search  space   possible color errors nucleotide mismatch insertions  deletions   process bfast  able  use  entire color string  alignment",-0.23178333849158236,0.2458592203511929,0.10516754056066822,0.1763938580598002,-0.018880527031690103,-0.0535507156171162,-0.09177044371066513,0.05706193044298904,-0.02815583154648159,0.16238304086294314,0.005412831115273887,-0.06882147347142546,0.15226240360468235,-0.11799368824023415,0.15197925817897068,-0.0513960564535142,0.060884708862217585,0.2423082009561625,-0.05965199468689617,0.08046745308378128,-0.025795058519625123,-0.23933774018712264,0.07534966158666923,-0.058228764214208265,-0.0781729924618084,-0.18873925794797086,0.04318810194601218,-0.14435165510261794,-0.10527085250314308,-0.027744829510886443,-0.0004932510805791061,0.2881993099033613,-0.2249575154525576,-0.06345118769340664,0.2493207986939809,0.06928433247730044,0.02381345309093412,0.0019477992826460989,-0.09726453039925842,-0.13208410245373242,-0.05311971576313725,-0.16893519713341767,-0.12241425738623138,-0.08860081363687355,-0.1670069518109884,-0.010714734841195759,0.14338029833458016,-0.16177425866572226,-0.2349821785216644,-0.4181311910900096,0.14077407729842786,0.06712999183275993,0.09660944124705424,0.6243478730109785,0.04905195443793405,-1.228243554809916,0.09756481141655468,-0.2129475221513798,1.0454313508030906,0.16826185596451693,-0.1719693525357762,0.3695992364380657,-0.052488310286243366,0.10252172952003127,0.5896329047145806,0.020722563755436,0.01364866245753279,-0.02452692313475863,0.22154465490066466,-0.19097372858802786,-0.0414544298423072,-0.03774711454367635,0.13227931196960008,-0.11758194639939272,0.2355291703567548,-0.015750607884518673,-0.12137182846701905,-0.12675311563390435,-0.3698902972254134,-0.0412225739621813,0.2654324980185087,-0.03743269125241604,-0.4235638388268211,-0.0071260006874331785,-0.9573279908865658,0.09705851715689813,0.27646321725150497,-0.12133692474020005,-0.1372520663145206,-0.0514214179324792,-0.17579343255412966,0.10987685025133496,-0.10237738607233328,-0.1278768189447731,-0.1374401843679473,-0.08056660607433193,-0.1290017338910462,-0.3523712168206853,0.3629148270781882,0.10160789880005634,Alignment,0
17,17,"fast  accurate read alignment  resequencing
nextgeneration sequence analysis  become  important task   laboratory  clinical settings  key stage   majority sequence analysis workflows   resequencing   alignment  genomic read   reference genome  accurate alignment  read  large indels   computationally challenge task  researchers  introduce seqalto   new algorithm  read alignment  read longer   equal    seqalto      faster  exist algorithms  retain high accuracy   ability  align read  large     indels  improvement  efficiency  particularly important   analysis  future sequence data   number  read approach many billions furthermore seqalto use less     memory  align   human genome seqalto  benchmarked  several exist tool   real  simulate data
seqalto search   global alignment  sequencer read   reference use  commonly know seed  extend approach   three phase   alignment process index construction ungapped alignment  needlemanwunsch extension define  kmer seed    sequence  nucleotides  length   nucleotide must come   set {   } hence  kmer  encode   unsigned integer   bits per nucleotide   bite system  allow  kmers  size         kmer   nucleotide   {   }      replace   uniform random nucleotide since     bite alphabet available  encode    approach use  bwa  many  tool let  index  define   list  tuples record  kmer   location   reference   kmer  index  sort   numeric value   kmer  fast search seqalto achieve  high speed first  use much larger kmer size compare  exist approach examine less repetitive kmers first   adaptively stop  kmer search large contiguous kmers greatly reduce  number  locations   kmer   reference  mostly unique hit  general large kmers would reduce  sensitivity   alignment however  longer read  choice  kmer size   reduce sensitivity  show   simulation result furthermore  novel subsampling approach  use  reduce  amount  memory require   index     compare  bwtbased approach  large kmer search  approach require less random access  memory per index lookup result  significantly improve performance  index construction  genome index ideally contain  location   overlapping kmers   genome naively store  kmers  size        one strand   human genome require     memory use  combination  two strategies   reduce  size   index        minor penalty   sensitivity  enable seqalto   run  almost  desktop computers  strategies   tune   powerful computers   become available   first stage   index construction  overlapping kmer together   location  extract   genome  store   array   array  tuples   sort   kmer value   leading  bits  remove   kmer       less     bits  store   prefix array   record  start  end locations    kmers tuples prefix     bits since   sorted kmers    prefix exist next          remain bits   kmer need   store    array  tuples  together   prefix array  form  genome index consider  genomes  less   billion nucleotides  twolevel index reduce  size   kmer location tuple   index   bytes instead   bytes hence  small prefix table size  entire human genome index   take     store  index construction also greatly improve  lookup speed   naive binary search seqalto   option   store every kmer   reference  order  reduce memory consumption without greatly impact alignment quality  speed  alignment   store  kmer   satisfy  hash function      numeric value   kmer  hash function   choose     approximately uniform coverage   genome  seqalto   use  select   memory usage   human genome       chromosome   median gap size      largest gap apart   centromere    empirically   little loss  sensitivity  use  approach  see   section   principle  expression  also  easily tune  machine   memory   expression  similar form  adequate  machine      memory  second step   require   larger index   construct  improve sensitivity  accuracy  index  essentially  large sort list hence   easy  add arbitrary additional kmers   index  negligible cost    construction  search kmers overlap know snps  indels could easily  add   index  improve  sensitivity  alignment  change would  moderately increase  size   index  ungapped alignment  first stage   alignment process   ungapped alignment stage  stage  separate   gap stage since  expect   gap read   align anywhere   genome  highquality ungapped alignments  separation also allow  easy interfacing   hardware accelerator   gap alignment  read  treat separately   alignment process  overlapping kmers  extract   read kmers satisfy  function   define    retain    kmers  discard highly repetitive kmers  also discard  kmer   search    index accord   follow order start   nonoverlapping kmers  number  locations  kmer exist   genome  compute   index   number  less   predefined variable max_loc    locations  examine   ungapped alignment   read   kmers  number  locations less  max_loc   examine   kmers  examine due   large kmer size many kmers either align uniquely   genome    align   hence  ungapped alignment stage proceed  quickly similar   idea  baezayates  perleberg     necessary  examine  kmers   read  instance read   mismatch   unambiguously identify  examine  one nonoverlapping kmer   pigeon hole principle read   mismatches  require examination     nonoverlapping kmers additional kmers  examine  order  determine   read    repetitive region see section  hence seqalto decide  stop examining kmers accord   follow boolean function      number  mismatch  gap   best alignment  far     number  kmers examine  read  high number  mismatch  early stop   guarantee find  correct hit  procedure  describe  algorithms    overall  procedure result  seqalto spend less time  highquality read   ungapped alignment output  best alignment  penalty score greater   single gap open  read   examine   single gap alignment   stage  location   kmer  normalize  subtract  location   kmer   read   pair  normalize locations  distance smaller   maximum gap size  locations  extend  find single gap alignments    one mismatch   side   able  resolve  indels  repetitive regions  needlemanwunsch extension  read    align   ungapped alignment stage  pass   needlemanwunsch extension stage  order  examining kmers       ungapped alignment  kmer location  search   band needlemanwunsch  affine gap penalty  find gap alignments  width   band   choose   user   default  find    least   indels   function    use  determine   program  continue examining kmers single instruction multiple data simd acceleration  sse2 instructions  use  improve  performance   stage  pairedend alignment pairedend information   use  help search  alignments  also resolve discordant read pair  one read   pair align    read   seqalto search   remain read within  maximum insert size   pair   combination  smithwaterman  needlemanwunsch  alignments  flag   output give  user additional flexibility  postprocessing   pair align  one   equally good hit  possible combinations  check   concordant pair   possible combinations  discordant seqalto search   concordant alignment within  region around  alignment define   maximum insert size  hybrid mode  read much less    seqalto   trouble align read  repeat regions  also read  high number  mismatch due   inability  locate enough seed   read  hybrid mode seqalto output read   valid seed   fastq file     align  bwa    alignment tool  two result sam file    merge  produce  final alignment  map quality score map quality mapq score provide  way  users  judge  reliability   alignment   first introduce  maq       estimation   probability  read  align incorrectly accurate calculation  map quality considerably slow   alignment process since  kmers   visit despite  visit  kmers seqalto also provide  estimate  map quality  map quality report  seqalto    specific   map quality report   tool however  practice   little difference  discuss   map  assembly  quality maq article       mainly two source  alignment error  first    best alignment fail   report   alignment algorithm  second    read align optimally   incorrect location due  genetic variation  read errors similar  bwa seqalto ignore  first source  error  assume either  best alignment   report   alignment   report   seqalto estimate  second source  error  record  alignments  differ   best    one mismatch  also  percentage   read cover  highly repetitive kmers  formula use  similar    bwa  compatibility  downstream tool  choice  kmer size  size   kmer seed need   select prior  index construction  single size  clearly  optimal   read lengths smaller kmers    repetitive  larger kmers  reduce sensitivity table  displays  performance  various kmer size  multithreading seqalto  able  take advantage  modern multicore computers  distribute  alignment   read  multiple thread   little communication   thread except  read  write file seqalto  run  default mode   million  pairedend read   real illumina dataset   alignment time  record table  shows  seqalto scale well    least eight thread  bwa  limit   nonparallelized pair step  illumina hiseq2000 generate   gigabases  data per run  translate    billion  pair   modern octacore workstation computer seqalto  able  align   billion pair    days compare    days  bwa    computer consider one illumina hiseq  take  days  generate  sequence data  allow one inexpensive desktop workstation  service several large sequencers  read lengths   quality  sequencer output improve  result  become even  significant",-0.2033142437586506,0.21553832938063164,0.14280154059474973,0.14504517170509715,-0.005375038039426297,-0.004868021209109564,-0.09355163025627466,0.055794698304226176,0.00656485191191785,0.08763059721780732,0.02410205772056915,-0.001111352960851667,0.12037568830820546,-0.11867801186575655,0.11809661257758593,-0.05307425067317315,0.027500900187217826,0.2044024313641144,-0.06732893250454665,0.08948571587371675,0.034114004773061306,-0.17950438739323307,0.061495052499893274,-0.013625795495211344,-0.0050893632107398,-0.15429756436918565,0.03946936032933507,-0.1654880373027732,-0.036113919105436314,-0.0584318668601797,-0.004525115380024933,0.2700255137798937,-0.17400426555873774,-0.10237865071139744,0.2105635685324124,0.07768581279668614,0.007258171750603477,-0.005037444468925929,-0.06878405733095662,-0.10462007980082486,-0.04721787199301592,-0.17711198832316874,-0.04822264712062385,-0.11751572681968946,-0.1516219363352987,-0.04110572343577296,0.14439922061056426,-0.16717891087903308,-0.19821411670013425,-0.3982027561617282,0.1521225873965778,-0.013998339561739409,0.05193906420695593,0.5967223479227046,0.05071558418461576,-1.2131792954790774,0.04293119751937948,-0.1814706136973848,1.0301638646774745,0.20367691385650424,-0.1442337042132532,0.2933997751514965,-0.09984567122996522,0.07650004049225076,0.5288723619324635,0.03085483588416871,0.036421927031439365,0.027511011278079173,0.1981689238419483,-0.17825151444043394,-0.08228066972105111,-0.03709146070051572,0.07399668368755195,-0.12449967390419488,0.2261838530326829,-0.008943511063336951,-0.14783625016182547,-0.11399961552986185,-0.34568149910850504,-0.059123786685036726,0.2780256176560557,-0.05671755338945636,-0.39857033610800413,-0.04548198598827652,-0.8893025867634349,0.08058001282263172,0.2374539318569901,-0.1173770662424658,-0.13701032200946392,-0.039859926338730166,-0.18548592919365586,0.12627024388045716,-0.1350386928131649,-0.130855258269423,-0.17418238879038792,-0.07801648517902451,-0.06270545784178183,-0.2846482845356472,0.3321031551536568,0.0794137928579349,Alignment,0
18,18,"basic local alignment search tool
 new approach  rapid sequence comparison basic local alignment search tool blast directly approximate alignments  optimize  measure  local similarity  maximal segment pair msp score recent mathematical result   stochastic properties  msp score allow  analysis   performance   method  well   statistical significance  alignments  generate  basic algorithm  simple  robust    implement   number  ways  apply   variety  contexts include straightforward dna  protein sequence database search motif search gene identification search    analysis  multiple regions  similarity  long dna sequence  addition   flexibility  tractability  mathematical analysis blast   order  magnitude faster  exist sequence comparison tool  comparable sensitivity
 maximal segment pair measure sequence similarity measure generally   classify  either global  local global similarity algorithms optimize  overall alignment  two sequence  may include large stretch  low similarity needleman  wunsch  local similarity algorithms seek  relatively conserve subsequences   single comparison may yield several distinct subsequence alignments uneonserved regions   contribute   measure  similarity smith  waterman  goad kanehisa  sellers  local similarity measure  generally prefer  database search  ednas may  compare  partially sequence genes   distantly relate proteins may share  isolate regions  similarity    vicinity   active site many similarity measure include  one  employ begin   matrix  similarity score   possible pair  residues identities  conservative replacements  positive score  unlikely replacements  negative score  amino acid sequence comparisons  generally use  pam matrix  variation    dayhoff      dna sequence comparisons  score identities   mismatch   score   course possible  sequence segment   contiguous stretch  residues   length   similarity score  two align segment    length   sum  tim similarity value   pair  align residues give  rule  define  maximal segment pair msp    highest score pair  identical length segment choose from2 sequence  boundaries   msp  choose  maximize  score   msp may    length  msp score  blast heuristically attempt  calculate provide  measure  local similarity   pair  sequence  molecular biologist however may  interest   conserve regions share   proteins     highest score pair  therefore define  segment pair   locally maximal   score cannot  improve either  extend   shorten  segment sellers  blast  seek  locally maximal segment pair  score   cutoff  ike many  similarity measure tile msp score   sequence may  compute  time proportional   product   lengths use  simple dynamic programruing algorithm  important advantage   msp measure   recent mathematical result allow  statistical significance  msp score   estimate   appropriate random sequence model karlin  altsehul  karlin    furthermore   particular score matrix  pam one  estimate  frequencies  pair residues  maximal segment  tractability  mathematical analysis   crucial feature   blast algorithm  rapid approximation  msp score  search  database  thousands  sequence generally   handful     homologous   query sequence  scientist  therefore interest  identify   sequence entries  msp score   cutoff score   sequence include  share highly significant similarity   query  well   sequence  borderline score  latter set  sequence may include high score random match  well  sequence distantly relate   query  biological significance   high score sequence may  infer almost solely   basis   similarity score   biological context   borderline sequence may  helpful  distinguish biologically interest relationships recent result karlin  altschul  karlin    allow   estimate  highest msp score    clmnce similarities  likely  appear  accelerate database search blast minimize  time spend  sequence regions whose similarity   query  little chance  exceed  score let  word pair   segment pair  fix length   main strategy  blast   seek  segment pair  contain  word pair   score   least  scan   sequence one  determine quickly whether  contain  word  length    pair  jhe query sequence  produce  word pair   score greater   equal  tile threshold    hit  extend  determine    contain within  segment pair whose score  greater   equal    lower  threshold   greater  chance   segment pair   score   least   contain  word pair   score   least   small value   however increase tile number  lilt  therefore tile execution time   algorithm random simulation permit   select  threshold   balance  considerations  implementation   implementations   approach detail    algorithmic step namely compile  list  highscoring word scan  database  hit  extend hit vary somewhat depend  whether  database contain proteins  dna sequence  proteins  list consist   word wreefs  score  least   compare   word   query sequence thus  query word may  represent   word   list   common wmers use pam score   many one may  course insist  every wmer   query sequence  include   word list irrespective  whether tmiring  word   yield  score   least '  value ofw   tlmt   find  usefnl see    typically   order   word   list  every residue   query sequence   word   sequence  length    little care  take  program  list  word   generate  time essentially proportional   length   list  scan phase raise  classic algorithmic problem  search  long sequence   occurrences  certain short sequence  investigate  approach simplify  first work  follow suppose      mai  word   integer       word   use   index   array  size   let  ith entry    array point   list   occurrences   query sequence   ith word thus   scan  database  database word lead  immediately   correspond hit typically    thousand    possible word     table    easy  modify  approach  use far fewer   pointers  second approach  explore   scan phase   use   deterministic finite automaton  finite state machine mealy  hopcroft  ullman   important feature   construction   signal acceptance  transition mealy paradigm  oppose   state moore paradigm   automaton' construction  save  factor  space  time roughly proportional   size   underlie alphabet  method yield  program  run faster   prefer  approach  general use  typical query lengths  parameter settings  version  blast scan  protein database  approximately  residuess extend  hit  find  locally maximal segment pair contain  hit  straightforward  economize time  terminate  process  extend  one direction   reach  segment pair whose score fall  certain distance   best score find  shorter extensions  introduce   departure   ideal  find guarantee msps   add inaccuracy  negligible    demonstrate   experiment  analysis   protein comparisons  default distance     probability  miss  higher score extension   ""  dna  use  simpler word list   list   contiguous wmers   query sequence often     thus  query sequence  length  yield  list  nwl word     commonly   thousand word   list   advantageous  compress  database  pack  nucleotides   single byte use  auxiliary table  delimit  boundaries  adjacent sequence assume     hit must contain  mer hit  lie   byte boundary  observation allow   scan  database bytewise  thereby increase speed fold   mer hit  check   enclose umer hit  find  extend   run   sun4   query  typical length  several thousand base blast scan  aitroxinmtely    base  facilities  run many  search  day load  compress database  menmry    share menmry sehenm afford  substantial save  subsequent search time    note  dna sequence  highly nonrandom  locally bias base composition  atrich regions  repeat sequence elements  alu sequence    important consequences   design   dna database search tool   give query sequence   example  atrich subsequence   commonly occur repetitive element   database search  produce  copious output  matchcs  little interest   design  somewhat  hoc  effective mean  deal    problems  program  produce  compress version   dna database tabulate  frequencies   tuples  occur much  frequently  expect  chance controllable  parameter  store  use  filter ""uninformative"" word   query word list also precede full database search  search   sublibrary  repetitive elements  perforfimd   locations   query  significant match  store word generate   regions  renmved   query word list   full search match   sublibrary however  report   final output   filter allow alignments  regions  bias composition   regions contain repetitive elements   report  long  adjacent regions  contain  feature share significant similarity   query sequence  blast strategy admit numerous variations  implement  version  blast  use dynamic program  extend hit    allow gap   result alignments needle  say  greatly slow  extension process   sensitivity  amino acid search  improve   case  selectivity  reduce  well give  tradeoff  speed  selectivity  sensitivity   questionable whether  gap version  blast constitute  improvement  also implement  alternative  make  table   occurrences   wmers   database  scan  query sequence  process hit  disk space requirements  considerable approximately  computer word  ever"" residue   database  damage    query sequence  typical length  need  random access   database  oppose  sequential access make  approach slower   computer systems  use titan scan  entire database",-0.2177331168849251,0.2023738516172402,0.11374832337470685,0.1874037196615098,-0.03677999677223975,-0.05072710365263297,-0.11901754153563784,0.054381862097569116,-0.039073545125682486,0.11636592665704887,-0.03347749160976004,-0.017575284747116046,0.16289842826014514,-0.11950984728725955,0.15719956321603,-0.05244818808292805,-0.012994071803834752,0.19355711557924252,-0.02612541626775608,0.11332894956868905,0.06299528556326718,-0.18789672152726727,0.045367707569104965,-0.008438920268920576,-0.05258445362025039,-0.1764304805055795,0.05825810846857585,-0.17732894664015306,-0.07171355685635955,-0.08918528979605374,-0.003792486850315713,0.2534967000352588,-0.17049919896098914,-0.11317963725941273,0.17474824228828215,0.09334194134316164,0.09438025095855684,-0.00873197591937253,-0.07742580743938811,-0.10648595570254568,-0.07584370197020943,-0.15684077299172,-0.07484841996505227,-0.08783889399917072,-0.14757200709066673,0.0003812203079634955,0.1574846353026486,-0.13257659379260728,-0.21316174749947614,-0.3854891623472029,0.15453332299656405,-0.029397365440642025,0.06870013897067509,0.5960138399008551,0.05097539327684535,-1.1873287322203028,0.07261158692486434,-0.2223108940105001,1.0019566892903644,0.21998056615587372,-0.1832810796203901,0.3351933763260297,-0.08294875394574559,0.08640487981114815,0.6441813581957155,0.033478959751198016,0.0660109464308626,-0.004309483348577809,0.2136868328397125,-0.2030241614774229,-0.09743355896848063,-0.06793122912412274,0.11872616455071648,-0.1071309665857666,0.2245960728994046,-0.07177992024113138,-0.11841871811741105,-0.16432441467096484,-0.3478099512301364,-0.057438788721699566,0.19778334403466186,-0.040270429656127135,-0.4077826372354158,-0.08946088888697437,-0.8951318095170967,0.09096447694855092,0.20478682281837,-0.14816061149101767,-0.13742454415201974,-0.06570373504870337,-0.2160642845521756,0.0926613548468088,-0.13578894511719905,-0.11225006912681687,-0.14398549767925167,-0.08106430812433307,-0.1068767440300371,-0.3252485998304961,0.3107288987788407,0.10608908797835688,Alignment,0
19,19,"hblast  fast protein sequence alignment toolkit  heterogeneous computers  gpus
 sequence alignment   fundamental problem  bioinformatics blast   routinely use tool   purpose     citations   past two decades   size  biosequence databases grow exponentially  computational speed  alignment softwares must  improve  develop  heterogeneous blast hblast  fast parallel search tool   heterogeneous computer  couple cpus  gpus  accelerate blastx  blastp—basic tool  ncbiblast hblast employ  locally decouple seedextension algorithm  better performance  gpus  offer  performance tune mechanism  better efficiency among various cpus  gpus combinations hblast produce identical alignment result  ncbiblast   computational speed  much faster    ncbiblast speedups achieve  hblast  sequential ncbiblastp resp ncbiblastx range mostly     resp      cpu thread   gpus hblast   faster  thread ncbiblastx furthermore hblast   time faster  gpublast
 blastx  blastp search procedures include four stag  setup stage  preliminary search stage  traceback stage   output stage without loss  generality  take  blastx search procedure   example   setup stage blastx   prepare search options query sequence  subject sequence   give database  also create  lookup table index query sequence   preliminary search stage  scan  subject list  match word call hit  seed   lookup table extend  hit link another hit   gappedfree alignment  gappedfree alignment exceed  threshold score  save   high score pair hsp   hsp trigger  gap alignment   traceback stage blastx try  find  aggressive alignments  record  number  position  insertions deletions  match letter information finally   last stage  print   alignments  query  pseudo cod  list  algorithm  algorithms  blastx  blastp   similar  fact  use   seed step   ungapped extension step  exactly    major difference   data type  query nucleotide  aminoacid  blastx  blastp respectively compare  blastp   extra job  blastx translate nucleotide query sequence  aminoacid sequence   six read frame   setup stage  consider insertion  deletion events  translate nucleotide query sequence among different frame   gap extension step   promise approach  accelerate blast   speed   preliminary search stage     computation intensive stage  blast report  profile study vouzis  sahinidis  zhao  chu    profile study  ncbiblastx seed  ungapped extension step  still   time consume   account     total compute time reason   use heterogeneous compute  speed  blast   list  follow heterogenous computers  gpus offer  low cost approach  high performance gpus  compute power source  latest titanx gpu  deliver 11tflops peak performance    power budget   latest intel core cpu present  3tflops    power budget  computer server   equip   gpus however one bottleneck  gpuonly compute   memory limitation  main stream memory size   gpu     largest    face    ncbi nonredundant ncbinr  brief protein database release    massive alignment result    enough memory space   gpu use  host memory space  ease  problem  stateoftheart accelerate blast algorithms  heterogeneous computers mainly focus  design  fast gpu kernels  cpugpu cooperation pipelines cudablastp liu      use  compress dfa  hit detetion   sort database  better load balance  gpus  also process gap step  gpus gpublast vouzis  sahinidis   gblastn zhao  chu  offer gpu kernels preserve   alignment result  ncbiblast gpublast claim  speedup   time  sequential ncbiblastp gblastn provide  cpugpu cooperation pipeline scheme  speed  blastn cublastp zhang    introduce  finegrained gpu kernel  replace  embarrass parallel approach  bundle execution task    diagonals  queue  parallel execution  improve  memory access pattern  gpu kernel  claim  speedup   time  multithreaded ncbiblastp however seed  extension branch  still mix together  would harm  performance  major bottleneck  accelerate blast  heterogenous computers  unable  fully utilize  available parallelism especially  gpus  source   bottleneck   unpredictable execution paths   blast heuristic zhang     many different couple branch   compatible   lock step execution style  gpus  increase difficulties  balance workloads among cpu task  gpu task    performance killer  gpu applications bakhoda     heuristic  massive parallelism need huge memory space  store onthefly result  example use algorithms  gpublast  blastx search would consume   12gb memory  cannot  easily satisfy  many gpus  key ideas underlie hblast   solve  bottleneck hblast try  decouple alignment job  bundle branch    type  queue  parallel execution  algorithms eliminate  interrelationship  find seed short stretch  identities  ungapped seed extension   short subject region  preserve   alignment result    ncbiblast job   queue  share  multiple gpu thread know  finegrained parallelism  batch execution  lead  much less divergence  better performance theoretically hblast also apply  linear workload prediction model  workload balance   cpugpu cooperation pipeline furthermore  use  lossless data compression strategy   dynamic memory allocation approach  gpu algorithms  decrease  memory need  speed  algorithm  hblast present two approach depend  case   one gpu  use  seed  ungapped extension step  accelerate  multicore cpus   gpu  score  gap extension step  speed   multicore cpus  rest part run  serial  gain  better total speedup  cooperation step pipelining task  cpus  task   gpu  involve  extra cost  analyze massive query sequence   gpus hblast take advantage   independency  alignment result  different sequence  divide query   parts equally   result stag      cooperation step   accelerate   cpu core hblast software consist  three modules  gpu scan module  cpu scan module   cooperation module  gpu scan module   accelerate  seed  ungapped extension step  gpus  entire algorithms        blastx  blastp  cpu scan module process    hsps   gpu module  gap extension  also  unprocessed database sequence   whole blast algorithms  merge  alignment result  cooperation module   parallelize  cpu  gpu task  main framework  hblast  illustrate  figure   implement  hblast algorithm   language  cpu cod  cuda  language  gpu cod  hblast software  base  ncbiblast  software package  immigrate code segment  gpublast  describe  implementation   finegrained gpu kernel design   cooperation pipeline  accelerate  seed  ungapped extension step  gpus   three major challenge  accelerate  blast algorithm  gpus due   unpredictable execution path   storage demand   heuristic parallelize  algorithm  well  balance  workload   storage demand  primary challenge  parallel applications minimize divergence   execution paths   specify issue  gpu applications especially divergence   execution paths   performance killer  gpu applications hblast offer  systematic approach  settle  issue  hblast gpu kernel adopt  finegrained parallel strategy  map  alignment task   database subject  multiple gpu thread   end hblast take advantage  hierarchy parallelism among different database subject  alignment task  independent denote   external parallelism   give offset  one database subject  seed task among different query offset  ungapped extension task   parallelize denote   internal parallelism  execution   hblast gpu kernel  organize  group  gpu thread   external parallelism  gpu thread within  group share  task   internal parallelism  minimize divergence   execution paths  balance  workload among different gpu thread  locally decouple seedextension algorithm  propose depict  algorithm    algorithm  execution  hblast seed  ungapped extension job  organize  batch   dualjobqueue pipeline  first stage   pipeline  pseeding present  algorithm   hitqueue use  pseeding  form   content index   wword   lookup table gpu thread search   subject sequence filter  hit  push  hit request extension  extension queue  lazy process  second stage   pipeline  pungapped_extension show  algorithm  unlike seed job execute every offset ungapped extension job  trigger  batch every  offsets  group size  gpu thread share one subject sequence alignment job vary  query sequence  hblast adaptively  group size permit  tradeoff   parallel efficiency   cooperation cost among gpu thread  small group size lead   low cooperation cost  job share   large group size yield high parallel efficiency due   balance workload  group size  hblast  determine   total length   query sequence vary       total length  aminoacid sequence  less   single thread   group  use otherwise four thread   group  optimal  ensure   alignment result  ncbiblast  well  independent job   extension queue  value    algorithm   hblast   greater   word size  otherwise job  extension queue   ensure   independent  cannot  execute concurrently  balance  storage demand   limit gpu memory volume hblast combine  memory dynamic allocation approach   lossless data compression strategy  parallel dynamic memory allocation approach  hblast  name  joint memory allocation  manage  memory pool share  eight gpu thread within  warp  job queue  output result set  implementation   joint memory allocation  base   hardware warp vote function  gpus replace  sequential atom operation use  gblastn hence  cost   ignore  fail  allocate memory   joint memory allocation   fix size buffer  correspond subject sequence  mark  realignment  cpu thread furthermore  joint memory allocation  threadsafe since    race contention within   warp  lossless data compression strategy  hblast  use  reduce  memory demand  onthefly  alignment result  memory need  onthefly result  alignment result   less        gpublast respectively   blastx experiment  peak memory requirement  onthefly result  hblast    compare     gpublast  parallelize cpu task  gpu task  execute cpu task  gpu task    time  cooperation module  employ  hblast   three functionalities   cooperation module  first  organize  blast algorithm   pipeline  overlap  cpu  gpu execution  different database volumes  second   data transport among cpus  gpus  third   workload assignment among cpus  gpus  key new element   module   load balancer  load balancer  hblast  selfadaptive  hardwareaware base   workload prediction model  model  relate   total length   protein database sequence   computational capacity ratio ccr  brief   cpu core   gpu  former reflect   workload obey uniform distribution  lengths  sequence approximately  latter  aware  hardware settings change  optimize  division   work  introduce  realtime greedy algorithm   base  minimize  difference   execution time  concurrent task  cpus    gpus   begin  alignment  give  initial load assignment ratio  cpus  gpus   database volume  search  load assignment rate  adjust automatically   difference   execution time   cpu task     gpu task  well   give ccr  load balancer  hblast  usertunable    interface  set options   ccr   value   initial load assignment ratio  detail   tune interface   discuss   next section",-0.18957635613003435,0.21023647630034767,0.13237672918585813,0.09413450479088444,0.053518277860315655,-0.0668150869409919,-0.12457758725449565,0.07345956834481063,-0.007641606231617605,0.1228303622255169,0.040965161672401385,-0.015339417761716176,0.14334419796818154,-0.10001046131439656,0.08404818715655732,-0.0594121074809773,0.011368074937467415,0.18025611864168656,-0.07211958993933648,0.03520786607911426,0.01852425551816508,-0.24053906274675754,0.06443976729078604,0.03517720486781185,-0.01649127278256721,-0.18601000592347472,0.032119554151731435,-0.13866399709165156,-0.05501800322604696,-0.056876492136338164,-0.04849941118196669,0.29365188714906754,-0.16459830273657838,-0.12750018683293898,0.15431017023708368,0.09069279352607082,0.04424826824152935,-0.01289245673667132,-0.034969466836562664,-0.1014953586972787,-0.07406141332577902,-0.18687249996714209,-0.03503351533905727,-0.08006446631970575,-0.12396630130937783,0.0017355196033315154,0.1374496911602927,-0.15804748133747354,-0.13694397787731946,-0.3433076223226816,0.10150636994214568,0.0032107131401700284,0.05260758633577901,0.6293374378857518,0.07896987871357421,-1.1753594602401254,0.06283650809900372,-0.1815703028938052,1.0492038588657349,0.19613341759493247,-0.15488386474754373,0.25255893176374394,-0.09439835181872254,0.05316482290004068,0.5468807950889307,0.029314373519361663,0.04812115812832807,0.02240569488084637,0.22095365464676384,-0.1677250329193702,-0.034302620774441836,-0.06230512463612733,0.05756570435499349,-0.12113406806521655,0.16420679638278438,0.004669874946200447,-0.14774896113835612,-0.07827243358055448,-0.3499192411261041,-0.03158874257784038,0.2607431021127693,-0.0187658935978697,-0.37056289599295744,0.0012612082330110616,-0.8813285601212417,0.10766151530937833,0.2088164090657633,-0.12526932064577273,-0.1146244381114426,-0.0504631591340917,-0.1657348947519276,0.12190456312468916,-0.15301562863157572,-0.0944166542868408,-0.0990069849833749,-0.09771090097522887,-0.02646668107624276,-0.2657984818750899,0.4024648739448198,0.10390821733546513,Alignment,0
20,20,"rapsearch2  fast  memoryefficient protein similarity search tool  nextgeneration sequence data
  wide application  nextgeneration sequence ngs techniques fast tool  protein similarity search  scale well  large query datasets  large databases  highly desirable   previous work  develop rapsearch  algorithm  achieve  ~fold speedup relative  blast  still achieve similar level  sensitivity  short protein fragment derive  ngs data rapsearch however require  substantial memory footprint  identify alignment seed due   use   suffix array data structure   present rapsearch2  new memoryefficient implementation   rapsearch algorithm  use  collisionfree hash table  index  similarity search database  utilization   optimize data structure  speed   similarity search—another  time  also implement multithreading  rapsearch2   multithread modes achieve significant acceleration    thread mode rapsearch2 require    memory  run  single thread mode     memory  run  thread mode
rapsearch2 use  collisionfree hash table  index  protein sequence   give search database  key   hash table represent  mer   reduce amino acid alphabet   position  mers   database  sort accord   hash value   mers   regular amino acid alphabet note   reduce alphabet representation   use  seed storage  retrieval   seed extension  significance evaluation  base   original sequence rapsearch2 use  bytes  bits  encode  mer   database  first  bits  use  represent  hash key   reduce alphabet   mers since  ≈   database   lower  bits  use  represent  offset   instance   mers   regular amino acid alphabet   representation allow   use bite shift operations  retrieve  position   mer   full  amino acid alphabet  constant time   entry    key  hash value  sort accord   four amino acids follow  mer allow seed     residues   search step rapsearch2 first scan  query sequence  find  entry   mer   hash table  use  binary search  find  occurrences   seed beyond  mers   range  actual instance    entry  also implement  multithreading technique  rapsearch2 since   search  individual query   seedextensions   query  individual subject  independent  implement  interquery scheme  process query  parallel  reduce overhead   thread switch rapsearch2  implement   use boost library    threadpool     test extensively  linux platforms  result  use   ngs datasets  use       test rapsearch2 see  example datasets   supplementary material  integrate microbial genome img    ncbi    june   nonredundant set databases  use   search databases table  compare  performance  rapsearch2  rapsearch  blast  four query datasets   computer  four xeon  ghz x5570 cpus   ram see  detail comparison  rapsearch  blast      since rapsearch2 use   seedextension algorithm  rapsearch  give identical result  rapsearch except   run  time faster due   optimize data structure therefore rapsearch2 retain  high sensitivity  rapsearch relative  blat see  comparison  rapsearch  blat        supplementary materials rapsearch2 also require less memory  rapsearch run  single thread mode require    memory onefourth   memory require   original rapsearch whereas run  thread mode require    memory   typically available  regular computer cluster furthermore  thread mode achieve    acceleration compare  singlethread mode   thread mode achieve  almost  acceleration indicate   multithreading implementation  efficient note  blat run  slightly faster  rapsearch   time slower  rapsearch2 rapsearch2 use   probabilistic model  evaluate  significance  protein sequence alignments use  blast altschul     report  evalues similarly  output  rapsearch2    format  blast    directly adopt   analytical pipeline  replace blast   similarity search engine therefore rapsearch2  readily use  routine protein similarity search  ngs data",-0.2500046956885949,0.2669876568862148,0.09782259678690912,0.1226806972247134,0.03900073832970415,-0.1484633056649105,-0.103299939261892,0.04554186572441074,-0.023997240726564204,0.17564392900406314,0.08654909493829431,-0.0955098678099446,0.19198341742960032,-0.09218543839505004,0.19990146511711146,0.04813669852324223,0.015092815727031115,0.18693611123969525,0.043362607981711085,0.08906256487708912,-0.017101485096140984,-0.2364552682766949,0.04097483986008324,0.07128308759166739,-0.008728241484442895,-0.1930192789490642,0.048458431565128135,-0.10603007266485093,-0.10484100937393258,0.04953368280208825,-0.012150004854243087,0.294098492236652,-0.2453529968741907,-0.08536950581256995,0.24293435617844664,0.07435044803117451,0.0577732161407105,-0.0271316455391962,-0.04521377969134385,-0.14638742487253756,-0.018107897922303082,-0.25055685213379314,-0.05671353531114615,-0.026271753128992312,-0.12391081111618145,0.02662061333977149,0.14390338202893874,-0.1551639200672819,-0.14922423748373004,-0.3607759245239091,0.17249249321136748,0.04175333557962373,0.052135058054834184,0.6264998551868081,0.03466187065141944,-1.1798919307237319,-0.030390176685910188,-0.2227795482342996,1.0867032651749382,0.189421787465038,-0.15088868979476036,0.3123995330369626,-0.06336618495022245,0.14086182419161655,0.5394539231307466,-0.0007859932372355433,0.015906138684261932,-0.05549712395785671,0.2636302265663894,-0.1623843856441062,-0.0615310194172716,-0.025893187054971,0.17739340400492604,-0.1435465089794088,0.20725228172241214,-0.0454910261797135,-0.10041600511449447,-0.13145230334858146,-0.3704592310483724,-0.10842417104227656,0.22430591631021227,-0.018438299291245814,-0.4119866947469672,-0.05340937479136235,-0.909105196850303,0.17854411307801427,0.3229124428789047,-0.20174360228089716,-0.12142893857362738,-0.030545263608408486,-0.1615643728252625,0.13869244587812662,-0.17154323990759218,0.0189568834762539,-0.07943178591197,-0.10747709710142044,-0.10070028044138568,-0.3778583259192523,0.40955772722344935,0.0724410499495111,Alignment,0
21,21,"search  cluster order  magnitude faster  blast
biological sequence data  accumulate rapidly motivate  development  improve highthroughput methods  sequence classification ublast  usearch  new algorithms enable sensitive local  global search  large sequence databases  exceptionally high speed   often order  magnitude faster  blast  practical applications though sensitivity  distant protein relationships  lower uclust   new cluster method  exploit usearch  assign sequence  cluster uclust offer several advantage   widely use program cdhit include higher speed lower memory use improve sensitivity cluster  lower identities  classification  much larger datasets
ublast  usearch  new algorithms  sequence database search  seek highscoring local  global alignments respectively uclust   new cluster algorithm  employ usearch   subroutine  assign sequence  cluster highthroughput  achieve  use  fast heuristic design  enable rapid identification  one    good hit rather   homologous sequence   give query database sequence  sort  order  decrease number  word  common  exploit  fact  similar sequence tend   short word  common see  edgar   examine   order    hit exist   database   likely   find among  first  candidates    probability   hit exist fall rapidly   number  fail attempt increase  search  therefore often  terminate  examine  small number  candidates without  large cost  sensitivity pairwise sequence comparisons  perform use standard fast alignment techniques include gapless highscoring segment pair detection  extend word seed  band dynamic program  detail  provide   supplementary material  result  compare ublast  usearch  ncbi blast  use pfama v24 finn     rfam  gardner    two large sequence family databases contain  protein domains   rnas respectively   case  sequence  extract  random  use   query   remainder use   search database table   supplementary table    simple model   classification task   top hit  consider   designate   true false positive   belong    different family   query though sequence  different families may  fact  homologous   test ublast   faster  megablast  significantly higher sensitivity  faster  blastn  similar sensitivity   faster  blastp  comparable sensitivity   protein twilight zone    illustrate typical improvements achieve  uclust compare   widely use program cdhit   godzik    efficient previous cluster method  set   pyrosequencing read  length    take   recent microbial ecology study costello     cluster  representative identities table  uclust produce higher quality cluster enable cluster  lower identities use substantially less memory  large set   often one   order  magnitude faster cdhit generate cluster  larger  thus apparently better average size   identity   prove    artifact   bug  cdhit  almost half    report identities    therefore fell   threshold   cdhits  measure many   assignments  verify      create independent alignments use muscle edgar  despite generate smaller cluster   enable higher average similarity   achieve cdhit produce cluster  lower average similarity  uclust   case  show    sequence   assign    one cluster uclust tend  identify  better match ublast  usearch introduce  new search paradigm  seek one    good hit rather   hit  order  improve throughput  approach  well suit  nextgeneration sequence classification  search  often  critical bottleneck  analysis lowranking hit  rarely need  may even  undesirable due  increase overhead  user  tune  tradeoff  speed  sensitivity  adjust parameters  control  many candidate hit  examine   search  terminate speed  sensitivity  thus strongly dependent   data  program options  typical applications usearch typically achieve good sensitivity  around  identity    amino acids    nucleotides ublast  sensitive   distant relationships  useful sensitivity extend   twilight zone  proteins blastp  significantly better sensitivity  lower identities   partly due  refinements   blast algorithm  yet implement  ublast  also  problem   distantly relate proteins   perfectly conserve word   require length ublast  usearch require memory   roughly   size   database   sometimes   blast    case  readily accommodate  currently available commodity computer hardware uclust  definitively superior  cdhit   usually significantly faster use significantly less memory  cluster  lower identities    sensitive  cdhit often fail  identify  closest cluster  overlook   match  possible false negative uclust rarely miss  match    case find  best possible match uclust also enable rapid cluster  much larger number  sequence ublast usearch  uclust  dramatically reduce  resources require  classification  large sequence set   therefore   value  biologists   wide range  applications",-0.21113487872786246,0.26001105625215304,0.14807544288664806,0.12692962701114835,-0.0014428117883460787,-0.08338509526518388,-0.14250044076676338,0.017098464664111288,-0.026750595392758036,0.11290363424174593,-0.02829715892814047,-0.06116735478599849,0.16856222002365534,-0.1274845139962677,0.183504654626056,-0.08214490921088484,0.0201752411576758,0.18635772015980048,-0.07019463399188204,0.16407626503609554,0.040188268990364484,-0.22508493304423752,0.08602128134276915,0.0036081258925796866,-0.0276488614895516,-0.19093149076396926,0.008831126940586397,-0.22438630224419465,-0.1054018711582379,-0.022692997434732663,0.009492073087153344,0.2979835481078499,-0.2216523312848364,-0.10651591305414053,0.2506853735520522,0.11435405012917815,0.04768968765523495,-0.0053894606545607,-0.0940236582456966,-0.09189646645093684,-0.1237655958603383,-0.1903728610750509,-0.09390565462849784,-0.12971819153996744,-0.11070030351093717,-0.0050521151865289505,0.17752926480008602,-0.11351110430083865,-0.17016857832196322,-0.4588433156923684,0.189414921085031,-0.04087313879758462,0.06268936296527572,0.6978152724321892,0.08208336653319506,-1.3363010158503998,0.016627062352328126,-0.21236159693175768,1.1266214340536889,0.21007823257940714,-0.19588931441414434,0.4419809800723663,-0.06914373929776882,0.10416250215356268,0.6240264963245105,0.005295337111583842,0.07890678920565904,0.006041963381109971,0.3263534365274101,-0.17059496857942485,-0.06762278992962421,-0.07242589445752602,0.1065274878838404,-0.12937727335070395,0.20146100163746086,-0.06222889943059876,-0.14262455898294285,-0.1676487749208342,-0.4434833050995091,-0.04866604210089813,0.2747501613269478,0.013275244976982127,-0.4341192409764752,-0.06510674661846483,-1.0449904376260817,0.031589605744727384,0.2333695351313997,-0.13125831169625846,-0.2143862366218897,-0.08325228302010627,-0.1669518004900483,0.06717214963148765,-0.11580938176505348,-0.12030222369094673,-0.1795943690498455,-0.02334040160621632,-0.18074328009147764,-0.3601147006668953,0.3597345157553583,0.08937087909330024,Alignment,0
22,22,"vsearch  versatile open source tool  metagenomics
vsearch   open source  free  charge multithreaded bite tool  process  prepare metagenomics genomics  population genomics nucleotide sequence data   design   alternative   widely use usearch tool edgar     source code   publicly available algorithm detail   rudimentarily describe    memoryconfined bite version  freely available  academic use  search nucleotide sequence vsearch use  fast heuristic base  word share   query  target sequence  order  quickly identify similar sequence  similar strategy  probably use  usearch vsearch  perform optimal global sequence alignment   query  potential target sequence use full dynamic program instead   seedandextend heuristic use  usearch pairwise alignments  compute  parallel use vectorisation  multiple thread vsearch include  command  analyse nucleotide sequence available  usearch version   several   available  usearch version  include search exact  base  global alignment cluster  similarity use length presorting abundance presorting   userdefined order chimera detection referencebased   novo dereplication full length  prefix pairwise alignment reverse complementation sort  subsampling vsearch also include command  fastq file process  format detection filter read quality statistics  merge  pair read furthermore vsearch extend functionality  several new command  improvements include shuffle rereplication mask  lowcomplexity sequence   wellknown dust algorithm  choice among different similarity definitions  fastq file format conversion vsearch   show    accurate  usearch  perform search cluster chimera detection  subsampling    par  usearch  pairedends read merge vsearch  slower  usearch  perform cluster  chimera detection  significantly faster  perform pairedend read merge  dereplication
algorithms  implementation    brief description    important function  vsearch  detail   implementation vsearch command line options  show  italics    precede   single   double dash   use read fasta  fastq file  vsearch command read file  fasta  fastq format  parser  fastq file  vsearch  compliant   standard  describe  cock     correctly parse   test file fasta  fastq file  automatically detect  many command accept   input file compress  gzip  bzip2  automatically detect  decompress use  zlib library  gailly  adler    bzip2 library  seward  respectively data may also  pip     vsearch allow  instance many separate fasta file   pip  vsearch  simultaneous dereplication  allow  creation  complex pipelines without ever   write  slow disk vsearch   bite program  allow  large datasets   process essentially limit    amount  memory available  free usearch versions  bite program  limit  available memory  somewhere less  4gb often seriously hamper  analysis  realistic datasets write result file vsearch  output result   variety  format fasta fastq table alignments sam depend   input format  command use  output fasta file  line width may  specify use  fasta_width option   mean  line wrap   turn  similar control  offer  pairwise  multiple sequence alignments search global pairwise sequence comparison   core functionality  vsearch several command compare  query sequence   database  sequence allvsall alignment allpairs_global cluster cluster_fast cluster_size cluster_smallmem chimera detection uchime_denovo  uchime_ref  search usearch_global  comparison function proceed  two phase  initial heuristic filter base  share word follow  optimal alignment   query    promise candidates  first phase  presumably quite similar  usearch edgar  heuristics  use  identify  small set  database sequence   many word  common   query sequence word  kmers consist   certain number   consecutive nucleotides   sequence   default adjustable   wordlength option  overlap word  include  sequence  length   contain        unique word vsearch count  number  share word   query   database sequence word  appear multiple time  count    count  word   database sequence quickly vsearch create  index     possible distinct word  store information   database sequence  appear   extremely frequent word  set  database sequence  represent   bitmap otherwise  set  store   list  finer control  kmer index  describe  usearch   pattern binary string indicate  position must match  slot options usearch   options  seem  ignore  currently vsearch ignore  two options   minimum number  share word require may  specify   minwordmatches option   default   lower value  automatically use  short  simple query sequence  less   unique word compare sequence base  statistics  share word   common method  quickly assess  similarity  two sequence without align    often timeconsuming   statistic  relate metrics  alignmentfree sequence comparison  often  use  rapid  approximate sequence match   statistical properties   well study song     approach use   similarities    statistic  multiple match    word  ignore   second phase search proceed  consider  database sequence   specific order start   sequence   largest number  word  common   query  proceed   decrease number  share word  two database sequence    number  word  common   query  shortest sequence  consider first  query sequence  compare   database sequence  compute  optimal global alignment  alignment  perform use  multithreaded  vectorised full dynamic program algorithm needleman  wunsch  adapt  swipe rognes  due   extreme memory requirements   method  align two long sequence  alternative algorithm describe  hirschberg   myers  miller   use   product   length   sequence  greater   correspond  align two   sequence  alternative algorithm use   linear amount  memory   considerably slower  second phase  probably  usearch  vsearch differ    usearch  default presumably perform heuristic seedandextend alignment similar  blast altschul      perform optimal alignment   option fulldp full dynamic program  use compute  optimal pairwise alignment   case give  accurate result   also computationally  demand  efficient  vectorised full dynamic program implementation  vsearch compensate  extra cost  least  sequence     long   result alignment indicate  similarity equal   greater   value specify    option  database sequence  accept   similarity   low   reject several  options may also  use  determine  similarity  compute iddef  usearch use  offer   version    sequence   accept  reject either   self minqsize   alignment  maxgaps maxsubs  search  terminate  either  certain number  sequence   accept   default adjustable   maxaccepts option   certain number  sequence   reject   default adjustable   maxrejects option  accept sequence  sort  sequence similarity  present   search result vsearch also include  search_exact command   identify exact match   query  use  hash table   way similar   fulllength dereplication command describe  cluster vsearch include command  perform  novo cluster use  greedy  heuristic centroidbased algorithm   adjustable sequence similarity threshold specify    option    input sequence  either process   user supply order cluster_smallmem  presorted base  length cluster_fast  abundance  new cluster_size option  input sequence   use   query   search   initially empty database  centroid sequence  query sequence  cluster   first centroid sequence find  similarity equal     threshold  search  perform use  heuristic approach describe   generally find   similar sequence first   match  find  query sequence become  centroid   new cluster   add   database  maxaccepts  higher   several centroids  sufficient sequence similarity may  find  consider  default  query  cluster   centroid present  highest sequence similarity distancebased greedy cluster dgc    sizeorder option  turn   centroid   highest abundance abundancebased greedy cluster agc     westcott  schloss  schloss  vsearch perform multithreaded cluster  search  database  centroid sequence  several query sequence  parallel     nonmatching query sequence give rise  new centroids  require internal comparisons   query sequence  subsequently perform  achieve correct result   cluster vsearch  create  simple multiple sequence alignment use  center star method gusfield    centroid   center sequence   compute  consensus sequence   sequence profile dereplication  rereplication fulllength dereplication derep_fulllength  perform use  hash table   open address  linear probe strategy base   google cityhash hash function write  geoff pike  jyrki alakuijala  available    hash table  initially empty   input sequence  hash  compute   lookup   hash table  perform   identical sequence  find  input sequence  cluster   match sequence otherwise  input sequence  insert   hash table prefix dereplication derep_prefix  also implement   fulllength dereplication identical sequence  cluster  addition sequence   identical  prefix   sequence  also  cluster together   sequence  identical   prefix  multiple sequence   generally  define  prefix cluster  behave vsearch resolve  ambiguity  cluster  sequence   shortest   candidate sequence    equally long priority   give    abundant  one   lexicographically smaller identifier   one   earliest original position   order  perform prefix dereplication vsearch first create  initially empty hash table   sort  input sequence  length  identify  length    shortest sequence   dataset  input sequence   process  follow start   shortest   exact match   full input sequence  find   hash table  input sequence  cluster   match hash table sequence   match   full input sequence  find  prefix   input sequence  consider start   longest prefix  proceed  shorter prefix  order   prefix  length    match   find   hash table  sequence  cluster  match sequence  delete   hash table   full input sequence  insert   hash table instead   match  find   prefix  full sequence  insert   hash table   end  remain sequence   hash table   output  accumulate abundances   sequence   cluster  order  identify match   hash table  prefix dereplication  hash  compute   fulllength input sequence    prefix  hash function use   bite fowlernollvo  hash function fowler noll      simple  quick  compute    series  sequence  add one nucleotide   time  sequence result  dereplication  many  command may  relabeled   give prefix follow   sequentially increase number vsearch exclusively also offer  possibility  relabelling  sequence   sha eastlake  jones   md5 rivest  message digest hash   sequence   string   highly likely   unique   sequence   digest  compute  sequence  normalize  convert     convert  symbols  upper case vsearch include public domain code   md5 algorithm write  alexander peslyak   sha1  steve reid  others vsearch also include  new command rereplicate  perform rereplication    use  recreate datasets     fulllength dereplication   course original label cannot  recreate chimera detection chimeras  detect either  novo uchime_denovo command    reference database uchime_ref command use  uchime algorithm describe  edgar    vsearch  divide  query sequence  four segment  look  similarity   segment  sequence   set  potential parent use  heuristic search function describe earlier   consider  four best candidates   segment use maxaccepts   maxrejects     threshold   vsearch optionally output borderline sequence   sequence   high enough score  specify   minh option    small  divergence   closest parent  specify   mindiv option multithreading  support  referencebased chimera detection lowcomplexity sequence mask vsearch include  highly optimize  parallelize implementation   dust algorithm  tatusov  lipman  mask  simple repeat  lowcomplexity nucleotide sequence   considerably faster   implementation    algorithm  usearch  code available  ftpftpncbinlmnihgovpubtatusovdustversion1src    public domain vsearch use  algorithm  default  usearch  default use  undocumented rapid mask algorithm call fastnucleo vsearch perform softmasking automatically   pairwise alignment search cluster  chimera detection command  behaviour   control   hardmask option  replace mask symbols   instead  lowercasing    dbmask  qmask options  select  mask algorithm none dust  soft use   database  query sequence respectively mask may also  perform explicitly   input file use  fastx_mask  maskfasta command fastq file process vsearch include command  detect  fastq file version   range  quality score use fastq_chars  well  two command  compute sequence quality statistics fastq_stats  fastq_eestats   also truncate  filter sequence  fastq file base  various criteria fastq_filter  new command  add  convert  different fastq file versions  quality encode fastq_convert    old phred encode illumina fastq file   newer phred format merge  pairedend read merge  pairedend read  support  vsearch use  fastq_mergepairs command  method use   similarity  pear zhang     recognise options similar  usearch  algorithm compute  optimal ungapped alignment   overlap region   forward sequence   reversecomplemented reverse sequence  alignment require  minimum overlap length specify   fastq_minovlen option default   maximum number  mismatch fastq_maxdiffs option default    minimum  maximum length   merge sequence fastq_minmergelen option default   fastq_maxmergelen option default infinite stagger read pair  read pair   ′ end   reverse read   overhang   leave   ′  end   forward read   allow  default  may  turn    fastq_allowmergestagger option vsearch use  match score alpha     mismatch score beta    perfect quality residues  score  weight   probability   two residues really match  mismatch respectively take quality score  account  probabilities  compute   way similar  pear score method  describe  algorithms  implementation   pear paper zhang     vsearch assume  nucleotide background frequencies    merge sequence vsearch compute posterior quality score   overlap regions  describe  edgar  flyvbjerg   speed score  probabilities  precomputed   possible quality score sort  shuffle vsearch  sort fasta file  decrease sequence length sortbylength  abundance sortbysize vsearch  also perform shuffle  fasta file  random order shuffle  seed value   pseudo random number generator may  provide   randseed option  obtain replicable result subsampling sequence  fasta  fastq file   subsampled fastx_subsample  randomly extract  certain number sample_size  percentage sample_pct   input sequence abundances may  take  account give result    input sequence  rereplicated subsampled   dereplicated",-0.1946660311399288,0.16232203185567273,0.10622073668751286,0.07756646246473481,0.013889101763757376,-0.013901837807558996,-0.1083735945998647,0.03599024185840809,-0.004249772727342935,0.08784576632217601,0.02001278200447808,-0.017860349118538604,0.12478245466047372,-0.07272474016482174,0.13378395824996392,-0.02751686648747369,0.029378202112855217,0.1408661626288716,-0.03633024865116027,0.05963328057860181,0.01838959193254424,-0.18116098740172712,0.036422146303934165,0.011927447987189579,-0.008929705742455146,-0.1521687186703695,0.037582322838410925,-0.14990341373136384,-0.03530828518044225,-0.02824058825470885,0.021521613735321358,0.2386147653231384,-0.17336480951572075,-0.07707203316782728,0.198750299155369,0.10280646047745408,0.0399456728323362,-0.01301631705000609,-0.06528373557100987,-0.09944205793777604,-0.0399381730288684,-0.1279900367802953,-0.04023915078045053,-0.0593221200264948,-0.11764463924278155,-0.01311119086338269,0.12305108561000212,-0.12295410010287575,-0.15041620680904408,-0.3100880247726385,0.13641452210750984,-0.017883460058983728,0.0582806989607577,0.5003706668096536,0.03546442327623245,-1.0423888617331143,0.059036619636438574,-0.15027998304491133,0.8413888903675028,0.14761006016452338,-0.134214008283214,0.2712885206166355,-0.08654784516087842,0.06113132525608269,0.4846935375594417,-0.015773789844210292,0.067156137996052,0.02655427877649167,0.1392960304973795,-0.16432098613840682,-0.0879758185335361,-0.03656219066608326,0.08990434498874791,-0.10951061648503108,0.16310148821391451,-0.026903213300559854,-0.13917151791974902,-0.13040589128302765,-0.30336012282136865,-0.08929787195589674,0.1814513942030622,-0.0604943268151585,-0.35192217715890506,-0.0803097427587173,-0.7362437890864945,0.04226063076187726,0.19150984692049436,-0.12309035260500582,-0.09001937608034724,-0.027795043005445202,-0.16964382884642956,0.1330545974191778,-0.11711469960685532,-0.08129408467474306,-0.12268456869477395,-0.09673780428186236,-0.07718760689266248,-0.2651194043569853,0.276304561875995,0.08517041183654805,Alignment,0
23,23,"clus_gpublastp accelerate protein sequence alignment use gpuenabled cluster
basic local alignment search tool blast  one    frequently use algorithms  bioinformatics applications   paper  accelerate implementation  protein blast  clus_gpublastp  multiple query sequence process  parallel  graphical process unit gpuenabled highperformance cluster  propose  experimental setup consist   highperformance gpuenabled cluster  compute node   cluster consist  two hexcore intel xeon  ghz processors    ram    cache  compute node  also equip   nvidia m2050 gpu  comparison   famous gpublast  blast implementation   time faster  single compute node   cluster   compute nod  implementation give  speedup    comparison  standard singlethreaded ncbiblast  implementation achieve  speedup range    
  implementation  protein blast subject database  divide  multiple fragment   head node   cluster  number  fragment  equal   number  compute nod   cluster   compute nod   cluster  homogeneous  compute node  allocate  different fragment   search   query sequence framework develop   execution  clus_gpublastp  show  fig   show  fig   execute  protein blast  gpuenabled highperformance cluster  application  divide  head node  compute node modules  head node perform  task  work distribution  result compilation  process  database fragmentation  allocation  also perform   head node  participate compute node need   gpu enable   remain operations  clus_gpublastp  perform   compute nod parallel blast  multiple query process  implement  cuda  openmpi   use  handle interprocessor communication portable batch system pbs scheduler  use  schedule  query sequence  different compute nod   texture memory   gpus provide faster access   data   implementation textures  define  access  database sequence  different thread   gpu  head node  execution   parallel blast program  start   head node   first activity perform   node identification  process allow  head node  discover  compute nod  available  run  parallel blast application  clus_gpublastp accelerate protein sequence alignment  fig  parallel framework  run clus_gpublatp  per  availability   compute nod  target database   process  divide  fragment target database  divide  equalsized fragment   almost equal number  amino acids  node  take almost   time  process number  fragment   equal   number  participate compute nod  segmentation  node   allocate  fragment  search    compute nod   allocate  different database fragment  perform search  different query sequence  next process   perform  transfer  query sequence   compute nod   parallel blast application  design  handle multiple query concurrently query schedule play  important role multiple query receive   user   head node  alignment   schedule   different compute nod  current application portable batch system pbs scheduler  use  schedule  dynamic schedule  perform  manage multiple query   compute node   cluster  gpu enable pbs schedule  query   different nod  reap  maximum benefit  gpuenabled compute nod   focus  none   compute node  remain idle  search   query sequence   database fragment   compute node   complete  node   allocate   query sequence  comparison partial result obtain   particular query sequence   transmit   head node  head node  schedule  query    compute node whose database fragment    search  pseudocode   head node  show  fig    compute node  carry   fragment   database  compute node    partial alignment result   query sequence   compute node  complete  search   assign database   particular query sequence   return  partial result   head node  head node  combine  partial result  already receive result    query sequence   nod    rani   gupta fig  pseudocode   head node   partial result    compute nod   particular query sequence   obtain  compile  head node  send  final compile result   user   process   repeat   query sequence   input file",-0.2527363733581361,0.2316358197596167,0.033063609105846214,0.052106180719441605,0.13690585863622204,-0.08258759051825873,-0.11721887880007698,0.13908955316781205,-0.030613458974386113,0.17926830583949127,0.10382384867834467,-0.08701118023944854,0.19039012164792965,-0.08820059977626131,0.10740346106433328,-0.03017315791903295,0.12623078159205395,0.2088252581689044,-0.061899197221728125,0.14074008650334438,-0.1033885582452144,-0.3283906976813616,0.09433262998557833,0.06574901952008723,-0.024971388736409108,-0.2007764532043428,0.08877181369238175,-0.04476784445764222,-0.007768982262440168,0.009925244949184932,-0.08350494480003003,0.3976973344388655,-0.22576075763656545,-0.06601983730987089,0.2318609353954306,0.06687797360365368,0.03695427319696228,-0.02587346202478959,0.005466517858681154,-0.15230543637157765,-0.0199695113362998,-0.15150645419312214,-0.02133082706252521,-0.05986448523957701,-0.17523787516002548,0.026354538478516418,0.10954821416309114,-0.1880602380687911,-0.15849561195203365,-0.3033241907399169,0.04661066273017924,0.0017302965224560724,0.0446414927949925,0.6177976352256342,0.06721014450249102,-1.1483398056589067,0.03216016596767324,-0.2170620536563929,1.1372435396900895,0.17746399665394655,-0.1331769276049385,0.2973314428504986,-0.06127014030604596,0.0729073821870092,0.5904700613329903,-0.026525947339722567,-0.0027430101053943557,0.061934984041124415,0.23335819803839605,-0.11419593399396087,-0.051349930667053886,-0.08008849740403115,0.12784108929453175,-0.17854312368938646,0.20721857700243412,0.038883106171335335,-0.21616974628679236,-0.08703861555109385,-0.3437671016642725,-0.11284716669456295,0.3079203444863869,-0.044367265410875614,-0.4484895806781639,0.015052970212928334,-0.9507143934981996,0.2373303958544089,0.324334597865329,-0.16724607930449806,-0.08277843038953797,-0.033462460984933315,-0.12540267764855198,0.2093063502657894,-0.11520385629491957,-0.061923690079628724,-0.04687614109609607,-0.16240274444836902,0.003999782846028195,-0.30991001298772336,0.4636910136447415,0.14766876248108254,Alignment,0
24,24,"kraken ultrafast metagenomic sequence classification use exact alignments
kraken   ultrafast  highly accurate program  assign taxonomic label  metagenomic dna sequence previous program design   task   relatively slow  computationally expensive force researchers  use faster abundance estimation program   classify small subsets  metagenomic data use exact alignment  kmers kraken achieve classification accuracy comparable   fastest blast program   fastest mode kraken classify  base pair read   rate    million read per minute  time faster  megablast   time faster   abundance estimation program metaphlan
sequence classification algorithm  classify  dna sequence   collect  kmers within  sequence   set denote     map  kmer   use  algorithm describe    lca taxon   genomes  contain  kmer  lca taxa   ancestors   taxonomy tree form   term  classification tree  prune subtree   use  classify   node   classification tree  weight   number  kmers    map   taxon associate   node   roottoleaf rtl path   classification tree  score  calculate  sum   node weight along  path  maximum score rtl path   classification tree   classification path    assign  label correspond   leaf    multiple maximally score paths  lca    paths leave  select  algorithm illustrate  figure  allow kraken  consider  kmer within  sequence   separate piece  evidence   attempt  resolve  conflict evidence  necessary note    appropriate choice    kmers  map uniquely   single species greatly simplify  classification process sequence   none   kmers    find   genome  leave unclassified   algorithm  use  rtl path score   classification tree  necessary  light   inevitable differences   sequence   classify   sequence present   library  genomes  differences  even  large value   result   kmer   present   library  associate   species far remove   true source species  score  various rtl paths   classification tree   compensate   differences  correctly classify sequence even   small minority  kmers   sequence indicate   sequence   assign  incorrect taxonomic label database creation efficient implementation  krakens classification algorithm require   map  kmers  taxa  perform  query  precomputed database kraken create  database   multistep process begin   selection   library  genomic sequence kraken include  default library base  complete microbial genomes   national center  biotechnology informations ncbi refseq database   library   customize  need  individual users    library  choose  use  jellyfish multithreaded kmer counter   create  database contain every distinct mer   library   database  complete  byte space jellyfish use  store  kmer count   database file  instead use  kraken  store  taxonomic  number   kmers lca value   database   create  jellyfish  genomic sequence   library  process one   time   sequence  taxon associate    use  set  store lca value   kmers   sequence  sequence  process   kmer   sequence    lca value previously set   lca   store value   current sequence taxon  calculate   lca  store   kmer taxon information  obtain   ncbi taxonomy database database structure  search algorithm  kraken  frequently use  kmer   database query immediately  query  adjacent kmer   adjacent kmers share  substantial amount  sequence  utilize  minimizer concept   group similar kmers together  explain  application   concept   define  canonical representation   dna sequence    lexicographically smaller     reverse complement    determine  kmers minimizer  length   consider  canonical representation   mmers   kmer  select  lexicographically smallest   mmers   kmers minimizer  practice adjacent kmers  often    minimizer  krakens database  kmers    minimizer  store consecutively   sort  lexicographical order   canonical representations  query   kmer     process  look    index  position   database   kmers   minimizer would  store   perform  binary search within  region figure   adjacent kmers often    minimizer  search range  often    two consecutive query   search   first query  often bring data   cpu cache    use   second query  allow memory access  subsequent query  access data   cpu cache instead  ram  strategy make subsequent query much faster   would otherwise   index contain  offset   group  kmers   database require    bytes  default kraken use  minimizers   user  modify  value  example  create minikraken  use  minimizers  ensure  total database size stay     implement kraken  make  optimizations   structure  search algorithm describe  first  note  roberts     simple lexicographical order  mmers  result   skew distribution  minimizers  overrepresents lowcomplexity mmers  kraken   bias would create many large search range  would require  time  search  create   even distribution  minimizers  thus speed  search  use  exclusiveor xor operation  toggle half   bits   mmers canonical representation prior  compare  mmers    use lexicographical order  xor operation effectively scramble  standard order  prevent  large bias toward lowcomplexity minimizers  also take advantage   fact   search range  often    query  make krakens query faster rather  compute  minimizer  time  perform  query  first search  previous range   queried kmer  find   range  query  return immediately   kmer   find   minimizer  compute   kmers minimizer      last queried kmers   query fail   minimizers search space   show     kmer    minimizer  change  kraken   adjust  search range  search    kmer construct simulate metagenomes  hiseq  miseq metagenomes  build use  set  bacterial wholegenome shotgun read  read  find either  part   gageb project     ncbi sequence read archive  metagenome contain sequence  ten genomes additional file  table        million read sample     metagenomes    sequence  select     ten component genome data set   genome  equal sequence abundance  sequence  trim  remove low quality base  adapter sequence  composition   two metagenomes pose certain challenge   classifiers  example pelosinus fermentans find   hiseq metagenome cannot  correctly identify   genus level  kraken      previously describe classifiers     pelosinus genomes   refseq complete genomes database however   seven  genomes  krakengbs database include six strain   fermentans similarly   miseq metagenome proteus vulgaris  often classify incorrectly   genus level    proteus genome  krakens database   single proteus mirabilis genome five  proteus genomes  present  krakengbs database allow krakengb  classify read better   genus  addition  miseq metagenome contain five genomes   enterobacteriaceae family citrobacter enterobacter klebsiella proteus  salmonella  high sequence similarity   genera   family  make distinguish  genera difficult   classifier  simba metagenome  create  simulate read   set  complete bacterial  archaeal genomes  refseq replicons   genomes  use    associate   taxon    entry associate   genus rank result   set  replicons   genera   use  mason read simulator    illumina model  produce  million  read   genomes first  create simulate genomes   species use  snp rate     indel rate    default parameters    generate  read   simulate read  multiply  default mismatch  indel rat  five result   average mismatch rate   range     begin  read     end   indel rate    insertion probability   deletion probability   simba metagenome   read set  generate   random sample    million read set evaluation  accuracy  speed  elect  measure accuracy primarily   genus level    lowest level    could easily determine  taxonomy information  phymmbl  nbcs predictions   automate fashion   due   manner   phymmbl  nbc report  result   genomes    taxonomic entries   seven rank species genus family order class phylum  kingdom  define genuslevel sensitivity       number  read   assign genus   correctly classify   rank     total number  read   assign genus  define sensitivity similarly   taxonomic rank  kraken may classify  read  level   species measure  precision require   define  effect  precision  assign  correct genus  example   assign  species     reason  define ranklevel precision         number  read label     correct taxon   measure rank    number  read label     measure rank     number  read incorrectly label   measure rank  example give  read     label  escherichia coli  label     coli  fergusonii  escherichia would improve genuslevel precision  label  enterobacteriaceae correct family  proteobacteria correct phylum would   effect  genuslevel precision  label    bacillus incorrect genus  firmicutes incorrect phylum would decrease  genuslevel precision  evaluate phymmbls accuracy follow  developers advice   select  genus confidence threshold   comparisons  select  read   simulate medium complexity simmc  data set cover  different genera  simulate short read   sanger sequence data   simmc set  select  last       read   run phymmbl    read  evaluate  genuslevel sensitivity  precision  phymmbls predictions  genus confidence thresholds      increments    find   threshold   yield  highest fscore  harmonic mean  sensitivity  precision     also  fscores within  percentage point   maximum additional file  table   therefore use   genus confidence threshold   comparisons although  selection   threshold depend   users individual need      extent arbitrary  threshold select   manner provide   proper comparison   selective classifier   kraken   threshold    time  accuracy result  use megablast   classifier  obtain   log data produce  phymmbl  phymmbl use megablast   alignment step  assign  taxonomic label   read  megablast  use  taxon associate   first report alignment megablast  run  default options speed  evaluate use  singlethreaded operation   program except  nbc phymmbl  alter    call   blastn program use one thread instead  two nbc  run   concurrent process operate  disjoint set  genomes   genomic library   total time   classifier  determine  sum  decompression  score time   genome wall clock time  record   classifiers  compare kraken    classifiers  use blast  phymmbl  nbc   metaphlan  classifiers   run    computer   amd opteron   ghz cpus     ram run red hat enterprise linux   data set use  speed evaluation   read    program   kraken   variants  metaphlan  use  read data set higher read number  use   faster program  minimize  effect   initial  final operations  take place   program execution although kraken    one   program  examine  explicitly perform operations  ensure  data   physical memory  classification  want   sure   program  evaluate   similar manner  evaluate speed   program  read  database file  imm file  blast databases  phymmbl kmer frequency list  nbc   bowtie index  metaphlan  memory three time  run  program  order  place  database content   operate system cache   store  physical memory reduce database size  generate   database   minikraken result  remove  first   every block   record   standard kraken database  shrink factor    select     smallest integer factor  would reduce  size  less     size   easily fit   memory  many common personal computers  users    ram available kraken allow  smaller shrink factor   use   give increase sensitivity use  draft genomes  construct  krakengb database  notice   several contigs  know adapter sequence   end  subsequent test  also find   sequence  sample  large amount  human sequence  consistently misclassified   database lead   conclude  contamination  likely present   draft genomes   attempt  counteract  contamination  remove   database  kmers  know adapter sequence  well   first  last  kmers     draft contigs    improve classification    eliminate  misclassification problem   reason  believe   draft genomes  use   kraken database  stringent measure   use  remove contaminant sequence   genomic library clade exclusion experiment  reanalyzing  simba data set   clade exclusion experiment  read   use  certain pair  measure  exclude rank   read origin lack  taxonomic entry  either   measure  exclude rank    use   particular experiment  addition  read   use   experiment unless  least two  taxa represent   database aside   exclude clade   exclude rank share  clade  origins taxon   measure rank  example  read  genus  would   use   experiment measure accuracy   class rank  exclude  genus rank unless  home class   least two  genera  genomes  krakens genomic library without  filter step   genus exclude      genus   class kraken could  possibly name  correct class   entries   database   class would  exclude  well     approach take  similar experiment   use  evaluate phymmbl  human microbiome data classification  classify  human microbiome project data use  kraken database make  complete refseq bacterial archaeal  viral genomes along   grch37 human genome  retrieve  sequence  three accession srs019120 srs014468  srs015055   ncbi sequence read archive   accession  two run submit  read  trim  remove low quality base  adapter sequence krona   use  generate  taxonomic distribution plot   sequence   pair read  join  read together  concatenate  mat   sequence  nnnnn   kraken ignores kmers  ambiguous nucleotides   kmers  span   character   affect classification  operation allow kraken  classify  pair  read   single unit rather    classify  mat separately",-0.17581838298651692,0.19030496187903576,0.11763769184981232,0.09308212103823753,-0.037611947332406616,-0.0001928341065724756,-0.08851612703998511,0.03693331556446015,-0.025129041365470558,0.1246127823002694,0.008005625486859529,-0.0019334418456330511,0.15426400533886947,-0.10252289816567044,0.10762108733402816,-0.04072196629436728,0.03872061886954063,0.18485278486075302,-0.04953421710285088,0.09140961428670497,0.0036261388584715843,-0.21407815745167472,0.04964168732474665,0.0016834030595191116,-0.0054993510630068024,-0.16772765077500384,0.05576655771201924,-0.16249247091022795,-0.04475289124219301,-0.05470833864782283,0.028793913756351836,0.2401752970048117,-0.16602930231557006,-0.09260702352620594,0.21983806836485897,0.11076300770126596,0.03369162309844738,-0.017103888562083322,-0.07585003867539326,-0.11460747915990235,-0.10009570066194293,-0.13120145438852304,-0.04415456396773199,-0.09697496612243972,-0.10309129535038053,-0.0001388914365470461,0.12992328262974284,-0.11458626727497295,-0.19607014461561453,-0.3508957198117724,0.17409691680981546,-0.012391770635847336,0.05309551046070152,0.5638119197429811,0.02735688573631696,-1.103128047295771,0.04403044784894472,-0.1933660697052974,0.975298540575644,0.20535196427095725,-0.14987504606137786,0.29877880199131035,-0.057241045832346425,0.08230990467353054,0.5691775918844768,0.015620717701774112,0.014555681590672276,0.023709785569584363,0.20005383217662548,-0.16458652589314796,-0.0893394891195923,-0.037378640062460035,0.06580090239730113,-0.12005380209731847,0.17650616443220776,0.001885875656571412,-0.16091945028434929,-0.15110055142797935,-0.3774242125463221,-0.03659849955968562,0.19890077089147068,-0.02608115001731172,-0.3574565022498073,-0.03219483025309328,-0.8203535536877207,0.03706628390267175,0.2039846221483664,-0.14634377540566035,-0.09394071358423776,-0.02371417512448455,-0.1844503494533894,0.08206461819817709,-0.10747159847552472,-0.09194566371134208,-0.1195611035860444,-0.09464466654536624,-0.07780810528076182,-0.29830271094579386,0.2995615884173249,0.0320277161295981,Classification,1
25,25,"kslam accurate  ultrafast taxonomic classification  gene identification  large metagenomic data sets
kslam   highly efficient algorithm   characterization  metagenomic data unlike  ultrafast metagenomic classifiers full sequence alignment  perform allow  gene identification  variant call  addition  accurate taxonomic classification  kmer base method provide greater taxonomic accuracy   classifiers   three order  magnitude speed increase  alignment base approach  use  alignments  find variants  genes along   taxonomic origins enable novel strain   characterize kslams speed allow  full taxonomic classification  gene identification   tractable  modern large data set  pseudoassembly method  use  increase classification accuracy      species   high sequence homology within  genus
algorithm outline kslam   metagenomic classifier  use  sequence alignment method  infer taxonomy  identify genes read  database genomes  split  short    kmers   add   list  sort   identical kmers  place next  one another iteration   list allow  base overlap  read  genomes   find along  alignment position  overlap   verify   full smithwaterman pairwise sequence alignment neighbor alignments  chain together along  genome   pseudoassembly  allow read  map  low complexity  conserve regions  still  classify precisely   chain often extend  unique sequence low score alignments  screen  taxonomy  infer   lowest common taxonomic ancestor   valid overlap alignments  also use  infer genes  variants  sortedlist method  find kmer overlap allow great speed  efficient parallelisation  modern hardware kmer base alignment   follow analysis assume    integer choose  compile time default      kmer   sequence   nucleotides  read  split   overlap kmers    base overlap   kmers  add   list  genome  split  nonoverlapping kmers  save memory   kmers  add    list  list  sort lexicographically place identical kmers next  one another  list  iterate  find overlap  read  genomes     overlap find  full smithwaterman pairwise local sequence alignment use mengyao zhao' simd smithwaterman implementation   perform  ensure  overlap  valid   find  variants alignments   score lower   userchosen cutoff  screen see supplementary data supplementary data   graph  sensitivity  specificity  various score cutoffs kmers  store along   offset   start   sequence  identifier   sequence     extract   flag   set   kmer   reversecomplemented  order  find overlap   strand kslam compare  kmer   reverse complement  store   lexicographically smallest  save memory  similar kmer base method use lexicographic sort  space kmer seed albeit  protein alignments  independently discover  use  diamond  pairedend read  read length   important  taxonomic specificity kslam  design  work  pair end read   insert size pair read  treat initially  two single read    overlap  alignments find use   kmer method  bacterial sequence  often repetitive   highly likely   end   pair read align  multiple place    genome hence  method  need  detect  pair   alignments  valid   readgenome pair    alignments  sort  offset   start   genome  algorithm  make alignment pair   ' nearest neighbor r2s  viceversa  allow   small subset  pair   consider instead  work   possible pair avoid  scale  library insert size   infer use  statistical method insert size   range   ≤  ≤       use  calculate  mean  standard deviation   pair  insert size  ≥     screen sequence technologies kslam  design  work  data      use sequence technologies   however  constraints   read  affect accuracy  read need   longer   length   kmer    sufficiently low error rate      least one error free kmer   read  allow   base overlap   find     verify   full smithwaterman alignment longer read  produce  alignments  greater taxonomic specificity taxonomic specificity  also improve  use pairedend read  lower error rate allow  longer kmer  hence  shorter compute time kslam   test  find   accurate  illumina hiseq  miseq platforms  well    ion torrent data pseudoassembly due   similarity   genomes  different bacterial species    large probability   read  map    one genome  make infer taxonomy difficult  read often map  long section  conserve sequence kslam attempt  solve  problem  group read  map  adjacent locations    genome together  pseudoassemblies  new alignment score  calculate   chain take  account per base similarity chain length  depth  coverage  long chain  read often extend beyond conserve section   regions specific  one particular strain  allow  read within  chain   assign   lowest possible taxonomic level follow   description   kslam pseudoassembly algorithm  apply   genome   genome sort  alignments  start position form chain  alignments  overlap     base   chain calculate  follow parameters lbebs     chain length  nucleotides      position   first  final nucleotides respectively cnbl     coverage     sum   number  base   read μsσsnb    mean score per nucleotide     smithwaterman score   alignment scμsl     chain' score   apply     alignments   chain infer taxonomy kslam infer taxonomy use  lowest common ancestor technique similar     huson   program megan    read  score cutoff  calculate  multiply  highest alignment score   user choose constant   alignments   cutoff  screen see supplementary data supplementary data   graph  sensitivity  specificity  various fractional score cutoffs taxonomy  choose base   lowest common ancestor   taxonomy tree   remain alignments  match gene  also infer   read   position   alignment along  genome infer genes genes  infer use  genbank format annotations   nonscreened alignment  gene    overlap base  choose   xml output genes  identical name protein ids  products   assign    taxonomy  combine   single entry   associate count synthetic metagenomes  order  calculate  taxonomic classification accuracy  data set  require   every read' taxonomic origin  know   impossible  real environmental metagenomes   standard procedure   produce  data set  silico    first test data set  entirely artificial use pairedend   read generate   randomly select ncbi genomes   error profile five time greater  would  expect  illumina read  error profile  take   kraken  paper  data set    species  equal proportion  design      see   accuracy   classifier change  different species  second data set  take  metabenchmark   effort  evaluate  accuracy  speed  metagenome analysis tool  data set use   million read  design  accurately mimic  complexity size  characteristics  real data  researchers create  data set  sample read pair  sequence genomes  well define proportion  error profile add  real hiseq data",-0.2213284293825506,0.23377034020373785,0.13799659104994427,0.1607771086501282,-0.027609282168776682,-0.019971600317884176,-0.09061164296204564,0.05207564720160705,-0.055343795258489564,0.16874855035480033,-0.0025838585496146945,-0.03453379337736731,0.18095673820632646,-0.10048080710156347,0.18197580868601912,0.0030507764638908275,0.0868465403402026,0.2181073809527342,-0.022297625399586008,0.08054695461132197,-0.006362993604897049,-0.20081989687023893,0.06987815844705385,0.0182876131829231,0.02788213411017709,-0.18833704170626572,0.08529843678832405,-0.16314794735255506,-0.06030010623639056,-0.052402663674300375,-0.006844791128670961,0.27715364673557424,-0.1466553843365048,-0.07964042521621126,0.2511030586566783,0.07992246424910926,0.04731867330765924,0.01977738823726105,-0.05862256993700985,-0.1199027617655887,-0.05897232235275213,-0.15288798183561544,-0.08392980177532053,-0.09058007986941533,-0.11478897823320874,0.02369549488576234,0.1325035815163994,-0.1436842464718764,-0.2307764174233369,-0.3141044018670526,0.16161747117145386,0.007467427664106616,0.07772840752487856,0.6251511670632067,0.016604418315575104,-1.2321762130935436,0.02302540627189297,-0.19844640801040775,1.042362385017742,0.2241383465636793,-0.16710412451308462,0.3756197536620559,-0.047982922632751085,0.10444954142528573,0.6548625835759627,0.02341408318539906,-0.0026067011836791647,0.029900010523745812,0.24350122616719735,-0.19330373912746102,-0.15429211019668912,-0.028933453678980037,0.11721400240226365,-0.12591472093817724,0.24113959834010745,-0.02024305419639704,-0.15855916162477213,-0.2095025321383788,-0.40593119645363857,-0.0706776200898422,0.2195383760277808,-0.053072659555492833,-0.43589397866436697,-0.06280011154189677,-0.8824758157526825,0.0935613498628482,0.2278597215685914,-0.19580514073841795,-0.10763927155664746,-0.0030421386323380927,-0.2055495898741776,0.12249151546802475,-0.11925812769847699,-0.12825960929295518,-0.14010428819850676,-0.08731823645660931,-0.14219462102644234,-0.3671427788538434,0.30640578695281345,0.054605832719031765,Classification,1
26,26,"centrifuge rapid  sensitive classification  metagenomic sequences
centrifuge   novel microbial classification engine  enable rapid accurate  sensitive label  read  quantification  species  desktop computers  system use  index scheme base   burrowswheeler transform bwt   ferraginamanzini  index optimize specifically   metagenomic classification problem centrifuge require  relatively small index     bacterial   archaeal genomes  classify sequence   high speed allow   process  millions  read   typical highthroughput dna sequence run within   minutes together  advance enable timely  accurate analysis  large metagenomics data set  conventional desktop computers    spaceoptimized index scheme centrifuge also make  possible  index  entire ncbi nonredundant nucleotide sequence database  total   billion base   index size     contrast  kmerbased index scheme  require far  extensive space
database sequence compression  implement memoryefficient index scheme   classification  microbial sequence base   fmindex  also permit  fast search operations   reduce  size   index  compress genomic sequence  build  modify version   fmindex   compress genomes  follow first  observe    bacterial species large number  closely relate strain  isolate   sequence usually   represent significant human pathogens  genomes include salmonella enterica   genomes escherichia coli   genomes  helicobacter pylori   genomes available  figure represent  content  refseq   december   expect  genomic sequence  strain within   species  likely   highly similar  one another  leverage  fact  remove  redundant genomic sequence    storage size   index  remain compact even   number  sequence isolate   species increase figure  illustrates   compress multiple genomes    species  store nearidentical sequence   first  choose  two genomes      figure    similar among  genomes  define  two  similar genomes    share  greatest number  kmers using      study  kmers  randomly sample   rate     genomes    species  order  facilitate  selection process  use jellyfish marcais  kingsford   build  table indicate  kmers belong   genomes use  two  similar genomes allow  better compression   tend  share larger chunk  genomic sequence  two randomly select genomes   compare  two  similar genomes use nucmer kurtz     output  list   nearly  completely identical regions   genomes  combine  two genomes  discard  sequence    ≥ identity    retain  remain sequence  use   index   find  genome    similar   combine sequence      combine     manner   describe  process  repeat   rest   genomes   result   concatenation procedure  obtain dramatic space reductions  many species   total sequence  reduce     mbp    original sequence size   enterica      mbp    coli see table  overall  number  base pair   bacterial  archaeal genomes  reduce     billion base pair gbp  fmindex   compress sequence occupy    memory   small enough  fit   main memory ram   conventional desktop computer   demonstrate   supplemental methods  supplemental table   compression operation    negligible impact  classification sensitivity  accuracy classification base   fmindex  fmindex provide several advantage  kmerbased index scheme  store  kmers   target genomes first  size   kmer table  usually large  example kraken' kmer table  store  mers   prokaryotic genomes occupy    disk space second use  fix value   incurs  tradeoff  sensitivity  precision classification base  exact match  large kmers    provide higher precision    expense  lower sensitivity especially   data  analyze originate  divergent species  achieve higher sensitivity smaller kmer match      use however  result   falsepositive match  fmindex provide  mean  exploit  large  small kmer match  enable rapid search  kmers   length  speed comparable    kmer table index algorithms see result use  fmindex centrifuge classify dna sequence  follow suppose   give   read note  centrifuge    easily process  long read assemble contigs   draft genome  even entire chromosomes  search   read forward   reverse complement  right  leave ′  ′  illustrate  figure  centrifuge begin   short exact match  minimum  extend  match  far  possible   example show  figure   first   match exactly   mismatch   41st base   right  rightmost  segment   read  find  six species           store   centrifuge database  algorithm  resume  search begin   42nd base  stop   next mismatch  occur   68th base   segment   middle   read  find  species      continue  search  mappings   rest   read identify   segment  match species  note   exact match  consider throughout  process    key factor   speed   algorithm  perform   procedure   reverse complement   read    example produce  mappings  smaller lengths       compare   forward strand base   exact match find   read   reverse complement centrifuge  classify  read use   mappings   least one  match figure  show three segment mappings   forward strand read  one   read' reverse complement  meet  length threshold centrifuge  score  species use  follow formula  assign greater weight   longer segment  assess  variety  formulas  empirically find   sum  square lengths  segment provide  best classification precision  almost  sequence     shorter occur   database  chance  subtract    match length  value       work almost  well  higher value     result  slightly lower precision  sensitivity   example  figure  species         assign  highest score  base   relatively long  exact match species    get lower score    considerably shorter match even though   two distinct match note    mappings    read   reverse complement    case centrifuge choose  strand  give  maximum score rather  use  sum score   strand  might bias  toward palindromic sequence centrifuge  assign  sequence  multiple taxonomic categories  default  allow   five label per sequence note   strategy differ  kraken  always choose  single taxonomic category use  lowest common ancestor   match species  figure  six different species match  read equally well  order  reduce  number  assignments centrifuge traverse   taxonomic tree first  consider  genus  include  largest number  species    example fig   genus   cover species       replace  three species   genus thereby reduce  number  assignments  four genus  plus species        five taxonomic label  remain centrifuge would repeat  process   genera  subsequently  higher taxonomic units   reduce  number  label  five  fewer  user  easily change  default threshold  five label per sequence  example   threshold  set  one  centrifuge  report   lowest common ancestor   taxonomic label mimic  behavior  kraken   example show  figure   label would    family level  would lose     specific information   genera  species  read match best   size   index    constraint   user  also use centrifuge  uncompress index  classify read use   algorithm although considerably larger  uncompress index allow centrifuge  classify read   strain  genome level    coli k12 rather    coli abundance analysis  addition  perread classification centrifuge perform abundance analysis   taxonomic rank  strain species genus  many genomes share nearidentical segment  dna   species read originate   segment   classify  multiple species simply count  number   read   uniquely classify   give genome ignore   match  genomes  therefore give poor estimate   species abundance  address  problem  define  follow statistical model  use   find maximum likelihood estimate  abundance   expectationmaximization  algorithm detail  solutions   model   previously describe  implement   cufflinks trapnell     sailfish patro    software package",-0.2062258642715998,0.22851189876393535,0.1580255694566618,0.11671034925300675,-0.017007974472137227,-0.034408112781043755,-0.06950646816338607,0.04948196011360286,-0.05621188834815681,0.12202064089694295,0.0254412100366698,-0.006920805190535026,0.16683416823086974,-0.11474028679429005,0.11004432411251992,-0.040267904500520924,0.012261075426844034,0.17320539832962145,-0.04918575542495082,0.10582072495698938,0.05606587292573348,-0.197547899910986,0.08182127697268506,0.007224893207238898,0.011509216752506459,-0.1897884168368637,0.03339993082770902,-0.20833332812940475,-0.027797033862460973,-0.042084468827755066,0.04062286472073976,0.25898832550518464,-0.17438508491657234,-0.11113462896677308,0.23015962722724265,0.1335991620477266,0.06211159900108136,0.010734144396035384,-0.10163138456505123,-0.08191878250690303,-0.06631995447597608,-0.16954344002173655,-0.05101825781620082,-0.09515613606274728,-0.08943238322523124,0.010526688555694618,0.16120366013618118,-0.14806400870623546,-0.21136317947889832,-0.3916390980914508,0.1589885207234533,-0.026413000942578785,0.039643771691212006,0.6176728744905617,0.015159125090865581,-1.2484124783009392,0.01537665343674699,-0.22410417544145933,1.0649537367334014,0.22097988170008329,-0.17761563476619646,0.4047300375067275,-0.05978900495634666,0.06610371380892441,0.5910328151698621,0.046630422555536455,0.04181079928319504,0.03930156065379882,0.236809274285573,-0.16830799233375773,-0.050286209038874735,-0.04477985237540779,0.04251901296899878,-0.09446871021797733,0.20862474078693827,-0.0035311364035512647,-0.17011575177878085,-0.1521555058717053,-0.3742299903422206,-0.02997202700083493,0.24659525173099214,-0.00731997601945004,-0.39406459251471865,-0.05553452364702319,-0.9126908409157328,0.0053211126276338115,0.2166144206047361,-0.16123562608946634,-0.11522136649282108,-0.02944200304092749,-0.18567080894039095,0.07235519171065001,-0.1068953572496282,-0.1503955693048871,-0.21511166345689325,-0.07843695262507085,-0.09265077673476513,-0.30513721098834484,0.3693806492349725,0.05162631336220588,Classification,1
27,27,"clark fast  accurate classification  metagenomic  genomic sequence use discriminative kmers
 problem  supervise dna sequence classification arise  several field  computational molecular biology although  problem   extensively study   still computationally challenge due  size   datasets  modern sequence technologies  produce  introduce clark  novel approach  classify metagenomic read   species  genus level  high accuracy  high speed extensive experimental result  various metagenomic sample show   classification accuracy  clark  better  comparable   best stateoftheart tool    significantly faster     competitors   fastest singlethreaded mode clark classify  high accuracy   million metagenomic short read per minute clark  also classify bac clone  transcripts  chromosome arm  centromeric regions clark   versatile fast  accurate sequence classification method especially useful  metagenomics  genomics applications
building targetspecific kmer set clark accept input  fastafastq format alternatively  input   give   text file contain  kmer distribution   line contain  kmer   number  occurrences clark first build  index   target sequence unless one already exist   specify input file   user want  classify object   genus level  another taxonomic rank heshe  expect  generate target  group genomes    genus     taxonomic label  strategy represent  major difference   tool   lmat  kraken  index   hashtable store   distinct kmer       target contain    number  distinct target contain     number  occurrences      target  hashtable use separate chain  resolve collisions   bucket clark  remove  kmer  appear    one target except   case  chromosome arm assignment   latter case kmers share   two arm    chromosome  use  define centromeric regions  overlap also kmers   index may  remove base   number  occurrences   user  specify  minimum number  occurrences  rare kmers tend   spurious  sequence errors  metagenomic classifiers like kraken  lmat   offer  protection  noise    useful  target sequence  read  lowquality assemblies   result set  targetspecific kmers  store  disk   next phase  time  memory need  create  index    give  additional file  table   table also contain  time  memory require  nbc  kraken observe  clark  faster  nbc  kraken  create  index   use less ram  disk space  kraken  classify object  concept  “targetspecific kmers”  similar   notion  “cladespecific marker genes” propose    “genomespecific markers” recently propose    clark use exact match  identify  targetspecific kmers derive   region   genome  author   disregard intergenic regions  author   focus  strainspecific markers identify  approximate string match  clark use exact match another important difference    method present   rely  megablast   perform  classification   several order  magnitude slower  kraken   users  want  run clark  workstations  limit amount  ram   design clarkl “light” clarkl   variant  clark    much smaller ram footprint   classify object  similar speed  accuracy  reduction  ram   achieve  construct  hashtable  smaller size   construct smaller set  discriminative kmers instead  consider  kmers   target clarkl sample  fraction   clarkl use mers mers appear    good tradeoff  speed low memory usage  precision  skip four consecutivenonoverlapping mers   result clarkls peak ram usage       index creation     compute  classification see additional file  table  clarkl  also  advantage    fast  build  hash table table  include  performance  clarkl   precision  sensitivity  lower compare  clark clarkl still achieve high precision  high speed sequence classification   full mode   index contain targetspecific kmers   create clark create  “dictionary”  associate kmers  target  clark iteratively process  object   object sequence  clark query  index  fetch  set  kmers    “hit”  obtain   kmer either forward  reverse complement match  targetspecific kmer set object   assign   target    highest number  hit see algorithmic detail  additional file  supplementary note   additional file  table   confidence score  compute           number  hit   highest target      number  hit   secondhighest target  rationale  remove common kmers  target   taxonomy level define   user    increase  “noise”   classification process    present  target could obtain   number  hit  would complicate  assignment   conflict   avoid     need  query  taxonomy tree  find  example  lowest common ancestor taxons  “conflicting nodes”  resolve        tool  kraken  lmat observe  additional file  figure     clarks assignments  high confidence score observe   least    assignments  hiseq miseq simba  simhc make  clark   full mode  confidence score equal    exactly one target get hit   average confidence score    assignments    imply   average  number  hit   top target   receive  assignment    time higher   second thus clark unlike lmat  kraken   need  taxonomy tree  classify object instead one “flat” level  clearly sufficient  users   interest  collect confidence score   hit count    recommend  use  default mode  clark   mode clark stop query kmers   object  soon     least one target  collect  least half   total possible hit also  mode load  main memory  half   targetspecific kmers     alternatively load  skip targetspecific kmers base   index position clark run significantly faster  default mode  time faster   experiment  negligible degradation  sensitivity  assignment rate also  ram usage  significantly lower   full mode    lower   experiment  speed   primary concern   design  “express” variant  clark call clarke clarke  base upon theorem  see additional file  supplementary note   state    object originate  one   target  either one   target   hit   kmers   object since  use targetspecific kmer set   one target   associate   kmers   object  addition  reduce  number  query   database  consider  sample   kmers   object  clarke  query nonoverlapping kmers   object  assign   first target  obtain  hit  optimization allow clarke   extremely fast compare  clarkkraken see table   maintain high precision  sensitivity run time analysis  experiment present   study  run   dell poweredge t710 server dual intel xeon x5660  ghz  core    ram clarkl  also run   mac   version   ghz intel core  duo    ram  compare kraken  clark   default mode  krakenq  clarke  always set kraken  “preload”  database  main memory  print result   file instead   standard output  achieve  highest speed  consistency clark  also run    condition   result  table   table  clark  nbc   kraken v0beta  run  singlethreaded mode three time    input  order  smooth fluctuations due    cache issue  report number  best value   also run  latest version  kraken v0beta     observe  significant variation  accuracy  usage  ram however  observe   decrease   classification speed compare  version v0beta",-0.17145503605348467,0.22023146780889724,0.14953625571836202,0.13730110335027906,-0.011883857783513141,-0.09200720364025322,-0.0791977007814068,0.007730991654629158,-0.05505741652550882,0.11608433828377895,0.003600426323326497,-0.03054681886450711,0.14340172098359447,-0.08577751380388947,0.12452546864206568,-0.06731935599584142,0.03547247639543498,0.16840296344299224,-0.03182560281175873,0.12810727635081068,0.049030875021329925,-0.20732737997354106,0.04781256341041913,0.035207872119959474,0.01202104327210845,-0.18200674620197607,0.04491533646250418,-0.1886639850231416,-0.0394695188841055,-0.0572947424346092,-0.0005915864029237184,0.25530357509777346,-0.17006733538686367,-0.06731824636266663,0.21543382504401884,0.14334178393547958,0.046843372994665775,0.016068567293053813,-0.05956038890964789,-0.1126134444415058,-0.09345263115158774,-0.1406173261204183,-0.051030484679831616,-0.11024784104897337,-0.1258244382367909,0.0033132928282773467,0.16821228739407484,-0.1968557708116992,-0.1808601902255576,-0.4207998527963065,0.17156726458858432,-0.018729735650486544,0.0416254107185716,0.6161738669410822,0.02573866297340204,-1.2830769435727392,0.006139850811489342,-0.2038521146857543,1.0652810118163611,0.23381525112392595,-0.12176208976794847,0.3243682779287129,-0.09225084716627073,0.08514971251087511,0.5885254216055567,0.011144707786890156,0.04948430431361955,0.04506746245688939,0.27161406018939216,-0.1310816713000786,-0.07468249323263404,-0.025983648385793288,0.10257203645492527,-0.11724352516574828,0.16005726707098752,-0.0041559977464338356,-0.1333707459888542,-0.14182351420254294,-0.4024568975088496,-0.051149931597024384,0.2643874250067134,-0.04212053043910473,-0.4013889446445131,-0.07357583321329572,-0.9025549928482316,0.033527916773785624,0.2120045370493944,-0.1942323543811779,-0.08958854434060043,-0.05275059517587468,-0.1536206343416273,0.08951229590024623,-0.12446024585873462,-0.09474582700410844,-0.16853185834002432,-0.07289675705070639,-0.10885395006392774,-0.31271270791374994,0.40320046785823627,0.05130541882482642,Classification,1
28,28,"fast  sensitive taxonomic classification  metagenomics  kaiju
ametagenomics emerge   important field  research    microbial ecology  also  human health  disease  metagenomic study  perform  increasingly larger scale  recent taxonomic classification program achieve high speed  compare genomic kmers  often lack sensitivity  overcome evolutionary divergence   large fraction   metagenomic read remain unclassified   present  novel metagenome classifier kaiju  find maximum inexact match   proteinlevel use  burrowswheeler transform  show   genome exclusion benchmark  kaiju classify read  higher sensitivity  similar precision compare  current kmerbased classifiers especially  genera   underrepresented  reference databases  also demonstrate  kaiju classify    time  read  real metagenomes kaiju  process millions  read per minute   run   standard 
first  sequence read  translate   six possible read frame   result amino acid sequence  split  fragment  stop codons fragment   sort either   length mem mode    blosum62 score greedy mode  sort list  fragment   search   reference protein database use  backwards search algorithm   bwt  mem mode  allow exact match greedy mode extend match   leave end  allow substitutions   remain fragment   list  shorter   best match obtain  far mem  cannot achieve  better score greedy  search stop   taxon identifier   correspond database sequence  retrieve metagenome classifier kaiju classify individual metagenomic read use  reference database comprise  annotate proteincoding genes   set  microbial genomes  employ  search strategy  find maximal exact match substrings  query  database use  modify version   backwards search algorithm   bwt20  bwt22   text transformation  convert  reference sequence database   easily searchable representation  allow  exact string match   query sequence   database  time proportional   length   query    context  read map mems   use   fast method  identify seed  map regions   reference genome  example  refs   use mems  quickly find  sequence   reference database  share  longest possible subsequence   query backtrack   bwt   speed   use  lookup table  occurrence count   alphabet letter   first propose  ferragina  manzini20   often call fmindex kaiju employ  sparse representation   table  use checkpoints  allow  decrease  otherwise large memory requirement due   size   amino acid alphabet  initial suffix array use  calculate  bwt  also implement   sparse suffix array  adjustable size   reduce  index size   little impact  runtime   suffix array   need  determine  name   database sequence   best match   read  find thus kaiju   first program  efficiently use  bwt  fmindex   large protein database allow query large set  sequence read figure  illustrate  step  kaijus algorithm first kaiju translate  read   six possible read frame    split  stop codons  amino acid fragment  fragment  sort  length  begin   longest fragment query   reference database use  backwards search   bwt give  query fragment  length    minimum require match length   backwards search  start   position        query   longest mem  retain  one   match  length l4m  find   set     next fragment   order list  query   database   length   least  otherwise  search stop   search  finish  one   match  find  taxon identifier   correspond database sequence  retrieve   suffix array  print   output  equally long match  find  multiple taxa kaiju determine  lca   taxonomic tree supplementary fig   output  taxon identifier thus  read  always classify   lowest possible taxonomic level give  ambiguity   search result  minimum require mem length    major parameter  trade sensitivity versus precision  little impact  runtime   error rate    sequence read  know   evolutionary distance  reference genome  sequence genome  negligible    estimate     read length23 however  metagenomics  evolutionary distance  add variation  top  sequence errors   know  priori  least one  estimate  false positive rate  count random match   end  create  shuffle version   microbial subset  ncbis  protein database use ushuffle25   window length   amino acids  search  mems  simulate metagenomic read   shuffle database supplementary figure  show  cumulative sum  match   shuffle database sort   length   match  one  observe  b95    r11 amino acids long  classify simulate read   original database   wrong classifications     correct classifications  length r11  therefore choose      default minimum match length  kaiju search  mems   fastest possible search strategy   sensitivity decrease  increase evolutionary distance  query  target     amino acid substitutions occur  exact match become shorter therefore allow  substitutions   backwards search  bridge mismatch  extend  match   cost   exponential increase  runtime depend   number  allow mismatch position    rapid expansion   search space especially    letter amino acid alphabet one could employ  greedy heuristic   substitutions   introduce   end   match instead   position   query sequence therefore  also implement  greedy search mode  kaiju  first locate  mems   minimum seed length default    extend   allow substitutions   leave end   seed match    backwards search continue   next mismatch occur eventually  search stop   leave end   query  reach    maximum allow number  substitutions   reach since amino acid substitutions  homologous sequence  nonuniform   speedup   gain  prioritize   likely substitutions   position  use  amino acid substitution model  total score   match   calculate   standard sequence alignment    use  rank multiple match  select  taxon   database  classification therefore   translation   read   set  amino acid fragment  rank  fragment   blosum62 score  start  database search   highest score fragment   substitute amino acid  modify fragment  place back   search list accord   new  lower score   match  find    higher score   remain fragment   search list   score   minimum score threshold   search stop   highest score match  use  classify  read  multiple match  several different database entries    score kaiju classify  read   lca     minimum require score  necessary  avoid random match   estimate  use  shuffle database   choose     default value  kaijus greedy mode kaiju  implement   commandline program      also available via  web server input file contain  singleend  pairedend read  either   fasta  fastq format kaiju output one line   read  read pair contain  read name   ncbi taxon identifier   assign taxon  well   length  score   match optionally kaiju  also produce  summary file   number  read assign per taxon    load  krona26  interactive visualization  also include  utility program   merge  classification result  different run  program  example  merge kaiju  kraken result performance evaluation  primary goal  kaijus proteinlevel classification   improve classification   part   metagenome    distantly relate   know sequence  belong   branch   phylogeny   underrepresented   reference database  therefore devise  benchmark study  address  problem  simulate  classification  metagenomic read   novel strain  species    contain   reference database   benchmark data set  download  snapshot   complete bacterial  archaeal genomes   ncbi ftp server date  december    genomes  retain   assign   species belong   genus    full chromosome  annotate proteins result   total   genomes belong   distinct genera supplementary fig  show  distribution  genomes  genera illustrate  large variance   number  sequence genomes   genus  example  genus streptococcus contain  genomes whereas  genera    available genome  genera   available genomes     distribution clearly illustrate  sample bias   sparseness across large part   phylogeny   total   genomes  extract  genera    least      genomes assign  result   list   genera comprise  genomes    measure  classification performance individually      genomes  simulate five set  hts read  create  reference database  contain  genome    use  classify  simulate read read  simulate   whole genome include plasmids use art27  four set  illumina read contain  read  length either       singleend  pairedend mode another set   roche read  minimum length     mean length     also simulate use art  evaluate classification accuracy  measure  number  classify read  well  sensitivity  precision  genus  phylumlevels sensitivity  calculate   percentage  read assign   correct genusphylum    total number  read   input precision  calculate   percentage  read assign   correct genusphylum    number  classify read exclude read classify correctly   rank  genusphylumlevel   measurements  use   study  ounit   kraken v04b  clark   run   default modes use     highest precision  clark  also run use    kaiju  run  mem mode use minimum match lengths   11y14   greedy  greedy modes allow       substitutions use minimum match score   55y80 speed measurements  run    apollo  system proliant xl230a gen9 server   two bite intel xeon   ghz cpus  core    ddr4 memory      rpm sata disk   kraken  clark  run  default modes      kaiju  run  mem     well  greedy  greedy    modes   index  use  suffix array exponent   performance  measure  process read  read pair per second rps use  parallel thread  kaiju  clark need  preload  index  memory   classification start kraken  either preload  index   load necessary segment   classification  therefore measure krakens speed use  options   turn   kraken run faster without preloading   hardware  therefore report  performance without preloading     five type  simulate read   exclusion benchmark  create  data set comprise  read   genome   reference database result    read   read type  combination  program  read type  measure four time  reduce impact  cache   fluctuations   fastest run   replicate  report",-0.17299501532474965,0.2425243708532507,0.14796913676870474,0.1328117587274987,-0.027225808887454,-0.02109167729699505,-0.06963787759181353,0.030284751536565693,-0.043776600380568235,0.11456675239708852,0.031178973949992358,0.005726019302753946,0.1404272444733337,-0.11764148192787212,0.15075513485415254,0.01922293389896013,0.02687752910011934,0.1868757934786536,0.013035670854601972,0.06743993992176509,0.02206317347523847,-0.22219252896410685,0.057877322405461326,0.06037178950279176,0.039785306395929865,-0.2025660125516042,0.08529151463056955,-0.1382504240290336,-0.04431736339151497,-0.04308993286137424,-0.0121988939859006,0.2451660087573202,-0.15732776406091398,-0.08054087194717134,0.23245808529772896,0.08324521702953276,0.04497401567306823,0.006414380246738335,-0.061407439504436875,-0.10221567074948534,-0.06558721156639409,-0.12107007321145047,-0.06991808124201318,-0.08613662890944655,-0.11810021098449194,0.01036791887516269,0.13307834589975964,-0.1533179695575562,-0.2102795782644792,-0.33061620784692664,0.165945203705697,0.0013432239592580158,0.04754306210783945,0.5775688754444102,0.02055869626594229,-1.1255018900295892,0.017876433187980302,-0.1886845266951796,0.9982578564286892,0.22991548027416725,-0.17374232288433775,0.3037711049362335,-0.07579541002323982,0.06810621197159769,0.5803091697785303,0.03851796651492925,-0.003520067726092957,-0.004128948050836989,0.2614778629528612,-0.1889935166141548,-0.10005061992249677,-0.016150206573275577,0.1074566965015086,-0.11295288177495574,0.2009445054918132,-0.0226858608541594,-0.18383037685715406,-0.15629620034509314,-0.3604391896798465,-0.08319043462709495,0.1888210319508788,-0.051439093876464205,-0.4345174673099928,-0.04618195640552456,-0.842130881674697,0.04043468814927866,0.2451543041267453,-0.18130322225083828,-0.09256417982345158,-0.01100869512563289,-0.230606878550818,0.14064325902187852,-0.14292556942446752,-0.07835128417329253,-0.11573499472723217,-0.1157544596538986,-0.060552973861948266,-0.3315344864927002,0.3345611475769171,0.04655554798393769,Classification,1
29,29,"krakenuniq confident  fast metagenomics classification use unique kmer counts
falsepositive identifications   significant problem  metagenomics classification  present krakenuniq  novel metagenomics classifier  combine  fast kmerbased classification  kraken   efficient algorithm  assess  coverage  unique kmers find   species   dataset  various test datasets krakenuniq give better recall  precision   methods  effectively classify  distinguish pathogens  low abundance  false positives  infectious disease sample  use  probabilistic cardinality estimator hyperloglog krakenuniq run  fast  kraken  require little additional memory
krakenuniq  develop  provide efficient kmer count information   taxa identify   metagenomics experiment  main workflow   follow  read  process  kmer  assign  taxon   database fig  krakenuniq instantiate  hyperloglog data sketch   taxon  add  kmers   fig   additional file  section    hyperloglog algorithm  classification   read krakenuniq traverse   taxonomic tree  merge  estimators   taxon   parent   classification report krakenuniq include  number  unique kmers   depth  kmer coverage   taxon   observe   input data efficient kmer cardinality estimation use  hyperloglog algorithm cardinality   number  elements   set without duplicate   number  distinct word   text  exact count   keep  store  elements   sort list  linear probe hash table   require memory proportional   number  unique elements   accurate estimate   cardinality  sufficient however  computation    efficiently    small amount  fix memory  hyperloglog algorithm hll    well suit  kmer count  keep  summary  sketch   data   sufficient  precise estimation   cardinality  require   small amount  constant space  estimate cardinalities   billions  method center   idea  long run  lead zero    efficiently compute use machine instructions  unlikely  random bitstrings  example  every fourth bitstring   random series  start   one  bit   first  bit   every 32nd hash start   conversely   know  maximum number  lead zeros    members   random set   use      crude estimate   cardinality  detail  additional file  section    hll algorithm hll keeps     byte count   maximum number  lead zero   data  data sketch    precision parameter typically     see fig   cardinalities      use  sparse representation   register suggest  heule       much higher effective precision ′    encode  index  count   vector  byte value see fig   add  kmer   taxons sketch  kmer       first map   hash function   bite hash value note  kmers  contain nona     character   ambiguous iupac character  ignore  krakenuniq  first  bits   hash value  use  index    later    bits  count  number  lead zeros   value   register    sketch  update    larger   current value     read classification  finish  taxon sketch  aggregate   taxonomy tree  take  maximum   register value  result sketch       kmers  count   whole lineage   begin krakenuniq  compute cardinality estimate use  formula propose  ertl    theoretical  practical advantage    require empirical bias correction factor     test  perform better  flajolets  heules methods additional file  figure     expect relative error   final cardinality estimate  approximately sqrt2p       sketch use  byte register     space  give estimate  relative errors  less   fig  note  krakenuniq also incorporate  exact count mode  however use significantly  memory  runtime without appreciable improvements  classification accuracy result   simulate   biological test datasets  assess krakenuniqs performance    datasets compile  mcintyre    see additional file  table   detail   datasets  place greater emphasis    biological datasets  contain  realistic laboratory  environmental contamination   first part   section  show  unique kmer count provide higher classification accuracy  read count    second part  compare krakenuniq   result   metagenomics classifiers  run krakenuniq  three databases “orig”  database use  mcintyre   “std”  contain  current complete bacterial archaeal  viral genomes  refseq plus viral neighbor sequence   human reference genome  “”  contain  microbial sequence include fungi  protists   nonredundant nucleotide collection nrnt provide  ncbi see additional file  section   detail  “std” database furthermore include  univec  emvec sequence set  synthetic construct  vector sequence  lowcomplexity kmers  microbial sequence  mask use ncbis dustmasker  default settings  use two metrics  compare  well methods  separate true positives  false positives   score   harmonic mean  precision   recall    recall   maximum false discovery rate fdr     method  compute  select  ideal thresholds base   read count kmer count  abundance call precision   define   number  correctly call species  genera divide   number   call species  genera   give threshold recall    proportion  species  genera     test dataset    call   give threshold higher  score indicate  better separation  true positives  false positives higher recall mean   true species   recover  control  false positives   ncbi taxonomy   update since  datasets  publish  manually update  “truth” set  several datasets see additional file  section   detail  taxonomy fix  case  might   miss would result   lower apparent performance  krakenuniq note   exclude   yearold simulate datasets simhc simmc  simlc  mavromatis     well   biological dataset jgi srr033547     read classification performance use unique kmer  read count thresholds  first look   performance   unique kmer count thresholds versus read count thresholds  would  use  kraken  kmer count thresholds work  well particularly   biological datasets table   additional file  table    genus level  average recall   biological datasets increase     average  score increase    species level  average increase  recall   biological set         score increase     simulate datasets  differences  less pronounce  vary  databases even though  average  unique kmer count   better however   two case genus recall  databases “orig”  “std”  difference  higher     direction  find  simulate datasets often lack false positives   decent number  read   lower number  unique kmer count   see  real data instead   simulate datasets  number  unique kmers  linearly increase   number  unique read   true  false positives additional file  figure   biological datasets sequence contamination  lower read count   true positives make  task  separate true  false positives harder comparison  krakenuniq    methods next  compare krakenuniqs unique kmer count   result   metagenomics classifiers  mcintyre     include  alignmentbased methods blast  megan   diamond  megan    metaflow   kmerbased clark  clarks  kraken  lmat   nbc    markerbased methods gottcha  metaphlan2   phylosift  krakenuniq  database “”   highest average recall   score across  biological datasets  show  table   see  use unique kmer instead  read count  thresholds increase  score   database selection prove    important krakenuniq  database “std”  perform  worse  krakenuniq  database “”  blast  higher average score  krakenuniq  kmer count thresholds   original database   simulate datasets krakenuniq   “” database still rank   top though  see previously    variation additional file  table  notably clark   good  krakenuniq  blast  much worse score   simulate datasets generate  better test dataset  select  appropriate kmer threshold   previous section  demonstrate  krakenuniq give better recall   score   classifiers   test datasets give  correct thresholds    correct thresholds  determine  real data  vary sequence depths  complex communities  test datasets   ideal    biological datasets lack complexity   maximum   species     sample   simulate sample lack  feature  biological datasets  thus generate  third type  test dataset  sample read  real bacterial isolate sequence run     tens  thousands   sequence read archive sra  way  create  complex test dataset    know  grind truth    feature  real sequence experiment include lab contaminants  sequence errors  select  sra datasets   different bacterial species   link  complete refseq genomes see additional file  suppl methods section   randomly sample   hundred   million read logarithmically distribute   experiment  give  million read pair  total furthermore  subsampled  read set      million read  read set  classify  krakenuniq use  “std” database consistent   result   previous section  find  unique kmer count provide better thresholds  read count   term   score  recall   test datasets  fig    million reads—species recall using kmers   recall use read   higher sequence depth  recall increase slightly—      species level        genus level  ideal value   unique kmer count thresholds however vary widely  different sequence depths  find   ideal thresholds increase    unique kmers per  million read see fig  mcintyre    find  kmerbased methods show  positive relationship  sequence depths  misclassified read  analysis also show   deeper sequence depths higher thresholds  require  control  falsepositive rate  general  find   correctly identify species  obtain   approximately  unique kmers per  read     read length   read sample  different location   genome note    genome  completely cover   unique kmers   detect thus  kmer threshold  always  several time higher   read count threshold   discovery  pathogens  human patients discuss   next section  read count threshold    unique kmer count threshold   eliminate many background identifications  preserve  true positives   discover      read exact count versus estimate cardinality krakenuniqs unique kmer count   estimate raise  follow question  use  estimate—instead   exact count—affect  classification performance  answer  question  implement  exact count mode  krakenuniq  expect exact count require significantly  memory  runtime   full test dataset   mio pair read sample   wgs experiment  bacterial isolate   efficient  two version  exact count require   memory     runtime    time  observe virtually  improvement  term  classification performance table   likely explanation   find     underestimation   true cardinality   small amount   rarely change  rank   identifications    case however   true species may fall    threshold due   estimation error  users may choose  use exact count  krakenuniq although   incur  large penalty   runtime  memory consumption result  biological sample  infectious disease diagnosis metagenomics  increasingly use  find species  low abundance  special case   emerge use  metagenomics   diagnosis  infectious diseases     application infect human tissue  sequence directly  find  likely disease organism usually  vast majority   read match typically   host  sometimes fewer   read   many millions  read  match   target species common skin bacteria   patient  lab personnel   contamination  sample collection  preparation  easily generate  similar number  read  thus mask  signal   pathogen  assess   unique kmer count metric  krakenuniq could  use  rank  identify pathogen  human sample  reanalyzed ten patient sample   previously describe series  neurological infections   study sequence spinal cord mass  brain biopsies  ten hospitalize patients   routine test  pathogens  inconclusive  four   ten case  likely diagnosis could  make   help  metagenomics  confirm  metagenomics classifications  author   original study realign  pathogen read  individual genomes table  shows  result   reanalysis   confirm pathogens   four patients include  number  read  unique kmers   pathogen  well   number  base cover  realignment   genomes even though  read number   low  two case  number  unique kmers suggest   read match  different location   genome  example  pt8  read contain  unique kmers  realignment show  cover base pair  contrast table  shows examples  identifications    datasets    wellsupported  kmer count  also examine  likely source   falsepositive identifications  blast  read   full  database  find rrna  environmental bacteria human rna  phix misassignments see additional file  suppl methods  detail notably  common laboratory  skin contaminants phix escherichia coli cutibacterium acnes  delftia  detect     sample  see additional file  table  however  identifications  solid  term   kmer counts— bacteria  phix  present   sample   read cover  genomes rather randomly  discount  comparisons   negative control   multiple sample  require  extensions  krakenuniq krakenuniq add three  notable feature   classification engine  enabling strain identification  extend  taxonomy  finest level  granularity  kraken classifications  nod   ncbi taxonomy  mean  many strain cannot  resolve    hundreds  strain share   taxonomy  krakenuniq allow extend  taxonomy  virtual nod  genomes chromosomes  plasmids  thus enable identifications    specific level see additional file  suppl methods section   integrating  viral strain sequence refseq include  one reference genome   viral species  mean   lot   variation  viral strain   cover   standard refseq database krakenuniq source viral strain sequence   ncbi viral genome resource   validate  “neighbors”  refseq viruses  lead      read classifications see additional file  suppl methods section   hierarchical classification  multiple databases researchers may want  include additional sequence set   draft genomes   search krakenuniq allow  chain databases  match  kmer hierarchically stop   find  match  example  mitigate  problem  host contamination  draft genomes  search may use  host genome   first database  complete microbial genomes  draft microbial genomes  detail  available  additional file  suppl method section  time  memory requirements  additional feature  krakenuniq come without  runtime penalty   limit additional memory requirements  fact due  code improvements krakenuniq often run faster  kraken particularly     read come  one species   test datasets  mean classification speed  million base pair per minute increase slightly     mbpm see additional file  table   factor   time need  summarize classification result  krakenreport   require  kraken  part   classification binary  krakenuniq krakenuniq   average  faster  memory requirements increase  average           pathogen  patient data    case     read  either assign  human  synthetic read krakenuniq  significantly faster  kraken additional file  table   classification speed increase     mbpm  average wall time    lower   average additional memory requirements  less    go       time comparisons  make  preloading  database  run   parallel thread",-0.15973054532569192,0.212364075886252,0.13861882212967555,0.09708940633516937,-0.05543926128893365,0.0034562003270968387,-0.08038698938735382,0.024440244524412902,-0.03090093454538786,0.076601378576224,0.003089109249078807,-0.01109338462860747,0.1520059946370222,-0.08254720137823683,0.14013468430958134,-0.00899963959103875,0.034331796350395016,0.17148238096825866,-0.024373251554361982,0.0919512010189115,0.029341497424725544,-0.1931301815156042,0.04367916230893987,-0.015120622778996125,-0.011880847537240974,-0.1559370738629436,0.08784446690093795,-0.1604683119829661,-0.0504586278795405,-0.06627339521303967,0.01843525171162935,0.20568185291913368,-0.17177573439007493,-0.06076977001861453,0.1878112784956424,0.08470599567150011,0.0026358178173573584,-0.004353920544424886,-0.08786158800465642,-0.05803178823935505,-0.11512601987010927,-0.1230139667092831,-0.0971513381004118,-0.11457721944107413,-0.09501551783023897,0.008932467112924823,0.14046664931848524,-0.1364072638004387,-0.225938782372558,-0.3585578868248421,0.22094149200005853,-0.040796085110786806,0.06312156024589864,0.5583966150426825,0.022032599159174014,-1.1168251076885507,0.03771732493956904,-0.1938478588984397,0.9205649190523292,0.20454448143859874,-0.1455167231346875,0.3701769288458848,-0.057574106887780564,0.058643175835926924,0.582697319232991,0.036895676393082666,0.03260313813642428,0.0047161703245295426,0.2231247790612316,-0.1678413214039264,-0.08644646058543654,-0.004232393447725634,0.07136030348923512,-0.08850512676500973,0.1964238726939082,0.006909932982231501,-0.12451978691555025,-0.1649141619260463,-0.36953933636302894,-0.03139110007958317,0.21027708201005335,-0.00636005285585914,-0.3841116874967256,-0.03055019382472065,-0.8529122341973812,0.026386536785737096,0.20190676561582008,-0.1090802004600933,-0.14458433150772773,-0.01723109127764172,-0.14644621585330894,0.057015524547512936,-0.07478024141155214,-0.08923603758633013,-0.10657569745063863,-0.057285692387385276,-0.10020440300400003,-0.31094174514423634,0.2764360551788075,0.06478985887190901,Classification,1
30,30,"livekrakenrealtime metagenomic classification  illumina data
 metagenomics kraken  one    widely use tool due   robustness  speed yet  overall turnaround time  metagenomic analysis  hamper   sequential paradigm  wet  dry lab  urgent experiment    crucial  gain  timely insight   dataset   present livekraken  realtime read classification tool base   core algorithm  kraken livekraken use stream  raw data  illumina sequencers  classify read taxonomically  way   able  produce result identical    kraken  moment  sequencer finish   furthermore able  provide comparable result  early stag   sequence run allow save    week  sequence time   illumina hiseq  high throughput mode   number  classify read grow  time false classifications appear  negligible number  proportion  identify taxa   affect   minor extent
originally kraken   linear workflow wood  salzberg  sequence read  read  fasta  fastq file  subsequently classify use  precomputed database since  read  independent       process  parallel  lowest common ancestor lca classification result find   read  write  krakens tabular report file  make  workflow fit   purpose  live taxonomic classification similar   approach take  hilive lindner     new sequence reader module  implement  allow read sequence data  illuminas binary basecall bcl format livekraken   use  analyze continuously  refine  metagenomic sample composition use   database structure   original kraken illumina sequencers process  read  parallel   call cycle append one base   read per cycle   cycle bcl file  produce  illuminas basecalls directory   declare  input  livekraken instead  fasta  fastq file new data  collect   bcl sequence reader module  userspecified intervals   sequencing cycle start   first kmer  size   collect data  send   classifier  refine  store partial classification   new sequence information temporary data structure  kraken  store   read    lca list  list  ambiguous nucleotides   number  kmer occurrences   database  lead   overall increase  memory consumption proportional   number  lcas find   read sequence additionally  crucial   iterative refinement  variable  store   hold  position     read  classify   refinement step output    tabular format  know  kraken  produce  enable early classification  also ensure   classification output  read  data   last sequence cycle  exactly    kraken would produce raw part  sequence read  stream directly   sequencer  krakens classification algorithm kmers  taxonomically classify use krakens precomputed map   kmer   lowest common ancestor   genomes contain  kmer  color cod   taxonomy tree  highest score path   prune subtree   taxonomic tree  select  classification   read wood  salzberg   result   example    unmask read  srr062462  transfer back  raw miseq data format result  report        sequence cycle  approximately          illumina miseq   sequencer finish  data   prepare   tool  start  result  visualize   sankey diagram  read classifications  species level   cycle  report  top five group    hit  show  group  fewer hit  conflate   read  cannot  assign  species level  denote  unclassified  unclassified nod  optically narrow  approximately    read   better recognition  relevant group thickness   flow encode  number  read go  one node  another  blue flow represent unchanged  new classifications  red ones show change classifications   number  unclassified read decrease  overall proportion  taxa stay   misclassifications occur  negligible magnitude  visualization  result   interactive sankeyplot  part  livekraken livekraken   instal via  include script install_krakensh analogous  kraken   additional dependency   boost library    test  gcc       boost   furthermore  conda package  available grüning    livekraken use   command line interface  kraken livekraken build   wellknown tool kraken hence  show  result  comparison   classic kraken approach   guarantee identical result  kraken   end   sequence run  also show  preliminary classifications allow  reliable estimate   sample composition long   sequencer  finish  run livekraken  three datasets   nih human microbiome project nih hmp work group     table  return result  every 40th sequence cycle  approximately          sequencer finish respectively  reference database  use  bacteria  archea sequence  refseq oleary    download  june 2nd   compare  result   output  kraken   full datasets table   example  visualize  figure  show   number  unclassified read decrease  time    minor number  read  misclassified  earlier stag   peak memory requirements  livekraken increase   compare  kraken   experiment speed decrease    supplementary fig    still order  magnitude faster   sequencer  therefore   runtime bottleneck  result confirm  hypothesis   classification  already possible long  classical metagenomic tool  even  start",-0.19120839195653114,0.22430318342175487,0.13910439381353068,0.08226529901436105,0.0344361010703105,-0.056578654283943174,-0.04912769902590367,0.09413628137517202,-0.039499237608456333,0.09032453038019446,0.055624909872849335,-0.01695458570648504,0.17181864195014054,-0.09188292569354106,0.15309964859920047,-0.0045494321793394426,0.09719515674529433,0.13595088870379532,0.004270365583187977,0.08769659982269183,-0.022266113174979018,-0.21531950236265726,0.0789265993169212,0.04366658416044709,0.007084534234585407,-0.1971033105075572,0.04143932304504221,-0.10568504012337168,-0.004535121117465056,-0.06101444156441095,-0.0203129365963602,0.2150867629731428,-0.18357872483880508,-0.07359448360401513,0.17535959369080406,0.14703207138720958,-0.011633393618122002,-0.009346478416796632,-0.05178391880777965,-0.14828331149485305,-0.10505341576807248,-0.13191567688448266,-0.07814936906016798,-0.059229963078514275,-0.061714734278488136,0.03063026403643689,0.13150601675203424,-0.1852019245683251,-0.16593367479155074,-0.3606866258878078,0.16791028222489124,-0.03166682288769774,0.0967208967380936,0.5709386001152422,-0.027099893093138604,-1.1934253736281226,0.020712172525236383,-0.18353435204362886,1.0026669133726442,0.1941042012517352,-0.15724081058127734,0.3124630938245785,-0.10392715507614296,0.04635510109479191,0.55224857453472,0.0476064922971816,-0.01766481820370153,0.000728678143925116,0.2214053220084656,-0.20813975293156867,-0.04880509428067289,0.01635473463783789,0.08802255995774604,-0.1454970754153991,0.1907144899198585,0.010984807607166679,-0.13795362668490638,-0.12742199892210598,-0.3385938988450349,-0.10619356391378207,0.17489750230724666,-0.006977334772376638,-0.3795207658107687,-0.026818867728793463,-0.7976298479660255,0.0553551406873673,0.2758939701811811,-0.15086004452019505,-0.06677045338751035,0.010112453347516485,-0.16051907203074756,0.093126913140634,-0.1425740323239448,-0.058175065741827126,-0.10949883656944677,-0.10940121846086392,-0.0830766223754168,-0.2754196359789223,0.2984663667304653,0.05272662306434322,Classification,1
31,31,"marvel  tool  prediction  bacteriophage sequence  metagenomic bins
  present marvel  tool  prediction  doublestranded dna bacteriophage sequence  metagenomic bin marvel use  random forest machine learn approach  train  program   dataset   phage   bacterial genomes  test    dataset   bacterial   phage genomes  show  three simple genomic feature extract  contig sequence  sufficient  achieve  good performance  separate bacterial  phage sequence gene density strand shift  fraction  significant hit   viral protein database  compare  performance  marvel    virsorter  virfinder two popular program  predict viral sequence  result show   three program  comparable specificity  marvel achieve much better performance   recall sensitivity measure  mean  marvel   able  identify many  phage sequence  metagenomic bin  heretofore   possible   simple test  real data contain mostly bacterial sequence marvel classify     bin  phage genomes  evidence suggest      bin  novel phage sequences
training  test datasets  build  test marvel  refseq microbial dataset  download january    genomes belong   bacteria domain ncbi txid    dsdna viruses   caudovirales order ncbi txid  select    baseline dataset tail phages  select   step   representative group give   constitute  majority  viruses present   environmental sample ashelford    filée    ackermann   baseline dataset  split  two subsets accord   genbank record date  january   january   thereafter  timebased division  usually apply  classifiers  simulate  use   tool  newly isolate sequence roux    ren     refer    subset   train dataset    andlater subset   test dataset  train dataset   phage genomes   bacterial genomes    use  train  generate  model  prediction  phage bin  test dataset   bacterial genomes   phage genomes train  test datasets   overlap   available  marvel repository page1 train  test datasets   process  generate mock datasets  contigs  specific lengths   fragment length analyze   study       kbp complete genomes  randomly fragment   contigs   specify length  may  may   overlap next contigs belong    organism  cluster  form  simulate bin  process  perform   train  test set   result bin  use  train  machine learn algorithm  asses marvel performance   compare marvel  virsorter  virfinder feature extraction  classifier development  previous study  show genomic feature   dna kmer profile   content   strong signal  link  differentiate genome sequence  bacteria  viruses edwards    ren    however   know  phages try  mimic host genome sequence  order  overcome  defenses carbone  bahir     cause classifiers base  kmer frequencies   poor performance  term  overall accuracy  especially recall   word  one   classifiers identify  phage genome   almost always correct    likely  miss  majority  new phages present  environmental sample seek  robust feature  focus  efforts  characteristics relate  genome structure  protein translational mechanisms   organism  characteristics require  second layer  information  may  add  utilization  result  gene prediction program   prodigal hyatt     genemark besemer    therefore  evaluate phage  bacterial genomes accord  six   genomic feature extract   baseline dataset  refseq complete genomes  six feature  average gene length average space  genes density  genes frequency  strand shift  neighbor genes atg relative frequency  fraction  genes  significant hit   pvogs database grazziotin    average gene length  compute  add   length   predict cdss   genome    contigs   bin   divide   total number  predict cdss average space  calculate   mean length    regions  two cdss density  genes  calculate   total number  cdss divide  genome length measure  kbp frequency  strand shift  compute  add   number  strand shift  neighbor genes  divide   total number  cdss   genome atg relative frequency  compute  count  number  atg triplets  one   strand   contigs   bin    complete genome divide   total number  mers   sequence one strand finally  cds   genome  search use hmmscan eddy    pvogs database  viral hmm profile grazziotin    download  january   significant hit  note   evalue  less   equal    number  significant hit  divide   total number  cdss  generate  fraction  genes  significant hit   pvogs database  value base  predict cdss  extract  genbank file  available  download  january  exploratory step  predict  simulate fragment  prodigal hyatt     drive  prokka seemann  use python scikit learn libraries pedregosa     try different machine learn approach base   six feature list  specifically support vector machine svm logistic regression neural network  random forest classifiers  evaluate use  train set  well  kfold crossvalidation      result  random forest   best approach   target prediction similar find  suitability  random forest classifiers  bioinformatics  also  report boulesteix    zhang     relative weight   feature   give dataset  calculate   id3 implementation  random forest quinlan  feature  low gain  information  remove   final model  order  simplify feature extraction   final version   tool  follow feature  select   informative gene density strand shift  fraction  genes  significant hit  pvogs database see section “results”   extract  three informative feature   complete train set   kbp simulate bin   random forest classifier  train   marvel prediction core  random forest model  train   initial tree estimators  leaf prune  parameters  set   default value test  simulate metagenomic bin simulate bin contain different fragment lengths  generate  genomes   test set  previously describe  asses marvel performance  test correspond   specific fragment length  perform  five randomly sample replicate   bin  bacteria   dsdna phages bin  submit  marvel  predictions  evaluate  true positive rat specificity accuracy   score accord   follow standard formulae tprtptpfnspctntnfpacctptntpfptnfnf12tp2tpfpfn  tpr  true positive rate spc  specificity acc  accuracy   true positive count   false positive count   true negative count   false negative count test  real metagenomic data  compost sample  dataset  illumina raw read  compost sample generate   group antunes     use  test marvel performance  real metagenomic data five sample  extract   compost unit  whole community dna  extract  generate shotgun metagenomic read  dataset contain mostly bacterial sequence raw read   five sample  crossassembled  metaspades nurk    generate  set  contigs metabat2 kang     use  bin  parameters      parameters remain   default value result bin  evaluate regard quality   presence  bacterial  archaeal marker genes use checkm park    pipeline implementation marvel  cod  python   use prokka seemann   hmmscan eddy   important dependencies  input marvel require  directory  metagenomic bin  fasta format  generate  result directory contain bin predict  phages  auxiliary script  make available  generate bin  illumina pairedend read use standard tool  methods breitwieser    performance comparison  marvel virsorter  virfinder  contig   simulate bin  contigs  total  individually give  input  virsorter  virfinder   give tool  entire bin  consider    positive prediction  case  least one   contigs  predict  viral note    experimental setup    bin   bacterial  viral sequence  contig  consider viral  predict  categories     virsorter    qvalue  less   equal    virfinder test  perform  different fragment lengths    randomly sample replicate   bin  bacteria   dsdna phages average value  true positive rate specificity  accuracy  compare use  wilcoxon signedrank test   consider significant   pvalue  less   run time  measure   tool use two set  bin  bin average  kbp   bin average  kbp   standard desktop computer   bite intel core   ghz   cpus    ram ddr3 run linux distribution ubuntu ",-0.1747558502203252,0.21986412499476085,0.10391845773545576,0.04411399021714632,-0.018078422049498014,-0.029290214290295782,-0.05289741409936397,0.007336804099619913,-0.057722505921463725,0.123568888333213,0.036801954749678296,-0.018451226176388485,0.13996835583550524,-0.0947758557969763,0.16432613866463894,0.06363389654307483,0.06795884183045169,0.1882448891658101,0.007898001780665022,0.12821155733745448,-0.024601228073180662,-0.22336515825268694,0.06880161458787723,0.034242594636930274,-0.042109528956739264,-0.14021433315886395,0.1049390692574588,-0.10776452744792746,-0.07154130932659257,-0.022830574644767385,0.019346134226556545,0.25676972043561186,-0.13997120356426776,-0.02761839207272801,0.2350512356699776,0.0871120585486772,0.03639811933837499,0.04342831713251349,-0.04803162537288444,-0.12267316149833693,-0.08815255734930183,-0.12571032770428586,-0.09555943205288374,-0.10804887036756268,-0.1012158307776691,0.0038205878420279477,0.11709051465686213,-0.16923764372596473,-0.2148547217780309,-0.301628010144599,0.11845625357077826,0.01718267411220601,0.08086096613638573,0.5181643600964289,0.026656736731755344,-1.0635256630685084,-0.005194976999640729,-0.17013702648196838,0.9139237217814418,0.22630948530054185,-0.14657014664398504,0.3497532461051832,-0.04698889365534633,0.0748705046904992,0.5642895881731914,0.08091366935027593,0.030264480049255013,0.033379059456034595,0.21004007527347426,-0.13169780308674053,-0.04391175330140789,-0.001994629270761345,0.10952932655597727,-0.1162245703949422,0.13456622416916209,-0.004864427503662824,-0.12573270604877276,-0.132795711553636,-0.3555014186318262,-0.05688569039776139,0.16905262339494306,-0.03412522949479102,-0.40015638386464025,-0.004089303970858797,-0.8214498957545128,0.10120998641822533,0.226329216105971,-0.13772742876016386,-0.11644719440194845,-0.002870963094924061,-0.13847829119896327,0.09159633373655868,-0.07981449349482697,-0.05587250115784537,-0.08313213401960498,-0.10003825695268576,-0.0990563636741007,-0.3337010345201734,0.2903042561130163,0.08349792338636389,Classification,1
32,32,"scalable metagenomics alignment research tool smart  scalable rapid  complete search heuristic   classification  metagenomic sequence  complex sequence populations
next generation sequence technology  enable characterization  metagenomics  massively parallel genomic dna sequence  complexity  diversity  environmental sample    human gut microflora combine   sustain exponential growth  sequence capacity  lead   challenge  identify microbial organisms  dna sequence  seek  validate  scalable metagenomics alignment research tool smart  novel search heuristic  shotgun metagenomics sequence result  retrieve  genomic dna sequence   ncbi genbank     base pair     sequence     species  index use  base pair hashtable shards  mapreduce search strategy  use  distribute  search workload   compute cluster environment  addition  one base pair permutation algorithm  use  account  single nucleotide polymorphisms  sequence errors simulate datasets use  evaluate kraken  similar metagenomics classification tool  use  measure  compare precision  accuracy finally use   set  train sequence  compare kraken clark  smart within   compute environment utilize  computational nod  complete  classification   datasets    min  use exact match   average throughput      read classify per minute  permutation match  achieve sensitivity greater     precision greater     simulate datasets   species classification level  demonstrate  application   technique apply  conjunctival  gut microbiome metagenomics sequence result   head  head comparison smart  clark  similar accuracy gain  kraken   species classification level  smart require approximately half  amount  ram  clark smart   first scalable efficient  rapid metagenomics classification algorithm capable  match    species  sequence present   ncbi genbank  allow   single step classification  microorganisms  well  large plant mammalian  invertebrate genomes    metagenomic sample may   derived
computational infrastructure  university  washington provide  share highperformance compute cluster know  hyak currently  hyak   intel xeon process core   computational nod  node use  test computational scale contain  cpu core     memory construction  database  v209 release  ncbi genbank  download september    genbank accession  link use  ncbi taxonomy database   single species  class use parallelization across  core   mapreduce framework  genomic dna   virtually cut  every  basepairs   mer  link   correspond species  class  sort finally merge sort  use  combine   sort mers  classification  dataset   split  shards base   first four basepairs   30mer create   separate databases  could  deterministically search  databases  save   hashtable format  could  load  runtime  memory   search program description  search heuristic  total   search program  start asynchronously  parallel   program assign   basepair shard  part   map step  search program  iterate   list  sequence  fasta  fastq format  slide   basepair window   first  basepairs match  assign shard definition   execute program  remain  basepairs   use  execute  inmemory hashtable lookup fig   reverse complement  also check  every read  successful match   species genus  class  keep  record  addition  edit distance permutation algorithm  create  generate every possible one basepair substitution permutation   mer search  account  sequence errors  single nucleotide polymorphisms without account  insertions  deletions  result   program  sequentially reduce  create  final classification result match  perform   species level  multiple match  different organisms  collect   match  mammalian   read  classify  mammalian  highest vote match   species genus  class taxonomy level  calculate   read   final classification   highest classification   read   tie   read  label  ambiguous   give taxonomy level datasets test simulate datasets hiseq miseq  simba5  take   publicly available datasets   use  evaluate kraken    previous clinical trial  acute conjunctivitisepidemic keratoconjunctivitis  phase iibiii novabay clinicaltrialsgov nct01532336  total  patients  clinical sign  symptoms  epidemic keratoconjunctivitis  recruit worldwide institutional review board approval  obtain  goodwyn irb cincinnati  approval number cl1104 clinical research adhere   tenets   declaration  helsinki   conduct  accordance  health insurance portability  accountability act regulations write inform consent  obtain  participation   participants   study conjunctival sample   upperlower tarsal conjunctiva  fornix  collect use sterile dry swab copan diagnostics inc murrieta  genomic dna  isolate  conjunctival swab use qiagen blood  tissue dna kit qiagen inc venlo  netherlands  per protocol three sample  randomly select  whole genome sequence wgs one nanogram  genomic dna   sample  use  prepare libraries  wgs accord   manufacturers instruction use illumina nextera  sample prep kit illumina inc san diego   dna libraries  sequence use miseq system follow  manufacturers standard protocols illumina inc san diego  three conjunctival sample  use   clinical trial collect  patients   day  enrollment prior   initiation  either placebo   investigative drug  fastq file   sample   upload   ncbi sra archive srr3033169 srr3033245  srr3033274 flash  use  preprocess  pair end libraries  sickle  use  quality trim   addition data   human microbiome project   download   additional metagenomic dataset specifically three gut microbiome datasets srs019120 srs014468  srs015055  download   ncbi sequence read archive  sickle   apply prior  analysis   sample evaluation  accuracy  speed  allow  direct comparison  performance statistics   definition  sensitivity  precision  use  describe  wood    briefly sensitivity  define   number  correct classifications  read divide   total number   dataset precision  define   number  correct classifications divide   total number  read attempt   classify comparison  smart  kraken  clark  order  compare  accuracy  performance   three tool dna sequence file    bacterial viral  archaeal section  refseq  download  kraken clark  smart   sequence  use  build  database   tool respectively follow  documentation provide  simulate datasets   analyze   tool    computational node  cpu core     ram    hyak  multithreading enable   maximum number  cpus  kraken  database  preloaded  memory  maximal performance  suggest   creators  kraken  users  nfs filesystems  clark  standard mode    use  analyze  simulate file   program fail  start   modes due   ram limitation  order  calculate throughput  program  run sequentially three time   lowest execution time  utilize  calculate throughput",-0.14559308725307346,0.19735980733559697,0.0704184236699075,0.09472049770440208,0.02897544785868376,-0.01968617352376896,-0.0741432130159228,0.07741556208726251,-0.04267244029173525,0.12873428672202866,0.05669613660284085,-0.05567344881652389,0.12145797377568668,-0.09646962495346087,0.1157150655449368,0.021735614215649547,0.09348699935959302,0.2127078004860232,-0.04794905784307048,0.05867086501646554,-0.08025980131002143,-0.25261341209894456,0.06724813975975849,0.05873009786300828,-0.03715913437947165,-0.152426792315091,0.08719803807907738,-0.12098853659583254,-0.04612686947635666,-0.04796662262408063,-0.02837161658913829,0.2671120812185109,-0.16060842108230702,-0.024935618917224928,0.17948125791685016,0.01870277167327004,0.022316377672832455,-0.028498625860665924,-0.08938348749317811,-0.0940583704013261,-0.08360380484540655,-0.1359068392618792,-0.11562777949380687,-0.0844946212763898,-0.09883941427862736,0.01144690251967404,0.11809220574330538,-0.17962399940515753,-0.21286293749159085,-0.30968600395281104,0.15026085266290465,0.004850900554447435,0.01748591949653928,0.5084031888656318,0.0035286678932607172,-1.0298254203516992,0.024889386024588026,-0.22022832060873046,0.9886682736943476,0.1759982312512875,-0.1371190807462699,0.25636660860160193,-0.019368496388196942,0.036287862449971724,0.4832589029165683,0.07594471871998394,-0.0484617585875094,0.016832728374865838,0.2337547242158325,-0.16566409114879208,-0.047408271348176635,0.006551293556840392,0.07936778678777046,-0.12075498710852114,0.11752627439331265,0.012346485067391768,-0.15572287497576326,-0.14119097982358653,-0.3535336717963219,-0.09051168904290537,0.21516308244832544,-0.0006101719223079271,-0.34833780199114694,0.04034370440233033,-0.8316755011369241,0.1248681296860741,0.2828917215147521,-0.13840205126907676,-0.12274874229900888,0.056821851771128425,-0.13073424508504106,0.0812822188422433,-0.12052726127149073,-0.04257013386782546,-0.005441769741591998,-0.040971172099525575,-0.023305489304475485,-0.2985263251047581,0.3446956763206981,0.031693058704258883,Classification,1
33,33,"taxonomer  interactive metagenomics analysis portal  universal pathogen detection  host mrna expression profiling
highthroughput sequence enable unbiased profile  microbial communities universal pathogen detection  host response  infectious diseases however computation time  algorithmic inaccuracies  hinder adoption  present taxonomer  ultrafast webtool  comprehensive metagenomics data analysis  interactive result visualization taxonomer  unique  provide integrate nucleotide  proteinbased classification  simultaneous host messenger rna mrna transcript profile use realworld casestudies  show  taxonomer detect previously unrecognized infections  reveal antiviral host mrna expression profile  facilitate datasharing across geographic distance  outbreak settings taxonomer  publicly available   webbased user interface taxonomer enable rapid accurate  interactive analyse  metagenomics data  personal computers  mobile devices keywords metagenomics microbiome pathogen detection infectious disease diagnostics
binner module identify small number  pathogen sequence hide among vast number  host andor microbiotaderived sequence read   major algorithmic challenge  metagenomicsbased pathogen detection tool  standard approach   use digital subtraction  whereby  sequence read  first align   host genome sequence    approach use  surpi   example  subtraction read  host origin  remove additional subtraction step may  use  removal  nonrelevant microbial sequence include  know  represent reagent contamination     sequence adaptors  greatly reduce number  presumably relevant microbial sequence   classify  alignment  larger reference databases since   remain read  match  select reference sequence pathogens   miss entirely    homologous  sequence   subtraction database taxonomer overcome  inherent limitation  digital subtraction  mean   “binner” module fig   compare  read  every reference database  parallel assign   broad nonexclusive taxonomic categories taxonomers binner database  create  count unique   kmers  different taxonomicgene datasets use kanalyze  version   taxonomicgene dataset represent  “bin”   query sequence   place base   kmer content  database  assign  unique bite flag  allow kmers  belong  one   bin   recognize  count  database bin  flag  show  additional file  table   kmer count  merge   binary file  contain  kmers   database flag  binary file share  similar organization   classification databases   organize  optimize query speed read   assign   taxonomic group    kmers  share tie  resolve  show  additional file  table   result summarize  visualization additional file  table  high bin accuracy  possible    minimal intersections    kmer content  comprehensive human  microbial reference databases additional file  figure s1a   optimal kmer count cutoffs  determine  youdens index   score      range   additional file  table s10 default     eliminate bin  read contain adapter sequence  default  binner ignore kmers present  illumina truseq adapters  database  external rna control consortium ercc control sequence allow quantification  ercc spikein control  demonstrate  advantage  taxonomers nongreedy bin algorithm  compare highlevel taxonomic assignments make  surpi  employ greedy digital subtraction use sequence alignments  snap     taxonomers alignmentfree binner additional file  figure   highlevel taxonomic assignments agree     rnaseq read taxonomer assign    read  ambiguous origin   match equally  multiple databases      classify  human  surpi   mostly due  highly conserve ribosomal  mitochondrial sequence data  show  similar effect  also apparent  fungal sequence   classify  human  surpi taxonomers binner  also able  capture  phageviral sequence    alignmentbased method   result  fewer unclassified sequence read      consistent  lower abundance  rrna  mtrna sequence  dna sequence data taxonomer  many fewer ambiguous assignments        classify  human     viral  surpi overall agreement   classifier module classification  taxonomer  base  exact kmer match taxonomer use databases   optimize  rapid kmer query  store every reference    kmer  find  well   associate kmer weight  every reference  fundamental question  classification   likely     particular kmer  originate   reference sequence refi  answer  question taxonomer calculate  kmer weight 𝐾𝑊𝑟𝑒𝑓𝑖𝐾𝑖𝐶𝑟𝑒𝑓𝐾𝑖𝐶𝑑𝑏𝐾𝑖𝐶𝑑𝑏𝐾𝑖𝑇𝑜𝑡𝑎𝑙𝑘𝑚𝑒𝑟𝑐𝑜𝑢𝑛𝑡   represent  function  return  count   crefki indicate  count      particular reference cdbki indicate  count     database  weight provide  relative database specific measure   likely     kmer originate   particular reference  order  classify  query sequence  calculate  sum   kmer weight  every reference    match kmer   query sequence suppose     possible kmers  query sequence    every reference refi  share  kmer    total kmer weight  refi  𝑇𝐾𝑊𝑟𝑒𝑓𝑖𝛴𝑁𝑗1𝐾𝑊𝑟𝑒𝑓𝑖𝐾𝑗  read  assign   reference    maximum total kmer weight   case   tie  query sequence  assign   taxonomic lowest common ancestor lca  protonomer module  develop  map scheme  amino acids   correspond codons  facilitate map  protein space  use   strategies  speed  develop  classification  nucleotide space   amino acid database  build  classification taxonomer assign every amino acid   one codon  unique map   term  nondegenerate translation  use  generate  artificial dna sequence  correspond   protein sequence   database  dna sequence  enter  taxonomers nucleotide classification databases query read  translate   six read frame use   nondegenerate translation scheme use  build  database   translate frame   classify kmer weight  read classification assignment  perform  describe   default protonomer database  subsets  uniref90  uniref50 see “databases”  detail empirically  find  kmer size    amino acids  perform best  choose  classify viruses  protein space    high mutation rat genetic variability  incomplete reference databases  figure  present benchmark data  protonomer  two  rapid protein search tool rapsearch2  employ  surpi  diamond   ultrafast blastlike protein search tool use rnaseq data  respiratory sample   children  document viral infections  determine   fdacleared molecular test esensor respiratory virus panel genmark  target pcr  additional file  table s11   complete viral genomes could  manually construct geneious version  viral read  define  map  read bin  “viral”  “unknown”   manually construct viral genomes sensitivity  specificity  determine base  detection  know viral read true positives  nonviral read true negative protonomer provide  single taxonomic identifier per read   classification assignment  make interpretation  result extremely simple neither rapsearch2  diamond classify  read instead   provide blastlike alignment information  benchmarking  rapsearch2  diamond  lca   alignment   lowest evalue  assign   classification  tool  benchmarked use  viral subset  uniref90   database  protonomer  rapsearch2 process pair read  concatenate  together   “”  mate pair diamond   support pairedend read   pair  search separately   hit   lowest evalue   read  use  make  classification assignments afterburner  increase recovery  distantly homologous viral proteins taxonomer offer two options first unclassified read    analyze use  afterburner module  degenerate kmer match engine  employ  collapse aminoacid alphabet additional file  figure s14   manner similar   employ  diamond   use kmeans cluster   blosum62 matrix  generate  compress amino acid alphabet  use  collapse amino acid alphabet   able  achieve higher sensitivity  classification  sequence    diverge   expense   higher false positive rate  compare  protonomer additional file  figure s14 importantly taxonomer   restrict  short read allow reanalysis  result contigs  still greater classification sensitivity figs    host gene expression estimations taxonomer also use  nucleotide classifier  assign read  host reference transcripts  default   transcripts  correspond gene model gtf file   ensmbl human reference sequence grch37 empirically  find   kmer size   work best  map read  human transcripts  benchmarked taxonomers gene expression estimate  sailfishs   cufflinks  use  biological  synthetic data  generate  benchmark data show  fig   run taxonomer   standalone fashion   taxonomer output  tie  transcripts   classification step   randomly assign  read   single transcript  use  transcript level assignments  calculate gene level expression  next employ  linear regression  correct  transcript assignment bias   similar fashion  sailfish  report correlations   calculate use  correct value  level  gene expression analysis   currently available   web interface    way data  stream however  result give   web interface    good approximation spearman correlation    set  genes   methods  positives count  spearman correlation    gene set  unrestricted   first experiment  employ qpcr result take   microarray quality control study maqc  specifically human brain tissue sample additional file  table s12  also compare performance use synthetic rnaseq read        generate   flux simulator tool  see additional file  table s13  parameters tophat   use  produce alignments  cufflinks like taxonomer sailfish   need external alignment information databases  classifier  protonomer databases  modular  easily construct consist   multifasta file   “parent tag”   definition line  tag describe  reference sequence immediate phylogenetic parenttaxon bacterial classification  base   marker gene approach  rrna gene   greengenes database reference set  operational taxonomic units otu cluster    version 13_8   additional file  table   reference set contain  otu cluster   reference sequence  taxonomic lineage   otu  use  create  hierarchical taxonomy map  represent otu relationships  support  otu “species” concept  taxonomy  complete  rank   taxonomic lineage    value unique dummy species name   highest taxonomic rank available  use  fill empty value versions   greengenes database  format  use within blast  rdp classifier  kraken fungal classification  also base   marker gene approach internal transcribe spacer  rrna sequence   unite database  version sh_taxonomy_qiime_ver6_dynamic_s_09 additional file  table   reference set contain  taxa species hypothesis  generate   reference sequence   defaultclustering threshold     expert taxonomic curation dummy name  create  rank    value versions   unite database  format  use  blast  rdp classifier  kraken viral classification  discovery  virus classification database consist   viral subset  uniref90  release 2014_06 combine   bacterial subset  uniref50 release 2015_03  viral protein database  reduce   viral sequence base  ncbi taxonomy phage sequence  separate leave  total   reference   viruses ncbi taxonomy  use  determine  sequence relationship  viral classification  discovery benchmarks show  fig 3ac   contiglevel classification   viral subset  uniref90  use additional classification databases  test purpose additional bacterial classification databases  construct  refseq identical  krakens full database    total reference    bacterial reference use ncbi taxonomy   complete ribosomal database project databases download   september     reference use rdp taxonomy database construction databases  construct  maximize query speed kmers  store  lexicographical order  kmer minimizers  use  point  block  kmers   database   block  kmers  isolate  binary search  use  complete  query  scheme provide extraordinary query speed  demonstrate  wood  salzberg   employ   basic database layout  kraken   important difference  instead  store   lca   kmer  also store  kmer count  every reference    adjustable cutoff  associate kmer weight detail information   database format  layout  available upon request gene classification protocols  extract reference sequence  widely use curated public databases  benchmark experiment   reference sequence  use  generate synthetic read datasets   variety  readlengths  error rat use wgsim  pcramplified  rrna gene sequence  two metagenomics study  stool    home environment   also use  analysis  limit  taxa  relative abundance   per sample  random sample  select   study bacterial  rrna   silva  nonredundant smallsubunit ribosomal sequence reference database   extract bacterial reference sequence       length  exclude reference annotate  cyanobacteria mitochondria  chloroplasts  high quality reference without ambiguous base alignment quality value    sequence quality    include    value  report  silva percent identity   closest greengenes otu  determine  megablast  use hit   query coverage   synthetic read   singleend   pairedend  pairedend  generate   reference sequence   coverage fungal   test  accuracy  identify fungal  sequence    represent   unite database   utilize  unite_public_dataset version_15 percent identity   closest unite species hypothesis  otus cluster     determine  megablast use hit   query coverage   synthetic read   singleend  generate   reference sequence   coverage due   variable length   sequence mean   range      pairedend sequence   generate classification criteria  reference methods blast default megablast parameters  use top score reference  identify  use  assign otusshs multiple otusshs  assign  synthetic read    one otush reference share   identity   otush    identity   read   otus within     top hit  assign   read  taxonomy   assign otusshs  compare   highest rank  common  use  assign  taxonomic value   read  percent identity  use  determine  assignment   highest taxonomic rank sequence read    identity   reference  assign  species   identity  genus     family  lineage information  available   rank rdp classifier rdp classifier analyse  perform   local server see  classifications  resolve   rank   minimum confidence level  ≥ kraken kraken analyse  perform   local server see  kraken report  taxon identifier   read final taxonomic assignment  accessory script krakenfilter   use  apply confidence score although  find  value  little impact  result   benchmarks  effect  apply different confidence score  show  additional file  figure  surpi surpi analyse  perform use  amazon ec2 instance   publish amazon machine image surpi report  best hit   map tool snap  rapsearch2   use  comparison taxonomer implementation taxonomer  write    python bind  cython  implementation  taxonomer  contain  entire pipeline functionality  write    drive  iobio web interface server specifications benchmarking  perform   machine  red hat linux    ram   cpus number  cpus  restrict   unless otherwise note webservice  visualization taxonomer  publically available   webservice build upon  iobio framework    available  taxonomeriobioio complex metagenomic data   process quickly  effectively interpret  webbased visualizations figure  illustrate  interface  read   stream   analysis server  pie chart  present summarize  result   bin procedure  one   bacterial fungal viral  phage bin   pie chart  select  result   classifierprotonomer modules  display   sunburst visualization additional information  provide   top   web page   many read  sample  number  read classify   detection threshold  detection threshold inform  user   abundant  particular organism must   order   detect   number  read sample  provide  indicator   sensitivity  detection   sample  addition  slider allow  user  select  absolute cutoff   minimum number  read require  order   display   sunburst dna  rnaseq  patient sample nucleic acid extraction sample    extract use  qiaamp viral rna extraction kit qiagen extraction  carry   describe   manufacturer   exception   aw1 wash step   step    aw1 wash buffer  add   qiaamp mini column  centrifugation   rpm     dnase  mix qiagen contain    rnasefree dnase      buffer rdd  add   column   column dnase digestion  incubation  room temperature   min  additional    aw1  add   column  centrifugation   rpm  manufacturers suggest protocol  continue   point  column wash use buffer aw2   wash step rna  elute     water extraction  total dna  perform use    sample   dneasy blood  tissue kit qiagen accord   manufacturers instructions dna  elute     nucleasefree water depletion  human dna microbial dna  enrich  nebnext microbiome dna enrichment kit neb briefly mbd2fcbound magnetic bead  prepare  combine    mbd2fc protein     protein  magnetic bead per sample  place  mixture   rotate mixer   min  room temperature  wash   bind buffer extract dna       add     bind buffer  result    add  mbd2fcbound magnetic bead   min  room temperature  rotation  enrich microbial dna  cleanedup  agencourt ampure  bead beckman coulter library generation  hiseq  miseq sequence index cdna libraries  produce  extract rna use  truseq rna sample prep kit  illumina omit polya selection rna  dry  resuspend     elute prime fragment mix  remainder   library preparation  conduct per manufacturers instructions  library generation  dna enrich microbial dna  fragment   covaris  ultrasonicator use intensity  duty cycle     cyclesburst       ° libraries generate  fragment enrich microbial dna  prepare use  kapa hyper prep kit kapa biosystems accord   manufacturers instructions pcr cycle use  library amplification  dependent upon  amount  input dna   cycle  use   experiment libraries  quantitated  qpcr use  kapa sybr fast abi prism qpcr kit kapa biosciences   apply biosystems 7900ht fast realtime pcr system apply biosciences library size  determine   agilent high sensitivity dna kit  agilent  bioanalyzer  pool  index sequence libraries  second qpcr  bioanalyzer run  perform  estimate  final concentration  sequence  ion proton sequence index cdna libraries  produce  extract rna use  smarter universal low input rna kit clontech  number  pcr cycle   range   base  rna yield sequence pool sequence libraries  analyze   hiseq      miseq      illumina  ion proton median read length   life technologies instrument accord  manufacturers protocols statistical analyse  gene expression analyse  report   pearson  spearman correlations      correlation coefficients  calculate use  scipy library  python  pearson correlation   log transform gene expression estimate necessitate  removal   genes whose estimate expression    log transform prevent outliers  dominate  correlation  also report  spearman correlation    log transform    necessary since    correlation base  rank thus  exclusion  genes  estimate     avoid",-0.16108885585446697,0.17110071573376964,0.0994387263411108,0.09322474391858623,-0.010493043569402907,-0.01942703570358291,-0.05565638705631502,0.020924825192445047,-0.014829439284752997,0.12970157877527294,0.01827100002316596,-0.039808428623405716,0.1426246261564637,-0.08861253156057848,0.15605362241773446,0.04341746478854515,0.04865498810368892,0.16260990032313774,0.030151092844630877,0.03799895043695239,-0.07191073396686642,-0.22649729107827815,0.06234226324540075,0.02468966944165919,0.0057396561891563756,-0.12023346381368835,0.09051011452207287,-0.0872051757046076,-0.07040096964930599,-0.02647365553763178,0.010537685420104305,0.2305139450192402,-0.17190995469218304,-0.0430664716088594,0.21373981599994052,0.07323559380070475,0.053849111456146,0.018875494593159115,-0.048214300068607614,-0.1088340297512878,-0.06252646202509211,-0.09515252237393187,-0.10427178151916056,-0.09970990909457944,-0.11307376490782785,0.01087712903217135,0.08695931706247909,-0.08467014080448808,-0.21582372803059072,-0.267294572104253,0.1405955283586743,0.04322370122164381,0.05391572912896543,0.4840568360788418,0.022382942716743442,-0.9139317649073208,0.01682557981624467,-0.18481330182792802,0.8333512983200742,0.16151769945803934,-0.11193497720054664,0.2649392517964709,-0.02158730611633236,0.06311738377734644,0.5284277625451312,0.052826917412546116,0.029575033619674663,-0.03999056725632381,0.21297764803438707,-0.18641986886813489,-0.06466948095377201,-0.021126120104281044,0.14181626667619313,-0.10528675183711826,0.14368800418090386,-0.016989860116510245,-0.09615732920944567,-0.1528395225796553,-0.3257154214141324,-0.06524702529118752,0.15226199897073672,-0.026710222302277896,-0.3317966002522152,-0.0004847646546345409,-0.7284221457475535,0.10651086811500776,0.24584798504004565,-0.11498428182996255,-0.11972126233268085,-0.02344068240526633,-0.1684028867533219,0.10123273728344867,-0.06521815914743206,-0.06246205316262345,-0.022487784896995586,-0.08027091445062655,-0.07094688213197442,-0.32785027350102336,0.26730073945972355,0.07144213340461814,Classification,1
34,34,"rnacode  noncoding rna classification tool  short read  ngs data lack reference genomes
 number  transcriptomic sequence project  various nonmodel organisms  still accumulate rapidly  noncoding rnas ncrnas  highly abundant  live organism  play important roles  many biological process identify fragmentary members  ncrnas  small rnaseq data   important step  postngs analysis however  stateoftheart ncrna search tool   optimize  nextgeneration sequence ngs data especially   short read   work  propose  implement  comprehensive ncrna classification tool rnacode   short read rnacode  specifically design  ncrna identification  ngs data  lack quality reference genomes give  set  short read  tool classify  read  different type  ncrna families  classification result   use  quantify  expression level  different type  ncrnas  rnaseq data  ncrna composition profile  metagenomic data respectively  experimental result  apply rnacode  rnaseq  arabidopsis   metagenomic data set sample  human gut demonstrate  rnacode compete favorably   sensitivity  specificity   tools
 propose  method  combine homology search  familyspecific  novo assembly  identify read sequence  ncrnas  particular  homology search  apply    short read  contigs produce  assembly program  method  design base  two key observations first read sequence  ncrnas tend  share higher sequence  structural similarity    native families  read sequence   families thus higher alignment score  ncrna homology search tool  expect  particular homology search  vital  identify ncrnas    cleavage  degradation read sequence  mirnas  hard  assemble   read correspond  mature mirnas   largely capture  rnaseq data none      map   regions   premirna due  fast degradation figure  show  map result  read sequence  premirnas obtain  arabidopsis  contig   short contigs   produce base   typical read map pattern  addition  read map pattern   change  increase  expression level  show   three mirnas  figure    type  ncrnas apply homology search  short read directly  indispensable  homology search  important apply   short  fragmentary read may introduce high false positive rate  detect remote ncrna homologs data   show  methods section thus rnacode employ  second observation  true ncrna read sequence    gene   assemble  contigs  significantly high alignment score   native families   contrary read align  chance   likely   assemble   tend  share poor overlap  properties  important  boost sensitivity  accuracy  short read classification rnacode consist  three key stag first rnacode coarsely classify read  different ncrna families use  secondary structure  sequence similarity   familyspecific sequence assembly  use  assemble align read  contigs   number  read   coarsely classify   first step indicate  expression level  abundance  ncrna genes   family  step choose  novo assembly parameters   kmer size  overlap threshold accordingly  produce contigs  generally longer  input read  thus   classify  ncrna families  better sensitivity  accuracy   last step  mirnas  cannot  assemble  contigs  use  biogenesisbased property  homology search result  classification  threestage workflow  choose tool   stage  illustrate  figure    highlight  rationale behind  design   three stag  first stage aim  classify  large number  input read  different ncrna families  high sensitivity  employ exist homology search tool  short  fragmentary read  stage  incur high  rate thus downstream analysis  need  remove  falsely classify read   second stage  novo sequence assembly tool  employ  assembly classify read  contigs  familyspecific sequence assembly  expect  produce contigs correspond  complete  partial ncrna genes however    extremely uneven  low transcriptional level  many type  ncrnas  low abundance  small overlap cutoff  kmer  need  ensure appropriate connectivity   families   result  contigs  chimeric  simply consist  randomly align read  third stage  use  remove  false positives  contigs  align  ncrna families  ones  score  lengths  give cutoffs  keep  mirnas  cannot form contigs  use stringent homology search score  know biogenesisrelated properties  classification criteria every stage   describe  great detail  stage  scfgbased filtration  maximize classification sensitivity short read  align   scfg model build   rna family  interest  scfg describe   primary sequence   rna family  also  secondary structure form  base pair interaction  stateoftheart implementation  scfg model  covariance model   software suite infernal  build     family  rna sequence  search  homologs use insideoutside algorithms    infernal  implement   treelike structure    node model  single base   base pair infernal  able  optimally align  sequence   tree   highest possible score short read however pose challenge   search algorithms    fragmentary sequence   nucleotides expect  form base pair could  miss due  miss base base pair  could   align   basepair node   parse tree   alignable     result read sequence   family may   well align   underlie  truncatedcyk trcyk    specialize tool design  fragmentary sequence search  perform local rna alignment     interest recover base pair   possibly miss  would otherwise  base pair  every alignment  score  provide  trcyk indicate  goodness  alignment homologous read tend  yield higher score  longer alignments  random read   report  performance comparison  two homology search tool    apply  short  fragmentary read one   mostly commonly use homology search tool blast   rely  sequence similarity   second tool  trcyk   goal   compare  performance  trcyk  blast  classify ncrna read  different lengths thus  read length      sample  true read  trna sequence obtain  rfam another  random read generate   rna families  mix  true trna read seed sequence  rfam  exclude   test data covariance model use  trcyk  format database use  blast   build  seed sequence  trna   search  trna read   mix read use trcyk  blast  performance   tool  visualize   roc curve  figure   figure demonstrate  trcyk  better performance  blast however  tool  high  rat show  need   screen like  alignment program  score cutoff  need  distinguish homologous sequence  others  set two cutoffs     alignment score  alignment length respectively    determine  strength  filtration  low cutoff  lead   overwhelm number  negative read  could significantly slow   next two stag  high cutoff however  exclude remote homologous read  poor conservation   analysis  trcyk   provide  thresholds  consider two strategies  determine  cutoffs first  expect alignment score   homologous sequence  length    use   cutoff  order  ensure high sensitivity  actual cutoff   smaller   expect score second montecarlo method   use  evaluate  sensitivity   rate   score cutoff use  large number  sequence   generate   ncrnas  nonncrnas   work  use  second strategy figure  show    short homologous read  poor alignment score   first stage define  upperbound   classification sensitivity  choose  loose cutoff     guarantee   positive read  pass  filtration stage  find   threshold also apply  read sequence   type  ncrnas   increase  read length  score threshold need   improve  well   first stage  design  achieve high sensitivity  default cutoff  set     increase  sensitivity  filtration  also accept read  alignment score  greater     alignment length § base stage  familyspecific  novo assembly  read   coarsely classify   family   first stage    input   novo assembly tool compare  conduct  novo assembly    read  input size  assembly tool  significantly reduce thus even memory intensive assembly tool   apply multiple  novo assembly tool exist depend   data properties   read length  sequence error rat sensible choices   make   work   novo assembly program  apply  rnaseq data  nonmodel organisms  metagenomic data thus specific properties   two data   consider  choose assembly tool unlike genome assembly highly diverse sequence coverage  expect   data set  rnaseq data heterogeneous expression level  ncrnas contribute  highly diverse sequence coverage  metagenomic data different abundance  ncrna genes lead  different sequence coverage choose one set  parameters   overlap threshold  overlap graph  kmer size   bruijn graph   whole data set   likely  produce optimal result  downstream ncrna analysis thus  first requirement   choose assembly program   users  adjust  parameters accord   output   filtration stage specifically although  first stage  coarsely classify read  gene families    use  estimate  expression level  abundance  genes   family  families  large number  read classify rnacode assume high sequence coverage  thus use stringent assembly parameters    hand  families  fewer number  classify read small overlap cutoffs   overlap graphbased assembly tool  small kmers   bruijn graph   use  ensure connectivity  lowly transcribe regions  low abundance genes second many assembly program remove kmers  low coverage   may contain sequence errors  order  assembly ncrnas  low expression  abundance  use  assembly tool   keep readskmers  low coverage   work   short read read length v50   apply  compare several assembly program   choose ssake    deliver better assembly performance   experimental data ssake   specialize  novo assembly tool  unpaired short read assembly    graphbased greedy assembler  efficiently assemble millions  short read follow nearlinear time complexity   assembly process   end   contig  extend   suffix overlap   prefix  another read ssake generate contigs progressively  search  prefix store   hash table   longest possible prefixsuffix match whose overlap    threshold  modify  cod  ssake  make  accept  overlap cutoff  follow standard notation  assembly algorithms  use   represent either  kmer size   bruijn graph   overlap threshold   overlap graph  assembly  length  overlap threshold    important parameter  ssake  higher  usually result  fewer   accurate contigs  lower  lead  higher contiguity  incorrect extension may happen   probability   random prefixsuffix match  high   novo assembly    exist optimal overlap threshold although  expression  abundance   know  prior  estimate  use  number  classify read   first stage  choose  accordingly  addition   observe  use  singlek  lead  suboptimal performance   novo assemblers   second stage  range    choose  use  short read assembly     read  use  assembly  contigs  different assemblies  subsequently pool together   analysis stage  contig selection  randomly align read  stage    remove  stage      part   contig however due   loose overlap cutoff  small kmers  read  still  assemble  contigs  thus produce  stage    three type  contigs  reference   ncrna gene family  positive contigs   assemble  read originate   family  negative contigs   assemble  false read    part   underlie gene family   chimeric contigs   form   true  false read negative  chimeric contigs   form due  small overlap  allow   multiplek assembly  probability   contig  extend   negative read due   random prefixsuffix match  high   small overlap cutoff sketch   three type  contigs  present  figure   distinguish positive contigs  negative ones  align contigs   underlie   choose  use trcyk   follow reason   sequence  structural information   contig   utilize  many contigs may   complete rna genes especially   gene transcription level  low thus  need  consider miss base  align contigs   underlie   trcyk  apply   contigs  stage    exist contigs  alignment score greater   predetermine cutoff  gene  interest  consider   transcribe  trcyk   local alignment tool   common   part   contig  align   underlie  thus  read  assemble  align part  classify   rna family  feature could   effective  multiple correct segment exist   chimeric contig although    observe  case   experiment bad segment interleave  correct ones could potentially  remove mirna families normally  classify read need  pass   entire pipeline   mirna families   contigs might  form  use two criteria  read classification first  alignment score  length   trcyk alignments   first stage must pass  predetermine threshold second   read  align   mirna* region  examine whether   form  stem  read align   mature mirna region    read align  mirna* region   remove   result many read  cannot form  contig   still classify  mirnas base    homology search result   first stage",-0.2043362580749027,0.19614836696731391,0.12844889438886864,0.14875797479256214,-0.05453008635814234,-0.045941319786665054,-0.13092939388027086,0.060850139457613514,-0.04673030054261223,0.11534774028373584,-0.03942023170885158,-0.019069399233054254,0.1769551722816261,-0.1001924705417984,0.1298263022949888,-0.023055151604857795,0.03281362440435315,0.2013781756436421,-0.028149085088372962,0.1192604923972082,-0.027023523563652167,-0.2273724118623836,0.07054571836554467,-0.02373120807503346,-0.028596456156583964,-0.19390914521534885,0.03682040789031557,-0.16499878763366346,-0.05580471771487259,-0.04641005905278056,-0.0035898714654905585,0.2775080242810077,-0.1552497336854634,-0.0915680599801577,0.2360196442674524,0.07605576879033432,0.05881169864462357,-0.0006135663649347486,-0.10206411856108696,-0.11024376352013238,-0.09652627326381287,-0.15450456945288718,-0.09255920076115713,-0.1063811554832009,-0.11277949596801573,-0.02532734752161976,0.13823920164360096,-0.1121246604307089,-0.2627958379412731,-0.4189205929454017,0.11892559911573942,0.005468831102145045,0.05349734620754587,0.6259926705635294,0.04630150433979501,-1.1796290766088962,0.04097681657816344,-0.2279007993449529,1.003247348546329,0.18950690424941116,-0.1944460613866366,0.3794459664835837,-0.06019730475787637,0.0551419373468377,0.6320385797129686,0.05362630347340535,0.049289085445683695,0.006277356864743386,0.22867985390700216,-0.24364745533948026,-0.05450092634397719,-0.07797980011402765,0.12124765812680408,-0.13791000561383493,0.21402754379412184,-0.052612050940651536,-0.15951637278645586,-0.14959160115965944,-0.37070361652940176,-0.07262664301385417,0.23923270388136444,0.009372511863112812,-0.4241827891665703,-0.05593686654155336,-0.945737928291682,0.05576600455686559,0.20422354431669693,-0.12227076250612252,-0.15292968446775884,-0.044813876367036515,-0.2039338833595993,0.05761445356680089,-0.10373736687712128,-0.1049905028345378,-0.1585848928473031,-0.05799348382440545,-0.13820623901261428,-0.3587318346598811,0.3184648103393651,0.1065120118021566,Classification,1
35,35," novel data structure  support ultrafast taxonomic classification  metagenomic sequence  kmer signatures
metagenomic read classification   critical step   identification  quantification  microbial species sample  highthroughput sequence although many algorithms   develop  date  suffer significant memory andor computational cost due   grow popularity  metagenomic data   basic science  clinical applications  well   increase volume  data  generate efficient  accurate algorithms   high demand  introduce metaothello  probabilistic hash classifier  metagenomic sequence read  algorithm employ  novel data structure call lothello  support efficient query   taxon use  kmer signatures metaothello   orderofmagnitude faster   current stateoftheart algorithms kraken  clark  require  onethird   ram  comparison  kaiju  metagenomic classification tool use protein sequence instead  genomic sequence metaothello  three time faster  exhibit  higher classification sensitivity  report comparative analyse   scalability  accuracy use  number  simulate  empirical datasets
 kmer taxon signatures  kmer   length  subsequence  genomic sequence   sequence  length   exist  maximum       possible kmers metagenomic reference material consist  one   complete reference genomes belong   organism increasingly sophisticate sequence techniques  permit discovery  distinct reference genomes   single species  organism thereby capture genomic variations   often important   functionality   microbial species  number  genomes whether draft  complete available  metagenomic reference material increase   new discovery   consider  dataset   collection  kmers  give taxon   describe   set  kmers present   reference sequence belong   taxonomic subtree  problem  classify  metagenomic read thus simplify   identification   taxon  best match  set  kmers associate   target read    sufficiently large  kp20  majority  kmers  unique   species carry   speciesspecific kmers may serve  signatures directly implicate  appropriate taxonomic classification however  significant proportion  kmers  present  multiple species make  unique   higherranking taxa   paper  formalize  taxonomic specificity   kmer   signature   taxon  kmer  consider    signature   taxon    kmer   appear   genomic reference belong  ancestors  siblings   target taxon    sequence belong   taxons subtree    kmer    signature   lowerranked taxon   subtree equivalently  taxon evince  kmer signature   lowest common ancestor lca   species   taxonomy whose reference genomes contain  kmer ames          way  illustrate  figure   set   kmers present   genomic reference   taxonomy   divide  disjoint collections    contain  set  signature kmers belong   single node   taxonomy tree formally let    set   kmers present  genomic reference annotate   taxonomy  let       jtjg   taxa nod present   taxonomy     divide  jtj disjoint set   fs0         jtj1     node     correspond   set  kmer signatures belong  taxon  thus  exist  map             kmer      signature   taxon     kmer classification  lothello  core data structure  metaothello  call lothello lothello  essentially  hash classifier first design  fastforwarding information base query       capable  classify  key   appropriate member   large collection  categories  high efficiency  memory  speed   particular application lothello support  map   kmer signature   correspond taxon  xliu    overview   lothello data structure lothello maintain  query function   give kmer   taxon                universal set  kmers             determine   total number  taxa      log2jtje  algorithm satisfy  follow properties  lothello  always able  retrieve  correct taxon  correspond   valid kmer signature                   taxon     specific   provide  alien kmer   kmer    appear   reference sequence lothello  able  recognize  alien  high success rate  may carry  slight risk  assign    random taxon   taxonomy figure  show  example lothello structure  lothello data structure work  maintain  pair  hash function hha hbi  two array  lbit integers                               integer value determine  lothello construction  relationships among  elements       view   bipartite graph          nod     correspond  elements     respectively  query  kmer    graph yield  node index   hað      node index   hbð     classification  kmer   determine   value              via   bitwise xor operation                 bitwise xor operation  integers   follow property   lbit integer             lothello  properly construct       kmer specific  taxon       success  lothello rely  assign bitmap value   side   bipartite graph   operation  two nod  directly generate  class membership set  bitmap  two nod   initial value  fairly simple    achieve  multiple ways  example      assume  membership   key     assign  bite value   two nod     either  i½¼         i½¼      however   value  one node  already  determine  another key    remain value  alter  example      already set   give                  worstcase scenario           already  determine   involvement   key  situation create  cycle   graph  edge     add possibly result   conflict  fail assignment   bite value   conflict arise   two options remove  kmer  select  different hash function theorem  show    randomly select pair  hash function hha hbi  probability    cyclic  extremely low   experiment fewer   kmers among  billion  remove due  conflict additionally  multiple kmers manifest  one read lose one kmer   significantly affect  accuracy   algorithm   may omit kmers whose inclusion would cause  conflict theorem  suppose    randomly select   family  random hash function                          give  set  kmers       s2l  let   jsj construct  bipartite graph           edge            kmer      hað     hbð    let    number  cycle     converge   poisson distribution  parameter               nffiffiffiffiffiffiffiffiffi mamb    proof  theorem    find  supplementary section   recommend  value      follow let      fig  illustration  metaothello algorithm   example  taxonomy  reference sequence   leaf nod mers   signatures   taxon  highlight  bold font  different shade   twostep approach  read classification fig   example  lothello     classify    kmers leave bipartite graph   correspond bitmaps     edge   represent  kmer hash function    map  kmer   correspond locations     right query   return sðsþ¼ð001þ2   metaothello   power       smallest value          smallest value        result                 practice   always expect  number  cycle   lothello   less    probability   smaller    probability higher    time  space complexity  lothello construction  query construction complexity  construction   lothello data structure generally follow  depthfirst traversal   bipartite graph thus  complexity       total number  kmers  memory complexity  oln     number  bits  encode  number  categories    reduce  memory cost  divide  set  kmers  smaller group base  prefix commonly  length  correspond     group  group contain approximately   kmers   group  build  lothello use time       memory cost       total construct  lothello structure still take  time query complexity   query    lothello compute two hash value hað   hbð    access two memory locations    hað          time complexity    procedure  include   basic arithmetic operations result   extremely fast execution speed   alien kmers  alien kmer  define   kmer    include   construction   lothello   context  taxonomic classification    kmers    include     reference materials alien kmers often arise due  noise  genomic sequence belong   novel species sample   sequence read   design two strategies  detect alien kmers first  would like  increase  randomness  assignments   case  alien kmers secondly  may add another bite   bitmap  let   log djtje double  number  categories    alien kmer   much higher chance   assign  alien categories  categories  use  exist taxon label   show   may leverage  randomness  alien assignment  predict  alien kmer within  lothello   first discuss  query result        extend   lothello     othello classify kmers             element       bite value   query   alien kmer    lothello still return  value    þ2f0   alien key                     let      fraction       bitmaps  respectively    jftja  ¼0gj     jftja  ¼1gj   similarly      fraction   suppose     uniformly distribute random hash function     arbitrary kmer   universal set      return   probability   a0b1  a1b0 similarly     return   probability   a0b0  a1b1  lothello  similar property also hold let    probability   query   alien kmer return exactly       indicate                 note      uniform random hash function    correlate hence                   x¼0 axbx       fraction  elements  value          fraction  elements  value      give  particular lothello   always compute  value            use time         value  affect   occurrence frequency   lbit integer namely              case  value   uniformly distribute  may result  imbalance among    circumstances   tune  value  flip  bitmaps   connect component   bipartite graph without change        practice   always tune  value        order  magnitude         approximately   two tune approach  describe  supplementary section    also explicitly detect alien kmers   increase  thus intentionally expand  number  target categories   majority    dummy alien due   randomness  class assignment   presence   alien many alien kmers  likely  fall   dummy categories   thus recognize  alien formally        jtj    alien thus alien kmers  recognize   stage  probability p2l  x¼jtj     jtj    taxonomic classification  sequence read  illustrate  figure  give  sequence read  algorithm iterate   kmer   begin   read    kmer retrieve  taxon     specific use lothello taxonomic classification   read  determine  assemble  taxa   kmers   read  classification  straightforward   kmers indicate   taxon     often  case disparate taxa  consider   consistent   belong    path   taxonomy mean  one assignment   higher rank      taxa belong  different branch  represent conflict information  issue   complicate   possibility  false taxonomic information return  query alien kmers   kmer   read   appear     reference sequence  tackle  challenge   design  windowbased classification approach  window  define   sequence  consecutive kmers   assign    taxon   give level  windowbased approach guard  falsepositive assignments due  alien kmers assume   taxon  return   alien kmer  random  chance   two consecutive alien kmers return   taxon      t¼0         value   small regardless   additionally  window correspond   maximum read subsequence  match  reference sequence thus  longer  window  longer  subsequence match   less likely  match  random  comparison  algorithms   kraken  clark count  total number  kmer match regardless   spatial distribution across  read  multiple taxon windows  available metaothello score    use  sum square  window size    follow formula  taxon   maximum score   select score tðþ¼         denote  number  kmers   ith window classify  taxon   xliu    kmer signature belong   taxon  also specific   higherranking taxa   higher taxonomic rank  exist  kmers  distinguish  taxon   siblings thus longer kmer windows  moreaccurate classifications  expect  higher taxonomic rank   assumption  topdown strategy  adopt  read classification give  read sequence metaothello start  classification   top rank  continue  classification   rank     exist  sufficiently large kmer window support  level base   kmer distribution   taxon metaothello establish  threshold  minimum window size   classification   taxon require theorem  show   minimum windowsize threshold   precomputed   taxon prior  read classification  minimum window size require   taxon  determine   probability   alien kmer query  lothello return  taxon root     acceptable falsepositive rate  larger  size   taxon subtree  higher  probability   random alien kmer may match    thus  longer  window require  reliable classification additionally  larger window size   require  order  lower  falsepositive rate theorem  give  userdefined falsepositive rate    total read number   minimum windowsize threshold require   taxon    compute  logp          denote  probability   alien kmer query  lothello return  value   taxon subtree  root   proof  present  supplementary section   example     genuslevel node suppose      tðþ          give  million read  suppose     logp            windows larger  three   take  consideration  determine  read assignment",-0.18875516208011195,0.2290909754521499,0.10722692628125956,0.1648279871581005,0.005394612027373459,-0.020247384562176837,-0.13258388520163253,0.022722586722028853,-0.014097976882543653,0.13344490328069725,-0.006963837249065446,-0.026980843162612702,0.16467234727618185,-0.0823351672654505,0.11894956970969285,-0.05000417842036239,0.033326234784235666,0.2089448914964556,-0.03307333168473188,0.10127248679940913,0.016082007705766944,-0.2359819633209708,0.05996232813500992,-0.044675735791971066,-0.01338188738094711,-0.1767455434313054,0.10639665461773848,-0.1827133169598691,-0.04078773022069675,-0.07348141461091916,0.020834993246470816,0.2342785180549484,-0.1598986236581324,-0.09839707505009954,0.19489727761765346,0.12996774615593407,0.07287116671386598,-0.009367068803048,-0.06826498915375387,-0.11982326096898173,-0.08243152805652715,-0.13382796614911646,-0.03107601641024587,-0.11637023708766042,-0.12755960692695986,-0.014505613873422968,0.15895514541057967,-0.09198944848111557,-0.2293417151608668,-0.3638577968542068,0.20307100954759855,-0.019804385706330585,0.0712873297030203,0.5988822415532088,0.032788985780519225,-1.1501051108756593,0.09888190998554926,-0.21490851124883845,0.980928009872994,0.20086286965811886,-0.1628126655219088,0.30970332834480224,-0.08848769229438393,0.043288282480657005,0.6139655093548493,0.02824616269483267,0.02992549688359705,0.017607829549331003,0.2143796143675607,-0.1851333595986383,-0.09502541696438584,-0.06278057596056323,0.04173356623314582,-0.11336062295225074,0.2048230439878512,-0.026680373610042198,-0.138983394053849,-0.1598453017289038,-0.37451944422046735,-0.052221009870479694,0.1858323244873689,-0.03046708746277368,-0.3802120779059569,-0.06148842379302559,-0.8225454919592895,0.02796484598677304,0.21657115051054945,-0.16562520394698171,-0.09096506648106584,-0.05873049540069046,-0.22676134905069065,0.060872087818074724,-0.07791087786875206,-0.10378256077032093,-0.11290646489216252,-0.09820928014002862,-0.11236799457864136,-0.3373181905188312,0.30778357096806863,0.07781075231603238,Classification,1
36,36,"taxmaps comprehensive  highly accurate taxonomic classification  shortread data  reasonable time
highthroughput sequence   revolutionary technology   analysis  metagenomic sample however query large volumes  read  comprehensive dnarna databases   sensitive manner   computeintensive   present taxmaps  highly efficient sensitive  fully scalable taxonomic classification tool use  combination  simulate  real metagenomics data set  demonstrate  taxmaps   sensitive   precise  widely use taxonomic classifiers   capable  deliver classification accuracy comparable    blastn     three order  magnitude less computational cost
database creation data   refseq genomes  blast  databases  retrieve   ncbi ftp server  organize  various databases see supplemental table    database duplicate sequence entries  remove   ambiguous nucleotides convert   character   every distinct kmer  compute  lca   taxonomic ids   sequence contain  derive   ncbi taxonomy database ncbi resource coordinators  kmers  assemble  extension  sequence  share   lca  procedure     fly   algorithm traverse  database  kmers  read  classify  every sequence record   database compression  initialize   creation   sequence correspond   first kmer   record  classify   lca   every kmer   lca classification match    sequence  sequence  extend   last base   kmer otherwise  new sequence consist   kmer  correspond classification  initiate  newly assemble sequence   index fmindex use gem marcosola     reassembly process  use   fmindex result   reduction   memory footprint allow   large databases   merge  simultaneously query although  overall strategy  similar  essence   one use  kraken  fact   operation  perform  kmers  length equal  greater   target read length allow  nonexact search   conduct    manner   would   original database mean   every alignment   raw database     least one kmer   compress database    alignment  possible thus render  compression lossless   purpose  taxonomic classification    eliminate    database sequence redundancy consequently improve map performance stability   also significantly reduce  number  postmapping computations   perform   particularly true  sample contain dna  rna  organisms   highly represent   databases   coli     repeat content  particularly high compress index   download  ftpftpnygenomeorgtaxmaps classification algorithm read  map  singleend mode   index database  ≥ read length use gem mapper  guarantee   optimal alignments  retrieve    userdefined maximum edit distance  default   parameter  read   taxonomically classify   lca   database sequence return  pairedend classification read  classify independently   classification   two end  discordant mean    different   roottoleaf rtl path  one end   fully include   rtl path    end  pair  classify   lca   singleend classifications   rtl path  one end  contain   rtl path    end  pair   classify   lower taxon   longest rtl path  situations    database match  find  one   two read  pair  classify solely  one read taxmaps also   stricter pairedend classification scheme    end  require   database hit   scheme  pair  always classify   lca   singleend classifications even  one rtl path  contain    ensure maximum precision   expense   higher rank classification implementation taxmaps  fully implement  python  work   transparent pipelinegenerating script upon userdefined parameters  read data  fastq format   also extract unmapped read  bam file  samtools     process step   adapter removal lowquality end trim  low complexity filter  carry   cutadapt martin   prinseq lite schmieder  edwards   part   taxmaps pipeline upon userspecified options users  also specify multiple index   query  define   indexspecific basis  maximum edit distance  number  thread use  gem marcosola    apart   taxmaps offer one singleend  two pairedend classification modes describe  map  classification result  give  tabdelimited file include full map information   read  gem format along   correspond taxonomic classification finally result   represent taxa  summarize   table   interactive report  generate use krona ondov    simulate metagenomics data set  build  simulate data set  first select taxa    rtl path include   major taxonomic rank    least one contiguous sequence longer     ncbi' nucleotide database ncbi resource coordinators         select taxa supplemental fig   randomly extract  single  sequence chunk   sequence  simulate data set  consist   million read pair  generate use  version  wgsim fork  samtools       combine five different read lengths          edit distance               follow additional parameters fragment length    indel fraction     maximum fraction  ambiguous base allow   interleave fastq file  convert  fasta file  blastn  megablast since  program   design  handle  fastq format  read  contain  taxonomic identifier   sequence     simulate  well   read length  edit distance   data set  data set  available  ftpftpnygenomeorgtaxmapsbenchmarkdatasets  additionally select  million read pair     edit distance     cluster  bin  increase multiplicity number  alignment best hit   uncompress ncbi' nucleotide database   use  compare gem mapper  blastn performance  compress  uncompress databases  run taxmaps kraken centrifuge blastn  megablast      simulate data set use default parameters   ncbi' nucleotide database  reference   methods  taxmaps databases  choice  kmer depend   read length   read length  blastn  number  read pair analyze  reduce    random sample due  time constraints give  blastn  megablast   taxonomic classifiers per   lca   best hit   read  determine  pairedend classification  criteria use  taxmaps  apply  estimate sensitivity  precision classifications  split  four distinct categories  correct   correct taxon  include   rtl path   assign taxon  concordant   assign taxon  different   correct taxon    include   rtl path   correct taxon  incorrect   assign taxon   include   rtl path   correct taxon    correct taxon include   rtl path   assign taxon   unclassified   taxon  assign ranklevel sensitivity   give   number  correct classifications   particular rank   total number  possible classifications  ranklevel precision correspond   number  correct classifications   particular rank   number  correct  incorrect classifications    rank pairedend ranklevel sensitivity  precision   program  calculate  eight major taxonomic rank species genus family order class phylum kingdom  root  every edit distance  read length combination supplemental fig  similarly singleend ranklevel sensitivity  precision data  also collect   program' output  singleend mode supplemental fig   correspond fscores   find  supplemental table   addition   sensitivity  precision metrics wall clock time data  collect   program   pairedend data set supplemental fig  taxmaps megablast centrifuge  blastn  run   computer cluster run centos   either intel xeon   ghz cpus  intel xeon cpu   ghz cpus due   high memory requirements kraken  run   largememory share host run centos   intel xeon cpu   ghz cpus  program  run use  cpus per job except  blastn   run  eight cpus give  longterm commitment require   resources  wall clock time report  blastn   extrapolate  match  number  read classify  number  cpus use    program strainlevel accuracy assessment     bacterial strain genomes available   refseq_complete_genomes database   determine  number  kmers      unique   strain  allow   select  bacterial strain   evenly distribute along  spectrum  percentage  strainspecific sequence    simulate  million  read pair   average divergence   ftpftpnygenomeorgtaxmapsbenchmarkdatasets read   classify use taxmaps  default parameters   pairedend  singleend modes   original database   strain strainlevel sensitivity precision  correspond fscore  compute mock community data set  assess  classification accuracy  real data  use two mock community singleend data set hiseq  miseq   previously publish benchmark wood  salzberg   data set  originally compose   singleend read   different bacterial species  adapter clip use cutadapt martin  removal  sequence shorter      complete removal  streptococcus pneumoniae   hiseq data set due   presence  chimeric read   likely artifacts      read leave   hiseq  miseq data set respectively   data set apart  run taxmaps         hiseq  miseq respectively kraken centrifuge megablast  blastn  additionally run  protein homologybased classifiers kaiju  diamond diamond classification follow   criteria  blastn  megablast moreover  filter strategy  implement   blast program use  criteria minimum bite score winscore  toppercent describe   author  megan huson     select  winscore    minimum bite score cutoffs    two value     explore   toppercent cutoff supplemental fig   methods use  refseq_complete_genomes database   exception  kaiju  diamond  use  correspondent set  annotate proteins available  ftpftpnygenomeorgtaxmapsbenchmarkrefseq_complete_genomes_db   tool ranklevel sensitivity  precision  compute correspond fscores  give  supplemental table    also estimate genus abundance base  read classification   hiseq miseq   two recently publish data set hclc  zymobiomics mcintyre     every genus abundance estimate aobs   tool   compare   truth set value aexp   relative difference   two drel  calculate   rel   obs   exp    obs   exp max   obs   exp   real metagenomics sample  download seven illumina data set  real metagenomics sample   sequence read archive sra leinonen     description  correspond accession number   find  supplemental table    data set adapter sequence  clip  lowquality end base trim    read  classify  pairedend  singleend modes use taxmaps    kraken centrifuge kaiju  diamond   data set apart  determine  number  classify read   method  compute  novel ranklevel metric call classification concordance  metric  define   percentage  read pair    independent classification   end  either    concordant   particular rank  long  one   end   classify   rank    instance  one end  classify  escherichia coli     enterobacteriaceae  classification   read pair  consider   concordant   species level    rank    second end   classify  proteus vulgaris instead  classification would  concordant   family level    rank   assess whether classification concordance could  use   proxy  precision  calculate  spearman' rank correlation    two metrics   simulate data set   methods    rank   exception  “root”",-0.1887964172403507,0.21514082603875265,0.10582121225600208,0.07503826603483918,0.005744985261477899,-0.05931194888260447,-0.07771938454483883,0.03775113940205038,-0.0424054423740378,0.14246645502261202,0.06309568652934164,-0.01598450864139898,0.16375183931023074,-0.09202051230307963,0.11787873587507584,-0.02405045465551786,0.09407680181157198,0.15844252790576466,-0.03547864851320772,0.10583686726605558,-0.008809715253974441,-0.2324895903500363,0.05287863800414234,0.029171218358851926,0.03269428893378243,-0.16615001879216842,0.07528225026547539,-0.08239499811171593,-0.0750323779018589,-0.004076398942164485,0.014901565180029256,0.23811157947324516,-0.19146724453499955,-0.08403456108926023,0.22285258346997308,0.0925803773912355,0.05028644182973288,-0.009421487333789884,-0.06375553647646957,-0.10499675825374366,-0.05225172538881783,-0.11317192658508765,-0.07301546033512231,-0.04353470305795781,-0.1204932519004532,-0.011946570930699974,0.10329230581044628,-0.17658452086693274,-0.18871317097033505,-0.2958880006876863,0.14139925253583302,0.026268973604661475,0.08729150259799001,0.5356566265123427,-0.018648784650583013,-1.0361799671577312,0.0589217404632402,-0.21583518382976766,0.9290757113394196,0.18027982430848627,-0.12702824845882413,0.2857729434362836,-0.07208271102242803,0.04151734709727658,0.5465628967532881,-0.002690650026981665,0.0248537583272781,0.0301158090198126,0.2182455625568328,-0.15673027073515652,-0.06247694179508336,-0.02358983950374344,0.0937418108315338,-0.07200429621412349,0.17077996975921236,-0.0006313081712881487,-0.14725807383136966,-0.15810795448824366,-0.3494201155017661,-0.07339899404520893,0.18941027691779566,-0.025756163413882687,-0.3525380925608516,-0.04611316047768082,-0.7559900424721716,0.09053174160531056,0.22312077731885066,-0.16473700867708213,-0.10121459210308822,0.0007990650826158802,-0.1779238531483368,0.09471624188773596,-0.10719276712158664,-0.10661212127792363,-0.09477026040859672,-0.09749995451228123,-0.07272732355930142,-0.2911951632295689,0.28733585617208685,0.06547413369465603,Classification,1
37,37,"megan analysis  metagenomic data
metagenomics   study   genomic content   sample  organisms obtain   common habitat use target  random sequence goals include understand  extent  role  microbial diversity  taxonomical content    sample  usually estimate  comparison  sequence databases  know sequence  publish study use  analysis  pairedend read complete sequence  environmental fosmid  bac clone  environmental assemblies emerge sequencingbysynthesis technologies   high throughput  pave  way  lowcost random “shotgun” approach  paper introduce megan  new computer program  allow laptop analysis  large metagenomic data set   preprocessing step  set  dna sequence  compare  databases  know sequence use blast  another comparison tool megan   use  compute  explore  taxonomical content   data set employ  ncbi taxonomy  summarize  order  result  simple lowest common ancestor algorithm assign read  taxa    taxonomical level   assign taxon reflect  level  conservation   sequence  software allow large data set   dissect without  need  assembly   target  specific phylogenetic markers  provide graphical  statistical output  compare different data set  approach  apply  several data set include  sargasso sea data set  recently publish metagenomic data set sample   mammoth bone  several complete microbial genomes also simulations  evaluate  performance   approach  different read lengths  presented
sequence comparisons   study  perform sequence comparisons   ncbinr database  nonredundant protein sequence use blastx   default settings  ncbint database  nucleotide sequence use blastn   default settings   wholegenome sequence obtain  dog elephant  human use blastz sequence comparison   computationally challenge task   likely  grow even  demand  databases continue  grow  larger metagenome data set  analyze  example compare  mammoth data set  ncbinr take almost   real time   cluster   cpus  estimate  perform   computation    million read   complete sargasso sea data set would require   real time   system analysis use megan   startup megan load  complete ncbi taxonomy currently contain  taxa     interactively explore use customize treenavigation feature however  main application  megan   process  result   comparison  read   database  know sequence  program parse file generate  blastx blastn  blastz  save  result   series  readtaxon match   programspecific metafile additional parsers may  add  process  result generate   sequence comparison methods  program assign read  taxa use  lca algorithm   display  induce taxonomy nod   taxonomy   collapse  expand  produce summaries  different level   taxonomy additionally  program provide  search tool  search  specific taxa   inspector tool  view individual blast match see fig   approach use several thresholds first  minscore filter set  threshold   score   alignment must achieve   consider   calculations  read  length    use blastx  compare  ncbinr  minscore    higher  recommend   read  length    minscore     suitable second  help distinguish  hit due  sequence identity   due  homology  toppercent filter  use  retain   hit   give read  whose score lie within  give percentage   highest score involve  note        keep  certain percentage   hit  smaller  set value    specific  calculate assignment    also  greater  chance  produce  overprediction    false prediction due   absence   true taxon   database  useful range  value   third  winscore threshold   set     give read   match score   threshold    read   match  consider  score   threshold fourth  help reduce false positives  minsupport filter  use  set  threshold   minimum number  read  must  assign   taxon       descendants   taxonomical tree   main computation  read   assign   taxon    meet  requirement  reassign   special taxon “ assigned”  default  parameter  set    result   lca algorithm  present   user   partial taxonomy    induce   set  taxa    identify see fig   program allow  user  explore  result  many different taxonomical level  provide methods  collapse  expand different part   taxonomy   node   represent  taxon     query  determine  read   assign directly     many read   assign  taxa   additionally  program allow  user  view  sequence alignments upon  specific assignments  base",-0.21444331286475066,0.24042207789089945,0.1466736624929278,0.109544447409334,0.01574433588431458,-0.053039647367323695,-0.1540826751479741,0.04996914823703399,-0.060062141838069585,0.13066597065405436,0.016197100303273787,-0.03038397960157858,0.16740382445067453,-0.137710450656919,0.1440657349700039,0.00447051373431114,0.1256227225246322,0.2692956140902997,-0.056126771286060965,0.17225296402315576,-0.07796600465145376,-0.2662164183402503,0.0728627999226942,0.044152494590660486,-0.03313884509951566,-0.19947662069634706,0.06747635076861587,-0.16180711592961514,-0.058267740863892775,-0.0632207517923908,-0.024246638699400202,0.24463949523417766,-0.197953024964038,-0.04837353793102213,0.2344820223189244,0.1098871280734548,-0.0047820839427273575,-0.014868773778693544,-0.0673969304551267,-0.11451263143185145,-0.1289498020069139,-0.12195965639979545,-0.1049239055766655,-0.1369925040950033,-0.12840593616301366,0.026365763817685312,0.1020923547308754,-0.15730613171709354,-0.25754236323819324,-0.3393323847696323,0.1736851443864267,-0.03686926334113297,0.025602408920207785,0.6189074428113936,0.028240754261086867,-1.2109495860420996,0.015570129492078666,-0.24259269809613385,1.0708638348271726,0.2020156506977165,-0.17608444029217396,0.3804987366746732,-0.05017446092016245,0.0509649452994819,0.6378843144397252,0.04564688299972288,-0.0014575465051974688,0.03580722413198264,0.2519245619868377,-0.1917912898240266,-0.08980101828531555,-0.005648100908405872,0.0738037293560208,-0.19440252889827309,0.13979886229563918,-0.028923812582312768,-0.1684259193979583,-0.18039411120289175,-0.4447384277203431,-0.04395400679808248,0.2373777418259393,0.0019822298640738826,-0.3883177466332132,-0.07579135566139249,-0.9102681785818679,0.05256640494572585,0.2712845467789857,-0.14192904511723167,-0.09629939511349356,-0.036394082242946345,-0.17246518931006669,0.07910865223880305,-0.07500300200362862,-0.11520101218985575,-0.1166394181187368,-0.08841076206752202,-0.11011551577356404,-0.34947704162396903,0.3635822393922825,0.06974752077798324,Classification,1
38,38,"metashot  accurate workflow  taxon classification  hostassociated microbiome  shotgun metagenomic data
shotgun metagenomics  highthroughput sequence may allow deep  accurate characterization  hostassociated total microbiomes include bacteria viruses protists  fungi however  analysis   sequence data  still extremely challenge  term   overall accuracy  computational efficiency  current methodologies show substantial variability  misclassification rate  resolution  lower taxonomic rank   limit  specific life domains   bacteria  present  metashot  workflow  assess  total microbiome composition  hostassociated shotgun sequence data  show  overall optimal accuracy performance  analyze  simulate  real datasets
 metashot workflow implement  twostep similaritybased approach  attain  best compromise  computational efficiency  assignment accuracy indeed  consideration   large majority  shotgun read derive   host  first carry   fast similaritybased screen  detect candidate microbial read   finegrained taxonomic assessment   much smaller set  putative microbial read  carry   use also  iterative taxon refinement procedure see supplementary material  detail  software package implement  metashot pipeline  freely available    include  utility tool  extract  read assign   specific ncbi taxonomic     leave unassigned  order  carry   comparative assessment  metashot performance  respect  kraken wood  salzberg   metaphlan2 truong    two state   art tool  analyze shotgun metagenomics data  use art huang     generate   silico design human microbiota   composition resemble  typical human sample contain human bacterial  viral sequence see table   supplementary material    detail description  simulate dataset also include read  phix phage    show  contaminate many assemble microbial genomes mukherjee      human endogenous retroviruses herv  escape detection   tool design  analyze shotgun metagenomics data    simply label  host read indeed  specific condition  viruses   express  may play  role  disease pathogenesis agoni        moreover  order  compare metashot kraken  metaphlan2   control real dataset  analyze  bacterial  viral mock community conceicaoneto    available   ncbisra archive srr3458569  result   benchmark assessment display  table  clearly show  metashot outperform kraken  metaphlan2  term   overall accuracy  read assignment   prokaryotes  viruses simulate datasets   family genus  species level  addition metashot perform better  kraken  metaphlan2 also  term  taxon assignment accuracy  species  genus level   qualitative see supplementary table s1s4  quantitative level see supplementary figs    finally  order  test metashot   real dataset  analyze dnaseq         read  rnaseq         read data   sample  cervical squamous cell carcinoma   uterus    know      cancers harbor human papillomavirus hpv genomes  specific serotype involve vary   common ones  hpv16 hpv18  hpv31 growdon  del carmen   previously establish  pcr assessment   test sample contain hpv31 indeed hpv31  detect   metashot   dnaseq  rnaseq datasets   read    total viral read  dnaseq data    read    total viral read  rnaseq data whereas kraken detect much fewer viral read     total  dnaseq  rnaseq data respectively notably  include hpv31 see supplementary table   also metaphlan2  unable  detect  result confirm  optimal performance  metashot  respect  kraken  metaphlan2 also   case  real data analysis  metashot output consist    html interactive table report   node   infer taxonomy  taxon name  ncbi taxonomy    number  assign read   csv file contain   information report   interactive table iii  krona graph ondov     graphically inspect  infer microbiome  remarkable unique feature  metashot   possibility  extract  unassigned read   set  read assign   specific taxon define   ncbi taxonomy   feature  particularly useful  downstream analyse   otu generation contig assembly   characterization  unassigned read  functional annotation   read belong   specific speciesstrain  addition  feature may allow  shotgun map speciesspecific dnaseq read   target genome  available  prevent  possibility  artifacts usually associate   strong positional map bias due  chimeric contamination  genbank reference sequence mukherjee    moreover   case  shotgun rnaseq read map   target genome may precisely assess  relevant expression profile  price   overall better accuracy  metashot   lower computational efficiency metashot      time slower  kraken  metaphlan2 respectively   complete analysis   simulate benchmark dataset see supplementary material",-0.18627706994268828,0.21411990562404934,0.12106197002888792,0.1017827161636703,-0.03305196282040476,-0.04170857762775099,-0.0693443645643023,-0.02588090489777075,-0.020110924440432162,0.10436003667680356,-0.015687629530725975,-0.048414967420166766,0.1542452869721076,-0.07703597659280564,0.16883514208408693,0.07592590739469691,0.06222456419398415,0.17018493927721662,0.03487628452358362,0.09607405714822287,-0.0833732903820287,-0.25701037960623024,0.06668639140379905,0.026689240595062627,-0.02715771374852815,-0.16369902184553636,0.1320839104340901,-0.15030958826579424,-0.04783873723668428,0.017232685592624468,-0.00858173602213408,0.21671593415152712,-0.18360623306986212,-0.060378604397503324,0.2611146261708885,0.08520266484381442,0.028441320784201012,0.010837246871391391,-0.08525542847401348,-0.09904325992818856,-0.1042706756390702,-0.1019097917030023,-0.10107253495337226,-0.09249256490906904,-0.08906716121207969,0.022214037753735243,0.13502156659302747,-0.12429779325105735,-0.2749934761390171,-0.3113000678114485,0.25203602546399995,0.009393392775234755,0.06351220472066231,0.494769956484653,-0.007852256675782291,-0.9934715332043276,0.02512111546652243,-0.2437958312414897,0.8256454531565659,0.18140005990711,-0.1652872174687429,0.3782067765721982,0.003675557257931517,0.06240447998878654,0.589835415170798,0.07624524247923704,0.03778467770156356,-0.02055849538579502,0.26391093060880416,-0.19269072194499354,-0.02965377721746968,-0.009310062846676716,0.11860672895958145,-0.11084180179581828,0.14141902816060092,-0.031881561965101224,-0.1611725135244078,-0.1503183619474378,-0.4095271884116169,-0.0573750541590161,0.1405755390776218,-0.009753527963345034,-0.32657480735898664,0.002463459687651661,-0.8055217199810389,0.05521005744863625,0.23280983490437485,-0.12830853387171426,-0.15445176075698566,-0.047061881058376144,-0.12799114465040318,-0.015389204596800297,-0.028450508317673925,-0.009238651036234249,0.00588580823260481,-0.026061339938230274,-0.15788518555590586,-0.4264315180058685,0.31075697043316736,0.049524561661477805,Classification,1
39,39,"riems  software pipeline  sensitive  comprehensive taxonomic classification  read  metagenomics datasets
fuelled   advent  subsequent development  next generation sequence technologies metagenomics become  powerful tool   analysis  microbial communities  scientifically  diagnostically  biggest challenge   extraction  relevant information   huge sequence datasets generate  metagenomics study although  plethora  tool  available data analysis  still  bottleneck  overcome  bottleneck  data analysis  develop  automate computational workflow call riems  reliable information extraction  metagenomic sequence datasets riems assign every individual read sequence within  dataset taxonomically  cascade different sequence analyse  decrease stringency   assignments use various software applications  completion   analyse  result  summarise   clearly structure result protocol organise taxonomically  high accuracy  performance  riems analyse  prove  comparison   tool  metagenomics data analysis use simulate sequence read datasets riems   potential  fill  gap  still exist  regard  data analysis  metagenomics study  usefulness  power  riems   analysis  genuine sequence datasets  demonstrate   early version  riems      use  detect  orthobunyavirus sequence lead   discovery  schmallenberg virus
implementation integrate software  databases riems  implement   unix shellscript write  bourneagain shell bash  script file  available   gnu general public license version  together   validation datasets   “novel viruses dataset”   riems  rely  validate standard software  databases  software applications  instal   local server specifications see  riems  access    genome sequencer software suite work  version   later roche mannheim germany available free  charge  registration    particular  assembler newbler    reference mapper  well   standard flowgram format sff   fasta nucleic acid fna tool command furthermore  ncbi blast software suite version  available  ftpftpncbinlmnihgovblastexecutablesblast   ncbi databases available  ftpftpncbinlmnihgovblastdb  nucleotide  protein   taxonomy  integrate   addition  emboss software package version     include  particular  applications  open read frame orf detection  amino acid translation  software applications  use  default settings  blast hit selection  base   evalue cutoff   hit   lowest evalue  select riems accept sequence input   common sequence format sff  generate  lifetechnologies iontorrent  roche genome sequencers fastq  instance illumina  fasta  case  fasta file preferably  combination   correspond quality file hardware  operate system riems   necessary applications  instal locally   server equip  four intel xeon e7450 processors   core   frequency   mhz    pc2 ddr2 mhz ecc ram  server  link     gbits port   storage area network  operate system  centos release   linux kernel release e15 delineation  riems data process  general overview   riems pipeline  depict  figure  riems  subdivide   basic analysis  taxonomically assign  bulk   dataset    analysis deal   sequence remain taxonomically unassigned   basic analysis   basic    analysis follow  general strategy  sequentially apply different tool  decrease stringency  order  achieve  fast  reliable overall analysis    basic    analysis  finish  result  summarize   spread sheet arrange taxonomically prior   analyse  read  quality trim  high reliability   final classifications   purpose   reference mapper application  use  intrinsically perform  quality trim thereto  polya sequence   nucleotides  length  generate  use  reference   map figure   trim point   determine   quick initial map   use  fix trim point   analyse  parallel  prescreening   dataset   user provide reference set  optionally  perform like show   analyse   clinical pathoscope dataset figure  basic analysis  main step   basic analysis figure   identification   sample background assignment  read   background species identification   abundant species   remain dataset   final blast analysis  decrease stringency first use megablast follow  blastn  first step   actual analysis   identification   sample background   species  bulk   read   assign    purpose  subset   read  randomly extract   trim read  assemble  contigs use   newbler assembler subsequently  result contigs  analyse use megablast   ncbi nucleotide database “”  genbank  embl  ddbj  pdb sequence  base  genbank identifiers gi   best hit  associate taxonomy ids   correspond species  determine   ncbi taxonomy database  information  use  retrieve  sequence   detect species   nucleotide database successively    sequence set  first use  reference   map  thereafter  megablast  analysis   read exclude   map due  length restriction  partially map read  include  detail depiction   repetitive taxonomy base sequence retrieval  alignment procedure   find  additional file  figure      case  identify organism   eukaryote  read   classify   organism  map  blast   partial database contain  viral sequence  order  identify viral read potentially classify  eukaryotic read due  viral sequence  may  part  eukaryotic genomes additional file  figure   read   classify  one   step  exempt  subsequent analyse  procedure generate  assemble  random sequence subset follow  blast sequence retrieval  map plus scan  viral sequence  repeat   remain unassigned read  either  new species  identify  blast  generate contigs   new contigs   assemble  repeat procedure enable  rapid automatic breakdown   dataset without user provide knowledge   organisms make   sample background    initial repeat background analyse    read  still unassigned  cannot  assemble  contigs another random subsetting process  initiate however   process   read  take   remain unassigned read   analyse directly use megablast  without  prior assembly  taxonomy ids   hit  determine accord   genbank identifiers gi obtain   blast result     eight read  assign    taxonomy   correspond sequence  retrieve   nucleotide database  use  reference   map   subsequent megablast analysis like   initial background analysis additional file  figure     read  remain unassigned   initial screen  assemble  contigs read  remain unassembled   step  assign   contigs  megablast   least    base   align   contig subsequently  contigs  search   local nucleotide database use blastn   blast align contigs  partially   unaligned part consist     consecutive nucleotides  unaligned part   search   database  blastn base   assignment   contig   organism read   align   contig  megablast  assign   respective organism  well additional file  figure  unassigned  partially assign contigs  save   file    analysis see   read   neither assemble   contig  assign   contig  megablast   previous assembly step  sequentially investigate  multiple blast analyse  first   blast analyse   megablast   database encompass  nucleotide sequence   organisms   identify   partial datasets  use  reference  mappings secondly  remain unassigned read  search   ncbi  database  use megablast finally blastn  use  search  unaligned remainder   ncbi  database     blast search unaligned part     consecutive nucleotides  partially align read  search  second time additional file  figure   analysis   analysis  optionally  execute  start  additional nucleotide blast analyse   read    subsequent analyse  sequence type  switch   amino acid sequence cod   sequence  remain unassigned read  contigs due   higher information content    letter amino acid alphabet usually additional sequence   classify  initial nucleotide read sequence analyse within   analysis  perform without low complexity filter first use megablast  subsequently blastn  search   ncbi  database deactivation   low complexity filter  decrease  stringency   assignments  even low complexity regions   sequence  consider additional file  figure  hence    chance  additional read   classify  next step   translation   unclassified read emboss sixpack   contigs emboss getorf   amino acid sequence   six frame   limitation  apply   lower size cutoff   amino acids  shorter peptide sequence cannot  analyse  blastp  yield  truly significant result hence  orfs   minimum length   codons  translate independently  start codons  reach  stop codon  settings assure  even   case  sequence noise cause nonsense mutations  insertions deletions  single base exchange  cod  sequence   analyse  least  partial sequence   case  short read  illumina hiseq style read  lower size cutoff    still permit  analysis  deduce amino acid sequence  bin accord   length  order  select  proper substitution matrices  blastp accord    amino acids pam    amino acids pam    amino acids blosum   amino acids blosum  contigs  deduce  sequence  analyse  blastp  ncbi  database additional file  figure  blastp analyse  ncbi  database   sequence deduce  read additional file  figure  start   longest sequence translate   read   proceed   next shorter  sequence deduce   read   hit  find   database   similar  sequence  detect  additional  sequence   respective read  exempt   blast analyse comparison   software tool   comparison  riems   tool  regard  sensitivity  specificity  use kraken    available kraken minidatabase    clinical pathoscope     database      metaphlan clade specific marker blast database      combination  megablast  read classification  three  use  default settings  recommend   respective author  combination   validate databases provide   project websites   comparisons  use different datasets namely  simulate sample see table    without deviations  small dataset comprise roughly  genuine illumina miseq read represent  different novel viruses   simulate sample #   clinical pathoscope project      modify  read accession  read represent streptococcal sequence   author didnt label  read accord   two different streptococcal species present   dataset     majority accord   classifications    tool  use roughly  read    discard   inconclusive classifications like riems  three tool put  readwise classifications   analyse use     rstudio   rstudio inc wwwrstudiocom  calculate  sensitivity  specificity  enable  robust comparison   different tool classifications  consolidate   species level   unambiguous readtospecies classifications  take  account  case  clinical pathoscope read longer   base   default split  fragment riems   capability  split read   partial match occur   case result obtain   subsequences  consolidate   read level    count   result  unambiguous",-0.200137996165914,0.18687739185093946,0.10902260491511363,0.08543671524406242,0.05356793023285061,-0.03512736317242588,-0.06728865761752854,0.038944974388647635,0.0066751349952570635,0.12493805113507332,0.07187079855913399,-0.018805369269811217,0.158301857015322,-0.07049203274982205,0.14311433013794947,0.0063557636722899645,0.07980343236391478,0.16346079181420708,-0.028287735467296824,0.08292373267281516,-0.08315252080327372,-0.2516126923268268,0.06649119527686981,0.022547902521426067,-0.021789688830458488,-0.2058325136022767,0.06616051118915596,-0.08831242023557273,-0.043266337396082065,-0.01943221967702762,-0.02063508190164573,0.2415508035883028,-0.1862957794875715,-0.08303156992657636,0.2197595334547604,0.0754881267266775,0.04785384331748615,-0.06486795415390924,-0.05209261916932493,-0.11323312412698056,-0.06185164673593457,-0.09941335469045706,-0.04852063234356605,-0.09669993184204638,-0.09996288789990668,-0.008197015736527877,0.13254584914490602,-0.14568875699741368,-0.1969326064737965,-0.3062766933968125,0.1374239207341753,0.07461304199128813,0.04550149780898837,0.5056889027108685,0.025672073230906776,-1.0118914339615837,0.030969525237157913,-0.22893229462173306,0.9695431771117894,0.18307787918582044,-0.1699896356904748,0.30286134567013023,-0.02815900503140147,0.07982823254484363,0.562513820994192,0.01844018743106383,0.0056216226366519045,0.005001780052989267,0.20891198470937533,-0.20226077644582308,-0.07191123466430126,-0.029834032190007742,0.13674710443551305,-0.1287142440098627,0.1449267563549896,0.006195697986831818,-0.16149904731751755,-0.13892656071328804,-0.3702867675981622,-0.10137895483719128,0.18552028688410407,-0.0693149289290296,-0.3498087584501053,0.0472572901094678,-0.8080390456631311,0.13374989663683345,0.266065160402852,-0.14586207552020286,-0.12110786074094765,0.03643641814093141,-0.16412650373066318,0.1016137707554858,-0.14492980788653606,-0.054979496536083125,-0.04560145244954445,-0.08474111765878474,-0.05735554875746704,-0.2809794969747172,0.3243891972987998,0.0719557993386024,Classification,1
40,40,"accurate readbased metagenome characterization use  hierarchical suite  unique signatures
 major challenge   field  shotgun metagenomics   accurate identification  organisms present within  microbial community base  classification  short sequence read though exist microbial community profile methods  attempt  rapidly classify  millions  read output  modern sequencers  combination  incomplete databases similarity among otherwise divergent genomes errors  bias  sequence technologies   large volumes  sequence data require  metagenome sequence  lead  unacceptably high false discovery rat fdr   present  application   novel geneindependent  signaturebased metagenomic taxonomic profile method  significantly  consistently smaller fdr    available method  algorithm circumvent false positives use  series  nonredundant signature databases  examine genomic origins  taxonomic challenge gottcha gottcha  test  validate   synthetic  mock datasets range  community composition  complexity  apply successfully  data generate  spike environmental  clinical sample  robustly demonstrate superior performance compare   available tools
gottcha' unique reference genome databases fastaencoded databases  unique signatures  prokaryotic  viral genomes  generate  use   work instructions provide   briefly databases  unique genome segment  multiple taxonomic level  family species genus strainlevel etc  use  taxonomic classification  read variants   databases    human mers  remove  also generate  use   study  mers  derive   grch37p10 genome reference consortium huref  craig venter institute  chm1_1 washington univesity school  medicine assemblies  include unplaced scaffold synthetic metagenomes several metagenome datasets  use  establish  validate  appropriate criteria  accurate taxonomic classification  abundance calculation use  gottcha databases    synthetic metagenomic datasets mg1mg16 analyze   study six  create   study  highcomplexity highcoverage hchc metagenomes   total read amount mimic    single illumina hiseq  lane  vary  community composition     organisms relative abundance even  lognormal distribution  perbase quality score  error rat  dataset consist   million   pairedend read read set  derive  either  constant number  genomes even mg1 mg3 mg5   number  cells  randomly select   species  along  lognormal distribution curve lognormal mg2 mg4 mg6 table ​table11  supplementary table  summarize  synthetic metagenomic communities synthetic data  generate use metasim   customize illumina error model  perbase quality assignments derive  follow errors  model  map real illumina hiseq   read  highquality genome reference whose assemblies  consider finish  sequence errors  record  collate accord   read base position   exactlymatched base  record  one lot  incorrectlymapped base  record   separate perbase lot  perbase error probability provide  metasim  obtain  divide  number  error base   specific position   briefly positionbased quality score  assign   error  errorfree position errorfree base receive qualities randomly choose   set  exactlymatched base qualities record   position   read    read whereas errorcontaining base qualities  randomly choose  quality score record   positionspecific lot ten previously publish synthetic metagenomes incorporate  maq error model   also use   crosstool comparison   considerably lower sequence coverage two highcomplexity mediumcoverage hcmc metagenomes    organisms   read mg7 mg8  two lowcomplexity lowcoverage lclc metagenomes    organisms   read mg9mg16 hmp mock metagenomes genomic mixtures   organisms  fix concentrations  create   human microbiome project hmp  test  sequence protocols  analytical pipelines two mixture type  available  even even mixture  aliquots  base  equimolar rrna operon count per organism   stagger stag mixture   rrna operon count  vary     order  magnitude accord   follow table   mixture   sequence    illumina genome analyzer      flx titanium raw sequence data  download   hmp website  since   highly unlikely   observe sequence distribution would correlate  input concentrations   library preparation stage   round  bwa  map use   know community members  reference  use  compute  individual' actual relative abundance although    organisms   mock community  analyse present  limit  complete bacterial genomes  thus exclude  eukaryote candida albicans   incomplete bacterial genome actinomyces odontolyticus leave   reference organisms mg17mg20 air filter metagenome  march  genomic dna  extract   air filter wash phosphate buffer saline  tritonx  spike  random amount  dna   biothreat agent francisella tularensis schu  two illumina libraries  create   extract    dna one construct immediately  dna extraction  one amplify use  qiagen replig whole genome multiple displacement amplification mda kit amplification yield    mda dna    library  prepare   prepare sample  sequence genome dna protocol without modification  sequence   single read    run   illumina genome analyzer iix generate    read  unamplified sample  prepare    illumina protocol  require speed vacuumconcentrating   usable volume  fragmentation   covaris e210 focusedultrasonicator      start material  much less      dna require   standard protocol  follow modifications  apply  prevent largeadapter  primer dimers  form     require adapter oligo mix  use   volume make    water  enrich use     pcr primers  clean  agencourt ampure bead beckman coulter yield   dnaμl  unamplified library  sequence across six lanes   illumina hiseq       run  cbot kit  cluster generation  sequence kit generate    read however  temporary instrumental malfunction result   generation    read spike human stool metagenome stool  collect   single individual divide  three sample  spike  various concentrations  several pathogens   center  disease control  prevention cdc  atlanta  bacterial pathogens include  a1122 vaccine strain  yersinia pestis   sterne vaccine strain  bacillus anthracis  test  dilutions      cfuml viral pathogens include human adenovirus  hadv strain mamastrovirus  human astrovirus   enterovirus  human poliovirus  strain sabin vaccine strain stock concentrations  adenovirus poliovirus  astrovirus     dilute       dilute        dilute    genome copiesml respectively  organisms  radiationinactivated  rna  extract use trizol  invitrogen  three sample   filter    centrifugal filter  clean   use  qiagen rneasy kit rna concentrations  determine  qubit rna assay  confirm use  agilent bioanalyzer   either  rna nano  rna pico chip approximately     sample average   rnaμl solution  ship  eppendorf lobind tube seal  parafilm  los alamos national laboratory  sequence sequence libraries  generate   three fecal rna sample use illumina' truseq  rna sample prep kit  include cdna conversion  pcr enrichment  three libraries   average size      range     library  sequence  one lane     hiseq pairedend   run gottchabased read classification gottchabased analyse begin  trim input read datasets  quality follow  fragmentation  read  uniform size read  first fragment   nucleotide  q20   remain read fragment  split   many nonoverlapping mers subreads  possible currently  use data  pacific biosciences     lower  quality threshold  q10 appear  provide result comparable  less errorprone read terminal fragment whose lengths        retain  subreads asis without split unlike  metagenome profile tool  report classification accuracy   perread basis gottcha' classification accuracy  organismbased  since exact read match  currently implement longer read fragment lengths increase  chance   mismatch   reason sequence read larger     break   fragment  test  recoverable signaltonoise ratio  read fragment  length       find   shorter fragment increase signal output       length also increase  classification error rat   value     select  data suggest however  allow  mismatch may  beneficial  increase read recruitment  homologous  slightly divergent sequence however  would require additional parameter optimizations  trim subreads   map  either  prokaryotic andor viral gottcha databases use  maximal exact match mem option   shortread aligner bwa bwa mem                 minimum seed length    minimum alignment score    mismatch penalty    gap open penalty    gap extension penalty     number  thread sam alignment result   profile  filter   gottcha profiler use  follow filter parameters minlen   mincov   minhits   ccov   minmlhl   binary classification gottcha classification occur   organism level rather     traditional read level   synthetic  mock datasets  algorithmidentified organism  label  true positive    organism  know   present   sample    false positive     know    present  false negative   call   algorithm   find  organism know   present true negative   dependent   number  organisms   reference database use      report  gottcha specifically     genomes  database       binary classifications  base   final output   program   gottcha profiler  include  filter step gottcha result  filter   serial twostage process  first consider   species whose linear coverage meet  exceed   second reject  species whose mean linear hit length    linear coverage  statistical measure  parameter filter   gottcha workflow  organism' linear coverage  gottcha' primary classification parameter  order  determine  minimum threshold    organism   classify  present   sample  evaluate  dependence   classification precision   tptp    recall   tptp     valid range  linear coverage  metagenomes  sequence amount  vary   order  magnitude     read supplementary table  supplementary figure  precisionrecall  curve supplementary figure   create  repeatedly profile  sam alignment file  different value   linear coverage  datasets mg7mg16  computational efficiency rather  compute precision  recall value throughout  entire range  linear coverage   compute  value    greatest linear coverage find   sample   point    higher value  linear coverage  true positives  find  hence precision  recall    plot supplementary figure s2a  s2b include  random guess performance line   precisionrecall value yield optimal f1scores  indicate   plot  best f1scores     precision  recallprecision  recall obtainable across  entire range  linear coverages  order  assess  best possible performance   tool among  diverse set  metagenomes supplementary figure s2c profile tool comparisons several tool  use  help classify metagenome read   result  compare supplementary table   tool include gottcha utilize   qualitytrimmed input dataset metaphlan    run  default settings use bowtie2    database  unique cladespecific marker genes release   october  motus   run use default parameters   report  species directly  ncbi taxonomic ids kraken v0beta  run  default parameters   preload option use  database available   november     kraken reporter classify ambiguous read   lca method  blastn    run   million randomly sample read   fecal metagenomic analysis    read    case bwa v0r385  use   standalone tool  run locally use  aln  samse singleend read option   sam file  process  samtools     bwa  blastn result  ncbi taxonomy  assign   read use lowest common ancestor lca method additionally  bwa  blast   specifically metagenome read taxonomy assignment tool  impose  cutoff    species     read count  report  order  limit  number  false positives  without compromise true positives  tool  run   thread precision recall fscore false discovery rate  accuracy  calculate   tool  detail  tool resource utilization  tool' resource utilization  track  process  hmp mock datasets use  thread  workstation consist  four intel quadcore xeon e7440  ghz processors   core total   ram  attach  six seagate sas drive model st9146852ss  hardware raid5 via  lsi logicsymbios logic megaraid sas  controller assess  proportion  genomes   use  classification use  randomly select genomes  investigate  much    sequence information  use    classify   various tool   much   sequence information contribute deleteriously   overall genometaxon assignment incorrect assignment   analysis   genomes  decompose   possible mers    maintain minimum compatibility   classification tool   consecutive mer  choose    overlap    previous mer  tool   use  classify  read accord   toolspecific protocol    read assignments record  correct assignment   record   mer  assign   correct source genome   incorrect assignment   record   mer  assign   genome    true source   tool  fraction  assign tpfp   proportion  correctly assign tptp    incorrectly assign read fptp    display use  boxplot function      function  taxonomic hierarchy   read place incorrectly   lower level  taxonomy may still  classify correctly  higher level  taxonomy community profile  synthetic  hmp mock metagenomes species identification proceed straightforward  metaphlan motus  kraken   apply  postfiltering   data data generate   aligners bwa  blastn  filter   species genomes recruit  hit  discard    limit  gross overreporting  false positives relative abundance calculations proceed  upon finalization  species identification species relative abundances  provide  metaphlan motus  kraken whereas   bwa  blastn  calculate  fraction   hit count gottcha relative abundances  calculate  calculate  ratio   base map   species signatures   total linear length   signatures map community profile  real spike metagenomes species identification  relative abundances proceed  describe   relative abundance   organisms detect   tool  organize   pivot table   subset   organisms—restricted    detect  gottcha—formed  basis   summary heat map use  matrix2png web tool  extreme value  trim   outlier effect  air filter metagenome value range     black   red whereas  human stool metagenome range     black   red gray value represent organisms unidentified   respective tool  human stool metagenome  quite large   blastn analysis  limit   random subset   read   dataset also include viral target  motus  metaphlan  currently incapable  classify    viral information  provide   two tool  order  correlate spike level  detectability gottcha hit count  report  addition   relative abundances   heat map gottcha classification efficacy  novel genomes  holdout analyse nearly  prokaryotic draft genomes  vary degrees  novelty    include   creation   gottcha databases  pass   gottcha workflow   modification  attempt  identify  parent taxa  draft genomes  obtain  ncbi   form  draft genome assemblies since genome assembly collapse sequence read   single contiguous representation   essentially devoid   redundant input data read need  distinguish signal  noise  use jellyfish   decompose  contigs   possible mers   mer occur one   time since contig qualities   readily available  qualitybased trim  implement  kmer' multiplicity however  retain   read fragment   map   gottcha database  taxonomic level    determine   taxonomic novelty   genome analyze  example  genome consider novel   genus level  map   family gottcha database  attempt  place    proper family",-0.14095222006098912,0.17592982566148285,0.10946556008982253,0.07964972514747608,-0.026539134780332967,-0.04155497026991115,-0.013114791583582485,0.04505749908321083,-0.032753629457081435,0.12404066499741777,0.011518790999811923,-0.029487506775330043,0.1073426601743834,-0.06193411834390392,0.1314574246536362,-0.010399544426746954,0.0668863448840572,0.15806035022873954,0.0057148194040821205,0.04097611612922248,-0.02266963752243249,-0.21412113914537312,0.06387503799697505,0.019363190759940828,-5.3703556630042356e-05,-0.12448804332172307,0.08420999463953928,-0.11198161333485508,-0.059856374974857726,-0.015400430846541885,0.02295571633067613,0.1971303942501256,-0.1599651146619876,-0.03808161283818822,0.17587629352600007,0.05480660000884662,0.03455586516359197,0.0012896508394100766,-0.059212212393498276,-0.08584059798234006,-0.08480965607392361,-0.1064372734166456,-0.11153459439724236,-0.0859715126532842,-0.07914669950174008,-0.016796930814814003,0.09673118240799924,-0.12133388623461505,-0.2126920652085732,-0.2533155374536484,0.13306380042572533,0.00680246849226275,0.04079388477508205,0.4518202068684755,0.003336085535960578,-0.8991738179382924,0.03707393109729155,-0.18725987027176647,0.8077325747803337,0.16126726409105094,-0.12265942430453955,0.25764898926865,-0.009597050734792015,0.0925585629061114,0.4568991132118506,0.020006095330939624,0.021976066356827386,-0.02291847811921477,0.1878126472229304,-0.14767957400222748,-0.06950891420684194,-0.01439158946506433,0.10264501640670884,-0.062472232773837975,0.13330192527654527,-0.022761185853356517,-0.0843718176647987,-0.14324695267262755,-0.2954074916556549,-0.045601870314885495,0.15861657553037356,-0.004395910890087397,-0.3378469377919635,-0.0197892981237415,-0.6815761045102792,0.07276276514492266,0.23012335299840134,-0.12215316290556025,-0.09198066189567068,-0.0008272828665382157,-0.15703585743538906,0.07122367264264362,-0.11827790861218003,-0.049445306133789266,-0.053602335917646536,-0.05959599581528256,-0.08134451726740521,-0.27536326993114035,0.2780492561304566,0.0448848815461052,Classification,1
41,41,"genometa   fast  accurate classifier  short metagenomic shotgun reads
metagenomic study use highthroughput sequence data  investigate microbial communities  situ however considerable challenge remain   analysis   data particularly  regard  speed  reliable analysis  microbial species  oppose  higher level taxa   phyla   present genometa  computationally undemanding graphical user interface program  enable identification  bacterial species  gene content  datasets generate  inexpensive highthroughput short read sequence technologies  approach  first verify  two simulate metagenomic short read datasets detect      bacterial species include   false positives  false negative subsequent comparative benchmarking analysis  three popular metagenomic algorithms   illumina human gut dataset reveal genometa  attribute   read  bacteria  species level  include  strain   species  demonstrate similar  better accuracy    program lastly speed  demonstrate   many time   blast due   use  modern short read aligners  method  highly accurate  bacteria   sample  represent  genomes   reference sequence  cannot find species absent   reference  method  one    userfriendly  resource efficient approach   thus feasible  rapidly analyse millions  short read   personal computer
genometa  program   extensive modification   establish integrate genome browser igb genome browser  igb  select    functionality clear user interface  extensible welldocumented java source code  igb codebase  fork  order  develop genometa   separate subversion repository sam  bam conversion  implement use  picard java library   read  bam file  count map  metadata  subsequently display   histogram    genome browser initially support   bowtie algorithm    include   graphical interface  bwa    include   future reference sequence  metagenomics  prokaryotic chromosomes  various source  concatenate  use  build  metagenomic reference sequence  include  august  versions   ncbi refseq collection  human microbiome project   genomic encyclopedia  bacteria  archaea   metahit programme    moore foundation marine microbial genome sequence project   earliest sequence strain genome   species  include use  inhouse script  include genomes  list within  genometa program  short read    map onto  reference   similar fashion   routinely use  genome resequencing  reference sequence  use  derive  result mention   paper reference sequence   update regularly use complete  draft genomes   resources  well  novel resources arise   future   design  java program name refselector downloadable   genometa website  allow customisation   reference sequence users modify  taxa   include list run refselector  receive  new reference sequence contain   genomes include   modify list accuracy  simulate metagenomes  advantage  use simulate data  assess  program    true origin  method  production   datasets  know  hence positive predictions  indeed  verify  short read offer  lowest cost per     underutilised  metagenome researchers  date   start   first base  sequence  filter  metagenomic project  longer read use  inhouse perl script   exception short read  extract  sanger read  position   avoid ambiguous base present  read start default bowtie settings  use  analyse   simlc   simulate ocean metagenome datasets simlc   dataset construct   researchers  allow objective assessments  metagenome analysis program  simulate ocean metagenome  create  metasim  use  read  ten marine strain  read  marinomonas  mwyl1   shewanella loihica   read  oceanobacillus iheyensis hte831  read  nitrosococcus oceani atcc19707  read  alcanivorax borkumensis sk2  read  synechococcus elongatus pcc6301  read  halobacterium salinarum   read  prochlorococcus marinus ccmp1375  read  nitrosopumilus maritimus scm1   read  candidatus pelagibacter ubique htcc1062 alignment speed comparison  blast  bowtie  order  test  alignment speed  blast  bowtie    datasets read  collect   human gut study   human stool diarrhea study   vineyard study    cystic fibrosis lung dataset  bowtie  run within genometa use default settings   exception   number  thread  raise  achieve optimal resource usage blast   run   follow settings blastall  blastn  allspecies_august2010fa  input            output1 analyse  run    machine  result  normalise  ensure comparability extrapolation  blast result  consider    hours  elapse  order  save power benchmarking algorithms   illumina human gut microbiome dataset  first  illumina   read  extract   illumina human gut dataset derive  stool sample srr042027 human microbiome project    read  take   represent  upper limit  could  late   submit  one   metagenome webservers test   first read   read pair  use  ensure comparability   program  test since  lack functionality  deal  pair end read  exact bowtie command use   genometa assessment  bowtie  allspecies_august2010 sam    gutfa gutsam megan  mgrast   carma3    run  default settings",-0.1790106444343381,0.17831790605588868,0.08168423294721704,0.05600702368563203,0.031666705149489084,-0.024102050678141817,-0.07767083518885319,-0.0076441090159560686,0.02546598210132548,0.10137937555193716,0.013185508928828587,-0.010566317580455209,0.13537414351007135,-0.11681116657401724,0.11428341726540743,-0.009458386013862787,0.13215343505979274,0.16109233967737896,-0.05195588267463265,0.10489272451431704,-0.08747146060250653,-0.20383292633131933,0.06300268134952564,-0.0057771629126025185,-0.025664748009352117,-0.13895945702748147,0.0635834614190769,-0.09336221662295044,-0.07524146850116736,0.00876899718206451,-0.006493807039597803,0.2472139425954083,-0.21024179412341265,-0.0547928399090389,0.2325545337195949,0.09176211261193366,-0.016373752849176526,-0.06134695062299566,-0.1042924437215277,-0.0994999296417292,-0.14138950946721282,-0.053474470964789834,-0.09546494205292133,-0.08944174961291068,-0.07805354391591282,-0.0004597229055875206,0.09442579816963224,-0.16726902356969267,-0.1664079624549587,-0.2438361772769189,0.1900560218798899,0.053375502712070165,0.05184023817317844,0.465519837858676,0.021451192566696902,-1.0061723076050049,0.014290587620821244,-0.21101756722475432,0.8657063470650117,0.11109195451952823,-0.138620970316715,0.30949750077774785,-0.043732863482845635,0.058021159666902765,0.5400497486600826,0.04538443040750597,0.009170193950617064,-0.026790327704345283,0.1988462765975161,-0.20450579192325247,-0.02833226409878854,0.045045651391333666,0.11528554482460356,-0.14110490335954168,0.10793685557621514,0.002782103372737765,-0.109902195555902,-0.09115815696578404,-0.398826322687489,-0.06290219089389426,0.19303820261360086,0.010909645306597238,-0.30441368358648635,-0.00279489795168318,-0.7425800391833691,0.11283224530992393,0.23090512566094906,-0.14855054139104665,-0.15498697672397915,-0.00811507705711508,-0.07911043273399278,0.05366137092253367,-0.045926690990872085,-0.04513698459895015,-0.047958666576587414,-0.03959974017600176,-0.11572098562288567,-0.3097561323736513,0.26684332990683385,0.04648217675818408,Classification,1
42,42,"scalable metagenomic taxonomy classification use  reference genome database
deep metagenomic sequence  biological sample   potential  recover otherwise difficulttodetect microorganisms  accurately characterize biological sample  limit prior knowledge  sample content exist metagenomic taxonomic classification algorithms however   scale well  analyze large metagenomic datasets  balance classification accuracy  computational efficiency present  fundamental challenge  method  present  shift computational cost   offline computation  create  taxonomygenome index  support scalable metagenomic classification scalable performance  demonstrate  real  simulate data  show accurate classification   presence  novel organisms  sample  include viruses prokaryotes fungi  protists taxonomic classification   previously publish  gigabase tyrolean iceman dataset  find  take     single node  core large memory machine  provide new insights   metagenomic content   sample
kmertaxonomy database  reference genome database consist   collection  genome sequence   genome sequence assign  taxonomic identifier  first step   convert  raw reference genome database   searchable kmertaxonomy database  store every overlap kmer along  select taxonomic ids  reference database  construct  complete  partial microbial genome sequence   ncbi genome database  october    raw genome database include   distinct genomic segment plasmids chromosomes   genomic segment  contain   viral  bacterial   archaea segment  remain segment  share among draft eukaryotic microbial genomes   include  assemblies  many contigs  supplementary mitochondrial genomes  eukaryotes  reference set include  bacterial species  archaeal species  viral species   eukaryotic species microbial genome segment range  length   small number  single read contigs  length less   base      base chromosome  sorangium cellulosum taxonomic ids represent nod   taxonomy tree  cover  rank   individual genome  strain    highest order domains figure  show  example representation   searchable database  input database construction require   ncbi taxonomy tree   reference genome sequence database  iii mappings   genome sequence identifiers  taxonomy identifiers   taxonomy tree   overlap kmers   genome database  compute   lca   taxonomic ids   kmer  identify finally  postorder tree traversal    lca count  number  genomes  contain  kmer   taxonomy node   traversal  initial expectation   use kmer count  weigh  kmers contribution   candidate taxonomic label assignment however  weight procedure  find   sensitive  genome representation bias  therefore  binary score scheme  choose   experiment  use  full kmertaxonomy database kfull   smaller database build   marker library kml  marker library contain   taxonomically informative set  kmers present   raw genome database  marker library  create  separate kmers  disjoint group  kmer   exactly one group  group   unique label  consist   name   genomes   generally sequence include genome plasmid segment  chromosome  contain  kmers   group  example kmers  occur  exactly  genomes       one group    kmers  occur   genomes     another group    kmers  genomes       third group       concrete example suppose kmer1  present  yersinia pestis kim ypestis co92  yersinia pseudotuberculosis ip32953 kmer2  present  ypestis co92  ypseudotuberculosis ip32953  kmers   lca  yersinia   build  marker library    two separate group base   exact set  genomes  contain  kmer kmer1s group  label ypestis kim ypestis co92 ypseudotuberculosis ip32953  kmer2s group  label ypestis co92 ypseudotuberculosis ip32953   kmers  group contain    kmers  include   marker library      kmers  kmer1s group    kmers    marker library     kmers  kmer2s group  none   kmers    marker library kmers whose lca    taxonomic rank  family   include   marker library  kmertaxonomy database  create   marker librarys set  kmers  score  read taxonomic ids   kmertaxonomy database  kmer  length   associate   list  taxonomic ids  outline  section   first step  determine  taxonomy    read   query set   assign  score   taxonomy    kmer   read  score  derive   proportion  kmers   read  occur   taxonomy node normalize   proportion  kmers   random read  also appear   taxonomy node  illustrate  detail   score algorithm  example  figure  show  query read  three kmers  tax ids   read constituent kmers  retrieve   kmertaxonomy database   read   length   binary classification table   size forumla  construct     row represent  kmers retrieve   read    columns represent candidate taxonomic ids kmers  store   database  canonical order remove strand specificity  canonically order kmers  use  query  database   entry indicate  tax  column belong   associate kmer row   tax    proportion  kmers   tax   compute show  fig    last row forumla⁠   example forumla  genome   score method use  random model  limit genome representation bias   database  avoid assign taxonomic label  random chance   novel organism   represent   reference database  score   read    taxonomic    define  forumla⁠  prj represent  proportion  kmers associate  taxonomy     random model  random model estimate prj  chance  assign  read  length   taxonomy   owe  random chance  simplicity  random score   show  fig   random model  precomputed  read length   assume  random nucleotide composition   optionally sample explicitly   range   content value read  randomly generate    search   database  calculate   value   random read   observe taxonomy   prj  set   maximum observe value forumla⁠  detail  random model construction  include   supplementary material  rankflexible read classification taxonomy classification combine lca selection   read label score evaluation candidate label  examine  order  decrease read label score  show  figure   illustration  numerator   read label score   show   specific taxonomic label  select     taxonomic label   conflict lineage   comparable read label score comparable  define   score within one standard deviation   best candidate use  read label score distribution   read  best candidate  find use  taxonomic lineage   highest score taxonomy label  path   highest score node   lca  create lcas  individual kmers identify offline  use   start point  find  lca   retrieve kmers online    case  reduce run time cost   subsequent label  evaluate  consistency   lineage  conflict label  encounter  lineage  prune    tree  resolve  conflict   example show  figure   lineage     lca   construct first    examine   identify  conflict     candidate lineage  prune  node   process continue   ninth label  encounter ⁠forumla⁠    purpose  illustration   score   threshold  comparable score  classification procedure terminate   read assign label  classifications  divide  categories  lca match category mean  lca   lower read label score    multiple conflict label  higher comparable read label score    traditional lca assignment algorithm huson     multiple significant match  compete lineages  find  direct match category mean  classification reflect match   taxonomy without  conflict lineage   classification could    rank include strain species genus  higher higher order rank assignments   direct match category imply   read label score  lower rank assignments    comparable score threshold  suggest sequence novelty   classify sequence novel match  report  multiple child nod  compete lineages  comparable read label score   threshold   lca   higher read label score  indicate novelty   query read  could occur   substantial subset   read kmers  find  compete lineages   combination  kmers observe   lca node   significant  database ingest  key feature   approach   store  kmertaxonomy database   file rather  build  anew   query run  permit shift computational cost   offline taxonomygenome ingest phase  database  create     use repeatedly  classification  enable database search  classification  file  map   memory address space   classification program allow kmers  associate taxonomy ids   access directly previous work  lawrence livermore national laboratory llnl  modify  jemalloc memory management library evans   enable memory allocation   address range memorymapped   file reside   storage device jemalloc   dropin replacement  regular malloc routines  allocate memory  modification  jemalloc allow   additional step  specify  database filename jemalloc memorymaps  temporary file   choose  use  memorymap file approach rather  implement  outofcore index algorithm    ease  program use  memorymap abstraction   persistent storage  data structure  place  memorymapped file onto  ramdisk  inmemory performance  ingest utility create  database  include  hash table whose key  kmers  value  set  taxonomy identifiers supplementary table  show number  kmers present   total storage require  several   databases  current default settings use   kfull    kml  databases use  bytes per taxon include genome count information  find   count  extraneous information    bytes per taxon identifier  require use  bytes per taxon allow    distinct taxa  current database    distinct taxa future work  expect  reduce  database size    kfull    kml  ingest pipeline   full database take   use     ghz advance micro devices amd compute nod     run singlethreaded task  dump intermediate result  file   parallel file system  test data  compare performance  exist stateoftheart publish tool accuracy  compare  phymmbl brady  salzberg  metaphlan segata     genometa davenport    phymmbl balance classify know species  classify novel organisms  use blast    scale well  sequencer output angiuoli    metaphlan use  small marker library make  scalable     attempt  label every read   also optimize   relative abundance estimation  lmat currently    genometa replace blast   potentially faster search algorithm bowtie2  bwa  attempt  assign  taxonomic label  every read ideally   reference database would  use   program however adapt  database  work  genometa  phymmbl require significant customization    technically feasible  metaphlan therefore  exist reference database   tool  use  genometa database   oldest database create    reference database  create  fall   phymmbl  metaphlan use databases create  mid   publish phymmbl dataset  use  read length    choose   test query dataset   test data  create   reference database  create  query species   present   reference database three additional simulate test query set  use  evaluate  accuracy   method   presence  query sequence absent   reference database  viruses prokaryotes  eukaryotes fungi  protists metasim  use     barthelson       richter    illumina error model  generate  novel bacterial  viral dataset respectively eukaryotes  take  single species sequence data deposit   short read archive sra  include trypanosoma evansi candida albicans coccidioides immitis aspergillus fumigatus  entamoeba histolytica read lengths range       bacterial dataset  sequence  find   reference database determine  genbank identifier  header comparison  select  random  serve   candidate test set     simulate read  equal concentrations    bacteria   strain  make    distinct species     species  find   reference database   viral case  read  generate assume equal concentrations   viral genomes  make   distinct species      find   reference database  every test sequence   novel datasets prove   divergent   reference database  detail description   test data  give   supplementary material  measure run time three nonsynthetic metagenomic sample represent  viral metagenome srx022172  human microbiome metagenome err011121   single species raw read metagenome drr000184  take   sra",-0.17351697247292025,0.2175514870121273,0.11877737037207092,0.10261256482109944,0.0007036534221080399,-0.022187946055629786,-0.07460501260844878,0.0181799695888792,-0.007574287544324138,0.12100159817603988,0.039468810326949884,-0.01160236691931702,0.15602899420320318,-0.09352287305321556,0.1130259138727838,0.0037672503151954468,0.08009512417815394,0.21618297261763028,-0.02717226819878673,0.07105031178127663,-0.02737481111422776,-0.2372240693974227,0.0722895059987043,0.016617393485346688,0.009687560540805508,-0.21177142653904754,0.10079165780973542,-0.1278413319574455,-0.05672037048946356,-0.03159594513032473,0.00911853566913744,0.21120472073638505,-0.1441592103367096,-0.08478185818015486,0.21312685118000785,0.10200302464275696,0.034254011078093186,-0.012162764338852718,-0.08966366316363865,-0.09262693726156293,-0.07456417456922823,-0.12451839607310973,-0.07603984897274099,-0.05561360635555968,-0.10512728469918772,0.02222612186136009,0.09809153670027304,-0.12233175655981693,-0.23380065561234986,-0.2732181867480652,0.19086621372191667,-0.004699452120273376,0.07203723009066205,0.5024992150266347,0.025269669873324963,-1.028498549517208,0.042409877153930436,-0.2498126963717857,0.9266885381053996,0.2261591951834726,-0.15346443430629747,0.3208033272244951,-0.030487683949788725,0.08105155765852795,0.6063513240012655,0.05211146541196693,0.03752812532595491,0.003163853448159361,0.2348824862634026,-0.2051721725174449,-0.07100335136765812,-0.005779456955968034,0.07993788057874678,-0.11290318172898862,0.1712200602649967,-0.0038272392623794594,-0.13772149336366366,-0.18100594870986847,-0.36483585067705177,-0.05199213657829072,0.15088402867604778,-0.01721803024608631,-0.3535252276891534,-0.043753918925582544,-0.7534238462670857,0.05708488834101424,0.2448797413005247,-0.16683465705891312,-0.08821480501271588,-0.023769496025660097,-0.20050715468052344,0.0735163622343782,-0.06589116750562565,-0.060650876231017725,-0.07660864455186643,-0.08871998210468457,-0.06326751444841867,-0.3491239933078958,0.2865835197647075,0.06465545399672737,Classification,1
43,43,"dudes  topdown taxonomic profiler  metagenomics
species identification  quantification  common task  metagenomics  pathogen detection study   recent techniques  build  map  sequence read   reference database  whole genomes marker genes proteins follow  applicationdependent analysis step although  methods   prove   useful  many scenarios   still room  improvement  species  strain level detection mainly  low abundant organisms  propose  new method dudes  referencebased taxonomic profiler  introduce  novel topdown approach  analyze metagenomic nextgeneration sequence ngs sample rather  predict  organism presence   sample base   relative abundances dudes first identify possible candidates  compare  strength   read map   node   taxonomic tree   iterative manner instead  use  lowest common ancestor  propose  new approach  deepest uncommon descendent  show  experiment  dudes work  single  multiple organisms   identify low abundant taxonomic group  high precision
 dudes workflow require three main input  set  read reference sequence   taxonomic tree structure fig   map  read   reference sequence  sam file      create  linkage   reference sequence   taxonomic information  perform  dudesdb  store   database file  file serve  input  dudes profiler  perform  iterative topdown analysis   taxonomic tree structure  first step   dudes algorithm   assign  set  reference sequence  read match   node   taxonomic tree   root node contain  sequence  match   escherichia node genus  contain   sequence correspond   organisms  belong   classification   respective match  general idea   start   root node   deeper   tree fig  evaluate  taxonomic level  identify nod  significant match    ones    consider present   sample  presence   node   certain taxonomic level  define   follow step comparison  dud  lca dud   topdown approach  start  low taxonomic level lca   bottomup method  solve ambiguities  high taxonomic level  node mark   circle  consider  lca   children nod dot arrows represent  dud    specific  higher taxonomic level point  candidates nod  lca   conservative  go back   lca step  identifications   taxonomic level  taxonomic tree structure   test level  black   reference sequence   node r1rn nod      first ones   compare     bin generation reference sequence green   respective read match  subdivide  bin   bin  matchbased score  calculate cpvalue estimation —bin score   node  blue reference r1r4  compare  bin score  node  red reference r5r7  black line represent  cutoff value base   top   bin score  node  —  best bin  select base   cutoff permutations   perform among  select bin — distribution  generate   randomly permute difference  mean  bin score  red dot line represent  critical value   green  observe difference  mean   example node   therefore significant  node  pvalue ≤ critical value  identification step      repeat   pair  nod   example node   identify      significant node    others row    node could  significant   columns  bin generation first  create  set  bin   node   tree bin  subsequences   reference sequence assign   node fig    nonoverlapping  equalsized  bin size  fix   nod    define  default   25th percentile   sequence lengths   whole reference database  bin size    balance point   number  small sequence   database  speed requirements  smaller  bin size   calculations  need  larger  bin size  bigger  chance  higher nod lack  full bin   analysis  25th percentile provide  good tradeoff   ensure   majority  reference sequence    least one full bin  one   subregions    bin score base  read match define   sum   match score   match score  define   match   msmle      length    edit distance   match minimum number  edit operations—insertions deletions  substitutions  letters—transforming one sequence  another levenshtein  bin score    take  number  match   bin  account  also  number  mismatch  indels   subregions  pvalue estimation dudes perform  pairwise comparison   nod   taxonomic level estimate  pvalue   pair  permutation test  permutations occur   nod bin score  bin  score higher  zero  consider additionally   best bin  permute  cutoff  choose base   number  bin represent  top  score   main node fig   cutoff  useful  order   prioritize nod  larger   reference sequence mean   comparison   certain node   node     different cutoff value   comparison    node     example consider  node    bin   node     bin  compare      first  bin  node   go   compare   first  bin  node   compare      bin   nod  go   consider supplementary figure   one   nod    enough bin   compare  cutoff   reset   total number  bin   node  fewer bin supplementary figure   cutoff  also useful  remove poorly map bin  low score   normalize  number  bin   two compare nod allow  fair comparison    limit  five bin  require   node  allow  significant permutation permutations   select bin score  perform  time  default  value  randomly shuffle  separate  two group base   cutoff value  random difference  mean   group  calculate generate  distribution like  one show  figure   onesided pvalue   estimate base   observe difference  mean   actual bin score supplementary information—pvalue estimation  estimate pvalue  consider significant    lower   certain critical value  many hypotheses   test multiple test correction  necessary  control  type  error    risk  falsely reject  hypothesis   true goeman  solari    apply two methods bonferroni correction locally taxonomic level   meinshausen procedure globally tree level meinshausen  two methods  apply together  multiple test occur  two ways several taxonomic level   tree  several nod   taxonomic level  test  meinshausen procedure  choose    hierarchical approach   achieve larger power  coarser resolution level   apply  control  multiple test error generate  several comparisons   taxonomic level   tree bonferroni correction  apply locally  correct   multiple test perform among  nod   taxonomic level although  bonferroni method  highly conservative  general    critical   application since  number  nod   taxonomic level  usually fairly small  critical value    node   calculate  cvnαn1lnl      significance level threshold default      total number  nod   test taxonomic level minus  comprise  bonferroni correction additionally    total number  leave   tree    total number  leave  node   stand   meinshausen procedure correction  nod  test       level    pvalue   comparison    critical value  comparison  set  significant  picture   table  figure   identification   nod within  taxonomic level   compare      evaluate use two criteria  many time    significant   many time  nod  significant   columns  row  fig  respectively  number  occurrences   two metric  sum   node  dudes select  one   minimum value  identify therefore present   sample   metagenomic dataset   possible    one node  identify     bin  similar abundances   case two   nod  sufficient number  bin  match  could   significant     go   identify concurrently  mean    one node  go   consider present   current taxonomic level lead    one path   follow tree analysis  threestepalgorithm consist  bin generation pvalue estimation  identification continue   next taxonomic level    children   identify nod  process  iterate   reach  leaf nod   tree  consider  deepest possible uncommon descendent— species level  default     identifications  possible due  lack  minimum match  bin support    point   advantage   dud method   lca   lca  apply  result tend    conservative   solve ambiguous identifications  go back one taxonomic level   lca instead  dud approach  always try     deeper taxonomic level even  ambiguities  find fig   way   possible   identifications  higher taxonomic level besides   provide data   allow  specific identification  higher level   still possible  propose  set  likely candidates base   concurrent identification   specific  go back   taxonomic tree   end   tree iteration one   paths   tree   leaf nod  identify  candidate tgs   present   sample  metagenomic sample  contain hundreds  thousands  organisms handelsmanl     filter step  perform  remove identify match  allow  iterations dudes perform  step  filter   direct match   identify candidates reference sequence furthermore  match   read    least one direct match  analyze   read match    lower   direct match   consider indirect match   filter   well   new set  match  new iteration  start   root node several iterations  perform   number  match    certain threshold    match  filter   end  relative abundance value  calculate   final candidates   base   direct match   identify leaf nod  normalize   length   respective reference sequence  identify leaf node    abundance  calculate  abn∑∑tj1msl      number  reference sequence belong   node     match belong   reference     match score     length   reference   abundance   parent nod  base   cumulative sum   children nod abundance dudes output  file   set  final candidates   bioboxes profile output format    strain identification  select dudes output  additional file   identify strain   relative abundances  strain identification optionally dudes  try  extend  species identification  provide  set  probable strain present   sample  process  strain identification work identically   threestepalgorithm  start  analysis   one   identify species nod sequence among strain usually  high similarity   composition  make  identification process  challenge   reason  implement  postfiltering process  better select  candidate strain give  set  identify strain   threestep method  choose one representative candidate    maximum sum value     set alternatively  provide  second output report   strain identify   relative abundance  dudesdb dudesdb preprocesses  taxonomic tree structure   reference sequence generate  database file   use  dudes profiler  current version  dudesdb support  ncbi taxonomic tree ncbi   use    accessionversion identifier  make  link  reference sequence  tree nod   strain level   directly define   ncbi taxonomic tree structure  consider  unclassified node   tag  rank   species level   strain node  map dudes  handle multiple match  account   map quality  match score improve  identification capabilities  default  number  allow match    high  possible allow  match  feasible since    computational impracticable  use  default value   match   read  map parameters   find   supplementary information—tools  parameters  experiment dudes evaluation  perform  four distinct datasets two synthetic communities  two real metagenomic sample first  analyze synthetic metagenomic data  available grind truth  evaluate  precise   identification method  choose  common set  metagenomics evaluations— human microbiome project hmp mock community turnbaugh      vitro synthetic mixture   organisms  bacteria  archaea   eukaryote  mimic errors  organism abundances  real metagenomics sample  bacteria  archaea  consider   evaluation   set  also divide  subsets  different percentages  read  compare   metagenomics analysis tool kraken wood  salzberg  gottcha freitas     metaphlan2 truong      choose   rather different approach  solve  taxonomic profile problem    good result  recent metagenomics study lindgreen    kraken   read bin tool  use  kmer approach  classify  read   give sample  focus  high performance gottcha   taxonomic profiler  use nonredundant signature databases  aim  lower false discovery rat metaphlan2 rely   curated database  approximately  million unique cladespecific marker genes  profile metagenomic sample  second synthetic community consist   laboratorymixed microbial genomic dnas  also evaluate shakya     community make  organisms  know sequence    broad diversity among bacteria  archaea   wide range  genetic variation  different taxonomic level    time  dataset provide  large number  sequence read   allow   realistic performance evaluation  also apply dudes  real metagenomic sample  gut microbiomes   outbreak  shigatoxigenic escherichia coli stec  germany   loman      dataset  evaluate  well dudes perform   real scenario  profile  pathogenic sample  compare  result   previously know experiment furthermore  evaluate  set base  previous know information  lab experiment  tool base   lca approach perform   specific profile lastly  profile  marine dataset  tara oceans sunagawa     bacteria archaea virus  eukaryotes present   sample show  versatility   tool datasets detail  show  supplementary table   hmp  stec sample  preprocessed   digital normalization algorithm brown     decrease sample variation   error correction   analysis  reference database  dudes  kraken  generate   set  complete genomes sequence bacteria  archaea together   taxonomic tree structure   ncbi ncbi   march    organim set  use without  filter   set  use   database   addition  four noncomplete genome sequence taxid        species   sample available   tara dataset  make  custom database contain  expect marine organisms bacterial archaeal  viral taxons  obtain   reference sequence use   tara oceans project sunagawa      eukaryotic set  taxons  obtain   mmetsp keel     ncbi refseq sequence relative   taxons  collect  generate  database  january    metaphlan2  gottcha  set  use  provide database v20  v20150825 respectively bowtie2 langmead  salzberg   use  read map parameters  usage detail   tool   find   supplementary materials—tools  parameters  evaluate  output   tool base   binary classification   sort taxonomic profile  binary classification  valid  tgs   certain taxonomic level true positives   tgs present   sample  correctly identify false positives   identify tgs know    present   sample false negative   tgs   present  could   identify  true negative   tgs   database  identify  know    present   sample",-0.1707515710796168,0.23160951457344606,0.12584048675425413,0.0845366249866134,-0.02281569943699972,-0.03215072228048859,-0.07020046736846887,0.025355645038336448,-0.04916336286260048,0.10891897421456899,-0.018044880386750103,-0.021868717444971587,0.17288156141790645,-0.06429116943314404,0.18743974172171232,-0.008289216288497247,0.04298462487943599,0.18987346583454007,-0.0242284121174153,0.08545326400331653,0.02813079560035155,-0.17945195464776856,0.04636837870256225,-0.02259965481489952,0.0008317643217143247,-0.17393384469751788,0.0965990386574798,-0.14666300173078473,-0.04885847566942282,-0.07766902124122306,0.016678656808140017,0.21051933648713575,-0.1230607957486962,-0.084503988869448,0.2153330010928317,0.09698327132355188,0.01789497735679855,-0.005763239037525423,-0.07767758235069562,-0.09373562173213404,-0.12622995901898215,-0.1262556664189694,-0.056892788779591426,-0.09312379578028306,-0.10447049018041392,0.005453808912748439,0.11857975529833578,-0.1359800396098495,-0.2582993733742435,-0.3280364814253356,0.16059168459062625,-0.05159961589186637,0.03077828497857006,0.5781603430180385,0.010064694346510805,-1.1266977746477898,0.06880596971453035,-0.18464212847924072,0.9180666571372806,0.20352193719533235,-0.16901386965342038,0.3567150687590851,-0.04789648443821695,0.05720258470757793,0.6026845650091727,0.04094747175943613,0.021289916112008915,0.0017213690072424015,0.20888852951954026,-0.1978544852060141,-0.061875146081654425,-0.017517611815545772,0.0691100659817975,-0.1209843539058698,0.18527560803576146,0.010784095910126138,-0.14698801489093433,-0.1807121095178659,-0.3488804276421433,-0.03543681653258425,0.21649658792803697,-0.013623393426528577,-0.36224152392113707,-0.04539233536546389,-0.8202679354409852,0.04057917510609139,0.2117762448555475,-0.13593387741398413,-0.11989424753975232,-0.039145627915679465,-0.19901612459280466,0.060729241305499976,-0.11566445204901835,-0.07951054469423766,-0.11377759914723674,-0.08079998641380158,-0.14141740601403666,-0.32237925192449063,0.287597726636758,0.05668491394638241,Classification,1
44,44,"nbc  naive bay classification tool webserver  taxonomic classification  metagenomic reads
datasets  highthroughput sequence technologies  yield  vast amount  data  organisms  environmental sample yet   still  challenge  assess  exact organism content   sample   task  taxonomic classification   computationally complex  annotate  read   dataset  easytouse webserver  need  process  read  many methods exist     publicly available  webservers        annotate  read  introduce  webserver  implement  naïve bay classifier nbc  classify  metagenomic read   best taxonomic match result indicate  nbc  assign nextgeneration sequence read   taxonomic classification   find significant populations  genera   classifiers may miss
 select  previously benchmarked dataset gerlach     biogas reactor dataset schlüter    compose    read  average   length  select  real dataset  oppose   synthetic one     want  tailor  dataset   specific database since  database  vary   web site  comparison fairly assess  webservers performance   realdataset contain know  novel organisms  conduct  test  nbc  five  webservers  july  august   webcarma  mgrast require  parameters phylopythia require  type  model  match  mgrast require  evalue cutoff   seed viewer   select  highest  select default blast parameters    database  galaxy  nbc  use  nmer size     default  organism genomelist  camera   retain  best tophit organism   read  use   prokaryotes blastn database  use  default parameters   rest  implement  nbc approach  rosen     assign  read  loglikelihood score  introduce two function  nbc   novice functionality    expert functionality  expect   users  fit   novicecategory   enable   upload  fasta file  read  obtain  file  summarize result match  read    likely organism give  train database  parameters  expert  novice users  choose    follow upload file  fasta format file  metagenomic read  webserver also accept zip   tgz  several fasta file genome list  algorithm speed depend linearly   number  genomes  one score     expert user  prior knowledge   expect microbes   environment heshe  select   microbes    score     speed   computation time  reduce false positives   algorithm nmer length  user  select different nmer feature size    recommend   novice user use   since  work well   long  short read rosen    email  users email address  require      notify     retrieve  result   job  complete output   beginner  suggest   upload  fasta file   metagenomic read   enter  email address  output   link   directory  contain  original upload file rename  useranalysisfiletxt  genomes   score  mastergenomelisttxt   summary   match   read summarized_resultstxt  expert user may  particularly interest   *csvgz file  heshe  analyze  score distribution   read   depth  discussion  figure   show  percentage  read    whole dataset  rank   top eight genera   algorithm  see   methods   unanimous agreement  clostridium  bacillus   methods except galaxy agree  prominence  methanoculleus camera support nbcs find  pseudomonas  burkholderia know   find  sewage treatment plant vinneras     biogas reactor contain  chicken manure      traits  sludge waste schlüter     hery    pseudomonas  sorangium   find  sludge waste streptosporangium  streptomyces  commonly find  vegetable garden nolan      quite reasonable since    agricultural bioreactor therefore nbc potentially  find significant populations  genera   classifiers  miss thermosinus    nbcs complete microbial train database  therefore    find  match nbc take    run  classify     read compare     webcarma    camera    galaxy     weeks   mgrast nbc run   core intel machine  speed would linearly increase  distribute compute   future",-0.2179922967307205,0.22364342059216336,0.1319928699745634,0.048769677305132035,-0.047734167596484106,-0.05321485640285058,-0.055795560467739175,0.048340198313167625,0.005411226611021299,0.08888173990074343,0.05027323942560415,-0.027580019624456185,0.12237177225239955,-0.16140932106826267,0.10892706591222624,-0.008401271656097829,0.12356815070036595,0.19797503642283035,-0.07056335014592975,0.1593825537246623,-0.05636702831238941,-0.2016228007837632,0.06692041977906109,-0.0027105388937286976,-0.0506064759697332,-0.18640421336884933,0.08257338886312571,-0.1363081362219383,-0.0283906474301606,-0.006599088929514147,-0.010755230659572049,0.2799983489319913,-0.161932512034857,-0.0608546163416612,0.23480306983018,0.17552723467364445,-0.014036299159042826,-0.052858004043268604,-0.0977103470713207,-0.12849935693142922,-0.1001374226155088,-0.10329731517542892,-0.0901748438852175,-0.1171900656723143,-0.08630824358407371,0.0017707223281789527,0.08665936615754842,-0.1780540566727187,-0.18185827520165174,-0.3234448460789845,0.18619082693115246,-0.03103643717346244,0.06205317478959969,0.5291189158393085,-0.008002686281571194,-1.105875358028814,0.007123972530893678,-0.203883835409638,0.9722477274029984,0.21622679687521146,-0.15403000370280315,0.3604552063729087,-0.07589778256631463,0.03392666260429384,0.6288537880759542,0.05795651846671344,0.08047836047936549,0.04102159655551866,0.20246047432202294,-0.18477398624089586,-0.04521810513112943,-0.009986233054624163,0.07857382315102253,-0.09315108064049492,0.13045097943287082,0.03117713006754774,-0.12218901462890858,-0.1584116880855949,-0.3847474487152767,-0.047506469214793526,0.26137944813745545,-0.005061156698953823,-0.42204763346654905,-0.0429668109304481,-0.812848300462798,0.024751493800702226,0.22712091007743698,-0.11906803676408675,-0.16142249678044088,-0.03038690302993871,-0.13437593225732647,0.061667810286243636,-0.05029108052957775,-0.0828846223247278,-0.0924325662939412,-0.04053255730505325,-0.1294364451463226,-0.2998496314091969,0.3288733078809383,0.08619844237867699,Classification,1
45,45,"kodoja  workflow  virus detection  plant use kmer analysis  rnasequencing data
rnasequencing  plant material allow  hypothesisfree detection  multiple viruses simultaneously  methodology rely  bioinformatics workflows  virus identification  workflows  design  human clinical data    beyond sequence map  virus identification  present  new workflow kodoja   detection  plant virus sequence  rnasequence data kodoja use kmer profile   nucleotide level  sequence map   protein level  integrate two exist tool kraken  kaiju kodoja  test  three exist rnaseq datasets  grapevine  two new rnaseq datasets  raspberry  grapevine kodoja  show    sensitive   method base  contig build  blast alignments  viruses detect compare    application  kodoja  raspberry show  fieldgrown raspberries  infect  multiple viruses   rnaseq  identify lower amount  virus material  reverse transcriptase pcr  work enable  design  new pcrprimers  detection  raspberry yellow net virus  beet ringspot virus kodoja   sensitive method  plant virus discovery  field sample  enable  design   accurate primers  detection 
 kodoja workflow  kodoja workflow combine two exist tool kraken   taxonomic classification use kmers   nucleotide level  kaiju   sequence match   protein level kodoja  three main components summarize  fig   kodoja_build  database generation  kraken  kaiju  kodoja_search   taxonomic classification  rnaseq read   kodoja_retrieve  extraction  viral sequence  species  downstream analysis kodoja_build database generationfor virus classification  main kodoja components kraken   kaiju   require  database generate   genome  proteome  know plant viruses   available  genome  proteome   plant host data download  database generation  achieve use  kodoja_build module  module download genomes  protein sequence file  refseq    implement code  kraken  kaiju  generate toolspecific databases  user  specify   viruses   plant viruses  include   databases   host genome  available either provide   user   refseq    also  add   database  host sequence classification  make kodoja easy  use readymade plantspecific viral databases  kraken  kaiju  provide  download     generate  download  complete virus  viroid genomes  protein sequence file  ncbi refseq release    select plant viruses use information   virushost    kraken kmer size  specify  build  database   kmer size    use   rnaseq datasets kodoja_search taxonomic classification  virus readskodoja_search   main kodoja component rnaseq read  first quality check use trimmomatic   trim  discard lowquality read fastqc wwwbioinformaticsbabrahamacukprojectsfastqc  use  summarize  read quality  trim   fastqc report form part  kodojas result kraken    use   nucleotidelevel classification kraken   sequence classification algorithm  assign taxonomic label  short sequence      divide  sequence  kmers  query    kmer database kmers   share  organisms  map   lowest common ancestor   information   use  build  subtree   general taxonomy tree   classification   sequence   tree  node   weight equal   number  kmers   sequence associate   nod taxon  roottoleaf path   tree  score  add   weight   path  leaf   path   largest score   classification use   sequence   use   kmer database make  classification algorithm  fast compare  alignmentbased methods    next step full length sequence read  translate  classify   proteinlevel use kaiju  kaiju translate  sequence  six frame  split  result translations  fragment use translation termination codons uag uaa uga kaiju balance precision  sensitivity  use  minimum fragment length parameter  use  minimum fragment length     number  mismatch permit  one fragment  query   protein database use  modify version   backwards search algorithm   burrowswheeler transform   key component  sequence classification   kraken  kaiju   toolspecific database   provide precomputed plant virus databases    use directly   kodoja workflow  custom databases  also  make use kodoja_build see kodoja_build database generation implementation   kodoja_search module result  read  assign  taxonomic class   kraken  kaiju read assign    virus class   tool set intersection  designate  stringent assignments  read assign   virus class  either kraken  kaiju set union  assign  nonstringent assignments  assignments  give   result summary  include  read count   type  assignment full result  kraken  kaiju  also provide   users  analyse  data  outside   kodoja workflow kodoja_retrieve extraction  viral readsthis module   use  extract speciesspecific sequence  downstream analysis outside   kodoja workflow  user  specify retrieval  read classify   species andor genus use either stringent  nonstringent assignments  ability  retrieve  download  read assign   specific virus give  user  potential  assemble complete viral genomes   analysis kodoja workflow availabilitykodoja  available  direct installation  use   command line  linux  bioconda   alternatively  code   download  github  kodoja  also provide   package  galaxy  open source webbased analytical environment  data analysis    available  github    galaxy tool shed  develop kodoja   package within galaxy make  available  researchers   local installation  galaxy  allow analysis   complete   command line input  use  open source workflow platform   way  tool  also potentially  use   cloudbased galaxy server benchmarking kodoja use exist datasets kodoja  test  three publicly available rnaseq grapevine datasets  analyse   presence  viral sequence    original work sequence data   grapevine sample  obtain include multiple sample  skin grain  seed    analysis work viral sequence  identify use contig build  subsequence blast alignment  contigs   reference viral database    kodoja benchmarking  select one library  grain g1r1 sequence read archive sra identifier srr866540 skin s3r1 sra srr866571  seed s3r3 srasrr866576 representative   datasets   largest   diverse viromes  datasets  denote gv1 gv2  gv3 respectively   current analysis assembly  alignment  confirmationto confirm  viruses predict  kodoja kodoja_retrieve  use  extract read assign   virus read   virus   assemble use trinity   minimum contig length   nucleotides  longest contig   virus   align   ncbi nonredundant nucleotide database use blastn   match  lowest evalue select  taxonomic comparison    read  available  contig assembly  read assign   virus species  kodoja  align apply kodoja  virus detection  raspberry rubus idaeus kodoja   apply  rnaseq libraries generate  two raspberry plant  variety glen dee denote    collect   commercial raspberry plantation  angus scotland   plant show viral infection symptoms  show vein yellow   show leaf blade yellow rnasequencingsymptomatic leave  collect   plant     freeze   °  longterm storage  months two sample  leaf  place   clean autoclave   eppendorf tube together   sterile   glass bead freeze  liquid nitrogen   powder use  bead beater qiagen tissuelyser     powder leaf  resuspend   mixture    qiagen rneasy plant mini kit buffer rlt   ambion plant rna isolation aid    mercaptoethanol thereafter  rna extraction follow  manufacturers instructions   rneasy kit   rna  elute  rnasefree water  rna  supply   glasgow polyomics facility   quality control ribosomal rna depletion library preparation pairedend    highthroughput sequence use  illumina nextseq instrument rd_pe275_33m  raw data file  sample    comprise      read respectively available   european nucleotide archive   accession err2784286  err2784287 respectively kodoja analysis  raspberry rnaseq datasetsthe kodoja workflow  run   two raspberry rnaseq datasets use  draft genome  black raspberry rubus occidentalis   host   kraken database build assembly  alignment  confirmationto confirm  predict viruses kodoja_retrieve  use  extract read assign   virus species contigs  assemble  align   reference database  describe  assembly  alignment  confirmation pcr confirmation  virus sequencesto confirm   viruses identify  kodoja  present new sample  total rna  extract   freeze leave  sample    use  thompson buffer method  describe previously   elute  rnasefree water  detection  raspberry leaf mottle virus rlmv  plant rna  convert  cdna use superscript iii invitrogen reverse transcriptase  random hexamer primer follow  manufacturers instructions   rna viruses raspberry leaf blotch virus rlbv  beet ringspot virus brsv  extract plant rna  add directly     illustra readytogo rtpcr bead  healthcare reaction together  virusspecific pcr primers table   detect  dna plant virus rubus yellow net virus rynv six   diameter freeze    leaf discs  extract use  dneasy plant mini kit qiagen accord   manufacturers instructions rynv  detect   elute dna  amplification     illustra readytogo pcr bead  healthcare reaction  virusspecific primers table  positive control  virusdetection  rnas extract  raspberry plant previously demonstrate  carry specific viruses",-0.1960708350988768,0.1924904981842243,0.1081936604461102,0.05926156581381605,0.035932063405855946,-0.03221241877854773,-0.01618612319624235,0.04206281379866893,-0.0009021437505805689,0.09769181688039114,0.02379684901324227,-0.045954412535350826,0.12396537361660433,-0.014993297383700685,0.10271571005600796,0.07227770353825144,0.14535934921807994,0.12601061650554254,0.017199871607137592,0.02551705178296411,-0.10004356690124104,-0.19009747728172613,0.045761084031671694,0.021538481832102573,0.015535205030425941,-0.07622824462122141,0.09082460494583326,-0.06264483641078633,-0.031183077563884408,-0.0027569202335993065,-0.00875778284107145,0.2537781584995119,-0.14581283421236468,-0.06292510249420738,0.17924503271833747,0.06108439246137164,0.021471527967979232,-0.010379540823502316,-0.031426516067432735,-0.10851718074571794,-0.07096487264019953,-0.15229820579310235,-0.09575017533348702,-0.098482926515223,-0.040307423112396094,0.02417393980731066,0.035459956763209934,-0.08304999879355174,-0.16879104355987354,-0.19859808671540732,0.1303029502073337,0.05911944857217773,0.013676729614023777,0.4453565353651273,-0.02770756969313101,-0.8595442738771882,-0.04572786783609855,-0.1718583190219596,0.8457106297496851,0.14616415555787632,-0.09972389703021103,0.27069423237982804,0.010111757196609604,0.0991960757808148,0.4876936973643743,0.023468580318335656,0.004962146662277418,0.019516640022563272,0.1919486072011403,-0.17743623963113897,-0.06774593719226113,0.021555117627944653,0.12594765518313525,-0.13055985661338615,0.1408185536240055,-0.0056334288100322,-0.09743919351204243,-0.11793610637858873,-0.3056275822798715,-0.04396495605510973,0.17726485288374086,-0.033838566925453374,-0.33188879868448273,0.01811287529500396,-0.6357881986177516,0.11489308686864093,0.2701988658943433,-0.12140855264798812,-0.07974307281998769,0.06986019015415422,-0.12405738971306406,0.08346784740097148,-0.0978910854982438,-0.0491135155415009,-0.014679025177730915,-0.08114312775965858,-0.06443575741611292,-0.28059321104333623,0.3056962959094344,0.05116706629080199,VirusDetection,2
46,46,"discvr rapid viral diagnosis  highthroughput sequence data
highthroughput sequence hts enable  pathogens   clinical sample   detect   single analysis thereby provide novel opportunities  diagnosis surveillance  epidemiology however  powerful technology  difficult  apply  diagnostic laboratories    computational  bioinformatic demand   develop discvr  detect know human viruses  clinical sample  match sample kmers twentytwo nucleotide sequence  kmers  taxonomically label viral genomes discvr  validate use publish hts data  eightynine clinical sample  adults  upper respiratory tract infections  sample   test  viruses metagenomically  also  realtime polymerase chain reaction assay    standard diagnostic method discvr detect human viruses  high sensitivity   specificity    able  detect mix infections moreover  produce result comparable     publish metagenomic analysis   blood sample  patients  nigeria discvr   design   userfriendly tool  detect human viruses  hts data use computers  limit ram  process power  include  graphical user interface  help users interpret  validate  output
 kmer databases  kmer   short sequence   nucleotides  kmer dataset  generate iteratively  slide  window  size  along  sequence one nucleotide   time extract kmers  count  frequencies   set  sequence   computationally intensive especially    large   sequence  numerous dedicate kmer count program   jellyfish marçais  kingsford   khmer zhang      incorporate  abundancebased tool  order  optimize speed kanalyze audano  vannberg   choose  integration  discvr   kmers  generate  sort lexicographically thus make  search  match  efficient kanalyze also use  canonical representation   kmer   lexicographically  smaller   kmer   reverse complement  feature allow  program  work    ram   purpose   study  define  virus kmer   kmer  uniquely represent  virus  set  relate viruses   exclusion   host  share kmer  define   kmer   common   virus   host  exclude share kmers    necessary   user  remove host read  use discvr thus speed   overall process time    small many copy  share kmers  generate     large many copy  virus kmers  find choose  optimal kmer size depend  balance  advantage  speed small     specificity  sensitivity large  furthermore   necessary  reduce  number  lowcomplexity kmers   virus kmer database   may  repetitive  sequence  present  otherwise unrelated viruses  filter  lowcomplexity kmers   selection   size    explain  supplementary section  shannon  sims         construct  virus kmer databases three comprehensive datasets  complete  partial viral sequence  extract   ncbi taxonomy database  first  human hemorrhagic virus dataset shorten   hemorrhagic dataset contain  sequence   hemorrhagic fever viruses list   center  disease control  prevention center  disease control  prevention   second  human respiratory virus dataset respiratory dataset contain  sequence  viruses associate  respiratory disease  third  human pathogenic virus dataset pathogenic dataset consist   sequence  viruses identify    health  safety executive list  biological agents health  safety executive  approve list  biological agents   database build discvr operate via three modules concern  database build sample classification  validation currently  database build module include three virus kmer databases derive   hemorrhagic respiratory  pathogenic datasets  use   sample classification module  addition    sequence   datasets define largely   presence   ncbi refseq database  use   set  reference genome sequence   validation module discvr also allow  user  create customize databases  set  reference sequence use  commandline utility script provide   discvr distribution  database build module involve select  relevant viral dataset collect  kmers  remove    share   host    low complexity  remain kmer   identify   taxonomic tag   indication   number  time  occur   sequence  kmers   subdivide    exist   single virus  specific kmers    exist  multiple viruses  nonspecific kmers  assignments  make   level  species  strain   use   output  illustrate  degree  specificity   kmers match  virus sample classification  analyze  hts dataset  file  load  discvr via  gui  kmers  extract   frequencies  calculate  single copy kmers   mainly attribute  sequence errors manekar  sathe   lowcomplexity kmers  commonly give confound match   nothing    homology altschul     filter    remain kmers  compare   choose virus kmer database   number  kmers   sample   enormous various data structure  consider  optimize  classification  machine  limit ram although search  trie  fast      size   kmer  require on2 overall time  build   space need  quadratic instead discvr use  fast search algorithm  group similar kmers together briefly  kmers   virus database  divide among smaller subfiles accord   first five nucleotides   procedure  use  divide  kmers derive   entire hts dataset search commence  load  correspond subfiles   virus kmer database   sample kmers  memory  perform  binary search   presence   sample kmer among  database kmers  match kmers  retrieve finally discvr display  straightforward list    virus hit detect along  summary statistics  taxonomic information   sample kmers fig   validation discvr help  user  assess  significance   find  facilitate  examination  kmer distribution allow   three mismatch across  reference sequence represent  target genome   alternative  also incorporate  examination  sequence read distribution carry   use tanoti sreenu     blastguided referencebased short read aligner   particularly tolerant  mismatch   case  output   graph show  depth  coverage  kmers  sequence read across  reference genome   summary  statistics   map result accuracy  respiratory database  use  analyze publish rnaseq data  nasopharyngeal swab sample       collect  adults  upper respiratory tract infections thorburn    supplementary table   average number  read per sample   range   sample   test use  standard realtime pcr rtpcr assay  human rhinovirus hrv influenza viruses    ifaifb respiratory syncytial virus rsv adenovirus adv human metapneumovirus hmpv parainfluenza viruses piv   human coronaviruses hcov hku1 nl63 oc43   thorburn     top hit   sample   virus   greatest number  distinct kmers use discvr  compare   virus detect previously  rtpcr  sample  also classify use three independent kmerbased program  require commandline usage   linux operate system kraken wood  salzberg  krakenhll breitwieser  salzberg   clark ounit      prebuilt database  kraken  contain  refseq viral genomes  sequence   comprehensive kmer database  build   program     sequence   respiratory dataset  order  standardize  result  successfully accommodate within species sequence diversity    normally take  account use  prebuilt database  initial objective   determine  number  distinct kmers  would maximize  sensitivity effectiveness  identify sample contain viruses  specificity effectiveness  identify sample lack viruses  discvr  output  discvr  categorize   basis   number  distinct kmers   top hit      program  assess   basis   number  read assign   top hit   tool sensitivity  specificity  define  tptp    tntn   respectively         number  true positive false negative true negative  false positive sample relative   rtpcr result  define sample   true positive   top virus hit  detect   rtpcr  discvr  true negative  neither rtpcr  discvr detect  virus  false negative   virus  detect  rtpcr    discvr   false positive   virus  detect  discvr    rtpcr receiver operate characteristics roc curve  generate  discvr kraken krakenhll  clark use  proc package    youdens statistic",-0.1948697451204117,0.17729968693040846,0.0673475531323458,0.12036923613257905,2.297019818797708e-06,-0.02145394804853519,-0.0829589852966213,0.002663437186163806,-0.012940946955045331,0.10161472340003544,-0.010491660254497435,-0.0780209563505542,0.16739449885242808,-0.09337377777140188,0.14403861683760105,0.012217704754134286,0.07347991879436276,0.1754212336589782,-0.03089185606776958,0.05747325082026821,-0.08632705568480084,-0.2431846200152428,0.09526520478982656,0.002584962631087928,-0.025578201891178088,-0.15794585134745354,0.13111375185530744,-0.12563651232935846,-0.10041329941436526,-0.026300317833444012,-0.008254789943540734,0.26777951314856874,-0.1931729044887193,-0.055220821989046064,0.20512079398481764,0.06901821387998228,0.03460250146274033,0.012427489909653864,-0.09226196206332783,-0.09646939638990998,-0.11924252786307728,-0.09603682233563242,-0.11871995258330745,-0.14361983397060873,-0.07605930742450125,0.05295642616526623,0.1279369691331383,-0.13971130793645334,-0.20438587920396545,-0.3122659041612808,0.2007623768034613,0.029425242483904143,0.022714954930069368,0.5275513738737486,0.0574311477865281,-1.0527470542833075,0.05383796011807308,-0.2123840946706921,0.9714749514524426,0.17394064387204014,-0.14616030423847926,0.3412185311730441,0.0016472478435995675,0.05442201864858535,0.5661746258864047,0.07866785067904164,0.006359174725366757,0.0028758415369923443,0.2577286017475195,-0.1501138952868392,-0.08060752524997952,-0.038584444410350575,0.11692639960827016,-0.07812314335398178,0.2055846420726517,-0.010233996361992986,-0.15428514510332164,-0.1352099169042915,-0.3823325872365829,-0.06301224030986695,0.2371680731799209,0.002427254600895269,-0.364994461797843,-0.02944289642937725,-0.8685215808162909,0.09778383915185086,0.25560178571890685,-0.1104809569771446,-0.17619013165655945,0.012250640826338591,-0.12912285050870628,0.06333181163700785,-0.07154425256663845,-0.10251396249846688,-0.030727314202868863,-0.040334138479028336,-0.11415371678179195,-0.36495089604854697,0.3073257058739685,0.056473222049646124,VirusDetection,2
47,47,"metavisitor  suite  galaxy tool  simple  rapid detection  discovery  viruses  deep sequence data
metavisitor   software package  allow biologists  clinicians without specialize bioinformatics expertise  detect  assemble viral genomes  deep sequence datasets  package  compose   set  modular bioinformatic tool  workflows   implement   galaxy framework use  graphical galaxy workflow editor users  minimal computational skills  use exist metavisitor workflows  adapt   suit specific need  add  modify analysis modules metavisitor work  dna rna  small rna sequence data   range  read lengths   use  combination   novo  guide approach  assemble genomes  sequence read  show   software   potential  quick diagnosis  well  discovery  viruses   vast array  organisms importantly  provide  executable metavisitor use case  increase  accessibility  transparency   software ultimately enable biologists  clinicians  focus  biological  medical questions
metavisitor consist   set  galaxy tool fig     combine   retrieve uptodate nucleotide  well  protein sequence  viral genomes deposit  genbank   index  sequence  subsequent alignments  extract sequence read    align   host genomes know symbionts  parasites iii perform  novo assembly   read use assembly tool available  galaxy align   novo contigs   viral nucleotide  protein blast databases use blastn  blastx respectively  generate report  blast output  help  know viruses diagnosis   candidate virus discovery  use cap3 optional see use case  blast  viral scaffold  select viruses  generate guide final viral sequence assemblies  blast sequence hit   group analysis step  functional task     provide detail   metavisitor tool  task  link together  build full workflows adapt   analysis   use case describe   result section get reference viral sequence  “get reference viral sequences” task  perform use  “retrieve fasta  ncbi” tool  send  query string   genbank database   retrieve  correspond nucleotide  protein sequence   viral nucleotide  protein sequence refer   “vir1”  use  tool  query genbank oct   retrieve viruses sequence filter   cellular organisms  bacteriophage sequence see  fig however users  change  tool settings  enter query string  fit  specific need  retrieve vir1  ncbi take several hours  allow users  skip  step  directly access  nucleotides  protein vir1 datasets   mississippi server    download   figshare   convenience nucleotide  protein blast index  vir1  also available   public library   mississippi serverbut  also  generate use  “ncbi blast makeblastdb” galaxy tool  bowtie   well  bowtie2  index   vir1 nucleotide sequence   generate   mississippi galaxy instance use  correspond “data manager” galaxy tool finally users  upload   viral nucleotide  protein sequence use ftp  transfer    galaxy history fig     use  galaxy data manager tool  produce  blast  bowtie index necessary  metavisitor  prepare data  “prepare data” task fig  process illumina sequence datasets  order  optimize  subsequent  novo assembly  viral sequence read fastq file  sequence read  first clip  library adapters  convert  fasta format use  tool “clip adapter” tool  table  clip read may   convert   fasta file  unique sequence head   character string  contain  unique identifier   number  time   sequence  find   dataset thus reduce  size   dataset without loss  information  optional treatment remove sequence duplicate  drastically reduce  workload   next step  well   coverage variations   novo assembly see use case    clip read   deplete  nonviral sequence  sequential alignments   host genome   genomes  know  potential symbionts  parasites  well   phix174 genome sequence   commonly use  internal control  illumina sequence  may contaminate  datasets fig   sequence read    match  reference genomes  retain  return   fasta file    use subsequently    novo assembly tool note   subtraction step   skip   host genome   know    aim   user   discover endogenous viral elements  iii assembly blast  parse  novo assembly   task “assemble blast  parse” iii retain rna sequence  subject   novo assembly  short read    test several round   novo assembly  velvet  use  oases software package  fig   kmer lengths range      table  read        also use  oases  kmer lengths range     finally  use case   use  trinity assembly software   available   galaxy tool   report  perform well  long read  trinity  well  spade  assembly softwares  also test  alternate option  oases   use case   table give similar output   noteworthy  users  adapt  metavisitor workflow use  assembly software available   galaxy tool shed blast next  novo assemble contigs  align   nucleotide  protein vir1 blast databases build   viral reference sequence fig  use  blastn  blastx galaxy tool   tool search nucleotide  protein databases use nucleotide  translate nucleotide query respectively   default parameters  adjust  order  report    best alignments per contig maximum hit option  set     generate  tabular blast output  include   standard columns plus  column contain  length   align subject sequence extend columns option “slen” check note   additional column   blast output  require  subsequent parse   blast output   “parse blast output  compile hits” tool parse tabular output generate  blastn  blastx alignments  process   “parse blast output  compile hits” tool  table  return  file namely “blast analysis  subjects” “hits” “blast align sequences”  “blast unaligned sequences”   “blast analysis  subjects” file  fig  subject sequence   viral nucleotide  protein blast databases  produce significant blast alignments hit   novo assemble contigs  list together   contigs  hit information  identity alignment length start  end coordinate  hit relatively   subject sequence percentage   contig length cover   hit evalue  bite score   hit  addition   subject sequence   list  length  nucleotide  aminoacid   subject sequence subject length  sum coverage   subject   contig hit total subject coverage  well   fraction   subject length   coverage represent relative subject coverage   best best bite score  mean mean bite score bite score produce  contig hit  compute  indicate  simplify output   generate without contigs  blast information  use  “compact” option   report mode   “parse blast output  compile hits” tool note   total  relative subject coverages indicate  much   virus sequence  cover   reconstruct contigs whereas  bite score allow  estimate  distance   reconstruct contigs   subject sequence  “hits” file contain  sequence  contig portion  produce significant alignment   blast step  query hit sequence flank  additional contig nucleotides      hit  size   margins  set    default    modify   user  margins allow  include sequence  might   significant homology  could still   viral origin finally  “blast align sequences” file contain contigs  produce significant blast hit whereas  “blast unaligned sequences” file contain      blastguided scaffold  last task allow  integrate hit sequence match  candidate virus   virus scaffold fig  first blastn  blastx hit  retrieve   “hits” file use  tool “pick fasta sequences”  table   appropriate query string  instance “dengue”  retrieve hit sequence  significantly blast align  dengue virus sequence next  hit sequence    cluster  longer contigs use  “cap3 sequence assembly” galaxy tool  table adapt  cap3  finally    still multiple unlinked contigs   stage    integrate uppercase character   match viral sequence take   scaffold lowercase character  scaffold  achieve   retrieve  viral sequence   ncbi nucleotide database   use   backbone   scaffold generate  blast index   sequence  align  contigs   index  blastn  tblastx tool  run  “blast_to_scaffold” tool  table take  input  contigs  viral guide sequence   blastn  blastx output fig  bottom availability  metavisitor  metavisitor tool workflows  use case  available   galaxy server  readers  import   personal account  publish metavisitor use case histories   correspond workflows  rerun  describe analyse  adapt    study  make  tool  workflows  compose metavisitor available   main galaxy tool shed    form   tool suite suite_metavisitor_1_2  thus   instal  use   galaxy server instance  metavisitor workflows  also available   myexperiment repository     freely modify  complement  additional analysis step within  galaxy environment",-0.22857606722707885,0.20149941771162114,0.10447225307712783,0.06311431219180022,0.04672828325977636,0.030846417310216086,-0.0978906212904318,0.052284133017371975,-0.004936339924777882,0.1143884168481792,0.07613422253942406,-0.04525234819210582,0.1115921176510451,-0.07214670138007724,0.11252864902064573,0.005634981245550428,0.1030171268228731,0.18753355239565336,-0.04361442235333742,0.058778491854538574,-0.07227245232372646,-0.2036947677264212,0.04565689300438462,0.02260632421206104,-0.005721177063144047,-0.1809502864217897,0.07598792485975107,-0.10983953520974116,-0.03741563090673344,-0.06991313187718523,-0.01986620501872065,0.2870002030046253,-0.21205009569515296,-0.10351587921245882,0.1947323261061834,0.08329945818823882,0.02091369113935836,-0.012052295844123694,-0.0885745059257588,-0.11568363269439952,-0.03678505411483179,-0.15187468856665542,-0.12689005000543313,-0.1228062238102692,-0.11153190020939883,0.042994021403331736,0.060998767257277216,-0.1524910034220955,-0.13378259696945827,-0.29527400609665583,0.1560322657659399,0.07342812886589492,0.05159227614344696,0.527675929498603,0.04496336426378416,-1.0830769797080133,0.017923517811310855,-0.2337232387719381,0.9799585592814776,0.22068071154904084,-0.17233548036553606,0.3461756604479944,-0.04574930669204212,0.05217073705418933,0.5827023472813069,0.03548466705975311,0.035632726391870886,0.028943481183710627,0.23949099929733056,-0.18505815317229385,-0.04837369490506844,-0.021180642788042683,0.10614354532009046,-0.17056572427635364,0.14799168304910573,0.000857359680245809,-0.1543038159480965,-0.10572282519008136,-0.3255684780584969,-0.06646822227636796,0.22971850547787534,-0.04113302647488715,-0.3554163278234939,-0.04011346236908196,-0.8346601252325261,0.08860375830472972,0.27224530497327004,-0.10336561911284604,-0.14294214818205614,0.03322471502736763,-0.13050001337605532,0.11128367548096693,-0.05215735322424998,-0.12184866595352213,-0.07342147258884837,-0.10036047599417124,-0.026332098424586663,-0.3194232006134149,0.35334604282783816,0.0991375975363883,VirusDetection,2
48,48,"development   virus detection  discovery pipeline use next generation sequencing
next generation sequence ngs  revolutionize virus discovery notwithstanding  vertical pipeline  sample preparation  data analysis    available   plant virology community  develop  degenerate oligonucleotide prim rtpcr method  multiple barcodes  ngs  construct virfind  bioinformatics tool specifically  virus detection  discovery able   map  filter  host read  deliver file  virus read  taxonomic information  correspond blastn  blastx report  iii perform conserve domain search  read  unknown origin  pipeline  use  process    sample result   detection   viruses know  infect  process sample  extension   genomic sequence  others   discovery  several novel viruses virfind  test  four external users  datasets  plant  insects demonstrate  potential   universal virus detection  discovery tool
sample source sample exhibit viruslike symptoms  either plant maintain   university  arkansasfayetteville  provide  collaborators  california michigan mississippi  oregon laboratory test elisa  rtpcr detect viruses    subset  sample indicative   presence  novel strain  species  others plant leave  phloem  harvest  keep   °  nucleic acid extraction sample preparation methods thirty one plant sample sample nos  table   use  nucleic acid extraction sample nos     subject   total nucleic acid extraction protocol poudel    whereas sample nos   process use  dsrnaenrichment protocol yoshikawa  converse  sample        know   infect   array  viruses whereas sample       never test  viruses  reverse transcription  perform essentially  describe  tzanetakis    use maxima™ reverse transcriptase thermo fisher scientific waltham     pdap213′ emaravirus specific primer  bello  tzanetakis   sample     bg4art  kpnirt primers    table   sample      cdna  use     pcr reaction    pdap213′ primer  sample     bg4apcr  kpnipcr primers    table   sample   chemical composition  previously describe poudel     pcr program consist   min denaturation   ° follow   cycle      °     °      ° conclude   min extension   °  pcr products  visualize   tbeagarose gel stain  gelred® biotium hayward   doppcr products       purify use genejet pcr purification kit thermo fisher scientific dna  quantify   nanodrop™ spectrophotometer thermo fisher scientific normalize    amount   sample multiplexed  indicate  table   sequence   separate ngs reactions ngs dataset nos  use illumina center  genome research  biocomputing oregon state university corvallis    junior sequence development  virfind virfind  develop   automate tool  process ngs output  pipeline  run   dell high performance computer node  amd opteron  series processors  core    ram house  arkansas high performance compute center  detail flowchart   step perform  virfind  present  fig  briefly ngs sequence file  convert  fasta format sequence   trim   ′  ′ end  remove  adapters  primers  collapse use fastxtoolkit   seq_crumbs  host sequence  remove   process  map  reference genomes use bowtie  langmead  salzberg   novo sequence assembly  perform  unmapped read use velvet zerbino  birney   kmer overlap value  datasets  average sequence length ≤  primarily sirna sequence additional velvet assemblies  kmer    construct short sequence may lead  false positives  blast    reason  contigs  singlets  ≥   subject  blastn search   genbank  database hit  genbank   filter   virus  nonvirus fasta read together   correspond blastn report  tabular format sequence without  match   subject  blastx search   genbank virus protein sequence cap3 assemblies  also construct  top   blast output official virus taxonomy information order family subfamily genus species derive  international committee  taxonomy  viruses ictv master species list   present   report  remain nonhit sequence   process use  python script   translate  six frame   consequently examine   presence  conserve domains marchlerbauer      ncbi conserve domain database cdd   web interface submission users need  complete  sequence submission form  contain  follow options  trim  adapterprimer  map  reference genomes  remove host sequence iii cutoff evalues   blastn  blastx step  define sequence relatedness   find  genbank   conserve domain search   remain unmatched sequence sequence file   upload   virfind ftp server  analysis   step  complete output file  compress  mail  users  information    download result   server virus detection  discovery ngs dataset nos  table    spike   random   virusviroid genbank sequence   use  test  ability  virfind  detect  single copy viruslike sequence  sample nos     virfind identify novel viruses pcr primers  develop table   use  amplify  sequence part   viruses׳ genomes confirm  presence  individual sample",-0.14342069582926342,0.18548175300275035,0.0916019762680662,-0.0004095140535355313,0.04469838395198167,-0.036793247540617816,-0.018160129123498337,0.0607445592439035,-0.02336674909456633,0.122896660137485,0.02392943801532965,-0.060652311106969135,0.14800329510399024,-0.013927645550938905,0.10598051152337576,0.08135351270284445,0.11518276134474945,0.16715237130856622,-0.009554961104731774,0.05856592545387685,-0.12856767276971368,-0.2207114999604528,0.10057050260074904,0.08238490377952985,-0.032385257496935084,-0.11024269268236822,0.09837203589704586,-0.04609632582323684,-0.024630942765452347,0.020626432145218133,-0.006038252759390161,0.2603404078087806,-0.18944220415869492,-0.02127593692166556,0.16744814555095214,0.025311255607084603,0.0230012338234701,-0.02472691502189264,-0.018979073647824408,-0.11066136092704257,-0.09540495842047676,-0.07279110095942087,-0.15010979225189658,-0.11886919183380087,-0.1028844226128058,0.028596838261000814,0.08535487101999024,-0.10216270157688996,-0.1827927845897648,-0.20042383822437845,0.12349374629775413,0.02335290777555201,0.07906948058589477,0.4005925341123657,-0.05231113417521556,-0.9231703240919159,-0.05944136861980951,-0.19407261982814816,0.8188580610090866,0.1830630357899281,-0.12313100323854087,0.3147701728397806,0.05983741490563261,0.08247276825131848,0.5358614817945636,0.057540618616985735,0.061364730898003476,0.02553331919116317,0.20285282894910775,-0.13630310787011696,-0.043979689520256215,0.042395674638737536,0.14427646370095318,-0.1449181539181154,0.10742740855057492,-0.003978957016079221,-0.08793737626328949,-0.10318350130619364,-0.3806516411146731,-0.022522031476546543,0.15531275391722374,-0.051474023166520055,-0.35080451901353626,0.016862223023599653,-0.7221808487545787,0.12931840227829525,0.2723513021963299,-0.1077963670155441,-0.09685873035996337,0.0278734802604049,-0.1379676837615989,0.09089867779257474,-0.05809680147708605,-0.023231178537389496,-0.03504155781774898,-0.10250061024817114,-0.05136346653816872,-0.3406994161241528,0.28258044488029554,0.06949031828444277,VirusDetection,2
49,49,"virusfinder software  efficient  accurate detection  viruses   integration sit  host genomes  next generation sequence data
next generation sequence ngs technologies allow   explore virus interactions  host genomes  lead  carcinogenesis   diseases however  effort  largely hinder   dearth  efficient computational tool   present  new tool virusfinder   identification  viruses   integration sit  host genomes use ngs data include whole transcriptome sequence rnaseq whole genome sequence wgs  target sequence data virusfinders unique feature include  characterization  insertion loci  virus  arbitrary type   host genome  high accuracy  computational efficiency   result   welldesigned pipeline
preprocessing virusfinders input  either  raw sequence read  fastq format   alignment file  bam format  user provide  raw sequence read virusfinder  first use  alignment tool bowtie    map  read   human reference genome   either  ncbi build    ucsc hg19hg18 #human virusfinder run bowtie    sensitive endtoend mode   bowtie    trim  ""soft clip"" character  short read  order  achieve high alignment speed   alignment file generate  bowtie   provide   user virusfinder  garner  read unmapped   human reference genome  downstream analysis    step user  allow  provide  sequence   virus  examine   input parameter  virusfinder virusfinder  skip step    pipeline  user provide  virus sequence  virus detection  step  use  detect  specific type  viruses present   sample  step   skip  user supply  virus sequence  virusfinder   virus type  unknown however virusfinder first align  unmapped read collect  step    virus database virus   current version  virusfinder release  use   virus  virusfa   one include   rins package    virus  contain viruses   know class   total  user  replace virusfa   alternative virus  genome information broker  viruses gibv    collect  virus reference sequence   smaller set  viruses  user interest next virusfinder  novo assemble  read align   virus   contigs  map contigs    human genome   virus   contigs   map   human genome  discard  alignment score   nonhuman contigs  align    virus    use  rank  viruses     map  sequence   top rank virus   apply   next analysis step  may  worth mention   virus detection method  describe  use rins    start point however different  rins  identify viruses  recruit  read map   virus       time align   human genome virusfinder utilize   read map   virus   unmapped   human genome  virus detection  use less read  rins   importantly   simplify pipeline virusfinder achieve significant speedup  rins without sacrifice  accuracy   test virusfinder     sample include unpublished ones infect  viruses  various type  virusfinder detect correct virus type    test sample see section   result  publically available data  virus integration site detection virusfinder combine  human reference genome   virus sequence designate   separate pseudochromosome chrvirus identify  previous step   provide   user   use  map tool bwa   align  read recruit  step    new reference another tool virusseq  also concatenate  human genome  virus sequence  virusseq include  fix set    virus sequence   reference genome  hence cannot  apply directly  detect virus insertion sit  sample infect  viruses   the18 predefined ones  concatenate  viruses detect  step    fly virusfinder  readily applicable  sample harbor viruses  arbitrary type  long    represent   virus    resultant alignment file virusfinder call interchromosomal structural variants svs use crest   breakpoints   svs  involve   virus  human genome       report crest utilize softclipped read  breakpoint position  svs   wgs sample   modest  coverage crest  take several days  complete  speed   pipeline  execute crest  run  much faster svdetecting tool svdetect    alignment file  calculate potential regions harbor virus integration sit   modify crest  make  search primarily within  regions identify  svdetect  blend svdetect  crest   able  reduce  computational time   call significantly  several days   wgs sample  around  hour   pipeline terminate three file virustxt contigtxt  integrationsitestxt  create   work directory  virusfinder  file contain candidate viruses identify  virusfinder contigs map   virus sequence  detect virus insertion sit respectively   virus insertion event virusfinder provide  breakpoints    virus sequence   human genome  detail explanations   file please read  user manual   supplementary material   software implementation  entire pipeline  virusfinder   initial preprocessing step   final virus integration site detection  fully automate  far   know    first fully automatic pipeline combine virus detection step  seamlessly  virus integration site identification step   thus  first ngs software enable  automatic detection  virus integration sit  sample   viruses may  necessarily  determine beforehand  aforementioned tool virusseq provide  virus detection script  virus integration site identification script  unfortunately  virusseq   separate program  cannot work directly together another advantage  virusfinder     capable  analyze largescale ngs data efficiently  improve significantly  computational pipelines  viruses   integration sit detection virusfinder  improve  analysis speed  blend  fast aligner bowtie    timeconsuming step    slower yet  sensitive aligner bwa   smaller subset  read  step  virusfinder  implement  perl program language    test  various linux platforms  depend  several thirdparty tool include blast  blast  blat  samtools   trinity   addition   aforementioned bowtie  bwa svdetect  crest   tool  publically available  download urls  brief descriptions  provide   supplementary material  different   tool crest require  installation   blat server  ease  distribution  virusfinder  modify crest   standalone tool  together  several  software  crest require   include   release package  virusfinder  remove completely  requirement  install  blat server  users system",-0.22411086584868606,0.20214286374071114,0.13539867249483445,0.07854710355064473,0.05067510625521158,-0.0364615272635209,-0.0983638632402866,0.06249256953504859,0.054684852841602204,0.1454541322570786,0.08256569023285577,-0.019114867172710347,0.15366054589291706,-0.12724882980774804,0.12220548137349288,-0.05730382212216385,0.09911320724204896,0.19864657243013326,-0.07963427356853482,0.09826715271105442,-0.03708831565654391,-0.23571577513430625,0.06324003614572095,0.003671487469053997,-0.02050746863680237,-0.16943624909358598,-0.0016820063912878335,-0.10469363164156677,-0.039022610827100165,0.00021350149487117583,-0.0577244538035422,0.3004078928561014,-0.2094754789842188,-0.09336862834854352,0.22244511478735754,0.10073305879394516,-0.011715463744537913,-0.0693113943454333,-0.08948676218048181,-0.08021789344324247,-0.08654551985907974,-0.12466692286635757,-0.09023841328514746,-0.08188679111274666,-0.1178458684514793,0.006112120461591793,0.08496814366682086,-0.18108796659648024,-0.1774215181980577,-0.3568616378303193,0.163474976200197,0.08322770569070853,0.038992697127330916,0.5711438731066022,0.04729660250486272,-1.202738865954869,0.023340146241343826,-0.18581407765681907,1.0605742170755128,0.16210664737364125,-0.1834563469728832,0.3617152877353868,-0.04658096638145448,0.07226077349712033,0.6036153999541459,0.027443149803273944,0.04406833026599271,0.025169361484154027,0.20109725858410668,-0.1956333176670104,-0.023528674607048067,-0.033239972290007413,0.09205249770891796,-0.1791584044921584,0.21651187154891666,-0.006300609368253069,-0.1610063833073888,-0.07979197394076974,-0.3731561036080592,-0.0997145404693067,0.2555115147583685,-0.055913467849059206,-0.3867208342786945,0.005502756683097495,-0.9246168531133199,0.1314771264928267,0.2704248459411865,-0.09140754016054788,-0.14221281216636594,-0.022043476876224124,-0.12323136352042577,0.09858443763755606,-0.08607958145316677,-0.13378052788758926,-0.13381935440222106,-0.09894447608600393,-0.07819816169195283,-0.2805725288603888,0.3629353170316949,0.08332095251237304,VirusDetection,2
50,50,"virusseeker  computational pipeline  virus discovery  virome composition analysis
 advent  next generation sequence ngs  vastly increase  ability  discover novel viruses   systematically define  spectrum  viruses present   give specimen  study  lead   discovery  novel viral pathogens  well  broader associations   virome  diverse diseases include inflammatory bowel disease severe acute malnutrition  hivaids critical   success   efforts  robust bioinformatic pipelines  rapid classification  microbial sequence exist computational tool  typically focus  either eukaryotic virus discovery  virome composition analysis      present virusseeker  blastbased ngs data analysis pipeline design   purpose virusseeker   successfully apply  several previously publish virome study   demonstrate  functionality  virusseeker   novel virus discovery  virome composition analysis
sample collection preparation  sequence stool  collect   adult rhesus macaque macaca mulatta    control animal  receive sham vaccines   previous publish study barouch    total rna plus dna  extract       freeze feces  randomly amplify  describe previously finkbeiner    wang    amplification product  use  nebnext library construction new england biolabs libraries  multiplexed   illumina miseq instrument washington university center  genome sciences use  pairedend  protocol  dataset  available    virusseekervirome workflow  vsvirome pipeline  control   master perl script virusseekerviromepl  input   pipeline   directory path  directory hold sequence data  one  multiple sample   two file contain fastq format sequence read  read1  read2  sequence preprocessing  preprocessing  sequence file consist   follow step  trim adapter andor primer sequence use cutadapt martin   join read1    pair end read together  form  longer read   overlap  define criteria use fastqjoin   eautils package  aronesty   quality filter  read trim low quality nucleotides poly  sequence remove read  low average quality score  obtain good quality sequence use prinseq edwards   remove redundant sequence identical  nearlyidentical sequence  frequently present  ngs data either due   sheer depth  ngs   many   presequencing sample preparation methods involve pcr amplification  reduce  compute cost  downstream analysis   reduce amplification artifacts cdhit   godzik   use  cluster similar sequence  default parameters  vsvirome  set  cluster sequence  share ≥ identity     sequence length  longest sequence   cluster  retain   representative sequence  use  downstream analysis    “unique sequences”  mask repetitive sequence  sequence quality control many eukaryotic genomes contain stretch  highly repetitive dna sequence  cause problems  blastbased similarity search  result  high rat  falsepositive alignments tantan frith   repeatmasker  smite     use  mask intersperse repeat  low complexity dna sequence  sequence fail  quality control criteria     contain  stretch   least  consecutive non“” nucleotides  “filtered sequence”   greater     total length   sequence  mask  ""low complexity sequence""  sequence  remove   analysis remain sequence  “good sequences” remove host sequence  align sequence  reference genome use bwamem   durbin   megablast  sequence map  ""host"" genomic sequence  remove   analysis  sequence preprocessing  obtain high quality unique nonhost sequence  identification  candidate viral sequence  high quality unique sequence  step   subject  blastn alignment   virusonly nucleotide database  detect   share nucleotide sequence similarity  know viruses remain sequence   align use blastx   virusonly protein database  detect viruses share protein sequence similarity  know viruses sequence    significant hit  either step  “candidate viral sequences”    classify  bacteriophage  eukaryotic viral sequence base   taxonomy identity   best blast hit sequence classify  ""phage""  pool   single file  remove   analysis taxonomy information  bacteriophage sequence  output  correspond file  false positive removal  candidate eukaryotic viral sequence  step   sequentially query   ncbi bacteria reference genomes use bwamem  database use megablast evalue cutoff  blastn evalue cutoff   ncbi  database use blastx evalue cutoff  sequence  significant hit  classify  eukaryotic virus phage  nonviral   hit host mouse fungal bacterial   base   taxonomy identity   best blast hit   sequence align    virus   sequence derive  another organism type  bacteria  fungi among  top  best hit   evalue   cutoff   classify  “ambiguous”  eukaryotic viral sequence   classify  viral families base   taxonomy    best hit sequence without  significant hit  blastx  ncbi  database  place   “unassigned” category  report   find  final output   sample   single file summarize   eukaryotic viruses identify   dataset rank  increase sequence similarity    closely relate viruses similar output  bacteriophage sequence  also generate  virusseekerdiscovery workflow  vsdiscovery pipeline  control   master perl script virusseekerdiscoverypl  input   pipeline        vsvirome  sequence preprocessing  preprocessing  sequence file  similar  vsvirome except   follow minor change first host sequence  filter prior   initial deduplication use cdhit subsequently  twostep assembly process  implement   cdhit process  longest read   top  longest read   cdhit sequence cluster  extract read  assemble use newbler   life sciences branford  singleton  outliers    first step assemblies  extract  use   input   second step assembly use newbler   contigs   first step assemblies  extract  use   input   second step assembly use phrap    contigs singletons  outliers   second step assemblies  extract  cdhit  use   remove redundant sequence repeatmasker  apply  describe   identification  candidate viral sequence false positive removal  report   find  describe  except   follow minor change sequence   query   ncbi bacteria reference genomes  avoid removal  contigs  share similarity  bacteria    small region  genome annotation  phylogenetic analysis orfs  predict  annotate use artemis rutherford    multiple sequence alignments  perform  muscle edgar  phylogenetic analysis  perform use  maximum likelihood method  mega7 program kumar      bootstrap replicate  percentage  replicate tree    associate taxa cluster together   bootstrap test  show next   branch  value greater    show  viruses analyze  sequence accession number use  analyse  viruses analyze include  follow genera species  strain bunyaviridae bunyamwera genus bunyamwera virus bunv np_047211  crosse virus lacv aaa62607 schmallenberg virus sbv agu16231 severe fever  thrombocytopenia syndrome virus sftsv ban58179 pacui virus pacv ain55741 ngari virus nriv afy23376 abbey lake orthobunyavirus abbunv aia08883 batai virus batv afy52608 phlebovirus genus heartland virus hrtv afp33395 rift valley fever virus rvfv yp_003848704 toscana virus tosv caa48478 uukuniemi virus uukv baa01590 severe fever  thrombocytopenia syndrome virus sftsv ban58179 silver water virus silv aiu95032 soybean cyst nematode associate uukuniemi virus scpv aef56734 hantavirus genus hantaan virus htnv saaremaa virus saav cac85165 dobravabelgrade virus dobv np_942555 recently propose gouleakovirus genus gouleako virus golv aej38175 cumuto virus cumv ahh60917 unclassified ssrna negativestrand viruses botrytis cinerea negativestranded rna virus  bcnv yp_009182153 macrophomina phaseolina negativestranded rna virus  mpnsrv1 ald89106 picobirnaviridae dromedary picobirnavirus dromedary pbv aiy31294 dromedary picobirnavirus dromedary pbv aiy31286 fox fecal picobirnavirus fox pbv aib06801 fox picobirnavirus fox pbv agk45545 human picobirnavirus gahpbv aag53584 gii human picobirnavirus chn hpbv aag53583  human picobirnavirus hpbv yp_239361 human picobirnavirus vs6600008 hpbv aig71990 human picobirnavirus hpbv ahx00958 human picobirnavirus hpbv baj53294 gii otarine picobirnavirus otarine pbv afj79071 picobirnavirus gipbvturkeyusamn turkey pbv ahz46150 picobirnavirus bovinerubvpind bovine pbv act64131 picobirnavirus monkeychn monkey pbv afk81928 porcine picobirnavirus porcine pbv ahi59999  nucleotide sequence accession number  follow sequence   deposit   ncbi database  correspond genbank accession number ky174981 camula virus  segment ky174982 pbv  rna  segment ky174983 rna  segment",-0.12317218454899954,0.16666870896976738,0.0789132816398578,0.02690019621187168,0.008982290414895467,-0.02965981112185932,-0.025587614032184198,0.003116488543979241,-0.02087699692324924,0.06247407529467646,-0.0316315391657357,-0.007719528526095729,0.13213824257611545,-0.013419338689560821,0.1158002139185672,0.0601873361969363,0.08290667568505154,0.09778630957006243,0.008060271918441438,0.0407626949307156,-0.059535608667962425,-0.15554291609010262,0.054573901745706296,0.040109590342747074,0.007041021678988673,-0.07389518398631043,0.08687701669742329,-0.057912418851162314,-0.022188195822546296,0.004920901154733229,-0.015361875986898752,0.18211515636355027,-0.08503365276313951,-0.02376245378604334,0.15205495305367994,0.04046041453569822,0.03266483160362902,-0.01325132962006456,-0.08399250376411996,-0.034432765651090186,-0.1015446626402546,-0.07718193172449772,-0.11103795600013587,-0.10187912080413616,-0.015496624684995243,0.03949370635892703,0.09530700028515636,-0.08918457285942928,-0.17961400213074766,-0.18317571773897398,0.09467158982910977,0.001419352003051722,0.04492389912509876,0.3524754830976232,-0.025825889325137987,-0.7791332125188765,-0.010661106614511692,-0.16114757786447068,0.6288618763557865,0.1829587012565068,-0.11268546115234915,0.30600821828998753,0.0290439836778874,0.044934907253296914,0.44096113710509305,0.07306639719143218,0.02618959172160359,-0.012022467528984048,0.21816450218809,-0.13835112654656742,-0.06841504531595223,0.023701624070466373,0.04311090635596765,-0.05762439347404188,0.11727746141298052,-0.019107973343974544,-0.1292119249776155,-0.1020226162325923,-0.30144591977677954,-0.02191719587076687,0.12053268541883347,-0.0025444118004387434,-0.2863118576888137,-0.004495066328731015,-0.5873973159026634,0.07215388777795508,0.20775738807221528,-0.10103168010661276,-0.10945694311195332,0.03271925083497112,-0.10181234117862367,0.012615532305871766,-0.05328287313671742,-0.024421788951781445,-0.04352472932871155,-0.045757790740004516,-0.08891132998911062,-0.28697661830780496,0.2279383831593079,0.003174519641810136,VirusDetection,2
51,51,"target virus detection  nextgeneration sequence data use  automate eprobe base approach
 use  nextgeneration sequence  plant virus detection  rapidly expand necessitate  development  bioinformatic pipelines  support analysis   large datasets pipelines need   easy implementable  mitigate potential insufficient computational infrastructure andor skills   study userfriendly software  develop   target detection  plant viruses base  eprobes    use   custom eprobe design  well  screen preloaded probe  raw ngs data  virus detection  pipeline  compare   novo assemblybased virus detection  grapevine  produce comparable result require less time  computational resources  software name truffle  available   design  screen  eprobes tailor  userspecific virus species  data along  preloaded probesets  grapevine virus detection
ngs data preparation use  protocol describe  burger  maree  dsrna  extract   phloem tissue   grapevines display typical grapevine leafroll disease symptoms   asymptomatic rootstocks sequence libraries  prepare use  adapt illumina truseq strand total rna library prep kit burger  maree    sequence  either  illumina hiseq hiscansq  miseq instrument data  trim  quality filter use trimmomatic bolger     head crop   nts  perform  read  trim   ′ end   quality score  lower   slidingwindow q20   novo genome assemblybased virus detection trim read  assemble  contigs use clc genomics workbench   minimum contig length  set   nts  automatic bubblesize  wordsize detection  apply  determine  viral status   sample  contigs  first align use blastn  blast camacho     genbank'  database use default parameters contigs  could   annotate  blastn   analyse use tblastx     database also use default parameters filter read  additionally submit  virfind   tzanetakis  apply default parameters  determine  viral status  truffle development truffle   interface develop  python  detect virus sequence  ngs data  design  implement virusspecific eprobes  bioinformatic pipeline base   tofiderived satya    pipeline call edna stobbe     outline  fig  firstly probe   design   customise   user' specific virus species  interest  probe design  genome   target virus  first compare     closely relate virus table  use nucmer       noextend maxmatch nosimplify  form part   mummer package delcher    delcher    kurtz     identity homologous genomic regions unique targetspecific regions  nts  longer  extract  serve  candidate probe  remove sequence contain homooligomers     nts  length  candidate probe  align  ncbi' online genbank  database word size  gap cost  open    extend  reward  penalty  remove  probe  hit  sequence    virus  interest  alignment   evalue    less  consider  hit  remain probe form  virusspecific eprobes  decoy set  sequence  also create  comprise   reverse sequence   eprobes   second application  truffle blast camacho     use determine  viral status   sample  probe  decoy  align  blastn task blastnshort   database compose   raw ngs data  score  generate   probe  decoy base   number  hit evalue  percentage  query coverage stobbe    depend   nature   scoredata one   follow statistical test  perform  compare  set  probe  decoy score  parametric student ttest  normally distribute data  equal variance  welch' ttest  normally distribute data  unequal variance   wilcoxon ranksum test  data    normally distribute sample   pvalue smaller   equal    consider   positive   specific virus  sample   pvalue greater   equal    consider   negative stobbe    sample render  pvalue   two margins   suspect   positive  indicate    grapevine virus probe design  implementation truffle  use  design probe  viruses   know  infect grapevine table   viruses consist   list  grapevineinfecting viruses generate  martelli  generally  reference genome   particular virus species available  genbank  use  target genome   type member   genus serve   nearneighbour genome  grapevine leafrollassociated virus  grapevine fanleaf virus  grapevine virus   full genome sequence  local isolate available  ncbi  use  target genomes   absence   full genome  largest available sequence  use  instance   target species   type member another closely relate virus  choose  nearneighbour  final probe  screen   raw ngs datasets    grapevine sample  determine  virus profile  target genome assessment different eprobe set  design  divergent glrav gva  gvb variants  result generate   distinctive probesets   species   compare  determine  effect  intraspecies genetic variation   sensitivity  virus detection  readmapping analysis use clc genomics workbench  filter read  map onto  detect viruses length fraction similarity fraction nonspecific read map randomly   percentage genome coverage determine",-0.2022038763890984,0.23146069511902465,0.09489170379503847,0.07489754062305336,-0.001754321045423514,-0.01640907197681079,-0.05952159279446436,0.038272841658811216,-0.006880056634920357,0.10820650417067036,-0.04976404811905685,-0.032529956132998604,0.14514487924018324,-0.0862158077277537,0.1250697974421884,0.04666393996769525,0.10252245538223427,0.16230534632470894,-0.007021235280604596,0.06954167584221398,-0.11937530591752656,-0.1924320141552016,0.0781992458921604,0.02214129307094786,-0.02531141598533914,-0.13130582645129188,0.09276547049478497,-0.10837508551932673,-0.08988316088208566,-0.0367883380595536,-0.01063182054246907,0.2593256385681288,-0.1522331567412405,-0.06778102800767281,0.2163910941833563,0.07513906982814855,0.03190176489750461,-0.01173599114080566,-0.0960906347925556,-0.07267210809842077,-0.06828493355783546,-0.1254717613235991,-0.10061519776803796,-0.09364222794038324,-0.08278210287688663,0.04504430141329653,0.08343868089477287,-0.11331911527804855,-0.2045635280262635,-0.2688662310555927,0.12894298505794333,0.055923153625194906,0.03154740697624562,0.4526139310168121,-0.019598061451102426,-0.945766520166876,0.015057583836426068,-0.2096288005365121,0.8493264433552805,0.14002225279277533,-0.11924907975978978,0.3358706585864065,-0.01050544824707478,0.08272314691312936,0.5008649802344832,0.05157085498498015,-0.0058596299018948365,0.00809758700623377,0.2231458367667733,-0.1415565482117298,-0.04520067643645368,-0.008664145441346914,0.10138828263392644,-0.13827890587811226,0.16030659006546008,-0.01865203066685256,-0.1495851417143998,-0.11285638505342532,-0.3112473941639366,-0.03689137051716422,0.1906242337245936,-0.05076602748935048,-0.3470990369444082,-0.021451924998631963,-0.741082159686293,0.051024534477814784,0.229991982980075,-0.09359936936502188,-0.13342776836244538,0.021663569781973008,-0.12512089801958493,0.0787153861715127,-0.08557213875683863,-0.09519583667822233,-0.06094264210789345,-0.03581432011345676,-0.08502004448021293,-0.3134354669936689,0.31530515446238555,0.06744168267582212,VirusDetection,2
52,52,"phispy  novel algorithm  find prophages  bacterial genomes  combine similarity  compositionbased strategies
prophages  phages  lysogeny   integrate   replicate  part   host bacterial genome  mobile elements   tremendous impact   bacterial host genomes  phenotypes  may lead  strain emergence  diversification increase virulence  antibiotic resistance however find prophages  microbial genomes remain  problem   definitive solution  majority  exist tool rely  detect genomic regions enrich  proteincoding genes  know phage homologs  hinder   novo discovery  phage regions   study  weight phage detection algorithm phispy  develop base  seven distinctive characteristics  prophages  protein length transcription strand directionality customize    skew  abundance  unique phage word phage insertion point   similarity  phage proteins  first five characteristics  capable  identify prophages without  sequence similarity  know phage genes phispy locate prophages  rank genomic regions enrich  distinctive phage traits  lead   successful prediction    prophages   complete bacterial genomes    falsenegative rate    falsepositive rate
data collection  bacterial genomes use   analysis  retrieve   phage annotation tool  methods server phantome server    march   server contain  complete bacterial genomes    contigs     bacterial genomes supplemental table    manually annotate prophages   lytic  lysogenic phage genomes  also collect   phantome server data analysis phispy publicly available    write  python     four step supplemental figure    flow chart   step  step  describe  calculation  different characteristics  first step calculate different parameters   whole genome  calculation   parameters depend   group  genes rather   single gene therefore   complete genome  parameters  compute use  slide window   genes  average number  genes    know prophages     window size   genes  consider  parameters   follow customize    skew  customize atgc skew  calculate  modify  cumulative skew calculation    group  consecutive genes  average skew        measure     number  genes    number   nucleotide   ith gene     customize    skew describe  result section  develop   calculate  follow  customize version combine atgc  compensate  local deviations   composition due   example strand bias difference  median protein length  median    lengths    proteins   bacterial genome  calculate   group  proteins   give window  median protein length   calculate   difference  median length  compute     transcription strand orientation   give window size  genes  partition    way    consecutive genes   particular partition point    direction  sum   number  genes   two largest partition  take   window  maximize  number  consecutive genes    direction abundance  phage word  word  define   set   consecutive base pair  gene  split    long nonoverlapping word four consecutive amino acids   unique phage word library  build base    bacterial genomes   wellannotated prophages  library  construct  follow bacterial word   { word   bacterial genes    genomes   include genes  prophages} phage word   { word   prophage genes    genomes} unique phage word library      measure  abundance  phage word shannons index    frequency   presence  phage word  calculate shannons index  calculate   follow formula     frequency   word   present   phage word library  frequency  word    window  calculate  divide  number  available phage word   total number  word   give window  abundance  phage word   homology   window   genes     least  genes whose functional description   phage subsystems  phage functional categories   phantome seed database   window  consider  prophage window otherwise   consider  bacterial window classification algorithm  second step  phispy   classify  window   bacterial   prophage window use random forest   random forest   classification algorithm  consist  multiple independent decision tree  random forest require  train set  multiple variables  build  forest  decision tree   case   five parameters whose value vary among distantly relate genomes   similarities  two genomes  evolutionary significant    consider  closely relate genomes otherwise   consider  distantly relate genomes  seed api  use  determine relatedness  therefore  every group  closely relate genomes  different train set  construct trainingtest set   phantome server    complete bacterial genomes    contigs  fewer   march     bacterial genomes  group  closely relate genomes  construct   group   least one genome   set   bacterial genomes  annotate prophages   group include     bacterial genomes   group one genome  manually annotate prophages  use   train set   rest   genomes   group table   supplemental table   genomes    belong   group    manually annotate prophages  test use  universal generic train set construct    way describe   use   bacterial genomes  parameter abundance  phage word  ignore   universal generic train set table   statistical software program    use  implement  random forest   random forest produce  rank   window   whole genome  suggest whether  window consist  bacterial  phage genes process  final rank   gene  third step  phispy provide  prediction status—either   non prophage genes    prophage genes   gene   genome   window size    gene contribute     windows therefore  final rank   particular gene  measure  take  average rank   window    gene participate  prophage prediction status  calculate   final rank   final rank  greater  half   maximum rank   gene   genome   gene  consider   phage gene otherwise   consider   bacterial gene evaluation   prediction  final step   define  att sit   predict prophages   overall evaluation   prophages  phages integrate   host genome   usually bound  two att sites— short repeat sequence  flank  insertion site  find  insertion site   predict prophage region consider  initial prediction  follow step  follow  identify  att sit  next step  verify  att sit   att sit lie inside  initial prediction  number  phagelike proteins  count   two gap  attl   start   initial prediction   attr   end   initial prediction   function  onequarter   genes   two gap belong  phage subsystems  initial prediction  consider   final prediction otherwise  region cover  att sit  consider   final prediction   att sit  outside  initial prediction   procedure  follow extend  predict region       side identify  duplicate short dna sequence   region find  repeat pair   minimum distance    either integraserecombinase  trnatmrna genes      multiple repeat pair  pair  cover  largest region  consider   potential att sit   integraserecombinase  trnatmrna genes  find   initially predict region  consider  verify  att sit  predict prophages  evaluate  check  function   proteins   region      five proteins whose function belong   phage subsystems   unknown   number  phagelikeunknown proteins   least half   total number  proteins   predict region   region  consider   potential prophage however   group  proteins whose function belong   phage subsystems   consider   classification step   probable prophage   region  also consider   potential prophage calculation  false positives  false negative  manually curated phage subsystems  use  evaluate  accuracy   approach  twostep program  design  automatically calculate  error rate   prophage prediction   genomes    information  prophages   original genome analysis paper   first step   program true positives   false positives   predict   predict region consist   least six phage proteins     proteins within  predict region belong  phage subsystems   unknown  predict region  consider   prophage otherwise  region  consider      prophage  limit  determine  empirically prophages consider  tps  divide  two group  know prophages—  region contain phagelike proteins  consider   would  identify  similarity base approach  therefore denote    know   undefined prophages—  region   phagelike protein thus  would unlikely   call  prophage   second step   program  region  consider   false negative      least six consecutive genes whose function belong   phage subsystems   region  unidentified   potential prophage however hypothetical proteins  ignore   case   presence  several hypothetical proteins   sufficient  predict  region   prophage region",-0.16588299665422535,0.20499743399749315,0.1372720110551058,0.1608697923229423,-0.029481057958101138,-0.004071261900669317,-0.04261219025626396,0.02907601748716053,-0.05167410502420558,0.14293410799799275,0.02418437443265304,0.0023080128942950173,0.18624066157386668,-0.10268671162968604,0.16209641421525098,0.0021423800613545427,0.04681470734067261,0.18903588371693095,-0.009001918745522804,0.07424132235838468,0.035033756382271776,-0.24300974608833226,0.03219450974739307,0.03173412803575517,-0.0115678946766183,-0.2249293490053534,0.1036410440324329,-0.16667926513478626,-0.0436766235837392,-0.0930366436245884,0.009117875877212012,0.2491183563906176,-0.16615308185252756,-0.08229625277146779,0.2274630954841601,0.039635904055482035,0.0866083220170423,0.04167596494425307,-0.10563821809863416,-0.08716530691015689,-0.11558330944029865,-0.11971217186375906,-0.06325188296067985,-0.11853582031486826,-0.08870690159654639,0.0066559087612073535,0.12154505672643393,-0.1417495344309382,-0.2895669251365609,-0.34034887932123525,0.1607125352100603,0.016350116885589475,0.05629248938952024,0.6043650727852895,0.04285159802437785,-1.2045991765164503,0.0019338636845486824,-0.2443317670140913,1.0561712787041435,0.25800492291975785,-0.1894895414577024,0.368229470092836,-0.022814884213758,0.07226308500595648,0.6785495103394225,0.08872522978805814,0.03290190816449979,0.019709152736420876,0.21718509473289632,-0.183443261944256,-0.08260441718871961,-0.01008653209310522,0.1135666311915337,-0.11758212628023278,0.21468473737786287,-0.050533091392684894,-0.1432390462530673,-0.20609228934510954,-0.4200763609226181,-0.06869791381476212,0.17772427181060538,-0.0044254224646366755,-0.4297223461604448,-0.039337374505353406,-0.886367042219168,0.03725432425080539,0.2262871525184828,-0.14615772558817275,-0.13491345108575475,-0.0017258657320556876,-0.24086239415595084,0.0730193082346988,-0.09678632689536143,-0.08998116266727994,-0.1416794261229402,-0.0872184157837865,-0.10664205180953563,-0.3528324241566955,0.3398146689732906,0.0729747429555637,VirusDetection,2
53,53,"phast  fast phage search tool
phage search tool phast   web server design  rapidly  accurately identify annotate  graphically display prophage sequence within bacterial genomes  plasmids  accept either raw dna sequence data  partially annotate genbank format data  rapidly perform  number  database comparisons  well  phage cornerstone feature identification step  locate annotate  display prophage sequence  prophage feature relative   prophage identification tool phast     time faster      sensitive   also able  process  annotate  raw dna sequence data  genbank file provide richly annotate table  prophage feature  prophage quality  distinguish  intact  incomplete prophage phast also generate downloadable high quality interactive graphics  display  identify prophage components   circular  linear genomic views
phast   integrate search  annotation tool  combine genomescale orf prediction  translation via glimmer protein identification via blast match  annotation  homology phage sequence identification via blast match   phagespecific sequence database trna identification attachment site recognition  gene cluster density measurements use densitybased spatial cluster  applications  noise dbscan     sequence annotation text mine  addition   basic operations phast also evaluate  completeness   putative prophage tabulate data   phage  phagelike feature  render  data  several colorful graph  chart detail   databases algorithms  implementation  give  creation  custom prophage  bacterial sequence databases phast' prophage sequence database consist   custom collection  phage  prophage protein sequence  two source one   national center  biotechnology information ncbi phage database  include   proteins   phage genomes   source    prophage database     consist   prophage regions   proteins  find   ncbi phage database since many   prophage proteins   prophage database  actually bacterial proteins      identify computationally   select  prophage proteins    associate   clear phage function  set include  total   phage protease integrase  structural proteins  phast phage library  use  identify putative phage proteins   query genome via blastp    search  addition   custom selfupdating phage sequence library phast also maintain  bacterial sequence library consist   nonredundant bacterial genomesproteomes   major eubacterial  archaebacterial phyla  bacterial sequence library contain   four million annotate  partially annotate protein sequence relative   full genbank protein sequence library  million sequence  bacterialspecific library   smaller  mean  phast' genome annotation step see    accomplish  faster genome annotation  comparison phast accept  raw dna sequence  genbank annotate genomes  give  raw genomic sequence fasta format phast identify  orfs use glimmer      orf identification step take      average bacterial genome     translate orfs   rapidly annotate via blast use phast' nonredundant bacterial protein library  mingenome  trna  tmrna sit provide valuable information  identify  attachment sit   calculate use  program trnascanse     aragorn      input genbank format file  provide  complete protein  trna information  step  skip phage  phagelike proteins   identify  perform  blast search  phast' local phageprophage sequence database along  specific keywords search  facilitate  refinement  identification match phage  phagelike sequence  blast  value less     save  hit   position track  subsequent evaluation  local phage density  dbscan    identification  prophage regions  prediction   completeness prophages   consider  cluster  phagelike genes within  bacterial genome  primary challenge  phagelike genes   identify   determine   genes  sufficiently well cluster  proximal      consider prophage candidates although     report cluster methods  identify phage gene cluster     find  general dbscan algorithm perform   well likely   identification  cluster  prophage genes    particularly difficult task dbscan take two parameters  cluster size    distance    parameter  define  minimal number  phagelike genes require  form  prophage cluster     maximal spatial distance  two neighbor genes within   cluster   case  spatial distance  two genes    number  nucleotides     word    consider   minimal prophage size     protein density within  prophage region empirically  set     since prophages generally    five proteins  value    set   base  assessments   small number  identify prophages  prophagedb     find  use  moderately different  value  generally  change  prediction sensitivity  phast' input file   annotate genbank file  additional text scan  perform  identify prophages  may    find  cluster  secondary move window scan look  specific phagerelated keywords   genbank protein name field   input file   protease integrase  tail fiber     proteins associate   keywords  find within  window   proteins  region  consider   putative prophage region even   insufficient number  phagelike genes  find  dbscan within  region finally   identify prophage contain  integrase potential phage attachment sit one   integrase  tandem prophages   identify  scan  region  short nucleotide repeat  base      prophage regions   detect  completeness score  assign   identify prophage three potential scenarios  consider   region  contain genesproteins   know phage     genesproteins   region  relate   know phage  iii    genesproteins   region  relate   know phage  scenario   region automatically   completeness score    maximum  scenario   iii  region' completeness score  calculate   sum   score correspond   region' size  number  genes    find   region  relate   know phage  score  calculate use  size  number  match genes   relate phage otherwise   calculate use  average size    average number  genes   typical phages  total score  scenario iii also count  number  identify cornerstone genes  well   density  phagelike genes   region cornerstone genes  genes encode proteins involve  phage structure dna regulation insertion  lysis    table  show  detail  phast' completeness score calculation  prophage region  consider   incomplete   completeness score  less   questionable   score       intact   score    program  web server characteristics phast' search annotation  dbscan cluster software  write use  combination    java phast' web interface  implement use  standard cgi framework phast' interactive googlemap style graphics  build use adobe' flash builder phast also support remote script use  url api   describe  phast' instructions link   maintain  large hyperlinked database  precomputed bacterial genomes  rapid prophage identification among knownwellstudied genomes see phast' databases link  screenshot montage  phast' output  give  figure    web application  platform independent    test successfully  internet explorer  mozilla firefox   safari  however  order  view  flash output  user must  adobe flash player instal   freely available         date instructions    use  server please read  online help page    performance evaluation  order  compare phast' performance   program  use  collection  handannotated prophages   bacterial genomes        gold standard reference control phast  evaluate use  genbank annotate sequence  bacterial genomes  manually  semiautomatically annotate genomes  well  raw dna sequence file  performance  measure use  sensitivity tptp    positive predictive value  ppv tptp   use   genome data set phast achieve  sensitivity      ppv    evaluate use genbank annotate file  use raw dna sequence    orf find  genome annotation tool phast achieve  sensitivity     ppv       genomes phast' performance use   annotate genbank data  superior  prophinder   ppv  prophage finder   ppv   phage_finder   ppv  phast' performance use raw dna sequence data   quite match    preannotated data   combine sensitivitypositive predictive value  still comparable  prophinder  superior   prophage finder  phage_finder detail comparisons    genbank  raw sequence input    genomes   find  phast' documentation page    phast' improve performance   necessarily indicate prophinder prophage finder  phage_finder' phage find algorithms  inferior  phast' algorithm rather    performance gain appear   due  phast' implementation   newer larger phage sequence library  perhaps  better exploitation  keyword annotations   challenge  evaluate  kind  prophage identification software      absolute  gold standard careful manual annotation  phage experts  certainly  high standard      likely   prophages    evaluation genomes   identify  decay  mutate  much    appear   casjens reference list      word    false positive predictions may  fact  true positives indeed  manual inspection  phast' result  find  number  dense positive blast hit  phage proteins  several genomes     label  prophages   casjens reference list instead  false positives  believe     consider  prophagerelated regions     previously report   literature  addition  evaluate phast' prophage identification performance  also evaluate  speed give  phast accept two kinds  file input raw fasta dna sequence  genbank format file  assess  performance   kinds  input file  give raw genomic sequence phast must run glimmer  well  several geneprotein identification program use  raw escherichia coli o157h7 genome sequence  genbank accession nc_002655 phast complete  prophage identification     min  test    input file prophage finder return result   min however   important  note  prophage finder   annotate bacterial genes  output   crude   combine snppv score  significantly worse  phast'  table   use  genbank annotate  coli o157h7 file phast complete  prophage identification    use   annotate nc_002655 file   prophinder    web server take  min  use  local copy  phage_finder    run    ghz pentium     ram   file take  min  data suggest  phast      time faster  exist prophage find program   complete feature  performance comparison  phast   exist prophage find tool  give  table   limitations phast   without  limitations first like   databasedriven annotation systems phast obviously perform poorly  identify novel phages whose genesproteins   closely relate   record   phast database   regard  appearance  large number  proximal proteins  unknown function could   good indication   novel phage second  dbscan algorithm use  phast assume  even density  phagelike hit  every prophage genomic sequence    generally true  practice consequently  highly uneven distribution  phagelike genes could potentially fool  dbscan algorithm finally phast  occasionally split larger prophages   number  smaller prophages due   paucity  blast hit",-0.19590810340628975,0.21771811320148368,0.1378723282702187,0.09063503320499752,0.023473631801356656,-0.009590118236638804,-0.10310316814477496,-0.006767740317847146,0.0077546516401745405,0.09926004848665766,0.069535271555306,-0.04931464699319772,0.17857899066000066,-0.14296440911380942,0.13430696081879182,0.019787452362301148,0.08634806486250078,0.17987682307510364,-0.020381441459025592,0.13266712481307533,-0.04004028585743448,-0.2278722615241161,0.0653800982841419,0.0031328659021929873,-0.015195325387798346,-0.1927098898147584,0.05706297875659747,-0.11841202783511233,-0.0889467022447332,-0.043376013581266686,0.022681794862364768,0.26637735318995664,-0.1827795897592421,-0.053700336325634666,0.2803810460938684,0.08350726046397729,0.004669895576782814,-0.006171639522202393,-0.08944118126387836,-0.1281186736916174,-0.07148796878516743,-0.1126674573627748,-0.06624061091246529,-0.12580854863285665,-0.12473335590615972,-0.033026184616017355,0.12987539203785328,-0.14335312003346062,-0.14894636173467635,-0.37270723137796796,0.1849006260925872,0.0411622365981798,0.08276243413124107,0.5769152219396221,0.03781383019856454,-1.20900031763424,0.006816258045703229,-0.17670630609214202,1.0380261564495068,0.1887935147638802,-0.2090602183031698,0.4011284582302324,-0.0665202544116945,0.07474227864164779,0.6001416940436747,0.02932460813738952,0.07084833974107008,0.02334631168309897,0.2119930707572323,-0.165651088690883,-0.05109847672931743,-0.006451191300960812,0.15050555512726566,-0.1510547872197188,0.19800387496221009,-0.010261845519788293,-0.12499452821693607,-0.08621927035911257,-0.4187486276241543,-0.1027071185483786,0.2146401755323088,-0.03351097081558065,-0.4268359347325745,-0.0414478229780296,-0.9164510276856036,0.08004760757880988,0.2451040756483241,-0.17009412574457358,-0.15126033737622746,-0.07669400212282575,-0.11935120128955218,0.0998648884257097,-0.08268766264393043,-0.042688901103623535,-0.08345763598054905,-0.09468855698876974,-0.14472727717606929,-0.37037496068585135,0.3320522066536922,0.106381308341795,VirusDetection,2
54,54,"phage_finder automate identification  classification  prophage regions  complete bacterial genome sequences
phage_finder  heuristic computer program  create  identify prophage regions  complete bacterial genomes use  test dataset   bacterial genomes whose prophages   manually identify phage_finder find    regions result   false positive   false negative prophages  search   complete bacterial genomes predict  putative prophage regions account     total bacterial dna analysis    putative attachment sit reveal trnas  target  integration slightly  frequently   intergenic   intragenic  regions  tmrnas  target     regions   popular trna target  arg leu ser  thr map   insertion point   consensus trna molecule reveal novel insertion point    side    loop   side   anticodon loop   anticodon  novel method  construct phylogenetic tree  phages  prophages  develop base   mean   blast score ratio bsr   phage prophage proteomes  method verify many know bacteriophage group make   useful tool  predict  relationships  prophages  bacterial genomes
system  software requirements phage_finder  write  perl   test use perl version   linux  mac    operate systems   work   unix environments   follow helper program  instal  functional ncbi blastall   wublast     blast search hmmsearch   find hmm match trnascanse   find  location  trnas aragorn   locate tmrna sequence  fasta33  mummer   blastn   find att sit phage_finderpl utilize  mathround perl module   write  geoffrey rommel  round number  define multiples   freely available ~grommelmathroundroundpm input requirements  run  include phage_findersh bash script  input requirements   follow name  file contain  protein sequence   bacterial genome   search  fasta format name  blastformatted phage protein sequence  name   file contain  dna sequence   entire bacterial genome   search   cod sequence   phage_finder information file tabdelimited contig_id size_of_contig feat_name end5 end3 annotation   genbank ptt file  invoke phage_finderpl directly   follow tabdelimited file  require  full functionality ncbi   blastp data hmmsearch data trnascanse data aragorn data  either  phage_finder information file  genbank ptt file   hmm data   provide   search  att sit    perform   data  trnascansearagorn   provide   phage_finderpl   associate  putative targetsite duplications  trnatmrna genes identification  prophage regions one   original intentions  phage_finder     program   distinguish  largely intact possibly functional prophages versus small regions  cluster  prophage remnants   mobile elements  take advantage  several feature  functional prophages  filter  unwanted fragment regions since functional temperate phages integrate  linear molecules   size range    good candidate prophage regions   cluster  phagelike genes   size range functional phages also   large fraction  hypothetical  conserve hypothetical proteins  stretch  phagelike  unknown genes  consecutive  break   operons  housekeep genes although  occasional metabolic enzyme   encode   phage tail phages    conserve late gene operon   responsible  package  head morphogenesis   conserve region include  small  large terminase subunit  recognize pac  cos sit   cleave phage genome concatemers  package   phage genome  capsids   portal protein  form  hole  passage   phage genome  package  release   prohead protease  generate mature capsids    major capsid protein  form  bacteriophage capsid  head   functional prophage region  also lack ribosomal rna sequence  boundaries  functional prophages  integrate  specific locations   determine  locate  sitespecific recombinase  one   end   phage region phages  integrate  trnatmrna genes  conserve genes  intragenic regions since many phages  genetic elements tend    affinity  trna genes   target  integration  trnatmrna gene present within  putative phage region  check first   target  integration  integrase  integrate   anticodonloop  tloop   ′ end   trnatmrna gene   phage genome  contain sequence near  integrase gene   homologous   ′ part   target  avoid inactivate  gene  insertion  follow integration  target gene    fusion   ′ end   bacterial origin   ′ end  phage origin   original bacterialderived ′ end    side   insert phage genome  search   end   putative phage region   sequence   trnatmrna gene include extra sequence  case  miscalculation   boundaries one  identify  look like  targetsite duplication  sequence   replace ′ end   trnatmrna gene  homologous sequence flank  genome   integrate phage genome  refer    core attachment site attcore   two half sit  attl  phagederived sequence  attr  original bacterial sequence sequence   ′   trnatmrna gene  also  part   attcore  phage_finder overview  first analysis  phage_finder    count  number  valid blastp phage match within  userdefined window size slide   userdefined step size   size   genome  reach   determine   window size       step size     optimal settings  define cluster  phage hit   least amount  noise  set   default window  step size settings  center   prophage region   define   window   greatest number  phage database match   region  begin   window   least  userdefined number  hit per window default  four hit per window   least one region  find within  minimum number  hit per window   ′  ′ boundaries   region  roughly determine begin   previously define center   region phage_finderpl slide gene  gene toward  ′  ′ end   region make  decision  inclusion  decision  include  gene within  particular phage region  make   follow order    protein   phage hmm hit  include      phage database blastp valid match  include iii   gene   trna  tmrna  include   either   next three genes  trnas  tmrnas  include    gene  annotation    observe  know phages     least three valid blastp phage database match   current window  include   annotation  describe     gene  annotation    observe  know phages     least two valid blastp phage database match   next window  include vii     least three valid blastp phage database match   next window  include lastly viii     least two valid blastp match   current step   current gene    match gene  include every gene    gene   database match   putative prophage region contain valid hmm match  xercd tigr02224  tigr02225  integron tigr02249 integrases   regions would  exclude   consideration   define  boundaries   putative prophage region  program attempt  define whether  regions  type prophage  type bacteriocin  whether regions    classify  mulike retron phage r73like p2like  p4like degenerate regions  determine  analysis  putative attachment sit  region  define  type prophage      core hmm match      lytic hmm match   tail hmm match   integrase hmm match   region   lytic hmm match   tail hmm match   integrase hmm match   region  define  type bacteriocin   analogous   phagelike bacteriocins pyocins  paeruginosa  monocins  lmonocytogenes   rtype  ftype pyocins  probably  best study  define phenotypically  genetically   pyocins encode headless phage tail regulatory proteins  lysis proteins   production  release  phage tail   specific  closely relate pseudomonads result  destruction   target cell  membrane disruption   region  sub classify  mulike    proteins within  region  match  follow muspecific hmms pf02316  dnabinding domain pf02914 bacteriophage  transposase pf06074 label  protein  unknown function duf935  match   portal gp29  pf07030 phage conserve hypothetical protein duf1320 match  gp36 pf06074  pf07030  determine   muspecific  search  phage database   model  via map  singlelinkage cluster   phage database search    blastp data  show  mulike phages  hit   hmms  combination  specific hmm match  region length  use  distinguish   retron phage r73     retron phage r73   p4like cryptic prophage   clinical escherichia coli isolate contain  retroelement  bacteriophage    satellite phage   use  head  tail genes  coliphage   package inself  infectious viral particles   three   phages   identify   hmm hit  pf04606 phage transcriptional activator ogrdelta  tigr01613 phageplasmid primase  family cterminal domain   integrase match  region  classify  retron r73like     match  pf00078 reverse transcriptase rnadependent dna polymerase   length   region        consider p2like  p4like   size     provide   file contain  dna sequence   genome  hmm  trnatmrna data  provide   region   mulike  search  putative phage attachment sit  conduct  user  specify blastn fasta33  mummer    nucleotide similarity search blastn  fasta33   advantage   imperfect direct repeat   identify  mummer  look  exact match blastn   default nucleotide similarity search tool   appear    better job  find  significant match   top two match  process  trnatmrna genes  within  putative prophage region  sequence   inmost trna gene  use   query  search  remain    region plus   additional nucleotides   similar direct repeat   direct repeat  identify  phage_finder attempt  extend  region  homology  search   trnatmrna sequence plus  additional nucleotides   ′ end   trnatmrna gene   homologies  find  program  identify  outermost integrase gene  sequence begin   outside  outermost end   integrase gene  extend outside   phage region     use   query  search  remain    region plus   additional nucleotides   similar direct repeat   putative att site  identify  coordinate  use  identify  putative target gene analysis   distance  integrase  att sit  know phages  conduct  determine     sufficient sequence  include  att site  coordinate  trnatmrna genes  use  determine whether  putative att site target  trnatmrna gene  case  incorrect trna  choose   series  multiple trnas  final step   format  data  print  summary   terminal  multiple output file  disk     contigsassemblies  analyze  program begin  find cluster  phage database blastp match   next contig   repeat      contigs  search input phage_finder begin  check   two require data file ncbi  wublast blastp tabdelimited data   query bacterial genome protein sequence  search   blastformatted database  bacteriophage protein sequence   phage_finder information file  genbank ptt file describe    file  give  present   data   phage_finder information file  genbank ptt file  process otherwise  program terminate   help menu  flowchart  phage_finder logic  present  figure   provide data  trnascanse  aragorn  process  store  future use  file  change infrequently  store   phage_finder home directory   hardcoded   program  list  satisfactory gene annotations  read   file   program  differentiate  housekeep genes   genes    previously associate  functional phages    associate  phages  hypothetical proteins conserve proteins  regulatory proteins  list   annotation  generate  parse  annotation associate  every phage sequence   phage database use  blast search remove space  make nonredundant  also allow  genes   actually phagederived   match anything   current limit phage database   include   phage region  orthologs  every phage protein  already   database  step would   necessary  orthologs   proteins   find   genomes  functional phages  also present  bacterial genomes  nonphage regions match   proteins   specific  phage regions  must  exclude  analysis examples  proteins  fall   category  transposases nonmulike abc transporters ribonucleotide reductase  certain  enzymes commonly encode   genomes  lytic phages  accession number   proteins  store   phage_excludelst file   use  phage_finderpl  exclude  protein database match  analysis  list  core phage hmms  well  list  hmms   specific  phage lysis genes  tail proteins  read   separate file table  match   hmms  well   integrase hmms pf00239 pf00589  pf02899  use  characterize  putative prophage regions  either prophage  bacteriocin match   specific phage hmms   length   region  use  distinguish  mulike regions retron phage r73    tabdelimited data  blastp search   database  bacteriophage protein sequence  read   process data  ncbi blastp option    wublastp    process   btab blast output parser   acceptable format  valid match  consider   analysis  valid match   top  best match whose subject accession number     exclude list    evalue less   equal   specify cutoff default    result  phagespecific hmm search   process protein sequence  search  hmmsearch   total model  glocalmode build  hmmls mode   fragmentmode build  hmmfs mode   explanation   glocalhmmls  fragmenthmmfs alignment modes please refer   hmmer user' guide  eight pfam fragmentmode model  remove due  frequent match  nonphage proteins pf05442 pf07352 pf05012 pf06992 pf06806 pf07068 pf05037  pf07230  valid hmm match  record   total score  greater   noise cutoff  glocalmode   greater   trust cutoff   fragmentmode unfortunately due   lack  sequence diversity   include   hmm seed  several glocalmode model pfams several reasonable match   use  phage_finderpl   total score    noise  trust cutoffs   five pfam glocalmode model pf00589 pf02316 pf02914 pf06074  pf07030   noise cutoff    set   lower value within  phage_finderpl program  increase  number  valid match   model     case   fragmentmode model   score   trust cutoff appear reliable output phage_finder  generate  least eight different filetypes  output   phagelike region  identify  include  follow   log file  give useful information   phage_finder process  data   summary   find   file    import  xgraph   plot  number  phage match   database per window  step size iii  tabdelimited report file  show coordinate incremented   step size # hit per window   feat_name  locus name   hit   file contain  ′ end   gene trna  att site within  region  name   feature   annotationdatabase matchhmm match  well      content   region  best guess   type  region   coordinate   region   without att site adjustments   three different name   file depend   size   regions            tabdelimited file contain contig_id size   genome    content   genome ′ end   phage region ′ end   phage region size  region   label small medium large region type prophage integrate element degenerate sequence  attr sequence  attl name  integration target     region ′ feat_name  locus name ′ feat_name  locus name # integrase hmm hit # core_hmm hit #  noise core_hmm hit # lytic gene hmm hit # tail hmm hit #  hmm hit orientation   prophage base  orientation   target   position   integrase  distance  att site  integrase   number  genes   region   file  fasta format contain  dna sequence   phage region vii  file  fasta format contain  dna sequence   gene within  phage region  viii  file  fasta format contain  protein sequence   gene within  phage region calculation  distance  bsr  bsr   use  compare three genomes   time   approach   expand  compare  number  genomes  compute  average  bsrs   genome   purpose  tree build  phylipstyle distance matrix  require  blastp  use  identify bidirectional match protein sequence  describe previously   bsr  calculate   protein match  meet  prerequisites  describe previously   proteins  fail  meet  prerequisites  give  bsr value  zero   phylipstyle distance matrix use  different numerical scale   bsr  simple calculation dab    bsr   use  convert  bsr   exact match    match   phylip distance   exact match    match  ensure  dab equal dba    proteins  two genomes     follow calculation  use  compute  mean   distance  genomes      ∑ dab   ∑ dba        total number  proteins   subject  query genomes     number   every genome pairwise combination  format   phylipstyle distance matrix file   use  input   phylip neighbor program",-0.14673414933494294,0.13270323411434534,0.117533110073497,0.08231683651199175,-0.02003952015035109,0.007386566410922973,-0.053503695214578116,0.02824885650746678,0.0018966043614508476,0.1126822710954488,0.02917322523104225,-0.023363904596665624,0.13063488402445764,-0.05637991282624742,0.14385348357169908,0.030146484655610893,0.03659084443710315,0.15097904078331936,0.016365438264784284,0.1031209912798138,-0.017022872649781726,-0.18255768119378252,0.03826601031815136,0.01265598160387957,0.02605407405107923,-0.13863902935530215,0.07134691934949505,-0.08118211020190277,-0.02913833476283028,-0.027917998183269902,0.025176636718005532,0.2435819839587933,-0.1177268568876115,-0.06402274691340601,0.22389660688419386,0.0664200040625426,0.04472447073032312,-0.023122114484162855,-0.06659570509104787,-0.07106740260913165,-0.04664925251658399,-0.0887116737578748,-0.06813987969546334,-0.09523575442686932,-0.0471133151377954,-0.011926310838645085,0.056390447645051016,-0.08740711861270789,-0.1960758304579512,-0.2488085282213219,0.10829981865301366,0.055827863953062974,0.05125098203202274,0.43633421530224537,0.007346043176100548,-0.9288608805829472,-0.015867062087520766,-0.1845441440755904,0.8278507353939317,0.207822418325919,-0.1601961968934522,0.3063022434037395,0.0017392675855770019,0.045529633226589004,0.5323244192021557,0.03831420569615483,0.012594046910787192,0.025700164596709717,0.15861190820703416,-0.17818020329455694,-0.060121837131398334,-0.05249959833223916,0.1343019325187595,-0.13109463265742025,0.1361919513872835,-0.04212983467450309,-0.10733660129873364,-0.13120547485319572,-0.3110694629776411,-0.04574956487703606,0.13642652094184546,-0.07298248245689717,-0.3419148971830807,-0.006816822406854362,-0.6927156295547401,0.1088511901211722,0.18065801866031256,-0.12209598149805195,-0.10209951564176926,-0.025202590134096613,-0.14955259740509208,0.12360779187121593,-0.06083030307370544,-0.08219476390055519,-0.060203476807299476,-0.1010179714629551,-0.041113949025553966,-0.2955029695600642,0.2583878143503225,0.06340118184591224,VirusDetection,2
55,55,"verse  novel approach  detect virus integration  host genomes  reference genome customization
fueled  widespread applications  highthroughput next generation sequence ngs technologies  urgent need  counter threats  pathogenic viruses largescale study  conduct recently  investigate virus integration  host genomes  example human tumor genomes  may cause carcinogenesis   diseases  limit factor   study however  rapid virus evolution  result polymorphisms  prevent read  align readily  commonly use virus reference genomes  accordingly make virus integration sit difficult  detect another confound factor  host genomic instability   result  virus insertions  tackle  challenge  improve  capability  identify cryptic virushost fusions  present  new approach  detect virus integration sit  iterative reference sequence customization verse   best   knowledge verse   first approach  improve detection  customize reference genomes use  human tumors  cancer cell line  test data  demonstrate  verse substantially enhance  sensitivity  virus integration site detection
next generation sequence data  use wgs   hepatocellular carcinomas hccs rnaseq   hcc cell line     merkel cell carcinomas  evaluate verse table    sample  publicly available   validate  harbor virus integration sit pairedend wgs        hccs  perform   illumina hiseq  sequencer  describe   average coverage   sample range     table   additional file   hbv integration sit identify   sample  validate use pcr  sanger resequencing   total  integration events  validate   tumor sample several sample harbor virus integration sit    close     example  two hbv insertion sit  sample   chr19   chr19      away table   additional file   discrimination  virus integration sit within  short distance  quite beyond  capability  current detection tool  verse apply    cutoff  filter  lowconfidence detections  regard two virus insertion loci  one   distance    less     give   final set   virus integration sit   sample whole transcriptomes   four hcc cell line  subject  sequence library preparation use  illumina truseq rna sample preparation kit  report   original publication  sequence  perform   illumina hiseq  platform generate pairedend read  length     average insertion size    table   additional file   average  million read  obtain per sample eleven chimeric hbvhuman transcripts  detect   sample use viralfusionseq   validate use sanger resequencing   two merkel cell carcinomas virus genomes  capture  formalinfixed paraffinembedded tissue  enrich use pcrgenerated capture probe  target pairedend sequence  perform   illumina gaiix platform      total    million read  produce   two sample respectively  viral integration sit   tumor genomes  detect use  breakdancer   slope   validate  identify virus insertion events primers  design use vector nti suite invitrogen   detail validation protocol interest readers  refer   besides  data   real tumors  cancer cell line  also simulate wgs  human chromosome  use  profilebased illumina pairend read simulator pirs   plug  mutate copy   hpv virus reference genome   chromosome   ucsc hg19  create  new reference    run  command imulate'  pirs  generate pairedend sequence read insert size   read length     average coverage  additionally  mimic real data  insert single nucleotide polymorphisms snps small insertions  deletions indels  structural variants svs   data  let  frequency  snps   time higher    indels   frequency  svs  time less    indels  simulation data  freely available   verse pipeline figure  illustrate  verse pipeline  overall follow  fourstep procedure  read subtraction  virus genome customization  host genome customization   virus integration site detection read subtraction  purpose   read subtraction step   collect viral read    read characteristic   viruses infect  host   step verse use  alignment tool bowtie    map raw sequence read   reference genome   host species  study bowtie   run   sensitive endtoend mode  order  achieve high alignment speed read pair  one   end unmapped   host genome  garner  read  call viral read  simplicity although      relate   viruses verse exploit primarily  viral read  order  detect virus integrations virus genome customization   step verse utilize icorn   tool  correct errors  small genomes  customize virus reference genomes specifically verse run icorn  map viral read   virus reference genomes   identify snps  indels   map read  highquality consensus snps  indels  use  modify  virus reference genomes icorn compare  coverage   map read   base     modifications  corrections  reduce  coverage  reject  whole process  read alignment  variant detection  base correction  run iteratively typically six iterations suffice  correct majority errors   small reference genome  host genome customization customization  large genomes  timeconsuming  instance  use short read  modify  ucsc hg19   take icorn   week  complete   vanderbilt advance compute center  research  education accre   speed  verse  extract genomic regions  host genomes   likely  harbor virus integration sit  run icorn    identify regions specifically  first combine  reference genome   host species  study   consensus virus genome create   previous step designate   separate pseudochromosome chrvirus next  use bwa   align  viral read   result new reference   alignment file create verse run svdetect   software tool  use anomalously map read pair  localize genomic rearrangements  call interchromosomal svs  involve   host genome  chrvirus  host genomic regions  potentially harbor virus integration sit   derive   map position   read   svs figure 1cii  genomic regions  typically    length significantly smaller   host genome next verse designate  region characterize   host genome   separate pseudochromosome  concatenate  together verse recruit read map   regions   bowtie align file create  step   follow   procedure  step  verse run icorn  iteratively align read   pseudochromosomes call snps  indels  read alignment   correct  reference   call snps  indels  final output   step  therefore customize host genomic regions    correspond   potential virus integration event  modify   small regions   able  reduce  computation time    week   large reference genome    hours virus integration detection   step verse concatenate  host genomic regions recruit   previous step   consensus virus genome  create  analysisready reference genome verse run bwa  map  viral read   new reference   utilize crest   detect interchromosomal svs crest   algorithm  exploit softclipped read  read  partial alignments   reference genomes   identification  breakpoints   svs  involve   virus  host genomes       report  virus integration sit result classification  filter  demonstrate  verse combine two complementary tool svdetect   crest   customize reference genomes  detect virus integration sit svdetect use span read   pairedend read  one end map   host genome  another align   virus genome  characterize virus integration loci   fast   able  discern integration breakpoints accurately  contrast  svdetect crest utilize softclipped read   potentially split read  harbor virus integration breakpoints within  crest  prone  miss truepositive loci due   difficulty  map split read    able  determine virus integration sit  singlebase resolution  combine svdetect  crest verse balance computational efficiency  detection accuracy  measure  confidence   predict position relative   real virus integration site  base   output  crest verse categorize  prediction  one  two class  high confidence     sufficient softclipped read  support  integration locus   crest  able  detect    low confidence  crest fail  detect    lack  highquality softclipped read   highconfidence prediction crest output  use directly   putative virus integration site   lowconfidence one however verse predict  position base   softclipped read  cover   particular verse derive  boundaries   region  potentially harbor  integration site   output  svdetect next verse sort  loci within  boundaries   descend order   number  softclipped read   align    one cover    softclipped read   use   estimate   real integration locus  discard  possible falsepositives verse require  distance  two adjacent lowconfidence virus integration sit    least    drawback   use   stringent cutoff   verse could mistakenly discard  real integration event    within    another input  verse  input  verse include ngs read  fastq format sequence   host  reference host genome  fasta format   reference virus genome fasta format  entire pipeline  verse   initial read subtraction step  virus integration detection  result classification  filter  fully automate  output   step  use automatically   input   next step   pipeline verse provide  argument sensitivity_level  allow users  designate  number  iterations  reference genome customization   majority  errors   reference gnome   correct use one  two round  icorn iteration  evaluate verse   human tumors  cell line   section   let sensitivity_level    simplicity   save time  encourage users  tune  value   applications    adjust verse detection sensitivity another input argument  verse  flank_region_size  define  size   flank regions upstream  downstream   genomic region  study   experiment present   section  flank_region_size  set   default value    mean verse  search   upstream    downstream   regions flank  genomic segment predict  svdetect  harbor  candidate virus integration site  allow verse  examine  flank regions  reduce  chance  miss virus insertion sit therein  mention   source code  verse  publicly available   open source software package virusfinder     core module  virusfinder  verse  utilize  virusfinder   characterize virus integration loci   sensitive detection mode see users manual ",-0.19406171873908806,0.1778603173497525,0.12550953295534126,0.14154552359935474,-0.003694973185718208,-0.02820067667423962,-0.05818361932923296,0.021520691548795563,0.01730863981781346,0.14934516412698445,0.0011923522432502132,-0.0009110478661576826,0.11904780797179235,-0.12999560445005207,0.1513486706007342,-0.017497523068100117,0.014750156047304813,0.17922523053703196,-0.041194455711525434,0.049942296435922566,-0.03895860265289326,-0.2527151344090585,0.04503840109358121,0.02012434781969945,-0.014131541217088006,-0.13770045974679224,0.06300958673097813,-0.1261457424040109,-0.013400665989242992,-0.03339263055495716,-0.008302633577970111,0.27088852414131925,-0.16476292622716587,-0.05625336253446366,0.20428770015525385,0.06354706949529658,0.011867960119894005,-0.03647202133423591,-0.10721287579456988,-0.04167040337502453,-0.12088657225509468,-0.1283001639899943,-0.13465869700226035,-0.12947486737661631,-0.12738648541253658,0.01043162230329858,0.1421800120507029,-0.14558307735138135,-0.2284066083300673,-0.3197585227662302,0.16284789619308,0.04695762986839085,0.0391400421576047,0.5525094546682605,0.030392059478373062,-1.0966672050623445,0.05450193540618623,-0.22610583654628036,0.9230246759810232,0.18250422681482464,-0.16819922168502446,0.33445580766007793,0.010090325984267305,0.0815225537254401,0.5493626054592711,0.07285042908490817,0.005568158098779035,-0.0016983077898456724,0.2134832229692668,-0.19110151361537567,-0.03206764521985708,-0.019036084531295933,0.07737129355621868,-0.1223770182468234,0.15545513640509184,-0.041013034248613314,-0.1262053794570605,-0.08810087036087992,-0.3656096141007564,-0.058815873955866835,0.202742988369644,-0.05212856404546677,-0.3546114055286197,-0.015939571414620872,-0.8610599989035945,0.0681719645754531,0.2621782998187649,-0.08763747869741452,-0.11449005231735156,-0.00657745697666928,-0.1511037076928496,0.09489062712970807,-0.1074982680479761,-0.09635622102346897,-0.08239379046284964,-0.053333110496426514,-0.07849337420718892,-0.3174925113560885,0.33709501906424816,0.05104771860621754,VirusDetection,2
56,56,"pathosphereorg pathogen detection  characterization   webbased open source informatics platform
 detection  pathogens  complex sample background   revolutionize  wide access  nextgeneration sequence ngs platforms however analytical methods  support ngs platforms    uniformly available pathosphere find  pathosphereorg   cloud  base open  source community tool  allow  communication collaboration  share  ngs analytical tool  data amongst scientists work  academia industry  government  architecture allow  users  upload data  run available bioinformatics pipelines without  need  onsite process hardware  technical support  pathogen detection capabilities host  pathosphere  test  analyze pathogencontaining sample sequence  ngs   spike human sample  well  human  zoonotic host background pathosphere analytical pipelines develop  edgewood chemical biological center ecbc identify spike pathogens within  common sample analyze   ion torrent  illumina sequence platforms ecbc pipelines also correctly identify pathogens  human sample contain arenavirus  addition  animal sample contain flavivirus  coronavirus  analytical methods  limit   detection  sequence  limit homology  previous annotations within ncbi databases   parvovirus utilize  pipelinehosting adaptability  pathosphere  analytical suite  supplement  analytical pipelines design   unite state army medical research insititute  infectious diseases  walter reed army institute  research usamriidwrair  pipelines  implement  detect parvovirus sequence   sample   ecbc iterative analysis previously fail  identify  accurately detect pathogens   variety  sample  work demonstrate  utility  pathosphere  provide  platform  utilize modify  create pipelines   variety  ngs technologies develop  detect pathogens  complex sample background  result serve   exhibition   exist pipelines  webbased interface  pathosphere  well   plugin adaptability  allow  integration  newer ngs analytical software   become available
pathogen isolate sample preparation isolate sample preparation sample    contain lujo virus  prepare  human isolate  rna  extract   cerebrospinal fluid  serum   liver transplant recipient  digestion  dnase   eliminate human chromosomal dna rna preparations  amplify  mean  reversetranscriptase pcr rtpcr   use  random primers   amplification products  pool  sequence   use    genome sequencer flx platform roche branford   dna fragmentation  omit  zaria bat coronavirus sample      negative control   obtain    tract  bat  test positive  negative   control  coronavirus  pcr  sample  contain gbvd  obtain  bat serum   prepare  detail previously  isolate rna   coronavirus  gbvd sample  convert  cdna   library  prepare similarly   lujo virus isolate detail   bat parvovirus sample   obtain   spleen  parvovirus pcrpositive bat like  discover     dna  isolate   prepare libraries  sequence    flx roche branford  sample contain merscov     prepare  previously describe  viral cdna  make use random primer rtpcr  nasal swab  camels  pcr amplifications  make use overlap pcr primers span   fragment  merscov   amplification products  pool  sequence   ion torrent pgm platform  human serum spike sample contain  pestis  tularensis   anthracis ​ mallei   psuedomallei  prepare  sequence  describe previously    sequence   flx roche branford  ion torrent pgm life technologies grand island   illumina miseq platforms illumina san diego  sra information   sample analyze   available   nbci bioproject # prjna276557 ecbc pipeline  pipeline describe   design  integrate  wide range  analytical tool   single automate process ngs data  first run  quality control trim use standard metrics   default  allow  user trim flexibility two preprocessing tool  currently available columbia universitys preprocessing procedure cupp   taxonomic analysis base  ncbi taxonomy result cupp  develop  reduce  complexity  total size   ngs dataset   procedure   read   sample  compare use bowtie2   map read   cupp database   remove host read   analysis  host databases  cupp include anopheles gambiae mosquito danio rerio zebra fish gallus gallus chicken homo sapiens rrna human homo sapiens chromosome human mus_musculus rodent sus scrofa pig mitochondrion genome  xenopus laevis frog   taxonomy analysis provide  lowest common ancestor   read thus provide  general description  bacterial viral  eukaryotic constituents   sample  procedures cupp  taxonomy analysis   use individually  serially  part   analysis request fig   tool   code use  implement    analytical pipeline  available  opensource software    iterative analysis  design  identify pathogens without assumptions   sample identity  complexity  fulfill  goal  process   construct  perform  subtractive approach  search  possible multiple pathogens  multiple chromosomal elements   single sample first  genomic data upload   system  read retain   preprocessing manipulations  process    novo assembly   case   data  read  assemble use   newbler roche program   illumina data  read  assemble  velvet    novo assembly produce longer contiguous lengths contigs  genomic sequence  database search step  compare  contigs  genome sequence   ncbi  database  identify high quality match  query    novo assemble contig result   series  hit   rank  blast bite score  resultant top hit per query  cumulatively rank use bite score compare    top hit  topmost rank ncbi database genome sequence   cumulative rank list  select   nearest neighbor  sequence   iteration   next step  taxonomical neighbor      ncbi nucleotide database  collect accord   follow procedure    rank  subspecies   direct taxonomical parent  rank  subspecies   database record belong    ncbi taxonomic subspecies subtree  collect   total count   collect record  less   default value   reset  user   species subtree   belong   search   additional database record  belong   subtree   also appear   rank hit list  collect   ' neighbor genomes  collect   input read   iteration  map     genome sequence  reference map   final step   first iteration   input read use   novo assembly  reference map    reference   unmapped read  extract  use  input   next iteration   data  read  reference map use   newbler roche program   illumina data  read  reference map   bowtie2 program    next iteration  step describe   repeat  iterative analysis allow multiple chromosomes plasmids  insert genomic elements   identify  report   user  direct manual analysis usamriidwrair pipeline  usamriidwrair pipeline  design   modular  thus give  flexibility  integrate new software   become available replace older versions  reason   speed  sensitivity acceptable input format include sff fastq single  pairedend  compress gzipped file step1 first decompress  file andor convert  file  fastq format   sff file   start input  convert fastq  pairedend fastqs  process  host removal use bowtie2   first iteration use  host genome  choice  read removal follow   host transcriptome  host read  remove adaptors  trim  read   quality filter use cutadapt   prinseqlite  read  assemble  contigs use   novo assembler ray meta  follow   contig assembly use cap3   ensure  longest possible contigs identification  contigs  single read singletons  achieve   iterative blast search use  ncbi  database iterative blast  use  contigs   query  start   megablast follow   discontiguous megablast   contigs    get identify   megablast     dcmegablast iterative blast   essentially   except   singletons  use   input  blast search scheme ensure  highly homologous sequence megablast word size    match appropriately   less homologous sequence discontiguous megablast word size   identify within  dataset  output  divide  contig  read report  output report resemble  top blast output   addition  read  align   contig taxonomy  assign use name  nod file  ncbi architecture  web implementation pathosphere   practical implementation  reference design  scalable secure web service  genomics process   two main part   pathosphere system  first   cloudbased web interface provide  custom applets run inside  liferay   second part   system consist   number  backend process computers  cluster  architecture separate  web interface user collaboration tool  result display mechanisms   systems  actually process  data  pipelines   way  pipeline design construction execution along   hardware configuration  completely independent   server provide  user interface  allow  unlimited flexibility   type  pipelines  integrate   pathosphere system  cloudbased front end web server  relatively low system requirements since  portion   system  store data  result allow submission  job  provide collaboration tool  design keep  computationally intensive process task    server currently  job  submit   process serially although   sophisticate job management system could  implement  current pathosphere front end server reside   single midlevel server   portion   system could  easily scale    powerful servers   user load   increase   future like  front end web server  backend servers   pathosphere architecture  also exist anywhere   world   network connection  backend servers  range  single machine  large computational cluster depend   type  algorithms  process  pipelines describe   paper  set   run   compute cluster consist   blade servers several support servers      share storage similar   front end  backend process need  build   expandable  cloud base service   user load increase security feature communication   client  web server  via https use tls   higher  public key infrastructure pki certificate   startcom sign rsa  bite key  ensure secure communication   client   webserver individual users  authenticate use usernames  passwords   information store   run   sample name  title  user   enter identifiable patient information   field   system   intented  store confidential patient data   data upload   specific user  visible   user unless   explicitly share  another user  order  join  community  user must  permission   group owner  web server mail server  cluster   network access restrict  external firewalls  limit access    expect network communication   access   backend compute cluster  via  secure shell ssh connection   pki key ensure   data remain secure  transit data   encrypt  store   compute cluster   cluster  locate   secure location   military installation",-0.17258119493764004,0.1875837236323681,0.11136208526172166,0.03626010880109135,0.047499952647232994,-0.016365227663853003,-0.052731465907276016,0.02811132753111211,0.06543850344348427,0.11975052171932955,0.026579169436970498,-0.05974563556505823,0.15501193816063066,-0.0534619474891447,0.09892555571722744,0.03222008877883726,0.13858510804658924,0.1776020426897987,-0.02330428874535144,0.041950065645708,-0.09388070397947228,-0.21792532834548128,0.10551095312899526,0.01137255438219145,0.015546517408247074,-0.11877988827179906,0.0876355862283665,-0.09196765252070273,-0.025676842561861545,0.015451650417956844,0.02034146073830452,0.2619628819355612,-0.1612825863902833,-0.014462259771661757,0.24839301761983704,0.07520797366677716,-0.02465478715332434,-0.046175972116760805,-0.039345730561866805,-0.08592528483775194,-0.03777883680229807,-0.11122125869096214,-0.1223727965968372,-0.1099228446069713,-0.06763062921301638,0.02860468105888642,0.07746979066854719,-0.08832601050245734,-0.2028191068125457,-0.21445231635452194,0.11082566795524527,0.07215563852423819,0.022085319893640497,0.4542315863409045,0.014542982386157031,-0.9823977591606012,0.018295199583938642,-0.20503660857904896,0.9272761528177682,0.1762674412778919,-0.12892657186784748,0.2788651307776372,0.01504147160360872,0.09467075191668124,0.5307707149849179,0.02914920105613808,0.022731019909047055,0.013498173126828012,0.241310888277566,-0.14967189764491085,-0.059590730181911376,-0.015560835752162647,0.10456452811799434,-0.15545411062021794,0.14327735459986482,-0.026826925481106826,-0.12488092848393607,-0.07106878624609779,-0.3767361628337711,-0.024368842096632298,0.23811452296770425,-0.03861594893593996,-0.3392978605217468,0.028915346794244588,-0.7776541649382611,0.16543726621211444,0.2924181474032422,-0.10082790462686987,-0.12885656853956826,-0.007268358105758319,-0.09429798611197387,0.07556287173776093,-0.033470180004738836,-0.05452741644761912,-0.02697389137650194,-0.06936127691049919,-0.06512126341032477,-0.3231318723518275,0.33838955532019016,0.07296158523323598,VirusDetection,2
57,57,"decontaminer  pipeline   detection  analysis  contaminate sequence  human ngs sequence data
reads alignment   essential step  next generation sequence data analyse one challenge issue  represent  unmapped read   usually discard  consider   informative instead   important  fully understand  source   read  assess  quality   whole experiment moreover    interest  get  insights  possible “contamination”  nonhuman sequence  viruses bacteria  fungi contamination may take place   experimental procedures lead  sequence   due   presence  microorganisms infect  sample tissue   propose  pipeline   detection  viral bacterial  fungi contamination  human sequence data similarities  input read query  putative contaminate organism sequence subject  detect use  local alignment strategy megablast   organism database decontaminer provide two main output file one contain   read match   single organism  second one contain  “ambiguous” match read   file data  sort  organism  classify  taxonomic group low quality unaligned sequence   discard  user criteria  also provide  output  information  summary statistics   number  matchedfiltereddiscarded read  organisms  generate  pipeline  successfully detect foreign sequence  human cancer rnaseq data
 decontaminer pipeline   suite compose  several commandline tool wrap together  identify  digital subtraction nonhuman nucleotide sequence generate  highthroughput sequence  rna  dna sample   mainly write use bash script   perl language  require  input  bam file   raw fastq file contain  unmapped read    read discard   alignment   human reference genome    schematic view   pipeline  show  fig    file     submit  decontaminer   collect    directory   path give  input  entire pipeline   subdivide  three main phase  first phase involve  filter  file format conversion step need  remove low quality read   obtain read  fastaformat file ready   align   genome databases   detail decontaminer wrap   pipeline two    use toolkits samtools   bedtools  use   format conversions  fastx    quality filter  filter  mainly base  two parameters set   user namely  phred quality threshold   minimum percentage  base within  threshold decontaminer work   pair  singleend experiment  parameter  must  specify   user  conversion step allow  sort  read  switch  bam  fastq    fasta format  terminate  conversion phase  map module  start   case  rnaseq data   crucial  remove  ribosomal rna rrna indeed rrna represent       total rna although  wet lab procedures provide  rrna removal step often  procedure   totally satisfactory due  high number  rrna copy  download  fasta sequence  human ribosomal rna      mitochondrial    ncbi website  rrna alignment  perform use  sortmerna tool     software design   aim   read    map   human rrna  undergo map  bacteria viruses  fungi genome databases ncbi  use  megablast  algorithm  rrna alignment reliability  evaluate use  evalue score  threshold   either set   user  leave   default sortmerna value  user  specify also  alignment length  number  allow mismatchesgaps  align  contaminate genomes  scheme   decontaminer pipeline   right  blue   input file   red  tool use  process  data   central part   flux  process step  describe   leave  parameters    set   step  indicate  green several tabdelimited file  one matrix   pipeline output   discard read  also provide  well    different file format generate fastq fasta etc  matrix contain   sample   easily use  create  bar plot  blast output  table format   submit   third  last phase  involve  collection  extraction  information   local alignments  module mainly compose  perl script  execute accordingly   userspecified parameters specify  filter  collect options  particular  filter  base   threshold number  total read successfully map    minimum threshold  read map   single organism instead  collect options involve  choice  organize  result accord either  genus   species name decontaminer store  output read  three main file unaligned ambiguous  align  “unaligned” file contain  read    satisfy  filter parameters  length  alignment number  allow gap  mismatch  ambiguous read    map  different genera   case  pairedend read   mat map  different genera ambiguous read map    one genus might derive  ortholog sequence since read match   filter criteria  store   “aligned” file  result  available   tabular format one   sample contain  name   detect organisms   relative read count furthermore decontaminer generate  matrix    easily use  create  barplot   type  diagram     data  collect together lastly  summary statistics   number  matchedfiltereddiscarded read  organisms  generate  store  tabular textual file",-0.2288669212787106,0.2223917472636156,0.15769704651466387,0.05735542994632645,-0.00147934884981453,0.0013131923996596582,-0.07944686296655115,0.04018447613732333,0.01757147919646606,0.14532430932606988,0.0578805461835261,-0.001803490810027155,0.17110816691025135,-0.0561638303691778,0.1403205112871704,0.06337875333637684,0.1147662332395006,0.19640920894039884,-0.016269891817771002,0.09612180321998136,-0.06928844377809852,-0.2557669580388977,0.1037072239743131,-0.0043340200466159785,0.0046397120751071955,-0.17616483284472714,0.10265612109916372,-0.1070438243675806,-0.03576308495921244,-0.027026539183445542,-0.028935314542794924,0.297058600999823,-0.14989115789947313,-0.07578495719762972,0.22936151152965775,0.08877522675419232,0.009984958686540068,-0.009811909915797095,-0.09319037905328187,-0.15949325995497546,-0.11417751441102528,-0.119116307547912,-0.09178768105450326,-0.12728077164018534,-0.11002474915204973,-0.015882331469053462,0.035495626648179734,-0.11792751112845876,-0.25198008792780097,-0.31512025720480985,0.20885341389799106,0.04943339008913629,0.04649081333563417,0.5822329871033979,-0.05131451510712553,-1.149251854208433,-0.059108029447114185,-0.23477476649767925,1.0151599728479297,0.272391136850859,-0.1814153470186798,0.4032128986473896,-0.027401671234794724,0.04542506757161873,0.7020769784154614,0.04658900486846708,0.029443255447956992,0.04497604583498657,0.1795996664538889,-0.2311378753507121,-0.08126260587195258,0.002868711572513149,0.10424562143334663,-0.1497914731764159,0.1669694628437336,-0.002574709672711184,-0.17310440160966373,-0.15135671206623585,-0.4101485622974356,-0.04679297725546632,0.22076722897561235,-0.021123359835453253,-0.3934813234109724,-0.03881101758554973,-0.8788014123374234,0.07297230425497267,0.2782349533388266,-0.11652007920407548,-0.1532298681742097,1.9396993400719897e-06,-0.16797576754727456,0.046940495139119534,-0.07972541318543243,-0.07176030444330124,-0.06261682679939212,-0.062138813683950724,-0.10004233406994874,-0.3758387803330412,0.320651354812836,0.08251350979458923,VirusDetection,2
58,58,"artdeco easy tool  detection  characterization  crosscontamination  dna sample  diagnostic nextgeneration sequence analysis
nextgeneration sequence ngs  routinely use  constitutional genetic analysis however crosscontamination  sample constitute  major risk  could impact  result   analysis   develop artdeco  tool use  allelic ratio    single nucleotide polymorphisms sequence  regions  interest   sample  contaminate  dna   different genotype unexpected ars  obtain    turn use  detection  contamination   screen test follow  identification  quantification   contaminant follow optimization artdeco  apply   constitutional dna sample  screen test  positive   sample   case contamination percentages     contaminant  identify   mostly locate  adjacent well three  positive case  due  barcoding errors  mixture  two dna sample interestingly  last contaminate sample correspond   bone marrow transplant recipient lastly  contaminant  identify   weakly positive    sample   consider   irrelevant  constitutional genetic analysis artdeco lend   mandatory quality control procedures also highlight  delicate step  library preparation result  practice improvement 
library preparation  sequence library preparation  perform manually  sureselect qxt kit   homemade   gene panel agilent technologies  first step   preparation consist  dilution   patients gdna      plate  columns  standard well plate gdna   fragment  adaptortagged  library  purify use agencourt ampure  bead beckman coulter amplify  repurified sample  hybridize   capture probe   capture use streptavidincoated bead dynabeads myone streptavidin  life technologies libraries  amplify  add barcodes  purify use bead libraries   pool  sequence   nextseq ® sequencer illumina® nomenclature   snp  wildtype homozygous sample  indicate  refref whereas  homozygous sample   alternative allele  indicate  altalt heterozygous sample  indicate  refalt rationale  strategy  base   detection  snps present unexpected   constitutional analyse  distortions   homozygous wildtype refref  homozygous alternate altalt   heterozygous refalt fig    snp    heterozygous sample      actually fluctuate around  value  due  differences  map quality  read   without mismatch  heterozygous range  define   note    range could  restrain  adapt   heterozygous distribution   distribution  know however    needful indeed homozygous snps   maximum contamination level result   value fluctuate around   around  whereas lower contamination level result   value    supplementary table  supplementary fig  consequently   range allow accurate discrimination  poorly call heterozygous snps  sample contamination   snp    homozygous sample  theoretically      practice  slightly different    background noise generate  polymerase sequence  alignment errors index hop  incomplete trim   adaptors see   extraction  background noise  generally low  illumina® sequence  expect value  usually observe   minimum depth   snps  study  set   see  snp selection  background noise  set    order  tolerate  least one read  default background  expect  intervals  homozygous snps use  therefore     refref  altalt genotypes respectively consequently unexpected ratios  situate      range fig   extraction  trim adaptors  cutadapt use default parameters  read  align via bowtie2 allow   one mismatch    bplong seed  report  unique alignments  read  map quality less    filter  variant call software   use   want  report  frequencies within  focus list  snps  depth  coverage function   genome analysis toolkit gatk  use  together  additional statistical analysis detail   report ars  snps  ensure analysis  highquality data  base quality ≥  consider  determination   depth  coverage   select polymorphisms snp selection   sample   distribution   snp selection  compute   algorithm  order  detect identify  quantify  contaminant supplementary fig  snp selection  retain informative polymorphisms   typical trimodal  distribution among   snps   european population frequency   range     genomes database  present   gene panel   recurrent high background noise  close  homopolymer stretch  exclude see “optimization stepˮ section  similarly polymorphisms within paralogous genes  exclude  avoid misinterpretation   spoil  expect misalignment  total   polymorphisms   able   analyze  snps   least  coverage  take  account  allow detection  low contamination homozygous snps    allelic version throughout  sample  noninformative  could   use  analysis detection  contamination “worstcase scenario” screen test  first step  identification  contamination consist   screen test   sample   run base  estimation   “worstcase scenario” wcs percentage  contamination  screen test  independent  background noise  identify sample possibly contaminate   certain cutoff define     present study follow  optimization step see   wcs calculation  define  wcs  maxr           median   highest   ars  refref snps    median   lowest   ars  altalt snps  main advantage   wcs test   rapidly rule   contamination    negative however    low specificity   positive wcs test must  confirm  identification   contaminant   worst scenario  never certain identification   contaminant contamination  suspect   wcs percentage  contamination  ≥  second step consist  identification   contaminant  order  confirm  contamination  identification  base   snps   contaminate sample   genotype compare   genotypes    sample   run  homozygous snps   contaminate sample  use  heterozygous snps exhibit excessive variability   value  allow reliable identification  small variations correspond  lowlevel contamination  snps       use correspond  homozygous snps refref  altalt include contaminate     noncontaminated snps      background noise  identify  putative contaminant  percentage  snps compatible  contamination  one sample   another sample   calculate accord   number  homozygous snps satisfy  compatibility condition list  table    word  homozygous snps  expect  value  contaminant      genotype   snps  unexpected  value  contaminant     different genotype  suspect contaminant  therefore identify   genotype   sample   sample    run  test score  rank  putative contaminants   sample   highest percentage  consider    putative contaminant  determine whether  putative contaminant actually contaminate  sample  study two condition   require firstly  percentage  snps compatible  contamination  sample   sample     higher   percentage  snps  sample  compatible  absence  contamination otherwise sample  could simply  genetically similar  sample   percentage  snps compatible  absence  contamination   percentage  snps   normal     among  total number  homozygous snp          supplementary table  secondly  putative contaminant    significantly  compatible   contaminate sample    sample   run fishers exact test  bonferroni correction  multitesting limit  significance  quantification  contamination   wcs contamination    rough overestimate value  refine percentage  calculate follow identification   contaminant  accord   genotype  contamination percentage   sample   contaminant  express   median   value obtain  calculation  contamination rate   snp  sample  collect  diagnostic  genetic counsel purpose appropriate individual write consent  genetic analysis  obtain    participate patients   legal guardians",-0.19663794577911872,0.18921690488988385,0.1487599846022157,0.1199340025951313,-0.07528814395071946,-0.006280113357090468,-0.09959414411779552,0.0346998993766821,-0.019101820837215896,0.1095548400542689,-0.04086983120415677,0.003403926819335035,0.15430250351237965,-0.11316089842659224,0.17815336868768505,-0.01647110057912985,0.03505719901357302,0.15187497804625774,0.02047112328557674,0.08686836914529658,-0.029032742293759625,-0.23501912824452875,0.0668209686287384,0.00849879379916758,-0.050627667108857806,-0.1896425074565025,0.0746987678947799,-0.19940149317141945,-0.06356392279609438,-0.055327835099114,0.04841043737743599,0.2156447203231708,-0.17178931090777352,-0.029669289517419487,0.2124717680863854,0.05334991556988593,0.0321400679568661,0.012376413458038402,-0.1036577591154863,-0.10082479300995437,-0.10169150060407467,-0.12244243302352804,-0.12986759601521275,-0.1361492182777704,-0.13714024831201546,-0.032213304195233536,0.13466962271535948,-0.14854846937375074,-0.2649161694438241,-0.4168332491331347,0.1877628887549632,0.021054180849224648,0.035297177519594776,0.5442032804879845,-0.007807143084101745,-1.0293834800534742,0.05640996504170037,-0.23627376174331305,0.910310062520674,0.20857748775535506,-0.1582208440616322,0.3123432671940889,-0.03283709275413632,0.10036808699604738,0.5671885866520708,0.040628233419835284,0.018501170007437662,-0.02822110218279549,0.22183123222698375,-0.1972501941865553,-0.09607632972450872,-0.04156031303407756,0.1364166259346406,-0.06643481148847136,0.1952919652338754,-0.02023905074221399,-0.14125076110328935,-0.1864909426057761,-0.3477503697535251,-0.08388719649395925,0.19228452110528066,-0.03523448512544534,-0.35033636127023937,-0.04294230959637022,-0.8419246721865381,0.02611596453650062,0.2424904704230164,-0.10127172399587196,-0.11009190328053244,-0.0013708721577286465,-0.22456491172488316,0.08169180452061986,-0.13412103653009833,-0.1048754084634872,-0.0980693370088665,-0.00967603954306972,-0.07858439147140474,-0.3282727663073332,0.24873013744086456,0.07879085653149424,VirusDetection,2
59,59,"paprbag  machine learn approach   detection  novel pathogens  ngs data
 reliable detection  novel bacterial pathogens  nextgeneration sequence data   key challenge  microbial diagnostics current computational tool usually rely  sequence similarity  often fail  detect novel species  closely relate genomes  unavailable  miss   reference database   present  machine learn base approach paprbag pathogenicity prediction  bacterial genomes paprbag overcome genetic divergence  train   wide range  species  know pathogenicity phenotype   end  compile  comprehensive list  pathogenic  nonpathogenic bacteria  human host use various genome metadata  conjunction   rulebased protocol  detail comparative study reveal  paprbag  several advantage  sequence similarity approach  importantly  always provide  prediction whereas  approach discard  large number  sequence read  low similarity  currently know reference genomes furthermore paprbag remain reliable even   low genomic coverages combiningpaprbag  exist approach  improve prediction results
summarises  individual step  paprbag  supervise machine learn setup comprise  train   prediction workflow  entire set    nonhp bacterial species  divide  nonoverlapping train  test set subsequently select genomes   species  fragment  read see subsection benchmark    range  sequence feature  extract subsection feature  train sequence feature together   associate phenotype label compose  train database    random forest algorithm train  pathogenicity classifier subsection machine learn  turn  classifier predict  pathogenic potential   read   test set base   raw result various analysis step   perform  section  provide  summary   different benchmark approach subsection benchmark evaluation strategies subsection metrics  metagenome configuration subsection metagenomic example use   result section machine learn  random forest classifier34  train use  belowdescribed feature  genome pathogenicity label   read   train data set  choose  classifier type   combine high accuracy fast prediction speed   capability  deal  noisy data35 among  different implementations   random forest algorithm available  opt  ranger37 since   one   fastest  implement   —   handle large data set  use probability forest  return  fraction  vote   class   also  interpret   prediction probability  therefore refer   prediction probability    class   pathogenic potential   read  another advantage  random forest approach    tuneable parameters   context  find  sufficient  train  tree per forest   tree   lead  better predictions see supplementary fig  fluctuations play  role  small tree number     tree per forest forest   tree   however yield  similar perread predictions  nearly identical pergenome predictions justify  parameter set   adjust  minimum size  terminal nod high number  result  impure terminal nod  smaller tree change    default   choice      effect  size   lead  overfitting change   parameters   substantial effect respectively  train random forest object  available  github feature   machine learn task  set  informative feature must  extract   read sequence  implement  number  different feature type  capture  information content present   sequence read genomic feature different feature  extract  dna sequence    base  kmer occurrence pattern since  analyse read data strand information   available therefore  cast  feature symmetrically    occurrences   word   reversecomplement  consider jointly  common strategy  relate methods39  first feature type   relative kmer frequency  find  include monomers dimers trimers  tetramers lead  good result  higher value     lead   improvement  occurrences  longer kmers  less likely  overlap among highly divergent sequence conversely  consideration   large number  uninformative long kmers  compromise prediction performance however  focus  select longer sequence motifs  still  beneficial  classification  also record  frequencies     abundant mers   independent set  bacterial genomes scan  strand  allow  one mismatch space word  introduce   alignment  dissimilar sequences41 thus  incorporation  useful   context  novel species discovery space word denote  occurrence   kmers interrupt   spacers   word  length    analysis  search   symmetric mers   space word  length  protein feature bacterial genomes  know   densely pack  proteins43 since protein sequence  evolutionarily  conserve  dna sequence peptide feature  provide additional valuable information  read might partially cover  protein sequence   correct read frame  unknown however longer dna sequence tend  contain frequent stop codons   antisense frame  chance therefore   simple heuristic  generally use  frame  strand   fewest number  stop codons  frame  translate   peptide sequence  several type  feature  extract codon frequencies relative monopeptide  dipeptide frequencies amino acid properties  amino acid index aaindex statistics  amino acid property feature consist   relative frequencies  tiny small aliphatic aromatic nonpolar polar charge basic  acidic residues47 finally  aaindex assign score  diverse properties often base  peptide secondary structure   residue   indices  select     lowest pairwise correlation feature  obtain  compute  product   amino acid frequencies   associate index score  total  include  feature   classification workflow feature importance  measure    permutation  gini test   important feature come   dna monomer dimer  trimer feature group see supplementary table  among    important feature  tetramer codon frequency aaindex  space word group  also prevalent  estimate  importance   different group  search   highest score member   group  result order  group importance  trimer monomer dimer tetramer space word aaindex score codon frequencies monopeptides dna motifs amino acid properties  dipeptides particularly  last five group   minor importance   classification task benchmarking crossvalidation strategy  evaluate  develop classifier  perform  fivefold crossvalidation study    randomly distribute    nonhp genomes  five equallysized nonoverlapping part respectively    single randomly select strain genome per species  consider  significant variation   number  strain per species       mainly due   pathogen study bias would  otherwise translate  largely skew train databases apart  markedly reduce label imbalance  ratio decrease      also reduce  train data size   describe approach reflect  scope   work   predict phenotypes   species level still  comparison  include  strain   train species   separate benchmark study see result  coli play  unique role    possess  large number  know   nonhp strain   study  consider   strain  since  aim   provide specieslevel predictions  rationale     sensitive towards pathogens read simulation    train  test data set  simulate   long illumina read   end  use  mason read simulator   default illumina error model48  number  read sample per genome differ   train  test set  train binary classifiers   generally advantageous  show  learner  equal number  examples   class therefore despite    nonhp ratio     decide  sample   total number  read per class   represent  tradeoff  genome coverage  train data size  increase   read   substantially improve  prediction result   number  read per genome   class  choose    genome    coverage  proportional   size   genome conversely   test data set  choose  sample    coverage  approximately    genome  read simulation  repeat   fold comparison   methods   compare  performance  paprbag   range   tool     originally develop  taxonomic classification first  use bowtie2 one   commonly use read mappers combine speed  accuracy49   consider pathoscope217   dedicate pipeline  pathogen identification  sensitive map  expect  blast13   still widely use  ngs pipelines   method integrate  alignment  compositionbased characteristics   assess kraken   emerge  one   primary taxonomic classification tools20 finally  consider nbc   compositionbased machine learn method22 unlike similar approach  allow  construction   custom train database  evaluate  performance   tool use  paprbag train  test genome set  use fivefold crossvalidation bowtie2  read map  use bowtie2    verysensitive configuration   highly tolerant towards mismatch  gap  obtain   top alignments   read parse  result sam file  match  bestscoring map   read   label database    one alignment share  best score  choose  match      match   nonhp  unmapped read  prediction could  make additionally  repeat  map workflow   larger reference genome set include  strain   train species pathoscope2 pathoscope2  work   postmapping filter hence  run  identification module   sam file produce  bowtie2  result filter sam file  analyse    obtain label predictions also  analysis  repeat use  allstrain reference set kraken  provide kraken    train genome sequence    build  database base  cladespecific mers base    tool try  classify  read taxonomically  result species  match   label database via  ncbi taxonomy    fail  species name obtain via krakens translation module sometimes still produce  match  krakens prediction    species resolution  prediction  make  since match mers  divergent sequence may prove challenge  repeat  entire analysis use mers kraken note   former share characteristics   alignmentbased method   latter   consider compositionbased blast  run ncbi blastn    option task dcmegablast   tailor  interspecies comparisons additionally  choose  evalue threshold     result blast output  highestscoring target  match   label database naïve bay classifier  create  set  nbc  train databases  word length    score  test read set   train databases   read  select  highestscoring hit  match  species name   label database since classification  nbc take  long    use parallel thread evaluation metrics majority prediction rule  test methods yield predictions  individual read  ultimately   interest   single integrate prediction   genome  individual read match    genome cannot    deem significant give  also nonhp genomes  contain stretch similar   genomes  paprbag  therefore average   readbased prediction probabilities   value exceed   sample  classify  pathogenic likewise    methods  assign  class   higher number  read  evaluation metric  henceforth  refer    majority prediction rule minimum detection threshold  majority prediction rule allow   simple estimation   pathogenic potential   sample however  ignore uncertainty due  miss predictions therefore  implement  complementary metric  minimum detection threshold   user  define  minimum fraction  read    require   confident phenotype prediction     give test genome  collect  readbased evidence   phenotype  consider  prediction    number  read support  exceed  minimum detection threshold   phenotypes  support  bettersupported one determine  prediction   prediction  make  neither phenotype  sufficiently support   phenotypes  assess  fraction  correct predictions  correspond   true positive rate tpr  true negative rate tnr respectively   summarise  performance use informedness also know  youdens  statistic    joint measure  specificity  sensitivity50 formally informedness  define    tpr  tnr    range    wrong predictions    correct predictions consensus filter individual approach may yield heterogeneous predictions  make  attractive  combine   enhance prediction confidence  therefore define  consensus filter  follow first  evaluate  predictions coincide  two methods   keep   consensus subset   performance evaluation prediction certainty  prediction make   majority prediction rule  associate  uncertainty  define  prediction certainty         denote  majority prediction  discuss   result   relative certainty value  always range   maximally uncertain   maximally certain note   value   reflect  predict class   normalise  certainty   predictor   highest certainty  report   genome     necessary step  aid visualisation metagenomic example  illustrate  application  paprbag   metagenomic context  simulate  artificial set  read belong   set  know nonhps present   give train fold   single unknown   present   fold    choose gardnerella vaginalis currently   know representative   genus since   know  invade  female urogenital system   select  range  nonhps   know  colonise   habitat  healthy humans accord   hmp   lactobacillus salivarius lactobacillus reuteri lactobacillus rhamnosus bifidobacterium breve  haemophilus parainfluenzae    find   relevant train fold   strategy resemble  use  ref  mimic  clinical sample  nonhps  commensals  generally vastly outnumber  give   sample  read     latter    read equivalent   coverage     former   control scenario   identify  number  true positives  vaginalis read map  another  false negative  vaginalis read map   nonhp  false positives nonhp read map   ",-0.20539726496902613,0.21987545635714,0.12716155063512052,0.13377321518303953,-0.045858400984832105,-0.040889830805189716,-0.1068693338079441,-0.00730327555691203,-0.029654676969212288,0.0992773987017702,-0.033709927539952875,-0.03912756477947375,0.177755437034196,-0.0977803396035032,0.16810829572702082,0.002596027078613153,0.04928263135490106,0.16425544259953045,-3.405107639517392e-05,0.09525201283955674,0.0012480158245650856,-0.24082720552270864,0.05651835813396755,-0.012562818192552935,-0.04367490897464178,-0.1900505085754308,0.09348515147363703,-0.12333152333154453,-0.07981043958228251,-0.03947700072712227,-0.009730515839070695,0.2367997608094777,-0.16550272761233822,-0.1117479155420471,0.2351886225851728,0.07752052469121913,0.06428040190410413,-0.0009926607905885619,-0.1090550228269331,-0.11012633364797304,-0.08504304620516863,-0.1105824229205564,-0.07923838654469308,-0.10357840935484887,-0.08908648787048988,-0.0022708424708946713,0.15514750934028074,-0.0872455503991682,-0.25561821475790986,-0.3591413120428239,0.1724854126960901,-0.008456780219191008,0.06876265250655435,0.5460083453615213,0.03631488478511879,-1.036351353133615,0.0809421160011422,-0.2215086018749056,0.8865705799684326,0.15992978921811368,-0.1828145565426137,0.3083883012134816,-0.05270754197476466,0.031684248881755146,0.5709269466616144,0.05393471180408743,0.024246245713019456,0.003077529468740446,0.2265469955539104,-0.21833271140999866,-0.0736126007524199,-0.061264882043287124,0.1182937666881625,-0.07653763832899334,0.16860515839616935,-0.06674388433558583,-0.15213689540284367,-0.17991572546393764,-0.3501543255680749,-0.060852771949764885,0.15176929606704395,3.965202233969575e-05,-0.4069991166101803,-0.0430605647901452,-0.7814127428025825,0.03398401601200631,0.2158578707639892,-0.11469591862897342,-0.12157063563777315,-0.02792287854272952,-0.20947659392432624,0.059280017062932004,-0.13555156087729886,-0.09835779922869728,-0.0919687577851568,-0.0368578440107706,-0.1363533505214008,-0.3297010043919591,0.26050112916442986,0.09585570651634384,VirusDetection,2
60,60,"virvarseq  lowfrequency virus variant detection pipeline  illumina sequence use adaptive basecalling accuracy filtering
 virology massively parallel sequence mps open many opportunities  study viral quasispecies   hiv  hcvinfected patients   essential  understand pathways  resistance   substantially improve treatment although mps platforms allow indepth characterization  sequence variation  measurements still involve substantial technical noise  illumina sequence single base substitutions   main error source  impede powerful assessment  lowfrequency mutations fortunately base call  complement  quality score    useful  differentiate errors   real lowfrequency mutations  variant call tool qcpileup  propose  exploit    nucleotides   filter strategy  increase specificity  tool  imbed   opensource pipeline virvarseq  allow variant call start  fastq file use  plasmid mixtures  clinical sample  show  qcpileup  able  reduce  number  falsepositive find  filter strategy  adaptive  provide  optimize threshold  individual sample   sequence run additionally linkage information  keep  singlenucleotide polymorphisms  variants  call   codon level  enable virologists    immediate biological interpretation   report variants  respect   antiviral drug responses  comparison  exist snp caller tool reveal  call variants   codon level  qcpileup result   outstanding sensitivity  maintain  good specificity  variants  frequencies   
several sample  sequence use illuminas genome analyzer  iix accord  manufacture protocols see supplementary material   virvarseq pipeline proceed  follow  sequence read  align   reference sequence use  burrowswheeler aligner tool    durbin   base   alignment  consensus sequence  define  realignment  perform   consensus  strategy  iterative map  increase coverage especially  sample   consensus strongly deviate   reference see supplementary fig    alignment qcpileup  execute  consist   threestep analysis   first step     codons   read frame  interest  retrieve next  threshold  determine dependent   quality   run finally  filter codon table  construct  virvarseq pipeline  run  fastq   filter codon table  available   together   users guide see supplementary material    read contain indel errors  remove  run qcpileup   hereby assume  indels  result  nonviable virus   rare occasion however  might   insertion mutation   codon level    investigate   separate analysis see indel table supplementary material    different step  qcpileup   explain   detail  quality  codons  pileup  read base  generate use  alignments   consensus sequence  analogy  mpileup  samtools    basepair information   reference position  describe cpileup describe  codon information   amino acid position   reference genome   position   reference genome  different codons  report together  one    codon  require      three nucleotides within  codon    summarize  comparative analysis  different summarizations reveal   weakest link  minimum    three nucleotides   codon provide  best separation  low  highquality codons see supplementary fig    minimum  represent  codons nucleotide   highest probability    sequence error  codon table  build base   pileup    codon position   reference  different codons within  sample  report together   frequency  table    minimum    codons   particular position  average  give  rough idea   overall quality however  individual minimum    codons   use  subsequent analyse  qintersection threshold  distribution   minimum   check  compare  one particular sample sequence  two different run  three different lanes reach  average coverage  around    fig    shape   distributions   approximate   mixture distribution  three truncate normal components see supplementary material  model selection  goodness  fit  supplementary fig   truncation  perform   lower  upper end    range  first mode represent  point probability       lowest illumina    due   artifact create  illuminas base caller read end   segment  mostly low quality ≤q15  give      second component distribution   distribution  low  reflect  sequence error distribution finally  highest mode close   originate   distribution  reliable call note   mixture  three normal components   errors  reliable call   consider    work assumption   neither trim  filter   data  require  fit  mixture model  expectation maximization  algorithm  mclachlan  mclachlan  jones     apply  fit  normal mixture model   write  rwrapper  run  original fortran code  mclachlan   embed   pipeline virvarseq   algorithm  initialize  set  three modes        variances     point probability      two distributions  marginal error probability  sum  mix proportion   distributions      set    bulk    high indicate  majority  reliable call   dataset green distribution  fig      end  clear point probability       see  red distribution  figure  correspond  lowquality codons   likely   sequence errors   several criteria  define  threshold  filter  lowquality codons   distinguish  errors  reliable call  approach  choose   adaptive  robust  intersection point   two component distributions  use   refer    qintersection threshold qit   indicate  vertical dash line  figure    distribution   minimum    codons  hence  qit vary  different run    sample confirm  need   adaptive filter strategy  filter  codon table   qit  determine  update codon table   construct  codons   minimum    threshold   filter   analysis  influence  trim  negligible   mainly affect lowquality nucleotides   remove   filter  threestep analysis return  codon table  different variants   frequencies   codon position   reference   robust  sequence errors distribution   minimum    codons present   hcv sample   sequence twice    run run    different lanes lanes       sequence yet another time  another run run   black line show  overall fit   mixture distribution  consist   blue  red   green component distributions  blue   red distributions correspond  codons  likely result  sequence errors   green distribution represent reliable call  qit  indicate   vertical black dash line  note   different codons observe   sample  count   codon position   reference genome   frequencies  calculate use  coverage   particular position    summarize  average  minimum    codons position amino acid position   reference ref codon   reference genome   particular position codon codon present   sample   particular position count  number  time  particular codon occur   cpileup   particular position coverage  number  read  fully cover  particular codon position frequency countcoverage mean average   minimum    particular codon   particular position",-0.18303848867155426,0.18908868681093485,0.13847625565389973,0.14059325605905187,-0.061244141197717886,-0.024307516012768975,-0.0938938068934842,0.028105030083846856,-0.024699713714590902,0.11038712921536303,-0.0044771168025039216,-0.029398998022802044,0.1791019439703956,-0.1161860210564116,0.19249208619888009,-0.004804275194888843,0.00760723542068796,0.13425327477926166,-0.03287372242655316,0.0763636937815878,0.015106628420789482,-0.2359863401359836,0.04039047406210253,-0.024142944502869045,-0.03213378656408,-0.18890526005496466,0.0944565111205374,-0.15632729260444952,-0.03414674842907129,-0.08063097374977735,-0.012724081083099177,0.27056603219451103,-0.15480883227403333,-0.08103627334422453,0.20688290703459974,0.09551096119944356,0.047596332469577736,0.02329141287074221,-0.07165208268303815,-0.0809066991151803,-0.08562549278133377,-0.1316253171523082,-0.09543670115441462,-0.11807978606412198,-0.12969463876978465,-0.013935587698215804,0.1323310001157813,-0.16802114407711224,-0.26158022879149184,-0.40922169426045296,0.1982154126878528,0.060348300662041575,0.04812214434151565,0.6023345975867329,-0.006938167176632232,-1.1557645200559037,0.0675857406798362,-0.2284886684290792,1.0064797164797354,0.19648909694802866,-0.17943040019641535,0.30622565583518274,-0.03682037796049068,0.05889340902306674,0.5958108163804041,0.060022667476883285,0.030398692690706133,-0.0251333122001158,0.19587029353180235,-0.22033232224378574,-0.04600629787623855,-0.05088076481579578,0.1412191055812933,-0.14482268112465396,0.22306090513319204,-0.04516884050299895,-0.10622402045931988,-0.1667266942777446,-0.33259449148719233,-0.12044485651300607,0.18542652715220995,-0.014088378997884916,-0.3828909753423034,-0.06622334927050852,-0.8883946662907216,0.07280484786984409,0.2412334565439893,-0.11366869324026095,-0.1376969374158626,-0.0048070232775804965,-0.21050520170407755,0.060022126131586674,-0.1854457856328548,-0.09814149447336752,-0.13864184038555674,-0.07023598383389541,-0.10970287694162208,-0.34065025092247103,0.3046120123246259,0.10240124962018302,VirusDetection,2
61,61," ""giant virus finder"" discover  abundance  giant viruses   antarctic dry valleys
mimivirus  identify     biofilm  anindustrial watercooling tower  england later numerous new giant viruses  find  oceans  freshwater habitats      geneswe  demonstrate  likely presence  four soil sample take   kutch desert gujarat india   describe  bioinformatics workflow call  giant virus finder   capable  discover  likely presence ofthe genomes  giant viruses  metagenomic shotgunsequenced datasets  new workflow  apply  numerous hot  cold desert soil sample  well   tundra  forest soilswe show     sample contain giant viruses especially   antarctic dry valleys  result imply  giant viruses could  frequent    aqueous habitats    wide spectrum  soil   planet
 believe   method present    general workflow  could also  apply  identify  set  taxa   giant viruses  step   general workflow   follow  identify  set   genomes   search    application example    set  genomes   giant viruses  apply subsequencesearch   sequence     target metagenomic shotgun sequence database    example   one    metagenomes    verify  specificity   hit  whole fragment   metagenomic dataset contain  highestscored alignments  align   sequence   large nucleotide database suppose   top score hit  score     hit  score greater      set  accept otherwise reject  hit   example  hit  align   sequence   nucleotide collection    ncbi   hit  accept   every sequence   topscored  belong  set      giant virus list   cutoff  apply   default value   megan phylogenetic analysis tool    similar decision  find  number   low   purpose   set   stringent value   users  simply change  threshold   require  giant virus toplist   workflow describe   need  list    genomes  sequence   organisms   search  define    giant virus       difficult question  would  like  use potentially questionable  dispute phylogenetic information   definition rather   simply construct  list  viruses  viral genomes  partial genomes     complete genome deposit larger   kbp   detail   reference genome data  take   ftpncbinlmnihgovgenomesvirusesallfnatargz file   ncbi genome ftp note   length  distinct genome sequence segment belong   single genome  sum  sequence  add   ncbi nucleotide database use  search term “viruses”organism  sequence length  “bacteria”organism  “archaea”organism  list   viruses find  also give  table    support material together   sequence accession number apply   work  inspiration   giant virus toplist come    toplist   uptodate  contain    full  also partial genomes however   well aware   toplist    single perfect list   need   modify   course  time   novel discoveries  genome depositions therefore   make  possible  change  list   “giant virus finder”  order  suit  specific need   users sequence alignments  metagenomic data   article   deposit   mgrast archive   download  convert  file  fastq format next   standalone blast distribution  downloadable makeblastdb program  create  blast databases      metagenomes  phase  figure   use  stand alone unix blastn program   default megablast algorithm  change  wordsize      evalue        parameters   score  penalties  retain  default  blastn next  phase   hit   evalue better    collect   alignment   align use blastn  wordsize     whole nucleotide collection   ncbi suppose   top score hit  score     hit  score greater       giant virus toplist  accept  hit otherwise  reject   summary   result   twophase search process   highest score giant viruses  give  supplementary table    count  figure    file create   workflow  give    advantage   twophase method use  straightforward one phase method  simply blastn search  read    database   wordsize option would require   years   hread   machine use  single cpu core select  candidate read    read    metagenomes  phase  reduce  run time    days   singlecore machine",-0.23391037764466874,0.2474120337146001,0.19745018882620166,0.0568009220182941,0.032617203943806176,-0.0004409787688040879,-0.07372566438431481,0.04730096830782003,-0.06228913114466743,0.0974256533020123,0.046697849464580055,0.013693774045195155,0.14863512941401422,-0.11857435708852272,0.12778878561126414,-0.0037330658424918244,0.14586835393466327,0.1700759010949755,-0.10564486105165376,0.13061704906626467,-0.032326283248527564,-0.1397685944008058,0.08268012468157927,-0.0043999494310862156,0.020843503942308054,-0.12407127501631375,0.06423533428838946,-0.12980063623139196,-0.08168171136557198,-0.05311443970507442,0.034111444531690065,0.2692190210847941,-0.16495254443488955,-0.06607027238871849,0.2153382730397928,0.10213232818258383,0.01580688806545989,-0.054489635735583616,-0.06731086679496727,-0.16555874186711825,-0.14601451600227425,-0.11339493344387187,-0.043877896638653366,-0.12182787799880256,-0.08457846879297527,-0.02518294106438241,0.0974329444948902,-0.13903601066307808,-0.16778975984387334,-0.3324205663262931,0.2087659272308484,0.03931926470344538,0.10008094440653496,0.5786734845913281,-0.011491923198544958,-1.2770130081723134,0.007596943409625076,-0.22931219555855906,1.0406591433850003,0.24562275624569935,-0.17560365797662672,0.3813120652751134,-0.06814128349343981,0.0313606982827338,0.7169922736390093,0.034796615548590884,0.07728421641324412,0.04225857844538381,0.18800475428967425,-0.23783358998645884,-0.06003244335567238,-0.017398519356303464,0.09075770409620648,-0.1495982445312694,0.11654486852069575,-0.014083861167981796,-0.1712412355691043,-0.136067688685645,-0.416208413577207,-0.02081897077567088,0.27284362680894275,-0.038383817188517466,-0.3544265595394872,-0.02152248197665809,-0.8373889404318742,0.053493219895791866,0.24641343929953455,-0.1507724327739419,-0.08502987105133414,-0.0073092271310250785,-0.12476211683602237,0.06634859146459911,-0.07201215202969355,-0.0801013602015782,-0.12139941087330748,-0.048048230567170926,-0.11925167006599467,-0.2685027531408743,0.3213552657999401,0.10232840762502037,VirusDetection,2
62,62,"imsa integrate metagenomic sequence analysis  identification  exogenous read   host genomic background
metagenomics  study  microbial genomes within diverse environments   rapidly develop field  identification  microbial sequence within  host organism enable  study  human intestinal respiratory  skin microbiota   allow  identification  novel viruses  diseases   merkel cell carcinoma    publicly available tool  metagenomic high throughput sequence analysis  present integrate metagenomic sequence analysis imsa  flexible fast  robust computational analysis pipeline   available  public use imsa take input sequence  high throughput datasets  use  userdefined host database  filter  host sequence imsa  align  filter read   userdefined universal database  characterize exogenous read within  host background imsa assign  score   node   taxonomy base  read frequency   output    taxonomy report suitable  cluster analysis    taxonomy map taxmap imsa also output  specific sequence read assign   taxon  interest  downstream analysis  demonstrate  use  imsa  detect pathogens  normal flora within sequence data   primary human cervical cancer carry hpv16  primary human cutaneous squamous cell carcinoma carry hpv   caski cell line carry hpv16   hela cell line carry hpv18
imsa use  action file  filter nonhost read  align  universal database imsa use  action file  guide  filter  alignment step  typical action file  filter  large read set   human genome might  quality bowtie human dodivide  true blat human  fastmap blat human blast human maxeval1e  word_size  blast human maxeval1e blast  maxeval1e  —max_target_seqs    step   additional parameter options   describe   user manual quality filter  default remove  read     base   quality less    user  define alternate quality metrics  omit  step   action file  example “quality  ” would remove read     base   quality score less    alignment action  line   action file specify two step first alignment  perform   specify alignment program   bowtie  blast next  read set  filter  remove read   hit   alignment result parameters  filter    pipe “” whereas anything   pipe  send directly   alignment program  parameters   “maxeval”  blast   use   filter  alignment   automatically  send   alignment program  default pair end  treat  individual read  maximum sensitivity   behavior   modify databases   alignment program  define   imsa configuration file   databases use   location   computer system   easily modify similarly  configuration file  specify  ooc file  use   blat alignment imsa  run  filter bowtie blat  blastn new ncbi version alignments filter  read set use  bowtie result   memory intensive   option  divide  file  piece   use  reduce  memory footprint blat  blast alignments   perform   sun grid cluster  run straight without  cluster  final step   action file   alignment   universal database  input   alignment   hostfiltered read set   step  blast result  use  subsequent analysis rather  simply  use  filter  read set  host filter blast step  default   set  max_target_seqs parameters    short circuit search  read  map multiple place   alignment   universal database see    last line   action file  parameter  set higher   match   read  find taxonomy score  calculate base  universal database alignment  visualize  taxmaps  imsa  complete  filter action file  next step   process  universal database alignment result  yield  imsa report first  blast result  process  identify  best alignment   read   read hit many sequence   universal database   alignment   highest score  keep   read align  multiple sequence  equally high score    target  report however imsa assign  score   target indicate whether   much  sequence read  split  example  read  align   single sequence   universal database  give  score     read hit two sequence   universal database  equal score  alignments get  score    read hit three sequence  get  score     hit etc  treatment allow tie   keep   score assign   node  lower  nonunique read  likely represent conserve regions  higher  read   unique   taxonomic node  default behavior   keep   tie score   way  imsa provide  functionality  filter read  score   give threshold though  reduce sensitivity    informative   look  read   unique best hit   universal database next  taxonomy   score blast result file  calculate    species   hit   universal database  determine      step imsa assume   universal database   ncbi nucleotide transcript database    universal database  another database  title   different format  user   customize  portion   code  extract     fasta title  translate    species   target  determine   hit imsa  retrieve  entire taxonomic record   target  ncbi imsa use  best read alignment score assign   target  calculate  score   species genus family  division   align read   sequence dataset  taxonomy  universal database result  list  taxonomy report text file  addition taxmap bubble diagram   generate  species genus family  division imsa generate text file   format ready   interpret   diagram use  graphviz open source graph software  data   use   downstream analysis  characterize  metagenome   sample   identify potential pathogens imsa include additional tool  subsequent investigation  python script getfastafortaxonomy take  list  taxonomy ids   level along   fasta file  filter read   blast alignment   universal database  create  fasta file    read align   taxonomic ids  script speciestoclustertable  take  set  species genus family  division file  create  table  result suitable  input  cluster  treeview  visualization   frequency   sample   larger study",-0.2095338676398468,0.2300883250059592,0.1824033435134172,0.07627243654173475,0.038699215360490286,0.005796946379834683,-0.08691356017940659,0.0449346144624643,-0.016093153956009902,0.1418579392783512,0.03113952835863327,-0.017805437705747964,0.1628062948897827,-0.10659867556589436,0.1607447171857833,0.022346160371348053,0.06216357473022072,0.17527863073094824,0.0019414224132358665,0.05624535021262192,-0.0798608076875098,-0.2680028319721007,0.0746066798961288,0.03534517650203068,0.01690989453749757,-0.1642284642795049,0.09744823731984474,-0.16765508889026629,-0.03637339432407316,-0.007646424775076512,0.008028415756093131,0.3152038794594571,-0.1608344132982893,-0.05140668141353268,0.2697570194593734,0.10928453509566476,-0.04082998233813365,-0.0012265193686794695,-0.08812102371403954,-0.061061103173010965,-0.08736889778992918,-0.1709173466556927,-0.13068594954125326,-0.14552142684988212,-0.10637193747708,0.053548321386592254,0.08105231859250732,-0.12129716399229235,-0.20214865613888836,-0.329980577851125,0.17899816592600676,0.037482146965178084,0.061596722412610286,0.5748836860099497,0.0252661512446745,-1.2490386258658772,0.05195490573694568,-0.21426948486340636,1.0688063389744558,0.2667038043590664,-0.15853832587375413,0.438610032788549,-0.007103442483639809,0.05175259525842395,0.6500710343429495,0.055062676277985806,0.04559614609267252,0.016024236118634388,0.2415739854695857,-0.19534815503296465,-0.08457506069227191,-0.03270484695571617,0.12367292162384225,-0.16324478999417302,0.1945059961645812,-0.015864401791380562,-0.1310401103627454,-0.1559209458517014,-0.38098193973969,-0.08383399801581011,0.2264372242500738,-0.03607368841827944,-0.4280441877506544,0.004960107267227915,-0.8938180511144714,0.07829065810680429,0.26457458063830724,-0.12675693753772066,-0.09821791890398243,0.025151161939094082,-0.14768972930889707,0.07029937896408632,-0.0577594359302667,-0.0772334432937593,-0.07030887394386001,-0.03751811309363499,-0.08691253711973937,-0.35784097831593603,0.3627086709505723,0.037700689206960514,VirusDetection,2
63,63,"identify viruses  metagenomic data use deep learning
 recent development  metagenomic sequence make  possible  massively sequence microbial genomes include viral genomes without  need  laboratory culture exist referencebased  gene homologybased methods   efﬁcient  identify unknown viruses  short viral sequence  metagenomic data methods   develop  referencefree  alignmentfree machine learn method deepvirfinder  identify viral sequence  metagenomic data use deep learn train base  sequence  viral refseq discover  may   evaluate   discover   date deepvirfinder outperform  stateoftheart method virfinder   contig lengths achieve auroc             sequence respectively enlarge  train data  additional millions  puriﬁed viral sequence  metavirome sample  improve  accuracy  identify virus group   underrepresented apply deepvirfinder  real human gut metagenomic sample  identiﬁed  viral sequence belong   bin  patients  colorectal carcinoma crc ten bin  find associate   cancer status suggest viruses may play important roles  crc power  deep learn  high throughput sequence metagenomic data deepvirfinder signiﬁcantly improve  accuracy  viral identiﬁcation   assist  study  viruses   era  metagenomics
viruses  prokaryotic genomes use  train validation  test  collect  refseq  viruses infect prokar yotes bacteria  archaea  ncbi  ncbinlmnihgovgenomebrowse  dataset  parti tioned  three part base   date   genomes  discover  use  genomes discover  january   train   january   may   validation    may   test  partition   dataset   avoid  overlap   train validation  test datasets  also help  evaluate  methods ability  predict future new viruses base   previously discover viruses  previously use  data  may   ren      study  update  dataset  include new viruses  may     natural  use    test data since sequence  real metagenomics data   various lengths range  hundreds  thousands  base pair  fragment  genomes  non overlap sequence  different size            build model  sequence   size respectively  particular  model       design   next generation sequence technology  commonly generate sequence   fix lengths table  show  number  sequence  different size   use  train validation  test  dataset  pair    number  prokaryotic sequence fragment   refseq  partition   exact  date  objective function   minimize  binary cross entropy loss   predict score yfinal   true label   prokaryotic sequence    virus sequence  train dataset  iteratively feed   model  batch  size  one iteration  finish feding batch   whole train dataset  call one epoch  parameters   neural network  update  backpropagation use adam optimiza tion algorithm  stochastic gradient descent  learn rate   dropout regularization  rate   apply   max pool layer    fully connect layer  reduce overfitting  neural network  randomly drop    dimension  convolutional neural network  three critical hyper parameters  length  motifs  filter  number  motifs   number  epochs  train  first two determine  complexity   model   third one control  balance  overfitting  underfitting  find  best parameter settings  train  model  different combinations   three parameters use  data  january   evaluate  model performance use auroc   validation dataset collection  metavirome datasets  achieve high prediction accuracy  deep learn algorithm need  large amount  train data though  large number  train sequence  obtain  refseq    potential  enlarge  train dataset  include viral sequence  metavirome sequen cing data metavirome sequence target  sequence mainly viruses  remove prokaryotic cells  sample use  physical   filter metavirome sequen cing   rely  culture viruses   lab    able  capture  cultivate  uncultivated viruses represent  true viral diversity   study  use  technique  extract viruses  sequence viral genomes  human gut  ocean sample  normal   sequence virome   human gut sample  ibd patients use illumina sequence technology  reyes   study viruses  fecal sample  malawian twin  severe acute malnutrition sam use roche  sequence technology  minot    kim   investigate virome  healthy human gut use roche    marine virome  tara ocean virome project collect  largest number  virome sample   surface  deepocean sit   world   collect  metavirome sample   study  aim  add  viral diversity especially add viruses   underrepresented  refseq   train data   careful  quality control   sample    likely   sample   contaminate  prokaryotic dna since  physical filter may  exclude small size prokaryotic cells  detail  preparation  metavirome data  quality control   find  supplementary materials  supplementary table     million  sequence  generate   metavirome data    combine  sequence derive  viral refseq  may   train   number  prokaryotic sequence  pair   viral sequence   enlarge dataset  train  new model  evaluate  compare   original model train base  refseq  use  test sequence  refseq  may  simulation  metagenomic datasets  assess  performance  deepvirfinder train previously use refseq  predict viruses  metagenomic sample  generate sythetic metage nomic sample base  organism abundance profile derive   real human gut metagenomic sample accession  srr061166 platform illumina give  total budget  base pair   sample  number  base pair  contigs sample   genome  compute proportionally   abundance profile   reference genome contigs  sample randomly  independently   genome   contig length follow   distribution     real human metagenomics dataset  crc patients fig    number  base pair reach  total budget  detail   find  supplementary materials  construct metagenomic sample  different viral fraction  evaluate deepvirfinder      metagenomic sequence experiment   two major type  genome sample strategies one  refer   cellular metagenomes     genetic materials include bacteria archaea  viruses  sample  sequence another type  data  metavirome  cellular organisms like bacteria  filter  first  sequence  mostly viruses  sequence  mimic  different viral fraction  real metagenomic data  abundance profile  rescale  make sample  three different viral fraction      keep  relative abundance within viruses   within host   viral analysis  human gut metagenomics  patients  colorectal cancer human gut metagenomics sample  patients  crc   control group  download  european nucleotide archive ena database see  websitewwwebiacukena  accession number erp005534 sample   cancer patients   normal individuals  randomly split    train    test  patient    disease status   find   supplementary materials  metagenomics sample  train  combine  crossassembled  guarantee high accuracies   downstream analysis include virus contig identification  contig bin  filter contigs smaller    deepvirfinder   apply  predict viral contigs   remain dataset  control  false discovery rate  predict pvalue   contig  convert   qvalue  qvalue   estimation   proportion  false prediction   prediction  make   level   correspond pvalue contigs  sort  qvalues   smallest   largest   contigs  qvalues    predict  viruses  viral contigs predict  deepvirfinder   group  contig bin   abundance  contig bin  derive base   read map result  study  association   viruses   cancer status  build  logistic regression classifier  lasso penalty  predict  crc status base   bin abundance  train data  evaluate  performance  test data  detail   find   supplementary materials",-0.16278983454113125,0.23689380103831634,0.10644998093411744,0.11002101039537324,-0.02319162939083533,-0.05330132175608451,-0.053270291649326784,0.014722701885083516,-0.03266851972824197,0.13804250652710984,0.004001495510128536,-0.01964578944604457,0.1500610195831402,-0.07423595839995596,0.168779190810069,-0.0326148560359728,0.08079781256316489,0.16769205927040112,-0.0005153015121064388,0.09139330426035093,-0.05451022845672576,-0.19286736391886786,0.08095249548411923,0.027538436498681252,-0.035871995285362036,-0.12187489601268175,0.12353621112167468,-0.16746484780559429,-0.03576872513700745,-0.009342558571274895,-0.020112382143317932,0.25168804953045265,-0.15037267702137685,-0.048998379092720784,0.22574839182301426,0.02463621425231196,0.013524341236677815,0.09154429288372357,-0.10460864019512116,-0.08769266961204128,-0.14282812984390542,-0.12272716188752265,-0.1596233216747311,-0.13492168450112266,-0.056655558704365484,0.050454923000661886,0.0961755833943512,-0.1264559493398248,-0.2455090175486485,-0.2854512587881169,0.1274611709507111,-0.017980791716785502,0.06095529527497565,0.5604498665728938,0.030265290232386718,-1.1330694318494552,-0.003121503071523592,-0.19832112660562834,0.9205113128770736,0.21304252498755816,-0.14240081464279192,0.39191476973772427,0.002390168028975241,0.04266938910809412,0.568383114241939,0.12629307091603173,0.003424806760051835,-0.01699031709917297,0.27118003499233595,-0.1617481251893873,-0.01850208488234824,-0.019705808576440716,0.0654206992015039,-0.11037488899189253,0.1651330153226262,-0.028429836930472994,-0.1132839341123736,-0.1786789898467988,-0.36666884883930345,0.01311205764227328,0.2633517732565401,0.04391233322049664,-0.3521815348121394,0.009219183429408959,-0.8527327150699957,0.07704106819051919,0.2296158800924533,-0.10693161220091288,-0.15384150201027266,-0.025495642939292386,-0.14463114055017354,0.04642516171942653,-0.04053312991211405,-0.09064816712030296,-0.10292515898367664,-0.0856205283847378,-0.11418128628194678,-0.3570510886604465,0.31182873641780723,0.01252385527258128,VirusIdentification,3
64,64,"viraminer deep learn  raw dna sequence  identify viral genomes  human samples
despite  clinical importance detection  highly divergent  yet unknown viruses   major challenge  human sample  sequence conventional alignments classify many assemble contigs  “unknown” since many   sequence   similar  know genomes   work  develop viraminer  deep learningbased method  identify viruses  various human biospecimens viraminer contain two branch  convolutional neural network design  detect  pattern  patternfrequencies  raw metagenomics contigs  train dataset include sequence obtain   metagenomic experiment   analyze  label  blast  model achieve significantly improve accuracy compare   machine learn methods  viral genome classification use   contigs viraminer achieve  area   roc curve   knowledge    first machine learn methodology   detect  presence  viral sequence among raw metagenomic contigs  diverse human sample  suggest   propose model capture different type  information  genome composition    use   recommendation system   investigate sequence label  “unknown”  conventional alignment methods explore  highlydivergent viruses  turn  enhance  knowledge  infectious cause  diseases
samples  sequence type  metagenomic sequence   work  generate use next generation sequence platforms    nextseq miseq  hiseq illumina  describe   manufacturer  dataset  derive  human sample belong  different patient group    describe  detail     goal   analyse   detect viral genomes   microorganisms  diseased individuals    match control subject bioinformatics   sequence experiment  process  analyze use  benchmarked bioinformatics workflow   summarize  start analysis  quality check  read  filter base   phred quality score afterwards quality check read  align  human bacterial phage  vector dna   identity     length  subtract   analysis use bwamem   read   leave  normalize   assemble use  idbaud  trinity  soapdenovo  soapdenovotrans  assemblers  assemble contigs   subject  taxonomic classification use blast  code   pipeline  available  github    data process  label  train dataset include  different ngs experiment   analyze  label  pcjblast   apply   novo genome assembly algorithms parameters  pcjblast   follow type  algorithm  blastn nucleotide match reward   nucleotide mismatch penalty   cost  open  gap   cost  extend  gap   evalue ≤   assemble contigs   label   bioinformatics workflow  merge  train several machine learn algorithms  extract input dataset  convolutional neural network label sequence  divide  equal piece 300bp  500bp  one    label   original sequence  remain nucleotides   end   contigs  remove    analysis  example accord   process   viral contig would produce two equal 300bp viral sequence   last  nucleotides would  remove   input dataset initially  generate two train datasets base  sequence lengths first  300bp   second  500bp  notice  300bp contigs produce significantly better result  continue work    dataset  drop   furthermore  contigs  contain even one “” letter reference   nucleotide  remove    analysis   common genes find   viral sequence   metagenomic datasets  list   table   common viral class  list   table  compute baselines  also count kmers   process dataset give  extract kmers become    computationally expensive   increase  conduct distribute  parallel compute  kmers  use hadoop   spark   spark code available   output    matrix    number  row   input dataset machine learn methods convolutional neural network cnns convolutional neural network cnns   type  feedforward neural network    addition  fullyconnected layer   alltoall connections cnns  definition also contain convolutional layer convolutional layer  partial connectivity  use   parameters repeatedly   supervise learn settings cnns learn  perform  task  observe inputoutput pair  learn  achieve  minimize  error  model output   know true output via gradient descent   cnns   widely use  image process      successfully apply  various field   include analysis  biological sequence   dna  amino acid sequence   convolutional layer treat  input  multidimensional arrays— image  treat    array   color channel   dna sequence  see    array  one channel per possible nucleotide value   present work  use sequence  length   consider  possible value atgcn   position correspond    sequence  length    channel  depict  fig   convolutional layer  characterize   set  learnable filter   convolve along  input dna sequence  along  width  height   image filter  smaller   input    apply  multiple locations along  input   position   filter  apply  dot product   weight   filter   local input value  compute  dot products result  apply   filter  different position along  sequence form  feature map  convolutional layer usually apply many filter  hence  output   set  feature map one per filter   output  computations   perform   apply  activation function pool  add  layer  parameter value   filter like   learnable parameters   model  optimize   gradient descent algorithm cnn architectures  predict  viral nature  sequence   work  use  convolutional neural network call viraminer  predict whether  give dna sequence    viral origin    model contain two convolutional branch  contribute different type  information   final fullyconnected decisionmaking layer  model  partly base   deepvirfinder dvf architecture  ren     dvf model   convolutional neural network cnn  apply  max operator   output   convolutional filter   feature map   one maximal activation value per filter  pass    next layer   information    often  good match  find  lose  architecture  illustrate  fig    work  suggest   convolutional layer follow  average operator instead  max operator provide important information   frequency  pattern information   otherwise lose    case  lose information   maximal activation best match  gain information  frequency— average cannot  high     good match  find  previous work  author  dvf   author   current article  show  methods base  pattern frequency kmer count relative synonymous codon usage  effective  separate viral sample  nonviral ones   use convolution  average   natural extension   pattern countingbased model  result   architecture  fig   clarify    claim  use convolutionmax  without merit  simply capture  different type  information  fact   viraminer model  combine feature map process  average   max operators  allow  model  base  decisions   patternmatching  patternfrequency information  viraminer detail architecture  show  fig   frequency branch  pattern branch refer   architectures  fig    without  input  output layer train   important  note  pattern  frequency model   use  separate model  train independently   first step   train scheme  train  two model  remove  output layer  use  middle layer  frequency  pattern branch   full viraminer model   second step  optimize   parameters   final layer   viraminer architecture leave  weight  bias value   branch unchanged exactly      independent model notice    last step  learn value   roughly two thousand parameters  change  stepwise train procedure help reduce overfitting compare  simpler approach  simplest alternative train strategy consist  randomly initialize  optimize   parameters  branch   final layer    time  standard endtoend approach allow  model  freely use    capacity  minimize  error  train data point however  much capacity might lead  lower generalization ability indeed   train procedure viraminer model strongly overfits  perform significantly worse  unseen data finetuning  another alternative train procedure   branch  initialize  pretrained value   value   freeze  mean   train  full viraminer model   final layer   branch  optimize  reoptimization  pretrained weight give  name finetuning similarly  endtoend train  see overfitting   intermediate train procedure therefore  model   result section  obtain  stepwise train procedure rather  endtoend  finetuning hyperparameter search  test  merge  shuffle  data originate   metagenomics sequence experiment  divide   train  validation   test set    perform  extensive hyperparameter search   pattern  frequency model separately   architectures hundreds  variants  train use    data  train set  performance   model  measure  auroc  validation set  model  train  validation auroc   increase   consecutive epochs   longer   epochs   epoch  model  save   validation auroc  increase adam optimizer   batch size   use   case  initial hyperparameter search scan  follow parameters filter size  range      step   learn rate      value  try   without learn rate decay  multiply learn rate      epochs layer size apply   number  filter  convolutional layer   number  nod  fully connect layer     dropout probability      second stage  hyperparameter search  possible filter size value  step    scan   region  interest determine  initial scan     frequency model     pattern model   hyperparameters  value  leave    second stage   clearly worsen  performance   extensive hyperparameter scan  complete  best pattern model  best frequency model  per validation auroc  select  use  initialize  branch   viraminer architecture   train  viraminer model  different learn rat learn rate decay  withwithout finetuning  branch   select  best model accord  validation auroc  select best model accord  validation performance  finally evaluate  best pattern best frequency  best viraminer model   test set    leave unused    point baselines use  split  also train two type  baseline model first   use kmer count extract   contigs  input  train random forest model   tree   parameters  default  scikitlearn python package     range       result section  report  model test auroc secondly  also train  random forest model directly   300bp sequence without  feature extraction    onehot encode  sequence  flatten  result   input  per  position   sequence notice   model   position invariant— shift   sequence   one base pair would completely change  output simulate data simulate pairended read   study  generate  art simulator   reference file   simulation include  thousand genomes  genbank consist  viral    cellular organisms mammals plant vertebrates  bacterias parameters   simulator   follow  msv1           simulation produce appproximately  million pair read   turn  assemble    contigs  use idbaud assembly  afterwards  apply   data process  label pipeline  describe    metagenomic datasets",-0.1737762227856782,0.20223912784357795,0.11149935706730336,0.1387825070016267,-0.002345560467129067,-0.01537143098520046,-0.08937737235448616,0.03653617121139272,-0.02870818500084935,0.12908693675134827,-0.0005770464486537613,-0.02505413095039712,0.16237797660748982,-0.09918612577330664,0.15151493772657978,-0.025006403170816732,0.05336710176994102,0.17376204187766894,-0.03975029987990067,0.0680073069887207,-0.013144361084912095,-0.213495172412621,0.06699687678919591,-0.02090886096391102,-0.015005102706355309,-0.1585557878406374,0.06670526851128754,-0.13723167899533073,-0.02197655461331998,-0.05949932373952487,-0.012839852565781058,0.2926732874852816,-0.18116305857831308,-0.08029661014697853,0.19678110287055733,0.08344879828028738,0.010664744904670356,-0.010988262286812366,-0.07461579631745316,-0.12644379117471385,-0.09784695017639404,-0.13590835314998265,-0.1194640027159719,-0.11332704786252525,-0.1232770223470866,0.02399312049017677,0.11234575439009437,-0.11583352863639665,-0.21771471428990846,-0.3392635869209499,0.16095111843311588,0.02410094584902499,0.07028586517028898,0.6204975569757107,0.014672547409011262,-1.163536041272492,0.0052859431629738475,-0.1906581924241736,0.9923351882276824,0.2173561937071837,-0.14574519801048896,0.3574182860419129,-0.01637144053537894,0.040225431952793295,0.6062470851152031,0.060176009851281735,0.02940588810100145,0.0074643231213930815,0.21241513139394208,-0.17082493464802956,-0.05371353566091668,-0.021695331310050792,0.11356489242279726,-0.12720572343679334,0.17837791630113586,-0.06370111406975477,-0.09983577660907612,-0.13687758337525088,-0.363134122518679,-0.0489514059226095,0.2174894262935667,-0.014959706738568763,-0.3843521155828751,-0.025926109081042682,-0.8802165228019779,0.07156904665194723,0.22911671848397036,-0.14265845865163745,-0.13413392243321862,-0.021513544791680897,-0.18284202589333126,0.04619708564244605,-0.13944651839258404,-0.06989396860056354,-0.10845591890886301,-0.06357484928988143,-0.11523635004335735,-0.32484566541846216,0.3268284675596113,0.0581132940304697,VirusIdentification,3
65,65,"virfinder  novel kmer base tool  identify viral sequence  assemble metagenomic data
identifying viral sequence  mix metagenomes contain  viral  host contigs   critical first step  analyze  viral component  sample current tool  distinguish prokaryotic virus  host contigs primarily use genebased similarity approach  approach  significantly limit result especially  short contigs    predict proteins  lack proteins  similarity  previously know viruses   develop virfinder  first kmer frequency base machine learn method  virus contig identification  entirely avoid genebased similarity search virfinder instead identify viral sequence base   empirical observation  viruses  host  discernibly different kmer signatures virfinders performance  correctly identify viral sequence  test  train  machine learn model  sequence  host  viral genomes sequence   january   evaluate  sequence obtain   january  virfinder  significantly better rat  identify true viral contigs true positive rat tprs  virsorter  current stateoftheart genebased virus classification tool  evaluate  either contigs subsampled  complete genomes  assemble   simulate human gut metagenome  example  contigs subsampled  complete genomes virfinder     fold higher tprs  virsorter       contigs respectively    false positive rat  virsorter     respectively thus virfinder work considerably better  small contigs  virsorter virfinder furthermore identify several recently sequence virus genomes   january   virsorter       nucleotide similarity  previously sequence viruses demonstrate virfinders potential advantage  identify novel viral sequence application  virfinder   set  human gut metagenomes  healthy  liver cirrhosis patients reveal higher viral diversity  healthy individuals  cirrhosis patients  also identify contig bin contain crassphagelike contigs  higher abundance  healthy patients   putative veillonella genus prophage associate  cirrhosis patients  innovative kmer base tool complement genebased approach   significantly improve prokaryotic viral sequence identification especially  metagenomicbased study  viral ecology
viruses  prokaryotic host genomes use  train  validation  collect  virus refseq genomes infect prokaryotes   prokaryotic host refseq genomes  ncbi  may   ncbi accession number   refseq sequence  provide   additional file  table   mimic fragment metagenomic sequence   give length          viruses  split  nonoverlapping fragment  length     number  nonoverlapping fragment  length   randomly subsampled   prokaryotic genomes fragment  generate  virus genomes discover   january     january    separately use  train  test set respectively table   generate evaluation datasets contain     viral contigs  number  viral contigs  set   table    combine   time  equal number  fold less randomly sample host contigs respectively highly represent host phyla actinobacteria cyanobacteria firmicutes proteobacteria  genera mycobacterium escherichia pseudomonas staphylococcus bacillus vibrio  streptococcus  select   analyse  viruses infect  taxa  exclude   train  virfinder  evaluation   different train virfinder model equal number  contigs   exclude viruses    viruses  select   combine  randomly select host contigs   total virus  host contigs  equal  number   analysis  virfinder train   prokaryotic genomes   without proviruses remove  genomes  download   database cite   likewise  position  proviruses predict  virsorter    genomes  obtain   publish data     use  remove theses sequence   correspond host genomes  kmer base machine learn prediction model   fragment sequence  let    number  occurrences   word       …     complimentary word ⎯⎯⎯⎯ ∈≡{𝐴𝐶𝐺𝑇}…  simplicity  use word   refer   word pattern    compliment ⎯⎯⎯⎯  define  sequence signatures   normalize word frequencies 𝑉𝐰𝑁𝐰∑𝑤𝑁𝐰𝐰∈ duplicate word pair  remove       example        unique word pattern pair  use base  sequence signatures  binary classifier  identify viral sequence  build  classifier  train use  train data    evaluate use  test data give  train dataset compose    number  viral sequence  host sequence  first use  statistic  test   word    mean word frequency  viral sequence  significantly different    host sequence note    subject   unit sum constraint ∑𝐰𝑉𝐰  overcome  problem  multicollinearity  exclude  word   highest  value  least significant word  base   select word  use  logistic regression model  build  binary classifier  add  lasso regularization  make  model flexible  let  data choose  model   highest accuracy let     …     sequence let         come  viral sequence           host sequence       sequence signatures        …    model log⎛⎝⎜⎜⎜𝑃𝑌𝑖∣∣∣𝑉𝑖𝐰𝑃𝑌𝑖∣∣∣𝑉𝑖𝐰⎞⎠⎟⎟⎟∑∈𝑘𝛽𝐰𝑉𝑖𝐰𝛽0    word 𝑃𝑌𝑖∣∣∣𝑉𝑖𝐰exp∑∈𝑘𝛽𝐰𝑉𝑖𝐰𝛽0exp∑∈𝑘𝛽𝐰𝑉𝑖𝐰𝛽0 thus  objective function  ∑𝑖1𝑛log𝑙𝑌𝑖∣∣∣𝑉𝑖𝐰𝛽𝐰 𝛽0𝜆∑∈𝑘𝛽𝐰     likelihood   estimate  minimize  objective function  choose  parameter     highest auroc use fold cross validation   train data   package “glmnet”  use   model train  test  rocs  plot use  package “rocr”   auc score   confidence interval  compute use  package “proc”   real metagenomic experiment  assemble contigs   various lengths  order  compare score  different prediction model   query contig   value  compute  compare  score   null distribution    distribution  score   test host contigs   value  compute   fraction  test host contigs   greater score   score   query sequence  estimate  false discovery rate  proportion  predictions   host  use  package “qvalue”    estimate false discovery rat base    value   query contig  associate   false discovery rate also know    value  contigs  sort   value   smallest   largest give  threshold  contigs   value smaller   threshold  predict  viral sequence   largest  value among  predict contigs give  estimation   false discovery rate   prediction simulation study  metagenomes metagenomic sample  simulate base  species abundance profile derive   real human gut metagenomic sample accession  srr061166 platform illumina   human microbiome project hmp  commonly use  metagenomic data analysis  follow  similar simulation procedure     first map read  sample srr061166 use bwa    virus   host complete genome sequence download  ncbi refseq  generate abundance profile  read   sample  first map  viral genomes    remain unmapped read  map   host complete genomes use  command  “bwa mem”   read map  viral genomes consistent   range previously report  human gut metagenomes  viral   abundance profile  provide   additional file  table    use nessm   simulate metagenomic sample  pairend short read  length     illumina miseq set mode base   abundance profile ten   million read sample  generate   different mixtures  virus  prokaryotic sequence  relative abundance among viruses  among host  keep     virus  host read  mix  make   native level  sample srr061166 determine  map    viral sample metaspades    use  denovo assemble  simulate metagenome sample use  command “spadespy meta”  contigs ≥   use   downstream analysis  obtain  true label   assemble contigs read   simulate data  map   set  contigs use “bwa mem”  contig  label   viral contig    assemble  read   viral genomes similarly  contig  label   host contig    assemble  read  host genomes  contig  label  chimeric    assemble   mixture  virus  host read  validate  prediction  plot roc receiver operate characteristic curve  different range  contig lengths      ≥   roc curve  base   predictions  viral contigs  genomes sequence   january  pair    number  randomly sample host contigs virsorter settings virsorter  run   “viromes” mode    set  evaluation sequence  use  virfinder virsorter report predict viral sequence  three categories   “ confident” predictions   “likely” predictions  iii  “possible” predictions assembly  analysis  human gut metagenomic sample  liver cirrhosis study  data  qin    contain two independent datasets    contain illumina     pair read metagenomes  stool sample   healthy individuals  liver cirrhosis patients   han chinese origin  metagenomes  download   european nucleotide archive accession number erp005860  first dataset refer    “training set”   sample comprise   sample   healthy patients   sample   liver cirrhosis patients  second dataset refer    “testing set”   sample comprise   sample   healthy patients   sample   liver cirrhosis patients megahit   use  crossassemble   sample train dataset use  default settings since   sample dataset   large  assembly cocacola   use  separately cluster viral contigs predict  virfinder  virsorter base  sequence tetranucleotide frequencies  contig coverages normalize  contig length  number  map read  sample contig coverages rpkms  determine  map sample read  bowtie2  use  default settings   average   bin average bin rpkms  use  train  classification model  classify  disease status   healthy    liver cirrhosis  logistic regression model  lasso regularization  use  order  enhance  prediction accuracy  interpretability thus  subset  viral bin  choose  achieve  best prediction accuracy  assess  classification model  average rpkm  bin   second dataset   sample  use  test  classification model  roc curve  use  evaluation twoway hierarchical cluster  perform use  average rpkm coverages    virfinder contig bin use   train set sample   sample randomly select    sample test dataset distance  compute use euclidean distance   cluster  complete linkage method   blast analyse  use  assess  predict viral contigs assemble   cirrhosis study sample  similarity  previously report sequence blastn  blastp search  perform  default settings  ncbis nonredundant nucleotide   protein  databases  august  protein sequence  predict   contig use prodigal     “meta” procedure  meta  best hit   contig nucleotide   predict protein   contigs  retain result proteins    databases  call  viral   come   virus record   taxonomy   one   follow term   definition line virus phage capsid tail head  terminase proteins  also search  pfam domains via  webserver   result domains  consider viral   description contain one   follow term virus phage capsid tail head tape terminase gpnn    digits “podo”  “sipho”",-0.16321220878071088,0.1858954373916485,0.10079606630391197,0.1235380025762646,-0.017886477241192262,0.023791097937075727,-0.036053883326720486,-0.03415188913324093,-0.022747331909591058,0.11920192487814857,-0.0014807483401101528,-0.027893110065539947,0.1755916833238506,-0.06780345576670264,0.13839628693835254,0.004187188970047186,0.07283914295178938,0.16823697548353633,0.02027462733161376,0.0891245269059559,-0.013456094358443551,-0.18118758817869665,0.019079325066888118,0.0014913486015810619,-0.03756284013344738,-0.15907918721376385,0.12588456160425965,-0.08911143976974735,-0.03905253356113535,-0.03197539743337021,0.024469074829965742,0.2185030612856762,-0.13255324993943424,-0.054573968484854886,0.2316576302511889,0.09077150445699744,0.050916419140678286,0.025353466628983055,-0.09519124689276943,-0.10747467268577862,-0.10006007747892323,-0.09299607755069944,-0.08062175313142768,-0.10163095171903576,-0.05921363005067268,0.015572128831275327,0.11191183017671663,-0.09302229741566424,-0.26203220495321644,-0.2469192467928718,0.1434375755186247,0.021286332578478992,0.07146392334827857,0.4788582272592069,-0.006202745742510254,-0.9534094660353152,0.04622644374165597,-0.18951167821839446,0.8245391966818681,0.20829241593688425,-0.17645097974900742,0.3084773400998009,-0.04121118996061158,0.04539861386700204,0.5101979349661331,0.09135080666626984,-0.007500270768575833,0.0029109145420147748,0.24046334951071274,-0.14105318638671133,-0.05482526726375992,0.01852063364098481,0.08775670494658237,-0.09037297415458194,0.17169389683634384,0.003264360230163054,-0.1541982689660819,-0.19227516455728502,-0.3271127384302121,-0.058231597097505514,0.14370858269428796,-0.019017894907146463,-0.36201530692998574,-0.04757514502635047,-0.7233736514644392,0.0639360562032056,0.22156532098968848,-0.13666929102167966,-0.12851681593975675,-0.005443714665678664,-0.1682861535253758,0.07475205651507331,-0.06607959189156286,-0.08578461955794388,-0.05970789943382785,-0.06067556627661828,-0.1569476999458039,-0.3306865173128087,0.2309137782129945,0.02297172019153449,VirusIdentification,3
66,66,"virnet deep attention model  viral read identification
metagenomics show  promise understand  function  diversity   microbial communities due   difficulty  study microorganism  pure culture isolation moreover  viral identification  consider one   essential step  study microbial communities several study show different methods  identify viruses  mix metagenomic data use homology  statistical techniques  techniques  many limitations due  viral genome diversity   work  propose  deep attention model  viral identification  metagenomic data  test purpose  generate fragment  viruses  bacteria  refseq genomes  different lengths  find  best hyperparameters   model   simulate  microbiome  virome high throughput data   test dataset  aim  validate  approach  compare  tool   stateoftheart statistical tool  viral identification  find  performance  virnet much better regard accuracy    test data
building train  test dataset  divide viruses bacteria  archaea genomes  refseq database randomly   train  test genomes    total base pair  train table  show  number  genomes  use  train  test  process  available viral genomes  nov 1st    sample  prokaryotic genomes due   huge number  available prokaryotic genomes   convert  viral genomes  nonoverlapping fragment  different lengths   {   }  generate  approximate number  nonoverlapping fragment  prokaryotic genomes    lengths randomly  well generate simulate virome  microbiome grinder    opensource tool commonly use  generate  simulate amplicon  shotgun metagenomic datasets  reference genomes  generate two metagenomic data  virome  microbiome   read  fragment length 100bp use grinder   reference test genomes  simulate shotgun metagenomic sequence  order  verify  ability   tool  detect viral read  metagenomic data instead  generate fragment   reference genomes  virome data    viral read  microbiome    deep learn model recurrent neural network rnn long shortterm memory lstm   gate recurrent neural network gru   model complex sequence    use  sequence model problems  deep learn model  implement   attentional encoder network figure   input sequence    …    calculate  forward sequence  hide state →…→  hide state →  average  obtain  attention vector  represent  context vector   input sequence embed layer map discrete input word  dense vectors  computational efficiency  feed  sequence  lstm layer  attentional network could learn   extract suitable feature   raw data   attend  previous dna nucleotide within   input sequence  attentional neural model  train   dna nucleotide base  fragment  different lengths  model  predict   binary output format whether  fragment  viral  nonviral  topperforming model figure  consist   input embed layer  size  map input dna nucleotide tokens   embed space   feed   lstm layer  forward sequence →   average together  create  attentional vector represent token context within   fragment  dropout layer  add   attentional layer  avoid overfitting   input data  input sequence  divide   grams size tokens  tokens   treat   single word figure   single token  map   point   embed space create  train  neural model  train  parameters  optimize jointly use adam  maximize  conditional probability  tokens find together  predict   input sequence  viral    hyperparameters optimization  select  grid search technique  order  find   suitable parameters  grid search  consider  traditional technique  hyperparameters optimization   brute force different combinations  run several experiment     train set      divide   train validation  test set   follow percentages      experiment  design  find  best parameters   number  recurrent layer  embed size   layer   input subwords ngram  report result table iii show   best parameters setup    layer  embed size   ngram",-0.2291276549041586,0.26444373584949266,0.10216977102780374,0.14854192391862958,-0.019997900589631586,-0.01638418882582424,-0.10354056739452744,0.042417073226096585,-0.038387661337406495,0.2082117117040664,0.016493620908438738,-0.07125383460273345,0.16190951972972478,-0.1023996521460828,0.17436867101476505,0.04226425573111735,0.06557293925784144,0.2488636412436991,-0.048741531804419334,0.07454820187268298,-0.0500158349701374,-0.2509091124233698,0.06336588856103904,-0.05954875013771349,-0.0023582897967759503,-0.14530870316882438,0.12302425307983605,-0.1072249079162491,-0.030789457425527588,-0.04773522968329664,-0.03945013815362199,0.2647300936279495,-0.21721437152370185,-0.06199532862700208,0.2650010267338451,0.013661619329370314,-0.026670088567399358,0.05573739105083503,-0.023082867531737692,-0.14497603809573315,-0.08332241101172959,-0.1620313779196397,-0.1475055036889258,-0.08416915890441534,-0.1830630153220829,0.0038024553670569774,0.06929922264021222,-0.14762582162290186,-0.2617002023786236,-0.27850566362030804,0.12217020214111173,0.010218470532254716,0.07434978784048851,0.6550375743563606,0.04536477260224897,-1.1280191452570365,0.00011464033905469197,-0.1966522162558266,0.9810583039269972,0.20128347677086075,-0.15017984617742527,0.3346899995780353,-0.022135263037793517,0.07149973485024183,0.6173041062768408,0.09533984481768044,0.04769388462980868,-0.0578688921706375,0.2400250132512651,-0.13824547797921355,-0.06994523894724419,0.01469622520039059,0.13399582224454787,-0.10917016480909443,0.18047269003054767,0.0199083093763657,-0.10107168409658568,-0.19644263038136275,-0.3435071990103789,-0.009245919618436394,0.19631221215295316,0.01213714936059493,-0.4224585691694293,-0.0380494928155794,-0.8823558534736015,0.14212683033845233,0.2688414521620307,-0.17904916937878226,-0.19002117561597265,-0.01389028037285559,-0.20365642231097664,0.11254224048322396,-0.11320878445206893,-0.07810859368379477,-0.045863269152723145,-0.1649124052073859,-0.10174380582560537,-0.4102383160670157,0.3389428949099419,0.09317063909579296,VirusIdentification,3
67,67,"virsorter mine viral signal  microbial genomic data
viruses  microbes impact  ecosystems  microbes drive key energy  substrate transformations include  oceans humans  industrial fermenters however despite  recognize importance  understand  viral diversity  impact remain limit    model systems  reference genomes one way  fill  gap   knowledge  viral diversity    detection  viral signal  microbial genomic data  multiple approach   develop  apply   detection  prophages viral genomes integrate   microbial genome new type  microbial genomic data  emerge    fragment  larger scale   singlecell amplify genomes sag  uncultivated organisms  genomic fragment assemble  metagenomic sequence   present virsorter  tool design  detect viral signal   different type  microbial sequence data    referencedependent  referenceindependent manner leverage probabilistic model  extensive virome data  maximize detection  novel viruses performance test show  virsorters prophage prediction capability compare    available prophage predictors  complete genomes   superior  predict viral sequence outside   host genome   extrachromosomal prophages lytic infections  partially assemble prophages furthermore virsorter outperform exist tool  fragment genomic  metagenomic datasets   identify viral signal  assemble sequence contigs  short  3kb  provide nearperfect identification  recall   precision  contigs   least 10kb  virsorter scale  large datasets   also  use  “reverse”   confidently identify viral sequence  viral metagenomes  sort away cellular dna whether derive  gene transfer agents generalize transduction  contamination finally virsorter  make available   iplant cyberinfrastructure  provide  webbased user interface interconnect   require compute resources virsorter thus complement exist prophage prediction softwares  better leverage fragment sag  metagenomic datasets   way   scale  modern sequence give  feature virsorter  enable  discovery  new viruses  microbial datasets    understand  uncultivated viral communities across diverse ecosystems
building reference databases  bacterial  archaeal viruses two reference databases  viral protein sequence  build  virsorter   available   iplant discovery environment datacommunity_dataivirusvirsorterdatabase  first include  proteins  viruses infect bacteria  archaea  refseqvirus genomes   january  hereafter name “refseqabvir” protein cluster pcs  define use mcl cluster enright van dongen  ouzounis    proteins inflation  base   reciprocal blastp comparisons threshold    bite score    evalue   pcs   least  sequence  use  define  profile database searchable  hmmer3 tool eddy   remain  unclustered sequence  format   blastp search  pcs    contain  sequence  caudovirales  unclustered sequence  viruses   caudovirales  mark  “noncaudovirales”  refseqabvir database   augment  virome sequence sample  freshwater seawater  human gut lung  saliva result   extend version   reference database hereafter name “viromes”  include  virome  refseqabvir sequence  combine reference dataset  help  detect new viruses    cultivate reference sequence  available   raw read  available viromes  assemble use newbler threshold   identity  35bp  result contigs   check   presence  cellular genome sequence     viromes     rrna genes  retain see table    complete list   viromes contigs assemble    viromes   manually inspect  annotations generate  metavir roux     reveal  identifiable cellular genome sequence   sequence contain    genes  match  cellular genome    find   know virus  total   complete predict proteins   qualitycontrolled dataset   cluster    proteins  refseqabvir lead   cluster   sequence     unclustered sequence pcs   combine viromes database  use  create  profile database searchable  hmmer3    unclustered sequence  refseqabvir  format  blast search unclustered sequence  viromes   add   database  prevent  inclusion  contaminate sequence within  databases viral “hallmark” genes  define though  textsearching script look  “major capsid protein” “portal” “terminase large subunit” “spike” “tail” “virion formation”  “coat” annotations   manual curation step remove genes   general annotation   “protease”  “chaperone”  pcs  single genes  identify  “viral hallmark genes”  latter point mean remove domains also match “protease”  “chaperone” domains   conduct  minimize false positives   viral hallmark genes category  extracautiously avoid pcs  might include domains  could derive  either  viruses  microbes virsorter sequence preprocessing virsorter  inspire  previous algorithms  tool develop  detect prophages viral sequence integrate  cellular genomes especially prophinder limamendez      set  genomes andor contigs  draft genomes provide  raw nucleotide sequence  initial stag  virsorter include  detection  circular sequence  sequence  match end likely represent circular templates roux    gene prediction   sequence  metageneannotator noguchi taniguchi  itoh   selection   sequence     genes predict virsorter also remove  poorquality predict protein sequence predict protein sequence     consecutive       residues likely originate  gene prediction across lowcomplexity  poorly define genome regions  “bridges”  contigs generate  scaffold  yield falsepositive match  compare  protein domain databases predict protein sequence   compare  pfam v27    viral database select   user either refseqabvir  viromes  hmmsearch eddy   blastp altschul      gene  affiliate    significant hit base  alignment score thresholds  significant hit   follow minimum score    maximum evalue    hmmsearch  minimum score    maximum evalue    blastp virsorter metrics computation follow  sequence preprocessing viral regions  detect  computation  multiple metrics use slide windows  metrics use   presence  viral hallmark genes koonin senkevich  dolja  roux     enrichment  virallike genes  genes  best hit   viral reference database either refseqabvir  viromes iii depletion  pfam affiliate genes  enrichment  uncharacterized genes  predict genes   hit either  pfam   viral reference database  enrichment  short genes genes   size within   shorter genes   genome   depletion  strand switch  change  cod strand  two consecutive genes    enrichment  depletion metrics  score comparable   one  prophinder  use limamendez    first  global value   metric  estimate   whole genome set global rate  virallike genes global rate  pfamaffiliated genes etc    window  number  observe events  number  virallike genes  compare   expect number deduce   global value   metric model   binomial law  pvalue  compute reflect  probability  observe  events    enrichment   events  fewer  depletion  random thus correspond   risk  generate false positives  pvalues  multiply   total number  comparisons   total number  slide windows observe   sequence   negative logarithmic transformation log10 define  associate significance score     prophinder algorithm limamendez      detection  virallike genes enrichment two different value  compute   dataset one base  genes   entire database refseqabvir  viromes  another base  noncaudovirales genes  indeed caudovirales genomes represent   refseqabvir   remain viral families usually    handful  reference genomes  global rate  virallike genes  cellular genomes  thus usually one order  magnitude lower  consider  noncaudovirales genes virallike genes ratio across  bacterial  archaeal class   complete genomes  available  ncbi refseq  wgs range       average   whereas  ratio  noncaudovirales genes    genomes range       average   hence   number  genes   region would  consider  nonsignificant  match caudovirales compare   global rate  caudoviraleslike genes   whole genomes  would  significant   compose  noncaudovirales genes sequence metrics summary  metric  compute use slide windows     genes wide start  every gene along  sequence   score greater    store local maxima  significance score   search   associate set  genes  define   putative viral region  different predictions base   metrics    merge  overlap extend  regions  include  predict windows lead   list  putative viral regions associate   set  metrics  regions  classify  three categories  category  “ confident” predictions regions  significant enrichment  virallike genes  noncaudovirales genes   whole region   least one hallmark viral gene detect  category  “likely” predictions regions  either enrichment  virallike  noncaudovirales genes   viral hallmark gene detect associate   least one  metric depletion  pfam affiliation enrichment  uncharacterized genes enrichment  short genes depletions  strand switch  iii category  “possible” predictions regions  neither  viral hallmark gene  enrichment  virallike  noncaudovirales genes  display  least two    metrics   least one significance score greater   finally   predict region span     predict genes   contig  entire contig  consider viral next higher confidence predictions  use  refine  sequence space search specifically sequence   open read frame  category  predictions    match  viral protein cluster  cluster  add   reference database refseqabvir  viromes depend   initial user choice  update database   use  another round  search  virsorter  iteration  category  sequence  use  refine  search  continue   new genes  add   database   new genes  add  final virsorter output  provide   user  include nucleotide sequence   predict viral sequence  fasta file  automatic annotation   prediction  genbank file format   summary table display   prediction  associate category  significance score   metrics  provide  predictions   underlie significance score users  evaluate  prediction  apply custom thresholds  significance score   simple textparsing script even  largescale datasets virsorter  available   application app   iplant discovery environment   appsexperimentalivirus see fig    stepbystep guide  virsorter app  iplant  application allow users  search  set  contigs  viral sequence use either  refseqabvir   viromes database  reference value  virsorter metrics   evaluate   complete set  input sequence hence mix datasets   sort  possible  type  bacteria  archaea  order  get   accurate result possible  addition   reference databases  virsorter app  iplant allow users  input   reference viral genome sequence already assemble  tobe assemble use iplant apps prior  analysis  virsorter assemble sequence  process  follow  genes  predict  metageneannotator noguchi taniguchi  itoh   predict proteins  cluster  sequence   userselected database either refseqabvir  viromes  iii unclustered proteins  add   “unclustered” pool virsorter script  also available   github repository  comparison  virsorter   prophage predictors  first evaluate virsorter result   manually curated prophages  casjens   genome  process  virsorter phispy akhter aziz  edwards  phage_finder fouts   phast zhou      tool  prophage  consider  “detected”   prediction cover      know prophage    detail example case  prophage detection   complete bacterial genome include  prophages  genomic islands   tool  apply   manually annotate pseudomonas aeruginosa les b58 genome winstanley    virsorter   compare    prophage detection tool   set  simulate sag   case  viral sequence  consider  detect  predict  completely viral    prophage   additional detections  manually check  verify   region  indeed viral originate   prophage  one   microbial genomes rather    viral genome   false positive   approach  use   simulate microbial  viral metagenomes result   set  predictions two metrics  compute first  recall value correspond   number  viral sequence correctly predict divide   total number  know viral sequence   dataset  reflect  ability   tool  find every know viral sequence   dataset second  precision value  compute   total number  viral sequence correctly predict divide   total number  viral sequence predict  indicate  accurate  tool    identification  viral signal simulation  draft genomes  metagenomes  total   singlecell amplify genomes  microbial metagenomes   viral metagenomes  simulate  nessm jia    microbial genomes  randomly pick within  bacterial  archaeal genomes available  refseq  wgs   january  viral genomes  pick within   recently submit genomes since june  thus    virsorter reference database simulate input   genome group viral  microbial follow  powerlaw distribution  abundances within  microbial  viral communities  proportion  viral read vary      microbial metagenome       viral metagenomes table      simulate dataset 100bp pairedend read similar   obtain  hiseq illumina  generate   sag   metagenomes qcd  fastq_quality_trimmer   threshold   part   fastx_toolkit   assemble  idba_ud peng     identify viral sequence   assemblies  result contigs  compare   viral genomes  nucmer delcher salzberg  phillippy    sequence match one   viral genomes   nucleotide identity    consider  viral  simulate contigs  composition table  relative abundance   genome   simulate dataset  available   iplant discovery environment alongisde virsorter result     simulate datasets iplanthomesharedimicrobevirsorterbenchmark_datasets  benchmark_results respectively",-0.16144293552313588,0.16345293794070848,0.11337488296935988,0.07986315785633531,-0.005229105161535635,-0.04202830446084957,-0.07071345801518315,0.01487448185793606,-0.011711763078755323,0.10817122057104778,-0.007689306443238533,-0.035150404951153236,0.14849900313889966,-0.10170984603035704,0.15192898678825148,0.005896358180733953,0.0407070414216274,0.21396553487187092,-0.03609060933772605,0.07527380778981177,-0.03022193649718375,-0.1891325030165414,0.0577184166307122,0.016611781461254218,-0.003439509102731551,-0.13449838912980466,0.0995408885728817,-0.08931533457882898,-0.03723731635504999,-0.041424186627499006,0.007807432078008883,0.22624548820844084,-0.14024295730673578,-0.04236093901864686,0.2001012998239419,0.04183169309838202,0.06151347772071236,-0.014955367954456037,-0.10299714225387248,-0.10707183035791099,-0.08117994633053936,-0.14062879998127115,-0.11410357468442893,-0.0787981403101105,-0.060392361546850265,0.03555409964827592,0.09352138477843257,-0.12161292236251348,-0.18758969430979175,-0.31278451497915705,0.12453651229969405,0.012684735896580509,0.022903988021119547,0.4549297455159065,0.044165938507598056,-0.9548098134003546,0.017467090841219352,-0.1765492738880168,0.8043357232324125,0.17985838374190374,-0.1630460353011139,0.3493029746874399,-0.012101604782551395,0.0672992589220756,0.5114772617343094,0.0792246416103393,0.03432468242341808,0.002876038270653481,0.21662068268030948,-0.1820155746658872,-0.0341015205978469,-0.006768572654497499,0.10406418644068477,-0.13403960770494386,0.1340155198559443,-0.02624671246280501,-0.111641867334644,-0.14389220841000214,-0.3167690809133969,-0.02569396442778637,0.18901333578953136,-0.031025496018966738,-0.3466508668005924,-0.015939010897336788,-0.6809525485659067,0.0463984570023808,0.20790794161148368,-0.12635523424843292,-0.10943448646923347,-0.009461475919325541,-0.1030234642136891,0.06794166903434272,-0.06680583839198542,-0.0810997710003632,-0.07182785171214819,-0.06282893269437186,-0.07102846090289715,-0.2856378094418273,0.2632821505403212,0.06770107573387928,VirusIdentification,3
68,68,"virusdetect  automate pipeline  efficient virus discovery use deep sequence  small rnas
accurate detection  viruses  plant  animals  critical  agriculture production  human health deep sequence  assembly  virusderived small interfere rnas  prove    highly eﬃcient approach  virus discovery   present virusdetect  bioinformatics pipeline   eﬃciently analyze largescale small rna srna datasets   know  novel virus identiﬁcation virusdetect perform  referenceguided assemblies  align srna sequence   curated virus reference database   novo assemblies  srna sequence  automate parameter optimization   option  host srna subtraction  assemble contigs  compare   curated  classiﬁed reference virus database  know  novel virus identiﬁcation  evaluate   srna size proﬁles  identify novel viruses extensive evaluations use plant  insect srna datasets suggest  virusdetect  highly sensitive  eﬃcient  identify know  novel viruses
implementation  virusdetect  virusdetect package  implement  perl bwa   durbin   employ  align sirna read   reference virus sequence host sequence  assemble virus contigs  referenceguided assembly samtools      use  process bwa alignments  generate perposition alignment information  pileup format   use  guide  construction  virus contigs  novo assembly  viral sirnas  perform use velvet zerbino  birney  virusdetect use  blast program altschul     compare assemble contigs  virus reference nucleotide  protein sequence databases perl modular biographics stajich     use  generate  track image accord   blast result  virus contigs  curation  classification  genbank virus sequence database virus sequence download  genbank  classify  eight different host kingdoms vertebrate invertebrate plant protozoa algae fungus bacteria  archaea base   virus taxonomy information provide   international committee  taxonomy  viruses ictv  use  perl script   include   virusdetect package virus sequence    classify  ictv   manually classify accord   descriptions   virus sequence   high sequence similarity   classify viruses virus sequence classify     eight host kingdoms   process  remove redundant sequence  sequence identity cutoff      respectively use cdhit   godzik   correspond protein sequence   virus  also extract   classify virus nucleotide  protein sequence  available   virusdetect website  plant material rna extraction  srna library construction  sequence  potato srna sequence  standard virus index two copy    vitro accession  select   germplasm collection   cip table  one copy   vitro plant  process  standard virus index    set  process  srna sequence total rna  extract     fresh leaf tissue use  ctab method  quantity   total rna  determine use  nanodrop analyzer thermo fisher scientific usa   quality  check  agarose gel electrophoresis srnas     purify  excise  band    agarose gel  demonstrate  efficiency  virusdetect  identify  assemble genomes  novel viruses  srna sequence  leaf sample   unspecified weed species  yellow  mosaiclike symptoms  collect   tomato field  barbacena brazil  february  total rna   sample  purify use trizol reagents follow  manufacturer' instructions invitrogen usa  quantification   nanodrop thermo fisher scientific usa rna molecules range       excise   polyacrylamide gel  extract srna libraries   weed  potato sample  construct follow  protocol describe  chen    chen     sequence   illumina hiseq  system    singleend mode  srna read process raw srna read  first process  identify  ′ adaptor sequence use  inhouse perl script   include   virusdetect package briefly  adaptor sequence  identify   srna read   first eleven nucleotides   adaptor could match  srna read    one mismatch srna read   adaptor sequence identify  discard   remain read   process  trim  ′ adaptor sequence  process read    low quality contain ambiguous base  shorter     exclude  downstream analysis  clean srna read  use  virus discovery use virusdetect  nonredundant  plant virus database  use   reference  potato genome      use   reference  host srna subtraction   potato srna datasets  standard virus index  potato index    potato accession  perform  virology service unit   cip follow  isoiec  accredit procedure  include  follow test  nash  potato spindle tuber viroid pstvd  pvt   vitro  greenhousegrown plant respectively  daselisa  three replicate  greenhouse grow plant  antibodies  pvx plrv pvs apmmv potato virus  pvy potato yellow virus pyv arracacha virus boca strain avbo  andean potato mottle virus apmov  iii mechanical inoculation  symptom evaluation  eleven biological indicator plant nicotiana benthamiana  clevelandiin bigelovii  debneyii  glutinosa  tabacum ""white burley"" chenopodium murale  quinoa datura stramonium gomphrena globosa solanum lycopersicum ""rutgers""  physalis floridana  addition graft inoculation   stramonium  also perform  validation  know  novel plant viruses detect  virusdetect potato viruses  confirm  rtpcr use virus specific primers  pvx pvs pvt plrv  apmmv supplementary table   total rna use  srna library construction  use  pcr  cdna synthesis    total rna   ngμl  random hexamer primers  use   total reaction mix    use    mmlv reverse transcriptase invitrogen  incubation   °   min  reaction  dilute   nuclease free water     use  pcr  pcr  perform use gotaq® dna polymerase promega   volume      final primer concentration      pcr protocol consist   min initial denaturation   ° follow   cycle   °     °      °     min  final extension   °   min pcr products  visualize   agarose gel stain  gelred biotium pcr fragment amplify   isolate  purify use  high pure pcr product purification kit roche  clone  pgemt easy vector promega follow standard procedures  transform  escherichia coli   sample  send  macrogen korea  sanger sequence  validate  genome sequence   novel virus bwvy assemble  virusdetect  series   primer pair supplementary table   design  amplify overlap fragment cover  entire virus genome amplicons generate use   primer pair  reverse transcriptionpcr rtpcr  sequence directly  clone use  topo  clone kit invitrogen  sequence use  sanger technology   functional biosciences inc madison   rnaseq data process raw rnaseq dataset   domestica describe  rodamilans     download  ncbi sra database  accession srp041925 adaptor  low quality sequence  remove use trimmomatic bolger     remain high quality read  align   rrna database quast    use bowtie langmead    allow    mismatch  unaligned read  use  virus discovery use virusdetect",-0.18465856586123075,0.14125181301892947,0.04866120286075579,0.007588971907991649,-0.029512580629454336,-0.06456338378459085,0.04991515129157539,0.052092869810542786,-0.00866695444004855,0.11272364940491987,0.01265919899450102,-0.07616694941385893,0.087041671699255,0.0039198373328251926,0.13191384706061526,0.14836096004434174,0.1378390030123966,0.14139583804357214,0.08021113675601305,0.006610288831986552,-0.10728960320071568,-0.20801762555103065,0.06282009361958868,0.06044526809275326,-0.008195602183666995,-0.01984061314504843,0.12010639441423765,0.005721967995210687,-0.08459167739736938,0.03818318084004813,-0.043461191453641655,0.20931148668924446,-0.16419889229504628,-0.03137829589712949,0.17974720766078034,0.03650699961276508,0.03382167898155471,-0.050323034656319585,-0.08541219354686316,-0.10949759514801316,-0.03786928773275288,-0.11394436907902228,-0.17037213847293026,-0.09431857339027927,-0.06848350091445636,0.019151141058778385,0.0010198385093046847,-0.05237129335257019,-0.2335640784510742,-0.1554292645776256,0.13156553384646885,0.05814537020165025,0.03335158554845774,0.3487628488183234,-0.06876609286365028,-0.6565675970534367,-0.033141147638798205,-0.15192612091763402,0.6579076755230335,0.1231346509684277,-0.09002792521556968,0.2476774633381973,0.0678571750344616,0.11267427045019418,0.4655176130477016,0.06749202817546726,0.01845921447482388,-0.033298892361313,0.2132752322477448,-0.1698403994679678,-0.0258135013961238,0.021057668569550915,0.1056177220140467,-0.05046896807657018,0.11485854577979135,-0.0015958722561791945,-0.09247694691589968,-0.08825267623533974,-0.30696878313299536,0.0012990117515610626,0.1279163268519272,-0.031098830224784376,-0.33481453748526185,0.0540853143304531,-0.5928912542479589,0.1650134341575485,0.2618689759485377,-0.08371415123356178,-0.1395874012778132,0.05288073697039874,-0.10594714343072338,0.034091659970050016,-0.07359491602434469,-0.03376128607736924,0.02066087250415208,-0.08185879648466671,-0.05625277247266017,-0.3367041580856514,0.194292880383854,0.049158898359580566,VirusIdentification,3
69,69,"vip  integrate pipeline  metagenomics  virus identification  discovery
identification  discovery  viruses use nextgeneration sequence technology   fastdeveloping area  potential wide application  clinical diagnostics public health monitor  novel virus discovery however tremendous sequence data  ngs study  pose great challenge   accuracy  velocity  application  ngs study   describe vip “virus identification pipeline”  onetouch computational pipeline  virus identification  discovery  metagenomic ngs data vip perform  follow step  achieve  goal  map  filter  backgroundrelated read  extensive classification  read   basis  nucleotide  remote amino acid homology iii multiple kmer base  novo assembly  phylogenetic analysis  provide evolutionary insight  validate  feasibility  veracity   pipeline  sequence result  various type  clinical sample  public datasets vip  also contribute  timely virus diagnosis ~ min  acutely ill patients demonstrate  potential   performance  unbiased ngsbased clinical study  demand  short turnaround time
 vip  comprise   series  shell python  perl script  linux  incorporate several opensource tool vip   set  fix external software  database dependencies  userdefined custom parameters  pipeline accept crossplatform result generate   ion torrent  illumina   variety  format   fastq fasta sam  bam alignment format read  handle  concatenate  file   single file  streamline analysis data import  quality control raw ngs short read data   import  transformatted  fastq format use picard  vip  determine  encode version   input data   necessary  make sure  differences   way  quality score  generate  different sequence platforms  properly take  consideration  preprocessing vip  also accept fasta format raw ngs data  quality control step however   perform sequencebased strategies    complexity  length  main factor generally  quality control step  comprise  trim lowquality  adapter read remove lowcomplexity sequence use  dust algorithm  retain read  trim length   use prinseq31  fast mode bowtie2 alignments  first perform   host  follow  remove  hostrelated sequence  remain read  subject  viprird nucleotide   sense mode  initial alignment  host   bacteria   follow  subtraction  read map backgroundsubtracted read   subject   virus subset  ncbi   extensive classification  coverage map previous report suggest  viruses   potential  mutate rapidly  jump  species read  mutation region   viruses might  unclassified  classify   species  strain  order  avoid  misclassifications cause  mutations  apply  twosteps computational alignment strategy  classification  vip fig    first step  match read   assign   specific gene identifier   nucleotideamino acid alignment  read  therefore taxonomically classify  genus level  lookup  match    ncbi taxonomy database  sql structure query language  accord     scientific name   reference record   compose   species genus  family information  achieve  append   alignment result secondly read classify  genus  automatically map    likely reference genome  follow abundance  reference sequence   select  nucleotide alignment correspond   genus  calculate  sort   hypothesize  genome coverage percentage  alongside   sequence depth  specific reference sequence   word  higher abundance   genome suggest  higher possibility  recover  genome   reference sequence   follow key word  keep  complete genomes  complete sequence   complete cds assign read  directly map   nucleotide reference sequence select use optimal blastn  rewardpenalty score   optimal score strategy   suitable  sequence  low conserve ratio32   genus coverage map   reference sequence   generate phylogenetic analysis  multiple kmer base  novo assembly  construction   phylogenetic tree allow   visualize  underlie genealogy   contiguous sequence  reference sequence  order  perform  phylogenetic analysis  candidate viruses   certain viral genus  backbone  high quality  wide spectrum  indispensable   genus sequence  refseq standard sunder  genus   reference sequence   use  generate  coverage map  select  carry  multiple sequence alignment  build  backbone use mafft   novo assembly step benefit   classification method  vip  significant reduction  complexity  read still  novo assemblies  virus sample especially rna viruses   genome sequence  challenge due  extremely uneven read depth distribution cause  amplification bias   inevitable reverse transcription  pcr amplification process  library preparations  present  multiplek method   various kmer lengths  use   novo assembly  velvetoases34  case  sparse read   overlap sufficiently  permit  novo assembly  longer contiguous sequence assign read  contigs  retain      appropriate empirical   longer   average length   candidate read finally  largest contig   novo assembly  add   backbone  generate phylogenetic tree  unweighted pairgroup method  arithmetic mean upgma  visualize  environment  tree exploration37 reference database   gigabase  human nucleotide database human   construct   combination  human genomic dna unlocalized dna grch38hg38 ribosomal rna rrna refseq rna refseq  mitochondrial dna refseq sequence  ncbi   july    viral nucleotide databases  fast mode  construct   combination  sequence  viprird   july    viral nucleotide   sense mode consist   entries  construct  collection   refseq viral complete genomes   neighbor genomes  neighbor genomes   complete viral nucleotide sequence   nonrefseq record  ddbj embl  genbank  viral protein databases  construct  ncbi refseq   bacterial   sense mode  construct   collections  unique genome segment  species level within gottcha38 package hardware vip  test   common desktop     ghz intel core      ram run ubuntu  lts minimum hardware requirements  run vip include     ram  run ubuntu  lts prefer vip   external dependencies require     disk space reference data require     disk space  vip runtime      size   input file may  need  additional temporary storage",-0.21124738929400147,0.1921867743397567,0.12403770546162765,0.09154790016012146,-0.010678315659299494,-0.07746556527888426,-0.08478419655864429,0.0105592054668693,-0.014159218804281832,0.11795402217607992,0.01686798864068439,-0.038179292989435135,0.1460778805898962,-0.11188308163031983,0.14273197863238876,0.03743690121435113,0.07713199633101074,0.18889557734508272,0.04739117217733972,0.0833080273166952,-0.1146062903650492,-0.2288136899688995,0.10347155166756627,0.01905915737696379,-0.030658058751096295,-0.13400579268814294,0.10518546978007193,-0.08978029984085785,-0.0916426235354844,0.0007413657927921938,-0.032597320736990634,0.2510365743583141,-0.19403857919478232,-0.05084871112644165,0.2440504173297653,0.07309635702517585,0.0599323505813909,0.00517814080295147,-0.06383791085175396,-0.10297709114580453,-0.08400026873833584,-0.1222480296214752,-0.09800713001145654,-0.1012874022942617,-0.10354354247608064,0.012366870585103313,0.12444146823549232,-0.12717970042072188,-0.222334611287655,-0.2871579634993301,0.1750499880361649,0.02051620802550286,0.04904154881762413,0.4856363398155996,0.05432394237088209,-1.0291471477271383,0.014858411782263938,-0.22761662460276974,0.9519329131931648,0.20037636991798904,-0.14041797652721175,0.3342234706450193,0.0019147406332194808,0.0911723769480036,0.6306432177276386,0.043991710626907266,-0.004463144002312964,-0.022941832132551986,0.2459342087156369,-0.17345226887075302,-0.07372569140979858,0.012758666302860627,0.1545748405893297,-0.12320957534958595,0.16454373213988668,-0.02920895641693821,-0.16861821436595364,-0.11733630590999572,-0.359080762316491,-0.05823523093395951,0.1815496790514618,-0.048609962324043375,-0.3660177549463697,-0.012394190807645393,-0.7985076139617542,0.1513453951997489,0.26039185893492073,-0.1405547672144875,-0.18000020846382825,-0.006698051937659235,-0.13735608836853658,0.08486922151142998,-0.10763142745898033,-0.06809853759243502,-0.020693589769932744,-0.07926750399940345,-0.04316879592219053,-0.3890353887075824,0.3224051055480279,0.10010862297578048,VirusIdentification,3
70,70," internetbased bioinformatics toolkit  plant biosecurity diagnosis  surveillance  viruses  viroids
detection  prevent entry  exotic viruses  viroids   border  critical  protect plant industries trade worldwide exist post entry quarantine screen protocols rely  timeconsuming biological indicators andor molecular assay  require knowledge  infect viral pathogens plant  develop  ability  recognise  respond  viral infections  dicerlike enzymes  cleave viral sequence  specific small rna products many study report  use   broad range  small rnas encompass  product size  several dicer enzymes involve  distinct biological pathways   optimise  assembly  viral sequence  use specific small rna subsets result  sequence  small rna fraction   plant hold  quarantine glasshouse facilities  australia  new zealand benchmarking  several  novo assembler tool yield spade use  kmer    produce  best assembly outcomes  also find   novo assembly use   small rnas  result  chimeric assemblies  viral sequence  plant host sequence  nonspecific assemblies   resolve  use      small rnas subsets among   select sample  identify contigs  sequence similarity   viruses   viroids   sample    viruses  assemble use    long virusderived sirnas virnas except  one citrus endogenous pararetrovirus    efficiently assemble use   long virnas  three viroids find   study  fully assemble use either      virnas optimise analysis workflows  customise within  yabi webbased analytical environment  present  fully automate viral surveillance  diagnosis webbased bioinformatics toolkit  provide  flexible userfriendly robust  scalable interface   discovery  diagnosis  viral pathogens conclusions   implement  automate viral surveillance  diagnosis vsd bioinformatics toolkit  produce improve viruses  viroid sequence assemblies  vsd toolkit provide several optimise  reusable workflows applicable  distinct viral pathogens  envisage   resource  facilitate  surveillance  diagnosis viral pathogens  plant insects  invertebrates
sample collection rna extraction  ngs sequence import plant  positive control sample  grow  quarantine glasshouse facilities  sample collection plant  grow  natural light   daytime temperature  approximately  °   plant sample one   leave  collect prior  rna extraction total rna andor small rna enrich fraction    extract  approximately    tissue use  mirvana microrna isolation kit ambion lifetechnologies follow manufacture instructions collect sample  store   ° within quarantine facilities  ship   beijing genomics institute bgi hong kong libraries  prepare use  truseq small rna sample prep kit illumina  sequence    singleend  read deep sequence  collect small rna sample small rnaseq   illumina hiseq2000  sequence  quarantine plant sample additional file  small rnaseq datasets   submit   short read archive sra   bioproject prjna325594 selection  small rna assembler  scaffold tool  compare velvet  spade  aby   soapdenovo  assemblers use twelve select small rnaseq sample collect  distinct plant species generate   study additional file   test  novo assembly use individual kmer lengths   k15  k17  k19   k21  well  combine kmer set   k15   k15 assemble contigs   scaffold use cap3 use optimise parameters  short overlap            additionally merge  scaffold  contigs produce  two   three assemblers  also evaluate assembly statistics  calculate use  quality assessment tool  genome assemblies quast  overview   automate viral diagnosis  surveillance toolkit  viruses  viroids surveillance  diagnosis vsd bioinformatics toolkit  develop utilise yabi   open source internetbased analytical environment  allow   customisation  tool  script  analysis workflows  yabi  five tabs namely job design file account  admin tabs   later   visible   person  group responsible   maintenance   customisation   yabi platform   job tab allow visualise  download result  prior job  design tab enable reuse  exist optimise workflows design  modify versions  exist workflows   construction  new analysis workflows  file tab present file  directories   available backend resources  hpc andor cloud instance   user   account tab enable  user  easily modify  password information   yabi account  admin tab facilitate  management  addition  new computational tool   yabi environment new feature   yabi platform include  save  share workflows  fetch data  public repositories iii submission  process data  specialise databases   national  international patient registries   enable bioinformatics  demand analyse   deployment  cloud instance   begin   computational workflow   obliteration   final step   data process  analysis workflow  vsd toolkit  three versions   virus  viroid detection workflows fig   users able  choose  three subsets  small rna read lengths        length read exist automate workflows   reuse  modify  save additional file  additional workflows    detect novel viroids  map read onto  reference genome  also available    run   separate job  add   virus  viroid detection workflows virus  viroid detection workflow file  small rna read  fastq format gzipped file  accept  first upload   file tab  yabi file may  upload directly   personal computer  transfer   yabi directory  another high performance compute storage location   file  upload users  navigate   design tab   choose  save workflow  interest        length read users  also able  build   workflows  simply drag  drop tool   workflow area  first stage   workflow   select file tool  fastq file  interest   select   adapter trim step need   perform users  add   fastx_clipper tool    workflow  perform quality control check use  fastqc tool  read  undergo quality trim   content dependent read trim tool condetri version   trim  remove read  low quality score  minimum read length  set    read   desire read length   extract   extract_reads_21   extract_reads_21    extract_reads_24  tool   novo assemblies  contigs perform  spade version   kmer size set      overlap spade contigs   merge  cap3 version date   contigs greater   equal      extract use  inhouse python script extract  rename contigs tool  blast search  databases generate   plant virus  viroid sequence populate   entrez search query  viruses “txid10239 orgn”  cellular organisms “txid131567 orgn” viroids “txid12884 orgn”  plant “txid3193 orgn”  blastn  task  set  blastn short    blastn  blastx  maximum number  align sequence max_target_seqs  set     expect value evalue set   blastn  blastx result  write    customise tabular format  extract   inhouse script extract blast hit tool  plant  virus  viroid blast output file contigs  also extract  fasta output file   inhouse script extract contigs  subsets   blast hit  plant  virus  viroid sequence  contigs   blast hit  blast output file   parse   inhouse script  produce several output file  csv format include  blast result  tabular format header add blast result  alignment lengths     summary file  report  genbank    virus  plant hit  name   plant  virus  number  contig hit  average percent sequence identity   hit   virus  alignment length  length   virus  plant sequence   percentage coverage  contigs   virus  plant sequence  statistics  calculate use  bioconductors genomicranges package version  detect novel viroids workflow  output file no_hits_contigsfasta   extract contigs tool represent sequence   blastn  blastx sequence similarity  viral  plant sequence  sequence   filter  extract contigs  lengths      typical  viroids  inhouse script   utilise  evaluate  sequence similarity  overlap   ′end  ′end  select sequence sequence  overlap end   sequence similarity  report  putative circular viroid candidates users  recommend   inspect identify candidate circular sequence  example evaluate sequence similarity  noncoding rna databases   rfam   mirbase     part   vsd toolkit viroids   pospiviroidae  grapevine yellow speckle viroid      avsunviroidae  avocado sunblotch viroid form hairpinlike rna secondary structure  thus  confirmation   evaluate  filter candidate novel viroid circular sequence use rnafold  furthermore  expression  candidate sequence pass  filter step   evaluate  multiple tissue   infect plant andor  progeny  validate    novo assemble circular sequence   provide independent evidence   expression  multiple tissue andor individuals map small rnas onto reference genome workflow map  virnas onto identify viral genomes  similarity search typically provide  broader coverage   viral pathogen sequence  compare   novo assemble contigs quality trim read   subset  read        length read   map   reference genome  choice fasta file must also  upload  users  bowtie2  optionally  samtools suite fig     use  sort  index align read  result alignment file  sam  bam format    download  view use  java standalone tool misis  unique feature   vsd toolkit  major unique feature   vsd toolkit  compare  virfind    ability  exclusively use   small rna read    novo assembly  viral sequence assembly  viral sequence   set  read directly reflect  plant endogenous antiviral response mediate  dicer4  dicer2  additionally  provide  assembly pipeline  use   small rnas overlap  expect size  endogenous heterochromatin  transposon derive sirnas     pipeline identify viral sequence potentially integrate   host genome particularly     detect use   pipeline finally  provide    pipeline  users  compare  output   publish work  typically use  broad range  small rnas andor compare   result   target      pipelines another unique feature   vsd toolkit   ability  modify  parameter options     individual step   workflow fig  additionally  vsd toolkit use optimise spade  novo assembly settings  yield improve result  compare   test assemblers see   similarity screen  viruses  vsd toolkit  run  parallel use  blastn  blastx     novo assemble contigs  viruses  viroid sequence      databases ftpftpncbinlmnihgovblastdb respectively  top five database hit    novo assemble contig  report improve coverage  specific isolatestrain viral sequence andor prevent false negative result   top viral hit  annotate  “synthetic sequence” virfind run blast screen   stagger manner report first nucleotide top hit  viral sequence    contigs  negative blastn result  blastx screen  conduct report  best hit  finally  vsd toolkit also provide  list  potential viroidlike circular sequence   sequence similarity   nucleotide sequence  public databases deployment   toolkit  optimisation  test   bioinformatics toolkit  workflows  run   dynamic sge cluster locate  amazon web service aws elastic compute cloud ec2  allow compute nod   ram   easily add  remove  require yabi   bioinformatics toolkit may  deploy   variety  high performance compute resources",-0.18849592817126815,0.17520303383314362,0.07244627586333081,0.06709520044736564,0.05657770047806913,-0.03985244137589775,-0.12682673825838026,0.05835555259409981,0.024687198420010863,0.10383233912156097,0.047654793515490984,-0.07176564963955788,0.14395635359726536,-0.0838255707059233,0.11266958426506744,0.03835763256514578,0.14314619107748427,0.1906419299116048,-0.017234311476848754,0.07603591758314343,-0.09841057207568417,-0.2156877526815515,0.07895225694913062,0.011898229022599049,-0.024307139646705417,-0.1641733020650489,0.09431074251016114,-0.06150639796186061,-0.07848967220456828,-0.023921216685502303,-0.04072504814270706,0.2532735622357133,-0.17444807854713873,-0.058969470184473766,0.2226809883617153,0.09098019277233453,0.03003341213179132,-0.045785247847837,-0.1017471887447339,-0.10541046245478182,-0.06160881050618454,-0.1347216441280519,-0.1309512539349851,-0.10095201197878592,-0.06174246792991956,0.05721391342957283,0.05604629046860195,-0.0939589501898514,-0.17727831607728842,-0.2683566582542179,0.13934579145251996,0.06787738220100956,0.031035858968888143,0.4630606703939182,0.02130697979236997,-0.9386251043452926,0.02753824815464517,-0.21391377650179147,0.9480906433581064,0.13671398712471794,-0.13179651247453875,0.3192304800530629,-0.009689877454989722,0.06630968963416914,0.5016567895206667,0.03931905221931326,0.030933269432612823,0.00885804720843832,0.2894578411882477,-0.191931571918318,-0.034547826446027365,-0.013388655340420968,0.0967054379121622,-0.1574196058675824,0.11187688398191573,-0.018923489699761074,-0.13103364358789155,-0.0929107573508684,-0.341451698413917,-0.07440028442003364,0.2301530130560804,-0.012391237841276008,-0.3180548332720285,0.027674640551919028,-0.7333084977260746,0.08134895374566051,0.2818655308526719,-0.08118892433714964,-0.10846433719320757,0.023337766688200645,-0.09895465977711693,0.09213636460270556,-0.050969559149373136,-0.10021501473284193,-0.07716125048475253,-0.023783402188370627,-0.05148708750005989,-0.3170921080186963,0.34540352369326033,0.07998445933418613,VirusIdentification,3
71,71,"identification  novel viruses use virushunteran automate data analysis pipeline
quick  accurate identification  microbial pathogens  essential   diagnosis  response  emerge infectious diseases  advent  nextgeneration sequence technology offer  unprecedented platform  rapid sequencingbased identification  novel viruses   develop  customize bioinformatics data analysis pipeline virushunter   analysis  roche   long read next generation sequence platform data  illustrate  utility  virushunter  perform roche  flx titanium sequence  two unclassified virus isolate   world reference center  emerge viruses  arboviruses wrceva virushunter identify sequence derive   novel bunyavirus   novel reovirus   two sample respectively  sequence analysis demonstrate   viruses  novel members   phlebovirus  orbivirus genera  phlebovirus  orbivirus genera include many economic important viruses  serious human pathogens
virus strain salanga virus strain anb   originally isolate   rodent aethomys medicatus collect  september   salanga central african republic  heramatsu virus strain  use   study  originally isolate   blood   bat myotis macrodactylus collect   mine  heramatsu kagoshima japan  july 18th  transmission electron microscopy  ultrastructural analysis  ultrathin section infect vero  bhk cells  fix   least     mixture   formaldehyde prepare  paraformaldehyde powder   glutaraldehyde    cacodylate buffer      picric acid   cacl2  add  monolayers  wash    cacodylate buffer cells  scrap   process    pellet  pellets  postfixed   oso4    cacodylate buffer      wash  distil water   bloc stain   aqueous uranyl acetate   min  °  pellets  dehydrate  ethanol process  propylene oxide  embed  polybed  polysciences warrington  ultrathin section  cut  leica  uc7 ultramicrotome leica microsystems buffalo grove  stain  lead citrate  examine   philips  transmission electron microscope    antigens  immune reagents antigens use  serologic test  infect newborn mouse brain prepare   sucroseacetone extraction method  specific hyperimmune mouse ascitic fluids  prepare   wrceva     viruses use   study  immunization schedule consist  four intraperitoneal injections give  weekly intervals immunogens   suspensions  homogenize infect mouse brain  pbs mix  freunds adjuvant  prior  inoculation sarcoma  cells  also give intraperitoneally   final immunization  order  induce ascites formation  animal experiment  carry    animal protocol approve   university  texas medical branch iacuc committee serologic test hemagglutination inhibition  test    microtiter plat  previously describe  use four units  antigen   titer  read  overnight incubation  antigen  antibody  ° complementfixation  test  perform   microtiter technique  use two units  guinea pig complement  overnight incubation   antigen  antibody  °   titers  record   highest dilutions give    fixation  complement   scale     preparation  sequence  viral dna  rna total nucleic acid  extract  heramatsu virus infect bhk cell culture supernatant  cell lysate independently   qiagen dneasy kit accord   manufacturers instructions dna  rna  extract  salanga virus infect culture  vero  cells cell separately  cell line  obtain   american type culture collection manassas  nucleic acid   sample  reversetranscribed  enable subsequent detection   rna  dna viruses   amplify  previously describe  amplification products  pool adaptorligated  sequence   washington university genome sequence center    gsflx platform  life sciences sequence   trim  remove primer  sequence prior  assembly use  newbler program  life sciences branford  next generation sequence data analysis   nucleic acid use  sequence contain  mixture  host cell dna  virus rna  use  customize informatics pipeline virushunter  identify viral sequence  virushunter pipeline  control   master perl script virushunterpl  execute  step   pipeline  input   pipeline   directory path  directory hold sequence data  different sample  sample    directory   single file contain fasta format sequence read  workflow   pipeline  show  figure     brief description   step  remove redundant sequence identical  nearlyidentical sequence  frequently present  ngs data either due   sheer depth  ngs   many   presequencing sample preparation methods involve pcr amplification  reduce  compute cost  downstream analysis cdhit   first use  cluster similar sequence  default parameters  virushunter  set  cluster sequence  share ≥  identity     sequence length  longest sequence   cluster  retain   representative sequence  use  downstream analysis    “unique sequences”  mask repetitive sequence  sequence quality control many eukaryotic genomes contain stretch  highly repetitive dna sequence  cause problems  blastbased similarity search  result  high rat  falsepositive alignments repeatmasker   use  mask intersperse repeat  low complexity dna sequence  sequence fail  quality control criteria     contain  stretch   least  consecutive non“” nucleotides  “filtered sequence”   greater     total length   sequence  mask  ""low complexity sequence""  sequence  remove   analysis remain sequence  “good sequences”  filter host sequence sequence  subject  blastn  alignment   appropriate host genome default human blastn output file  parse use bioperl   sequence  share significant similarity  value ≤   classify  ""host""  remove   analysis  desire sequence database   use  filter  salanga virus    unique case wherein  virus  culture  vero african green monkey cells  inoculate  infect newborn mouse brain homogenate  use  reference human genome    genomes project  reference ftpftpncbinlmnihgov1000genomesftptechnicalreference  simplicity  heramatsu virus   culture   bhk hamster cell line  use  golden hamster mesocricetus auratus genome   reference genbank assembly  gca_000349665  blastn  ncbi  database sequence retain   previous step  query   ncbi  database use blastn sequence  significant hit  value cutoff   broadly classify  human mouse fungal bacterial phage viral   base   taxonomy identity   best blast hit  ncbi   taxid data  nucleotide sequence  upload   mysql database   number   best blast hit  use  query  database  obtain  taxonomy     turn use  retrieve  full taxonomy lineage use bioperl   instance one query  two   hit     value   sequence align    virus   sequence derive  another organism type  bacteria  fungi     value   classify  “ambiguous”  eukaryotic viral sequence   classify  viral families base   taxonomy    best hit sequence without hit progress   next step  blastx  ncbi  database sequence retain   previous step  query   ncbi  database use blastx evalue cutoff  blastx output file  parse  sequence  phylotyped  describe   previous step sequence without  significant hit  place   “unassigned” category  report   find  final output   virushunter pipeline   single file summarize   viruses identify   dataset   input directory  pipeline   customize  generate similar output   bacterial fungal  parasitic sequence virushunter  write  perl  use shell script  bioperl library mysql database cdhit repeatmasker  ncbi blast suite  pipeline  fully automate  highthroughput  components  organize   hierarchical set  readily modifiable script  multiple copy   pipeline   run  parallel  pipeline  design  run   high performance compute cluster use gridengine   job scheduler    easily modify  use  job management software  pipeline   easily customize  example  replace  human genome database     different host installation  configuration  virushunter require basic knowledge  perl mysql database  linux system administration distribution  source code  virushunter   available   assembly   viral genome  genome annotation sequence identify  viral  well  sequence    significant hit   sequence      databases  assemble use newbler  life sciences branford   default parameters orfs  predict  annotate use artemis  multiple sequence alignments  perform  clustalw  phylogenetic analysis  perform use  neighborjoining method  maximum parsimony method  mega5 program    bootstrap replicate tree    topology  generate use  methods    data set use   study phylogenetic tree  visualize use treeview  viruses analyze  sequence accession number use  analyse  viruses analyze include  follow genera species  strain bunyaviridae phlebovirus genus aguacate virus aguv yp_004414703 arbia virus arbv aga82737 arumowot virus amtv aef30501 durania virus durv aeb70976 leticia virus ael29649 also name phlebovirus coar  odrenisrou virus odrv ael29670 rift valley fever virus rvfv yp_003848704 rift valley fever virus rvfv_abd51499 abd51499 salehabad virus salv aga82741 toscana virus tosv caa48478 uukuniemi virus uukv baa01590 reoviridae orbivirus genus african horsesickness virus serotype  ahsv cap04840 african horsesickness virus serotype  ahsv aac40586 bluetongue virus serotype  btv yp_052968 bluetongue virus serotype  btv agj83521 chuzan virus chuv baa76549 epizootic hemorrhagic disease virus serotype   strain new jersey ehdv yp_003240108 epizootic hemorrhagic disease virus serotype   strain csiro  ehdv can99553 great island virus giv yp_003896058  croix river virus scrv yp_052942 yunnan orbivirus yuov yp_443925",-0.1593215423417351,0.1644983351441694,0.08023898661198396,0.04778168604312745,0.00720237470858802,-0.02800203667863246,-0.016031581097017075,0.03215978185827779,-0.022407811966242752,0.08612850777147675,-0.016220275445359308,-0.025743679867013702,0.11747082309846048,-0.01341120968247158,0.11154372658795464,0.07159870127916101,0.10126607186925007,0.09886917527493333,0.0306662651819606,-0.0019867224207675486,-0.08003622149174278,-0.19345823757006894,0.056110808947485866,0.06324332415727063,0.01154518116166216,-0.047319359721825945,0.08017258212701793,-0.043973820163116135,-0.045747598393826736,0.007778228782003393,-0.01800454011935109,0.2336813841109535,-0.14069049582824594,-0.043918121015079886,0.15697798129787605,0.033377208065573725,0.013101521215745137,-0.03238411810614618,-0.05336113188933122,-0.06191683633583093,-0.06908556900910749,-0.08074613289004033,-0.14188794673573538,-0.1246898438143658,-0.010256911019210124,0.048449379879813584,0.08398786003838156,-0.07785885731094938,-0.1806194441561128,-0.18774963278401569,0.08258979261398537,0.039892048197804536,0.0501366582878424,0.3750591676937045,-0.0215136765705306,-0.7808965397331135,-0.024930434328360625,-0.16605382380037084,0.6973581065442511,0.17046775799653724,-0.09509528981049756,0.291230371296593,0.04177828239416622,0.07048140996788267,0.42936567126910063,0.06194730106801433,0.022882170634154132,-0.03076647624336395,0.1775429799519414,-0.16068255602442366,-0.04125887285095763,-0.002305475382797397,0.0724302737200649,-0.07266070979030256,0.12440768680309093,-0.0016610238931493485,-0.1012691651931736,-0.11738816776086568,-0.30313299830524265,-0.02285042140541842,0.15008347003657202,-0.009924551378345359,-0.2913385596622101,0.0303084975145342,-0.609497753302876,0.1423392040377004,0.24580504689907,-0.0792771836981288,-0.1155007039513268,0.056546338661051784,-0.055223035260178535,0.009355422984922656,-0.07214914535789366,-0.016270424380989655,-0.008303045990821495,-0.04801952516211529,-0.06991651767412595,-0.3168512508207997,0.2738753782922705,0.02109037409088789,VirusIdentification,3
72,72,"vipie web pipeline  parallel characterization  viral populations  multiple ngs samples
next generation sequence ngs technology allow laboratories  investigate virome composition  clinical  environmental sample   cultureindependent way    need  bioinformatic tool capable  parallel process  virome sequence data  exactly identical methods   especially important  study  multifactorial diseases   parallel comparison  laboratory protocols   develop  webbased application allow direct upload  sequence  multiple virome sample use custom parameters  sample   process  parallel use  identical protocol    easily reanalyzed  pipeline perform denovo assembly taxonomic classification  viruses  well  sample analyse base  userdefined group categories table  virus abundance  produce  crossvalidation  remapping  sequence read   union   observe reference viruses  addition read set  report  create  process unmapped read  know human  bacterial ribosome reference secure interactive result  dynamically plot  population  diversity chart cluster heatmaps   sortable  searchable abundance table  vipie web application   unique tool  multisample metagenomic analysis  viral data produce searchable hit table interactive population map alpha diversity measure  cluster heatmaps   group  applicable custom sample categories know reference   human genome  bacterial ribosomal genes  optionally remove  unmapped dark matter read secure result  accessible  shareable  modern browsers
 pipeline process demultiplexed pair fastq file   typical product  metagenomics sequence several step   perform  parallel   sample quality control  denovo assembly  putative genomic contigs taxonomic classification   assemble contigs  orphan singleton read  perform blast query   local custom virus database derive  genbank  finally remapping   sequence read onto reference sequence identify   taxonomic classification default analysis parameters   easily modify    stringency    novo assembly algorithm depict  fig  vipie pipeline use multi processor architecture  integration  postgresql  performance  data management  provide secure interactive result  allow web form parameters   assembly  score  individual parameters   default value  list   user guide trim  quality control  parameter base apply galaxy project utilities     integrate lead denovo assembly tool  velvet  metavelvet  idba   megahit soapdenovo   aby   methods  tool   describe  review   taxonomic identification  perform use blast    local ncbi database restrict  whole virus genomes  final step   parallel analysis remaps  raw read use bwa  onto  list  best match   blast query  list  count  original read match     reference  case  read match equally well  multiple viruses  score  divide among  best match  express importantly  ambiguity  assignation   motifs share among viral taxa   uncertainty   presently available classification denovo contigs  read    match   currently know virus optionally filter  human genome  know ribosomal dna   retrieve   analysis   dark matter   virome presumably contain novel viruses  pipeline allow  direct export   unmapped read owe  threestep filter strategy read unmatched  know viruses  first deprive  sequence  match  ribosomal dna  bacterial archeal  fungal origin   perform  remapping  read   bwa program  databases      rdna  copy  ftpncbinlmnihgovgenomestarget   reduce database   rdna    next step remaps  reduce set  read   human genome  step yield  potential dark matter   human genome mix   small proportion  bacterial genomic dna  pipeline   filter   bacterial genomic read   may contain novel lysogenic dormant phages vipies reference virus database  build  three source  cluster  sequence    level  identity  reduce  complexity first  viruses  download   refseq database   ncbi   reduce   identity  use  cdhit program    virus sequence label  “complete”   “txid10239” superkingdom viruses   “orgn” field  retrieve  genbank  query retrieve approximately  sequence   database   subsequently reduce    similarity  use  cdhit program finally similarly  previous two databases phages  merge  cluster   european bioinformatics institute ebi repository ftpebiacukpubdatabasesfastafilesembl_genomesgenomesphage  web form interface dialogs  result  program  html5 standards  use javascript  modern open source javascript libraries    browser compatibility biopython   use  sequence parse  format parallel process  achieve via python  subprocess module implementation  use postgresql  schema  job track  result merge standard smtp library  use  notification hence  email registration requirement cluster heatmaps  implement   ggplot2    summary  alpha diversity statistics  compute use custom python script population map  read distribution count summary chart  create use highchartsjs   custom event handlers  interactivity",-0.1635880346261329,0.2341758497040385,0.14550030840608574,0.07248129421490145,0.10876547263067593,0.006126871919390254,-0.0729212743618468,-0.04057544129043635,0.025559791592814345,0.1598268138375194,0.052739201928109714,-0.044601275716037635,0.15080889771665532,-0.11337717581185412,0.07091785216907262,0.10621440686190316,0.1869198008135556,0.18522371468977952,0.004823582271168597,0.06998533733926278,-0.16926940003749744,-0.23207916924834224,0.14456577557089806,0.028326335578477344,-0.0018300260265482168,-0.19960896214257914,0.13057366133592066,-0.06754489965829391,-0.12429145530870347,-0.048336686793993854,-0.02624113355984711,0.30420281947144845,-0.1921874996523467,-0.04991765860343012,0.2655396705966576,0.04943771581453687,0.02833312356856679,-0.022529538672687397,-0.08851587221008217,-0.1382024057559496,-0.08466528768799833,-0.11332045965797664,-0.13032947976467524,-0.052750918576236,-0.09001047833267514,0.021071833127605997,0.06674293718006735,-0.10145631965597886,-0.19477275833153807,-0.21907778608602102,0.17268928128722388,0.05890727144057775,0.022762419492861785,0.4610912812364073,0.006769170992968283,-0.9950146508562008,-0.00539786214197012,-0.17357615175761634,0.94235029507122,0.19359435289809995,-0.13321479636687006,0.32648473822104845,-0.012985925731652626,0.01927214151133437,0.5691761371621965,0.03491233675469529,-0.012291274477296558,0.02060716237542174,0.27703654831912405,-0.1679468973574277,-0.06734951976299929,0.04259939750526419,0.14436579259823104,-0.1368464105117896,0.10278998957552524,-0.0009369589373202394,-0.12946945349063954,-0.14709829830326418,-0.4084367371188531,-0.09105299523362666,0.1789098002674651,-0.036614131255997565,-0.33600546083950017,0.026849905348986583,-0.7760382040080702,0.16769025724681538,0.26523904276310983,-0.17192952082255789,-0.16002598240272314,0.03242259799026511,-0.11172818599104978,0.12004374118570348,-0.07935313150766934,-0.0415527226128149,0.0004965212025091124,-0.07002817395413204,-0.10021726381039726,-0.34873837274510616,0.3153453245121949,0.1194573825298041,VirusIdentification,3
73,73,"viromescan  new tool  metagenomic viral community profiling
bioinformatics tool available  metagenomic sequence analysis  principally devote   identification  microorganisms populate  ecological niche   usually   consider viruses   software   design  profile  viral sequence however    efficient   characterization  viruses   context  complex communities like  intestinal microbiota contain bacteria archeabacteria eukaryotic microorganisms  viruses   case  comprehensive description   hostmicrobiota interactions   ignore  profile  eukaryotic viruses within  virome  viruses  definitely critical   regulation   host immunophenotype viromescan   innovative metagenomic analysis tool  characterize  taxonomy   virome directly  raw data  nextgeneration sequence  tool use hierarchical databases  eukaryotic viruses  unambiguously assign read  viral species  accurately   fold faster   exist approach  validate viromescan  synthetic microbial communities  apply   metagenomic sample   human microbiome project provide  sensitive eukaryotic virome profile  different human body sit viromescan allow  user  explore  taxonomically characterize  virome  metagenomic read efficiently denoising sample  read   microorganisms  imply  users  fully characterize  microbiome include bacteria  viruses  shotgun metagenomic sequence follow  different bioinformatic pipelines
workflow   software  download viromescan locally process  metagenome  search eukaryotic viral sequence input file   singleend  pairedend read  fastq format  pairedend read compress file  gzip bzip2  zip format  also accept retrieve  shotgun sequence  rnaseq depend   research strategy viromescan give users  option  choose   range  inhouse build reference databases include human dna virus database human dnarna virus database eukaryotic dna virus database  eukaryotic dnarna virus database  human virus databases contain  viruses    human    natural host    hand  eukaryotic virus databases also include viruses  vertebrates invertebrates fungi algae  plant  exclude bacteriophages  databases  base   complete viral genomes available   ncbi website   ncbi ids   viral genomes use  build  different databases  report  additional file   schematic description   procedures  analysis compute  viromescan  provide  fig   detail metagenomic read  compare   viral genomes   select database use bowtie2   first step   complete  accurate screen   sequence  select candidate viral read  perform  procedure  filter process allow  considerable gain  time   subsequent part   pipeline due   reduction   dataset  less      total amount  metagenomic read afterwards  quality filter step   candidate viral read   implement  describe   process procedure   human microbiome project hmp   brief sequence  trim  low quality score use  modify version   script trimbwastylepl  work directly  bam file   script  utilize  trim base   end  sequence  show  quality value  two  lower  threshold  take  delete   base   uncertain quality  define  illuminas eamms end anchor max score segment filter additionally read trim  less     also remove since  sequence analyze  wholegenome  rnaseq products   plausible   candidate viral read contain  small percentage  human read   reason   necessary  subject  sequence   control  human contamination  report   hmp procedures  human best match tagger bmtagger    efficient tool  discriminate among human viral  microbial read first   bmtagger attempt  discriminate  human read    read  compare  18mers produce   input file   contain   reference human database   process fail  additional alignment procedure  perform  guarantee  detection   match    two errors humanfiltered read may also contain  amount  bacterial sequence  need   filter   avoid bias due  bacterial contamination bacterial read  identify  mask use bmtagger   tool utilize   human sequence removal procedure  particular  order  detect bacterial sequence humanfiltered read  screen   genomic dna   representative group  bacterial taxa   know   common   human body niches see additional file    list  bacteria include   process nevertheless  user  customize  filter procedure  replace  bacterial database within  viromescan folder   microbial sequence  interest associate  environments    human body  microbiome associate  animals soil  water finally filter read   compare   viral genomes   choose hierarchical viral database use bowtie2  allow  definitive association   virome sequence   viral genome   sample analyze  total amount  count  summarize   table  number  hit  relative abundance additionally graph represent  abundances  family genus  species level  provide use  “graphics”  “base”  package validation   tool  comparison   exist methods five different mock communities  contain  human dna viruses  different relative abundances  build  submit  viromescan   validation  mock communities contain also human sequence  read   microorganisms  test  filter step   pipeline  simulate metagenomes  compose  sequence    randomly generate   choose genomic dnas   inhouse develop script  order  compare  performance  viromescan   exist tool   mock sample  analyze use metavir   blastn   particular   metavir pipeline  determine  taxonomic composition use  number  best hit normalize  genome length   gaas metagenomic tool   genomes use  generate  five mock communities  report  additional file  case study use viromescan  profile  eukaryotic dna virome across different human body sit twenty metagenomic sample  hmp  belong  four body sit include stool mid vagina buccal mucosa  retroauricular crease  use  illustrate  result    obtain  viromescan  ids  hmp sample  report  additional file   metagenomes   sequence use  illumina gaiix platform    pairedend read  entire metagenomic dataset  utilize  study  differences   composition   viral communities across different body sit  ethics approval  require   work perform   study",-0.2276962157676497,0.2190178349614847,0.1254702596028344,0.06583941328477147,0.003656827956522474,-0.0217133942708634,-0.11014948209348133,0.025142033330131087,0.013657620443619248,0.12681158774200366,0.0009158635315037925,-0.050296062144965736,0.18646232866661186,-0.11237172569004747,0.13542141099572969,0.03712716343773253,0.09913437362068143,0.20487379257055846,-0.03202535153234383,0.0863342165983538,-0.10640156347926402,-0.22111785297107592,0.0950400301879919,-0.01815770444631846,-0.04523877648065525,-0.17615664522993602,0.06639305788765484,-0.1491687769067454,-0.04312426814736638,0.0050381939445644786,-0.002790877228624573,0.26863458807287555,-0.19725660919816745,-0.059337489552946425,0.22781305138861935,0.10438745768088004,0.0004125727548790122,-0.0658187857446376,-0.1251070657247337,-0.11076816782728822,-0.1350230405719464,-0.13993793481306188,-0.1471767824368616,-0.1287517345885344,-0.15939618382807624,0.03000966878959577,0.08915181839775317,-0.12869779550079313,-0.25540591519237343,-0.3338234205491098,0.2079113610957544,0.040373624855331684,0.0203026922267026,0.5335788675147781,-0.012089234749361692,-1.0630988488860114,0.02117919209982997,-0.2632185811503281,0.9913321098036996,0.18612793927231108,-0.16738047371831233,0.4100023908184503,0.015026574549926416,0.05789293303840942,0.6435717247803541,0.0675510142787762,0.07211200738384801,-0.018181209335021046,0.22193590342981626,-0.22764724539205985,-0.050897507819996766,-0.0028025177908847475,0.12069670736620533,-0.13151285386844075,0.12471537297068225,-0.010624070485119687,-0.1959872840639215,-0.14554645122398885,-0.3634976453465773,-0.0272548909709167,0.1825991492701576,-0.0012491061039173305,-0.36225891324341175,-0.00491211199331072,-0.8434082550046617,0.07032644243160363,0.28997153553213456,-0.09308139711793924,-0.17572601436246246,-0.0012464775907662148,-0.108573777755083,7.792347115380097e-05,-0.07964141904503062,-0.09678987037651438,-0.037788099754922484,-0.03428224680222166,-0.14174917238001966,-0.3552488247762656,0.3335387006903551,0.07748070260470458,VirusIdentification,3
74,74,"genome detective  automate system  virus identification  highthroughput sequence data
genome detective   easy  use webbased software application  assemble  genomes  viruses quickly  accurately  application use  novel alignment method  construct genomes  referencebased link   novo contigs  combine aminoacids  nucleotide score  software  optimize use synthetic datasets  represent  great diversity  virus genomes  application   validate  next generation sequence data  hundreds  viruses user time  minimal    limit   time require  upload  data
genome detective accept unprocessed pairedend  single read generate  ngs platforms  fastq format andor process fasta sequence  fastq file lowquality read  filter  adapters trim  trimmomatic bolger     quality   read  visualize use fastqc brown       trim candidate viral read  identify use  proteinbased alignment method diamond buchfink     use  viral subset   swissprot uniref90 protein database  contain representative cluster  proteins link  taxonomy ids  improve sensitivity  speed  swissprot uniref90  constantly update    time   submission   paper  viral subset   database contain   protein cluster    time also  ncbi refseq database  constantly update    time   submission   paper  viral subset   database contain  unique taxonomic ids genome detective   automate procedure  download new versions   reference databases   current version   number  viral taxonomy ids identify  show   interface  speed  accuracy  genome detective  also improve  first sort short read  group  bucket  objective   run  separate metagenomic  novo assembly   bucket   read  one virus species need   assign    bucket  bucket   identify use  taxonomy    lowest common ancestor lca   hit identify  diamond however  read  represent   viral species  assign  bucket  different taxonomic rank  solve  problem  either distribute  read   node downwards  collapse  upwards  compare  number  read identify   node   taxonomy tree versus   descendant nod  addition give  metagenomic study  accelerate review  rise     increase number  reference sequence   novel viruses    yet  classify  cause  lca taxonomy    unspecific   number  uniref cluster    analysis  hit identify  diamond  avoid  problems  retain  sequence   exclude  taxonomic classification   viruses  lca algorithms     read   sort  bucket  bucket    novo assemble separately use spade bankevich     singleended read  metaspades bankevich     pairedend read blastx  blastn  use  search  candidate reference sequence   ncbi refseq virus database genome detective combine  result  every detect contig  amino acid  nucleotide  level   calculate  total score    sum   total  score plus total amino acid score   choose  five best score reference   contig   use   alignment  contigs   individual species  join use advance genome aligner aga deforche     new dynamic program algorithm aga  design  compute  optimal global alignment consider simultaneously  alignment   annotate cod sequence   reference genome aga build    optimal alignment algorithms first propose  needlemanwunsch smith  waterman  smithwaterman smith  waterman   gotoh gotoh   expand  induction state  additional state parameters  make alignments use aga  therefore genome detective  sensitive  accurate     protein score  take  account  order  produce  consensus sequence    novo contigs  report  generate refer   final contigs  consensus sequence available  fasta file  report also contain detail information  filter assemblage  consensus sequence webbased use  jwt libraries graphics  available  viral species genome image alignment viewer   amino acid similarity measure  read count  addition  user  produce  bam file  bwa   durbin  use  reference   novo consensus sequence  select  detail report supplementary fig   access viral phylogenetic identification tool  oliveira    directly   interface",-0.2263050621880061,0.21012700879423854,0.1298635830070574,0.05433663845751581,0.052650712567058895,-0.04163603813893448,-0.07549040157743912,0.033916606840963565,0.0268875293279668,0.13769178369859836,0.05701757166635495,-0.08205521280884626,0.13278540386085025,-0.15652644361220813,0.15537675540226487,0.054859930800648014,0.14751745250046722,0.18421124887304824,0.014026184228072894,0.10025400265970627,-0.08575389749099185,-0.26105037120658553,0.09646584570071456,0.0136265102842654,-0.03598718260466231,-0.1964642081930353,0.1053023634837779,-0.10832151832191024,-0.030674212278548888,-0.04217205662257405,0.008226719112905461,0.3210100956237325,-0.1907815254297049,-0.04051828270596562,0.21769974895674596,0.08353002411856474,-0.003636559332156275,-0.024555396602129725,-0.06023598537325684,-0.11766347696447348,-0.09877808275197147,-0.10818089160528062,-0.13356455977970375,-0.1256803826902861,-0.1468985655059026,0.04330575267149971,0.0523033916767353,-0.1887608162543597,-0.2211457663784024,-0.30112149408747124,0.16341656772190646,0.03737736624052774,0.05064491749334141,0.5288271701264041,-0.003992401655602057,-1.0678079919962902,0.01701136450736974,-0.16128062550436822,0.9323596667799012,0.1713200633058427,-0.15904178026493904,0.3112476248602111,-0.04346539845642465,0.07954478832342163,0.5862886396449382,0.013397819580744923,-0.0017619484441545536,0.0586581182939888,0.2678049013575935,-0.1816324098049443,-0.04882969774051907,0.008040448387752024,0.09329595374938936,-0.17769548876988372,0.18998258740835508,-0.00264859142691249,-0.17473440568923482,-0.16295196866161946,-0.3900675858741289,-0.10578649770789304,0.18132814219382806,-0.04592424202902888,-0.35808690164051904,-0.07095283387397511,-0.7952219651806659,0.1069722219153058,0.2606191806106528,-0.1739298160862559,-0.13415333568498924,0.018379492181152524,-0.12800895310865024,0.11362184313268907,-0.08881402146309526,-0.09860733681079734,-0.07183970206629807,-0.11618384990912647,-0.07119241615896678,-0.3433093272633557,0.3426873603667037,0.061572539422562064,VirusIdentification,3
75,75,"vapid  lightweight crossplatform viral annotation pipeline  identification tool  facilitate virus genome submissions  ncbi genbank
 sequence technologies become cheaper  easier  use  group  able  obtain whole genome sequence  viruses  public health  scientific importance submission  genomic data  ncbi genbank   requirement prior  publication  play  critical role  make scientific data publicly available genbank currently  automatic prokaryotic  eukaryotic genome annotation pipelines    viral annotation pipeline beyond influenza virus annotation  submission  viral genome sequence   nontrivial task especially  group    routinely interact  genbank  data submissions  present viral annotation pipeline  identification vapid  portable  lightweight commandline tool  annotation  genbank deposition  viral genomes vapid support annotation  nearly  unsegmented viral genomes  pipeline   validate  human immunodeficiency virus human parainfluenza virus  human metapneumovirus human coronaviruses 229eoc43nl63hku1sarsmers human enterovirusesrhinoviruses measles virus mumps virus hepatitis  virus chikungunya virus dengue virus  west nile virus  well  human polyomaviruses bkjcmcv human adenoviruses  human papillomaviruses  program  handle individual  batch submissions  different viruses  genbank  correctly annotate multiple viruses include   contain ribosomal slippage  rna edit without prior knowledge   virus   annotate vapid  program  python   compatible  windows linux  mac  systems   create  portable lightweight userfriendly internetenabled opensource commandline genome annotation  submission package  facilitate virus genome submissions  ncbi genbank
vapid   download    installation guide usage instructions  test data  also  find    webpage  invocation  vapid  show  fig  users must provide  standard fasta file contain    viral genomes  wish  annotate users also must provide  genbank submission template sbt file  include author publication  project metadata  genbank submission template   use  multiple viral sequence  submissions   easily create   ncbi submission portal   optional sample metadata file csv file   provide  vapid  expedite  process  incorporate sample metadata  optional file  also  use  include    source modifiers support  ncbi    sample metadata file  provide vapid  prompt  user  input  require sample metadata  runtime additionally users  provide  specify reference    annotate  viruses   run  well  provide   blastn database  force vapid  search ncbis  database   internet  vapid pipeline  summarize  fig   first step  find  correct reference sequence   accomplish  three ways  use  provide reference database default  force vapid  execute  online blastn search  ncbis  database   inputting  accession number   single ncbi sequence  use   reference   default case ncbis blast tool  call   command line  search   reference database   include   vapid installation  database  generate  download  complete viral genomes  ncbi  may    best result   search  pass   reference   next step   online option  find  reference  specify vapid find  appropriate reference sequence   genome   annotate  perform  online blastn search   word size   use biopythons ncbi wwwqblast function   online ncbi  database  blastn output  parse   best score alignment among  top  result  contain “complete genome”   reference definition line   complete genome  find   top  blastn result  topscoring hit  use   reference sequence   specific reference  provide vapid simply download  directly  ncbi   correct reference  download gene locations  strip   reference   pairwise nucleotide alignment   reference   submit sequence  generate use mafft   relative locations   genes   reference sequence   map onto  new sequence base   alignment  putative alignment  require  start codons   regions  high homology    rely  intergenic space  gene lengths gene name  take   annotate reference sequence genbank entry spellchecking  perform use ncbis espell module  module provide spellchecking  many biological string include protein product name  optional argument   provide  execution  enable  step  diverse array  methods viruses use  encode genes  present problems   viral genome annotator ribosomal slippage allow viruses  produce two proteins   single mrna transcript    ribosome slip one  two nucleotides along  mrna transcript thus change  read frame since ribosomal slippage  well conserve within viral species  complete reference genomes often list exactly   occur custom code  use  strip  correct junction site  include    annotation rna edit  another process   viruses  include multiple proteins   single gene  rna edit  rna polymerase cotranscriptionally add one  two nucleotides      template  change  specifically create  viral mrna transcription    viral genome replication rna edit present  annotation issue   annotate protein sequence   match  expect translate nucleotide sequence  correctly annotate genes  rna edit vapid parse  reference genome viral species detect  rna edit locus  mimic  rna polymerase vapid add  correct number  nontemplated nucleotides   viral species  provide  alternative protein translation  process  hardcoded  human parainfluenza  nipah virus sendai virus measles virus  mumps virus although rna edit occur  ebola virus reference  ebola virus  annotate    way  ribosomal slippage  code write  ribosomal slippage handle ebola virus annotations  ribosomal slippage  rna edit  process file require  genbank submission  generate   provide author  sample metadata vapid first generate  fsa file tbl file  optional cmt file submission file   viral genome  package   separate folder   sequence vapid  run tbl2asn   folder use  provide genbank submission template file sbt",-0.17492703457128594,0.1693619826947053,0.1497094119081785,0.03789950872191648,0.10285665951051948,0.04855169811030375,-0.06518835182571052,-0.02178675334084949,0.07260160327864677,0.10320838469725856,0.043814011603697314,-0.034815267958370914,0.17310717853632288,-0.06472586248998471,0.12733510402685602,0.054569174195457176,0.11036665033430372,0.17361681838367693,-0.034524429069065006,0.0954830810892566,-0.113153326322075,-0.2572614044199083,0.14214946294592973,0.06434925704330109,0.02273595671883169,-0.14772868359437075,0.0793024895229952,-0.021770317702450685,-0.03329322792230527,0.021858789671206347,0.012639251409031549,0.3551994364669096,-0.14172471832678793,-0.032388170356664414,0.2869345230580912,0.057384463703926365,-0.037857472061505235,-0.0566844967457548,-0.047560870063071164,-0.08476186529950093,-0.08594602377416817,-0.044516291864852814,-0.11688791064117895,-0.13799932034377288,-0.06114436231809973,0.01924967881006012,0.054141593113955534,-0.18957646009040496,-0.2055886456068739,-0.2471186346165209,0.15865677487397312,0.1047862614603908,0.036604537472799965,0.4872655029366024,-0.031031318810871907,-1.0539090436475436,-0.05407363871337688,-0.20204963812526933,1.0266050433367566,0.2468270721238143,-0.2063446095442225,0.3969178070200857,0.03366935347492983,0.028655296956262018,0.5945808782738335,0.07063613127417911,0.008254257528403518,0.029074230818188725,0.2070572903460452,-0.1995924037055256,-0.09526091165567847,-0.0528667843090279,0.1567171920346571,-0.1731252773966202,0.1548686788106958,0.02975199099065541,-0.17615539210489373,-0.11371972969370996,-0.4023559356026132,-0.11430022577615152,0.22618343694907084,-0.1197928560570908,-0.3711802097983975,-0.003061080530850412,-0.8801807880651181,0.1843082074941824,0.2794866503362416,-0.14115619127413415,-0.1462948165289537,0.012393475208441754,-0.11641310832122327,0.1561153196673414,-0.09411053787429932,-0.10373472440926956,-0.04793703707096356,-0.10242122832154613,-0.06402812276516426,-0.3609959095202119,0.35037674103693106,0.1092139084503763,VirusIdentification,3
76,76,"virusseq software  identify viruses   integration sit use nextgeneration sequence  human cancer tissue
 develop  new algorithmic method virusseq  detect know viruses   integration sit   human genome use nextgeneration sequence data  evaluate virusseq  wholetranscriptome sequence rnaseq data   human cancer sample   cancer genome atlas use  data  show  virusseq accurately detect  know viruses   integration sit  high sensitivity  specificity virusseq  also perform  function use wholegenome sequence data  human tissue
mappingalignment   read  fastq format  use  input virusseq work   wholegenome  wholetranscriptome sequence data  raw  read  align   reference genome use mosaik hiller    alignment software  implement   hash scheme   smithwaterman algorithm  produce gap optimal alignments  virus detection  ngs data virusseq start  computational subtraction  human sequence  align raw  read  wholegenometranscriptome sequence   human genome reference thus  set  nonhuman sequence  effectively generate  subtract  human sequence   second step virusseq align  nonhuman sequence   comprehensive database  include  know viral sequence  genome information broker  viruses   quantify  virus representation   overall count  map read within  virus genome  determine  existence  viruses  human sample   empirical cutoff  virus   overall count  map read   cutoff  treat  nonexistent  use    cutoff   overall count  map read within  virus genome  cutoff   applicable   rnaseq data  wholegenome sequence data   coverage  cutoff   reduce  half    lowpass wholegenome sequence data  identification  virus integration sit  genome sequence  viruses   well know  term  cancer association   detect   previous step    cancer genome atlas tcga dataset  concatenate   single chromosome name chrvirus  relate annotation   viral gene  refflat format  new hybrid reference genome name hg19virus  build  combine hg19  chrvirus designate  chr25  hg19virus   read without computational subtraction  map   reference hg19virus    read  uniquely map  one end  one human chromosome     chr25  read pair  report   discordant read pair  discordant read   annotate  human  viral genes define   curated refflat file virusseq  cluster  discordant read pair  support   integration fusion event  hbvmll4 virusseq implement  dynamic cluster procedure detail  supplementary note  accurately determine  boundary   cluster whose size  constrain   insert size fragment length distribution  remove outliers within  cluster virusseq implement  robust extreme studentized deviate multipleoutlier detection procedure rosner   outliers  detect within  cluster  cluster boundary  reset  exclude  outlier read virusseq report  fusion candidates  use  support pair  least four  junction span read  least one   cutoffs meanwhile   silico sequence  generate use  consensus  read within discordant read cluster   fusion candidate  help  pcr primer design  facilitate quick pcr validation  ",-0.2267483899094855,0.19912515915649268,0.10297754909455156,0.13740044496030193,0.017916251249589968,-0.03939061784264083,-0.012299523917000055,0.02310624040780996,0.010748569023977408,0.16990180730541374,-0.047711065386277465,-0.06215753300575775,0.15644523178377115,-0.12046121461142988,0.24309162080057775,0.1033222612726834,0.10406143620246272,0.18292443707452194,0.034015176314646484,0.019556186901239527,-0.09979624372783877,-0.24618481401750156,0.058740863758513985,0.012864871239610788,-0.0007872443335751692,-0.12729752270890207,0.11022915979633216,-0.14170854089877985,-0.06030096465219267,-0.0646682238813768,0.01670724725776925,0.2806300771912432,-0.1709758224575941,0.005884231953351791,0.1933559882963055,-0.006183959213192521,0.02647972028520515,-0.003399344689036109,-0.07749764117761515,-0.08006761491234446,-0.06080609585068874,-0.1080761202956428,-0.11965478158685723,-0.1191487762168446,-0.22598660180088265,-0.0018950565771638664,0.08709701255028104,-0.18873573019270967,-0.3021195540873698,-0.29758171363193114,0.17063714651492606,0.07808457421414533,0.04883134100404194,0.5224349046478599,-0.011276285751487246,-1.0357891982956522,0.004084306035790293,-0.20148044343082366,0.8604045405919696,0.2059059767106056,-0.142488638366788,0.2801043616785753,0.0040753548550044845,0.07154685981710837,0.5969912483097299,0.06301535977968603,-0.001933896550159345,0.04611040530699551,0.24009792983913986,-0.181256145440596,-0.04759437369566826,-0.007314567971839462,0.08149806027910833,-0.14020887288618192,0.20998241762488806,-0.06934027026953367,-0.15518530687429652,-0.14544958063406635,-0.3693261847285361,-0.11213445955092602,0.18266724351052216,0.0025658943990095593,-0.3569421964441961,-0.034792400310458285,-0.8346868173337016,0.13380201510722406,0.2938592702728407,-0.10375621762586994,-0.15972043478583126,-0.014288850636462328,-0.16553353504866533,0.14222569448000955,-0.09856444522510978,-0.07655494000987502,-0.018981903145790912,-0.0951244215877063,-0.05457846420728762,-0.3595433256149977,0.27029344267425953,0.08563975071208016,VirusIdentification,3
77,77,"paipline pathogen identification  metagenomic  clinical next generation sequence samples
next generation sequence ngs  provide researchers   powerful tool  characterize metagenomic  clinical sample  research  diagnostic settings ngs allow  open view  sample useful  pathogen detection   unbiased fashion  without prior hypothesis  possible causative agents however ngs datasets  pathogen detection come  different obstacles     unfavorable ratio  pathogen  host read alongside often appear false positives  irrelevant organisms   contaminants tool  often challenge  sample  low pathogen load  might  report organisms present   certain threshold furthermore  metagenomic profile tool   focus  one particular set  pathogens  example bacteria  present paipline  bioinformatics pipeline specifically design  address problems associate  detect pathogens  diagnostic sample paipline particularly focus  userfriendliness  encapsulate  necessary step  preprocessing  resolution  ambiguous read  filter   visualization   single tool  contrast  exist tool paipline   specific  maintain sensitivity   show   comparative evaluation  paipline  benchmarked along  wellknown metagenomic profile tool  previously publish wellcharacterized datasets additionally  part   international cooperation project paipline  apply   outbreak sample  hemorrhagic fevers   unknown etiology  present result show  paipline  serve   robust reliable userfriendly adaptable  generalizable standalone software  diagnostics  ngs sample    step stone   downstream analyses
 main step  paipline  data preprocessing read assignment  result evaluation   describe  step  along   sample  data preparation preprocessing  workflow start   preprocessing   set  raw read  fastq format initially  read input quality control  perform  three step  base quality control step  sequence complexity control step   length cutoff step  base quality control follow  slide window approach  default  window size     minimum average quality  q10     prevent mislead lowquality base  contribute   sensitive alignments  provide  basis   sample constituents calculation later  subsequently  remain base   read  check regard  sequence complexity base   sdust algorithm  discard regions  low complexity  strongly bias composition   read morgulis     prevent mathematically valid alignments  low biological significance  could possibly stem  regions   naturally occur repeat regions  regions   find  different clades  species throughout  tree  life thus  result alignments   provide insight   origin   read   knowledge     pipeline    complexity filter approach  read  implement read  discard    shorter   minimum length cutoff   default   previous trim step since  short alignments  extremely unlikely   unambiguous  preprocessing parameters   change   user  account   specific experimental requirements  data  read alignment  validation follow preprocessing  read  map   choose foreground  background databases use bowtie     sensitive mode langmead  salzberg  langmead    typical databases    use  paipline  viral bacterial fungi amoebozoa  apicomplexa databases    create use  database updater script describe   subsection database preparation read  map   background  remove    analysis whereas  remain foreground align read undergo blast validation   query   blastn program   complete ncbi  database altschul    camacho     ensure   every read  possible origin sequence  find  long    know  include   ncbi  database  user  control  parameters   apply assignment methods accord     need  result presentation  read assignment paipline generate  result overview  construct  taxonomic tree include  otus hit   number  read   respective ancestors    taxonomic root subsequently  tree  check  ambiguities  evaluate  hit   taxonomic rank  hit  deem unique     assign  reference within  single otu   read hit several otus  hit  assume   unambiguous   identity   reference within  best hit otu  higher  every hit    otu  identity cutoff   step   configure   user   name taxonomic rank   species genus family etc  reasonable default value  provide  none   hit qualify  sufficiently unambiguous  hit  move upwards   tree  compare    nexthigher rank therefore paipline use  modify lowest common ancestor lca approach huson      point  userdesignated olis  mark  filter purpose afterwards  construct taxonomic tree  transform  save   csv file  allow easy parse filter  visualization use thirdparty applications   spreadsheet software  result file contain  otus  taxonomic lineage  well   respective unique unambiguous  total hit count  database preparation  paipline need databases contain foreground  background organismassociated sequence  provide  auxiliary script  allow users  download  maintain  local copy   ncbi nucleotide  database  well  subdatabases  interest  script download   database along   taxonomic information provide  ncbi  reannotates  contain sequence   taxonomic lineage keep  original ncbi annotation afterwards userdefinable subdatabases  taxonomic clades relevant   pathogen search  example viruses bacteria fungi apicomplexa  amoebozoaare create along  background databases  host organisms  artificial sequence finally  newly create databases  index  use   alignment tool apply   workflow  paipline  precomputation         usable   paipline run afterwards  database update script  available    benchmarking  assess  performance  paipline   benchmarked along  select set   previously publish metagenomics tool  benchmarking include pathoscope  hong    kraken wood  salzberg   sigma ahn    apply  four publish biological sample kohl      artificial one  tool  select    wellknown   field  bioinformatics    inherently limit  term  detectable pathogens   approach forbes      evaluation  precision   calculate   define    tptp      true positives    false positives furthermore  recall  define    tptp     denote false negative  evaluate lastly  fscore   determine    harmonic mean  recall  precision        use  average  two   evaluation  datasets use   benchmarking  paipline    metagenomic profile tool  obtain  two ways   select   representative  biological sample  different background   different lab  clinical sample  artificial dataset  generate use pirs   default settings    long illumina read       design  test  pathogen detection capabilities   employ tool  typical virus sequence  different degrees  similarity  human genome sequence  result composition   artificial sample   see  table   biological sample  acquire  sequence  describe previously kohl    one   sample  obtain   marmoset  die   sendai virus infection   sample use   study  obtain  infect fertilize chicken egg  low dose  vaccinia virus  orthoreovirus  influenza virus   sendai virus respectively  represent  metagenome contain various viruses   study  chicken dna library chicken rna library marmoset dna library  marmoset rna library  use   benchmarking  analyse  run   onsite server   core   ghz    ram run ubuntu  lts  tool  run   respective default parameters except   number  thread   set    possible  databases  paipline  pathoscope  create   ncbi  database   tool  provide subdatabases contain  respective background organisms  database  sigma  provide  run  include database creation script",-0.18595936387346865,0.21628414975035246,0.13721938767405442,0.09559416848995933,-0.012562041863160164,-0.02782217377406236,-0.07058201807586281,-0.05359751960874514,-0.0016799567104858716,0.12283931717731406,0.016769420159547483,-0.027109723779112967,0.19967912403104532,-0.07658698426987326,0.14725279093951496,0.005122132763418174,0.10110276814680114,0.17010693096563892,-0.032686647963452935,0.06852916289191302,-0.10004064051304444,-0.2319985402098229,0.06962956925840551,0.02472592573382805,-0.04246933158205519,-0.1620593719422644,0.11230920947503384,-0.13905723722689506,-0.08477829609311263,-0.0019854830971886514,-0.012924749407440771,0.2537216571588096,-0.18951556981381484,-0.04523879718234279,0.2090155991469104,0.1033212834295037,0.00017072180621759142,-0.04254905327932563,-0.08141390071534768,-0.13282081748245195,-0.13871223801451865,-0.10515026940451801,-0.1117876952515406,-0.11003091397971393,-0.08550567497867484,0.00947217988351165,0.1203223834485682,-0.12626717462458886,-0.25450784946347826,-0.3423323254073905,0.21338873048161355,0.01974263296199984,0.06088901373806821,0.5342417698256064,-0.0028679534233835807,-1.0558441314662181,0.0424181857417056,-0.23337806327143945,0.9469113874324966,0.1825386241016108,-0.1621799296104528,0.3900915717708792,-0.0598815290771728,0.06893937536027976,0.6103908109684409,0.04306563740098026,0.010160213731619159,-0.02045982682993993,0.2488598244752042,-0.18964406933803327,-0.08271793943281093,-0.010178377365133032,0.09031812111937798,-0.14462629266104898,0.17553826751577303,-0.020181392306505248,-0.15359556447719286,-0.1776920533874397,-0.3899429138944766,-0.10962345774886524,0.18174695203779265,-0.01098279297016128,-0.3785846817442541,-0.03870999092117038,-0.8602755070401378,0.105165543662774,0.24670856675582525,-0.09536454925871304,-0.14208096934504116,-0.005766528020856554,-0.16835316485768662,0.06144318916932355,-0.01811686240770816,-0.06777819674543299,-0.035164666782284894,-0.025447754846171063,-0.13638630833525514,-0.3644964193742517,0.2876710740914352,0.10377209234663264,VirusIdentification,3
78,78,"gatk pathseq  customizable computational tool   discovery  identification  microbial sequence  libraries  eukaryotic hosts
 present  update version   computational pipeline pathseq   discovery  identification  microbial sequence  genomic  transcriptomic libraries  eukaryotic host  pipeline  available   genome analysis toolkit gatk   suite  configurable tool   report  microbial composition  dna  rna shortread sequence sample  identify unknown sequence  downstream assembly  novel organisms gatk pathseq enable sample analysis  minutes  low cost  addition  tool  build   gatk engine  apache spark framework provide robust rapid parallelization  read quality filter host subtraction  microbial alignment  workstation cluster  cloud environments
pathseq begin  removal  low quality low complexity hostderived  duplicate read supplementary fig  supplementary material  several methodological improvements   make   step  order  improve performance apache spark  use  process batch  sequence read asynchronously  memory thus maximize resource utilization  minimize slow harddisk operations  pipeline stag  accelerate filter  lowcomplexity sequence  repeatmasker step    replace   symmetric dust algorithm morgulis     rescue read   partially informative  new version also incorporate trim  lowquality base sequence adapter artifacts  lowcomplexity sequence  read   subject   fast kmer search use  bloom filter bloom   detect short sequence   host reference read contain  least one host kmer     remove  step typically subtract    host read prior  perform sequence alignment thus greatly reduce run time  blast altschul    aligner   replace   faster bwamem aligner     use  map  remain read   host reference supplementary table  pathseq  align  remain nonhost read   reference  microbial genomes viruses bacteria fungi etc supplementary table   classify  read taxonomically alignment efficiency   improve use bwamem classification specificity   increase  run  aligner  pairedend mode  require   read   pair map    organism  classification finally  report  generate contain microbial abundance estimate   taxonomic level  species genus family etc",-0.3124398003840311,0.2357228185275965,0.09826467524169746,0.06956057617948815,0.029844128159862576,-0.0865014403098912,-0.07299705996940081,0.03264659954742952,0.00583096311117212,0.16903823434770332,0.06510690044555249,-0.032491870712714664,0.14160055830002286,-0.1368170166402265,0.15498944578364238,0.03435025991109962,0.08770491362859806,0.18963563569369868,0.0455880844725691,0.09258137427157524,-0.1553136049967372,-0.28300063863650643,0.10737455664035003,0.07165001168931749,0.053343900808161406,-0.12304938832918805,0.02823359166963421,-0.029860334050361856,-0.11028515527194196,0.0032535207683615608,-0.09895579216042252,0.2341435887872869,-0.25254224613873344,-0.07421438059042856,0.23200818334960124,0.09549358924709712,0.024057964802804317,-0.06098217441502845,-0.04441420995545658,-0.07235050729871023,-0.08726484217314108,-0.1840692409610545,-0.183487321061054,-0.0675438879636314,0.0008732037562312503,0.06615390562748706,0.06512157106348737,-0.1037907183621869,-0.17214170591623495,-0.284312813092644,0.1713893799781517,-0.0055510636482557114,-0.006798747611923539,0.5544439587234096,0.010939930324358018,-1.0520252663303504,-0.04493483737336867,-0.23422355896186536,0.9657893151044844,0.20862311821318036,-0.17371263863240144,0.3706393038797559,0.012654106351405832,0.1317179218156856,0.6197627190909716,0.059204891923758565,0.0072620972313664186,-0.07303263126399763,0.336018613895232,-0.2374226632178761,-0.007823947782338964,-0.048533664579206916,0.11273670605680144,-0.13969875018705022,0.18428675826765936,0.02294148470867764,-0.1220295423867576,-0.10202478874531208,-0.34554560329468753,-0.0053485202518376435,0.16184932214673609,-0.005543029987055696,-0.4066546865936482,0.032538522235258965,-0.7699301421896301,0.21911884288896213,0.37527112149153696,-0.17884518274628192,-0.1958756063472141,0.027148602338451327,-0.10804706761811042,0.01648068420560748,-0.06394908310224612,-0.07490579500568635,-0.055611992122915885,-0.10773467246414813,-0.08228004981029892,-0.4352099870613804,0.32256770428890985,0.05195118604002125,VirusIdentification,3
79,79,"rapid identification  nonhuman sequence  highthroughput sequence datasets
rapid identification  nonhuman sequence rins   intersectionbased pathogen detection workflow  utilize  userprovided custom reference genome set  identification  nonhuman sequence  deep sequence datasets    rins correctly identify  know virus   dataset srr73726   compatible   computer capable  run  prerequisite alignment  assembly program rins accurately identify sequence read  intact  mutate nonhuman genomes   dataset  robustly generate contigs   nonhuman sequences
 appeal  search  pathogen sequence  highthroughput sequence data  grow  massively parallel sequence capabilities  develop shendure     sequence  identify pathogens    merkel cell polyoma virus   contribute factor  merkel cell carcinoma feng    algorithms   pathseq kostic     emerge  apply computational subtraction   task  pathogen detection  algorithms  computationally intensive  thus still require cloud compute scale resources   present rapid identification  nonhuman sequence rins  alternative  computational subtraction   efficiently identify  presence  pathogens   custom reference  highthroughput sequence datasets  speed  local computingbased nature  rins make  attractive  hypothesisdriven discovery  pathogens  large datasets  accessibility   workflow   rins open  door  extensive pathogen discovery   variety  contexts   cancer   difficult  treat diseases rins employ intersection analysis   user provide reference set  oppose  computational subtraction  latter   process  map first   reference organism' genome   attempt  assign  unmapped read   nonreference organism  map algorithms require intense ram  store  unmapped read computational subtraction  slow  require cloud scale resources   methods ultimately filter   reference organism  human  look  pathogenic sequence rins first map   query dataset thereby lower  computational requirements   use  nonhuman reference set include genomes  viruses bacteria   pathogens  set  use   template   rins initial search  reference genome set include   rins package contain viruses   know class  infect  variety  organisms  order  offer  broadest template  identify pathogens  workflow start  generate nonoverlapping  mers   read  maximize  sensitivity   alignment  blat kent    reference genomess provide use   match threshold fig  rins step   threshold  optimize  sensitivity  specificity performance   randomly mutate test set step   rins remove duplicate  may   generate  step  alignment  filter  longestassociated read   map  mer  complexity use  lempelzivwelch lzw welch  compression ratio   rins step   lzw compression method yozwiak    use  dictionarybased approach  quantitate  complexity   sequence  add   dictionary  new word  every unique string  character eliminate repeat regions  repeat  frequently find   humans  microbes make organismal origin difficult  pinpoint  complexity ratio  optimize  minimize loss  nonhuman read   filter  data  potentially confound repetitive sequence  filter read   map   human genome use bowtie langmead    rins step     intersection read  map   human genome  remove   read set remain read   mate pair   dataset  pair end  assemble  contigs    novo assembler trinity grabherr    rins step  use  local version  blast  classify contigs rins step   contigs  minimal homology  human sequence   extend  map  original read set back   contig  process  identify mate pair  assemble  contig  repeat    method  extension allow  read   part   contig   eliminate   filtration methods   reincorporated   contig  increase  sensitivity  specificity   result rins   output  tabdelimited text file detail  candidate contigs    generate present   number  support read   blast evalue parameters use   modifiable   user  desire rins use intersection mark  asterisk  subtraction  identify nonhuman read  workflow intersect  read   dataset   reference  nonhuman genomes  interest use blat  align nonoverlapping  mers   read read   homology  align   human genome  read   homology  remove   read set remain read  complexity filter   lzw compression ratio    mate pair  sufficiently complex read  identify  read set   assemble  pathogen sequence contigs sensitivity  rins  evaluate   randomly mutate test set  viral genomes  serve   stringent measure system   test set mutations occur randomly throughout  genome without  conserve regions   often find  nature   test set   show  use   mer read promote identification  mutate nonhuman genomes supplementary fig s1a specifically  mutation rat  map   custom reference   shorter read segment  significantly better  identify genomes    full length read supplementary fig s1b  indicate know pathogens  identify  confidence  genomes   homology   reference genomes   extract   data use rins  positive control  use  test rins accuracy  speed supplementary table  sequence data   cahpv prostate cancer cell line srr073726 prensner     analyze  rins  accurately retrieve  hpv serotype   transform virus     contig supplementary table    rins take    perform  analysis   dual core machine     ram    ghz processor accuracy  rins   test  rna sequence data  sézary syndrome sra046736 lee   manuscript  preparation   contig  homology  vector construct  hiv  generate supplementary table  use pcr amplification  sanger sequence data  show  existence   laboratory contaminant   cdna   relevant sample  confirm comparisons  rins   pathogen discovery algorithm pathseq show similar performance  better speed  lower cost  rins pathseq sensitivity  specificity  derive  statistics present   author   work use  analogous test set  randomly mutate viral genomes  sensitivity  pathseq     mutation rate    drop     mutation rate   kostic    supplementary data  supplementary data rins   similar sensitivity   base upon test set read recovery   mutation rate    rins sensitivity drop     mutation rate  though      minimal sensitivity   supplementary fig  specificity   test set    pathseq rins also   false positives   test set   false positives  identify   cahpv data   sezary syndrome data give rins  specificity    additional rigor  pathseq would confidently allow identification  novel pathogens though  ability  rins  identify read     divergence   reference genome suggest  could also  feasible  rins   novel pathogen   least  homology  one     custom reference genomes pathseq require    cloud compute time  cost  process  million read whereas rins take      million read  srr073726 importantly rins scale  well   able  complete  six highthroughput datasets  sra046736   average read depth   million read       additional cost beyond access   computer  lower cost  faster speed  significant  accessibility  researchers interest  either hypothesis drive query  datasets  query  many different datasets   reasonable timeframe rins  optimize  matepaired highthroughput sequence data  read  least           run  sequence data   species nonpaired end sequence data  also  use though contig generation  extension   less robust   read length  number  read increase  computational time require  complete rins  increase  blat  trinity process speed  decrease include   online package    viral genomes   class curated  genbank benson      international committee  taxonomy  viruses ictv retrieve   national center  biotechnology information ncbi also provide   script  run  process  options  user control   default parameters  user must provide  open source softwares reference ",-0.208712842366995,0.21319130609208053,0.11385512737489925,0.09735392048206833,-0.029395520704711457,-0.049501737976335364,-0.07852938147000248,-0.03250719833206669,0.03059252173826572,0.12420921263150245,-0.027586106498144226,0.0048220514914914395,0.1281289738835767,-0.13861813682319388,0.16630468635825135,-0.019120645569873796,0.04213527843446546,0.228015570251004,-0.022602735338720783,0.07151269402383321,-0.04445891192851843,-0.2311609631677148,0.06662237233447436,0.020965970450773516,-0.019493366497672797,-0.10068113300571133,0.07508346475179184,-0.1427457940273949,-0.06670635478124308,-0.017514863613754192,-0.04625362348725055,0.2929249177829804,-0.19385796443155615,-0.06743641213311809,0.2428390157358339,0.07343358180644037,-0.0044483304443901535,-0.02037286563412414,-0.09787321683278824,-0.0679159374836109,-0.11440107830785935,-0.13830661649299697,-0.14141344943415932,-0.09929365412211566,-0.08437682974768618,0.024699752149585787,0.1656290339235084,-0.1418238062846479,-0.2155954171968435,-0.34385470968971343,0.1804117911567954,0.013551293220489195,0.053804642961686716,0.5786990521837329,0.012196823472079116,-1.1128044801830377,0.020886847335693952,-0.2169142323436788,0.9282713929205414,0.1785335342788615,-0.1233932232336634,0.375540835279995,-0.003279331534377625,0.07454512566656021,0.5841187700619779,0.09407671000176172,0.025038046642090785,-0.006991682207917435,0.2426592392075321,-0.193737479321674,-0.015173902534046518,-0.03971366324804152,0.08135994762437226,-0.1477130919601532,0.19348393625498225,-0.035611689026907166,-0.14256626432838373,-0.15311956638174826,-0.3992744090832146,-0.07070838724975688,0.2344841476028128,-0.0192291957390055,-0.4025707472506367,-0.017836585389609746,-0.9032546933598552,0.11316000792268205,0.2943943031191315,-0.10974505452703932,-0.1887485758415636,-0.01798532260960053,-0.1311731296118708,0.06553636063250765,-0.07660883157869339,-0.05372432178668772,-0.03926406426415519,-0.05624810946209422,-0.09374238462524186,-0.3934125524821755,0.3210111495493297,0.07259033379312793,VirusIdentification,3
80,80," cloudcompatible bioinformatics pipeline  ultrarapid pathogen identification  nextgeneration sequence  clinical samples
unbiased nextgeneration sequence ngs approach enable comprehensive pathogen detection   clinical microbiology laboratory   numerous applications  public health surveillance outbreak investigation   diagnosis  infectious diseases however practical deployment   technology  hinder   bioinformatics challenge  analyze result accurately    clinically relevant timeframe   describe surpi ""sequencebased ultrarapid pathogen identification""  computational pipeline  pathogen identification  complex metagenomic ngs data generate  clinical sample  demonstrate use   pipeline   analysis   clinical sample comprise    billion sequence deployable   cloudbased  standalone servers surpi leverage two stateoftheart aligners  accelerate analyse snap  rapsearch    accurate  exist bioinformatics tool  order  magnitude faster  performance  fast mode surpi detect viruses  bacteria  scan data set   million read   min      comprehensive mode  know microorganisms  identify follow   novo assembly  protein homology search  divergent viruses   min    surpi  also directly contribute  realtime microbial diagnosis  acutely ill patients underscore  potential key role   development  unbiased ngsbased clinical assay  infectious diseases  demand rapid turnaround times
clinical ngs data set detail regard clinical sample approve research protocols  sample collection  ngs library construction  provide   supplemental methods hardware minimum hardware requirements  run surpi include  multicore server run ubuntu  prefer   least    ram surpi   software dependencies require    disk space reference data require    disk space  surpi runtime     size   input fastq file may  need  additional temporary storage  specific hardware use   surpi test  benchmarking  provide   supplemental methods custom modifications   snap nucleotide aligner snap   new hashbased nucleotide aligner develop  map  ngs data  reference genomes across  wide range  read lengths   zaharia    available   snap run  faster  exist tool  maintain comparable  higher accuracy fig   aligner partially derive  speed  load  entire index reference database  ram since snap  originally design   human genome hg19 map  generate  custom build tailor  alignment  different reference databases contain thousands  similar andor overlap sequence   bacterial refseq pruitt     modify snap build  include options  improve alignment speed  efficiency  stop   first hit “” parameter  retain hit  map  multiple locations “” parameter    snap alignments use  surpi incorporate  two additional parameters reference databases  description    reference databases use  surpi  generate  give   supplemental methods roc curve analysis   silicogenerated query data set roc curve analysis zweig  campbell   use  evaluate  ability   various nucleotide aligners snap bwa bt2  blastn  correctly classify  give set   silico ngs read  map   human  bacterial   viral nucleotide  fig 2ae similarly roc curve analysis  use  compare rapsearch  blastx performance  map translate nucleotide read   viral protein  fig  detail   construction    silico query nucleotide data set  range  parameters use   roc curve analysis supplemental fig   provide   supplemental methods  gold standard criterion use   correctly classify read   give database     silico read  originate   database  generate  roc curve  true positive rate tpr  tptp    sensitivity  plot   false positive rate fpr  fpfp    specificity youdens index    score harmonic mean  apply  independent criteria  select  optimal cutoff point  diagnostic accuracy   roc curve akobeng    instance  cutoff point identify  youdens index    score  identical speed benchmarking  aligners detail  speed benchmarking   various alignment algorithms  provide   supplemental methods roc curve analysis  clinical query data set  roc curve analysis use ngs data set correspond   stool sample   child  mexico  diarrhea      nasal swab sample   patient  acute respiratory illness greninger      serum sample   patient  california  hantavirus pulmonary syndrome nunez    harbor rsv influenza ah1n1pdm2009  sin nombre virus respectively supplemental methods seven million unique preprocessed read  select   data set  human  bacterial read  remove prior  roc curve analysis  snap alignment   human   bacterial  respectively use  edit distance    gold standard criterion   correct viral classification  blastn alignment   target viral genome obtain  sanger sequence   evalue cutoff   surpi pipeline  surpi pipeline  comprise   series  shell python  perl script  linux  incorporate several opensource tool include  snap  rapsearch aligners surpi   set  fix external software  database dependencies supplemental fig   userdefined custom parameters supplemental methods  pipeline accept  raw fastq file  input  recognize  presence  multiple barcodes use  index pairedend read  handle  concatenate  file correspond   individual read   mate pair   single file  streamline analysis  preprocessing step consist   trim lowquality  adapter sequence use cutadapt martin  retain read  trim length    remove lowcomplexity sequence use  dust algorithm  prinseq schmieder  edwards    normalize read lengths  snap alignment  crop read  length      fast mode snap alignments  first perform   human  follow  separate alignments   human backgroundsubtracted read  bacterial  viral nucleotide dbs whereas  comprehensive mode  initial snap alignment   human database  follow  sequential alignments   index  subdatabases follow snap alignment match read  taxonomically classify  lookup  match giaccession number   ncbi taxonomy database  taxonomic classification   append   sam sequence alignmentmap file output  snap  comprehensive mode  surpi pipeline continue    novo assembly step  use  empiric approach   optimize  ngs metagenomics data supplemental material duplicate   level  crop read  first remove use genometools  sequniq gremme     correspond fulllength read   demultiplexed  barcode  analyze use  message pass interface mpibased parallel version   aby  novo assembler aby  release simpson    increase robustness    brujin graphbased assembly  obtain  run aby multiple time   kmer size   use   entire data set  individually partition set   read  input output contig sequence  length greater   equal   read length   combine   single file   analyze use  olc  novo assembler minimo minimo  release treangen     default parameters contigs  retain      length   original read finally  fulllength unmatched read along   final assemble contigs  subject   protein homology search   viral protein  use rapsearch   evalue cutoff    userdefined option also allow   protein homology search   ncbi   retrieve taxonomic information  sequence  fasta format  append   rapsearch output  generate coverage map read classify  surpi  viral  bacterial  automatically map    likely reference genome present  follow   discrete viral  bacterial genus assign ngs read  directly map   nucleotide reference sequence correspond   genus   species strain  substrain level use blastn   evalue cutoff     genus  coverage map   reference sequence   highest percent coverage  generate  priority give  reference sequence   follow order  complete genomes  complete sequence   partial sequencesindividual genes detection  clinically relevant pathogens use surpi  output   surpi pipeline include  list   classify read annotate   taxonomic assignment  summary table  read count stratify  family genus species  accession number supplemental methods   series  coverage map  detect microbial genomes supplemental fig  coverage map show  figure   edit use microsoft excel   pie chart derive   summary table supplemental table s6s21 sequence correspond  bacteriophages  group together   single category speed benchmarking  surpi endtoend process time   surpi pipeline fig  supplemental table   measure use  elapse wallclock time  include  follow individually time step  preprocessing  computational subtraction   human   snap alignment   bacterial  fast mode  snap alignment   viral nucleotide  fast mode  snap alignment   complete ncbi   comprehensive mode   novo contig assembly comprehensive mode  rapsearch viral protein homology search use translate nucleotide query comprehensive mode   overhead time include file conversion sequence retrieval determination  read count  generation  summary table  coverage map process time trend line  regression  value  generate use microsoft excel",-0.1643495655433569,0.1581214354322047,0.08853018960474353,0.1053590378687276,0.00398070257745291,-0.05525720329033088,-0.056614114350492226,-0.0010426019311049267,-0.004433839832873721,0.1362067909891668,0.05438117330134111,-0.03954873113843956,0.13498628128663098,-0.09282025110025548,0.14652276411652565,0.05821335916536076,0.07312639814997582,0.1748137310320683,-0.0007233282178640366,0.041880046967662087,-0.09061245912318364,-0.23182617320434046,0.06466203767622478,0.05249513245751395,-0.017551170487299955,-0.12900219085087114,0.13497983779954284,-0.09875140788462504,-0.09444441448406954,-0.03649260442348589,-0.005718061611742565,0.2477313036707193,-0.18118757653717985,-0.028682529691998894,0.2159098229746604,0.0903274996894853,0.0390794928359652,-0.022422601499006545,-0.07382980379423029,-0.09816980746599208,-0.08144921912529847,-0.10202545648780774,-0.11352518536701894,-0.10821309174827644,-0.08394025178920282,0.04219380792279385,0.09457290110727436,-0.1800879841814994,-0.20396558484381164,-0.2791966659612464,0.17548615408203516,0.0368913321471528,0.042530007646296566,0.4820231930852721,0.04347866114081913,-0.946908988832055,0.05185471532768325,-0.1932075470796247,0.8842798704830439,0.16829833542156086,-0.13741588425828682,0.30947143895931445,-0.019423828065199288,0.06271362810138319,0.4827052763124046,0.07295211716996211,-0.030187299405469707,-0.0007007548811012193,0.2456875587735129,-0.1437818215386697,-0.09711698879542956,0.01072341624004031,0.08919544425174153,-0.1104736229943994,0.1982469184522664,-0.0031058613372672546,-0.1614245204740253,-0.10588027921725847,-0.3449780919564594,-0.1055550769689542,0.1896810283998677,-0.025543519396727023,-0.3407654100529065,-0.010586514154596157,-0.7933005105802103,0.13898440063232556,0.2928373565872837,-0.13223506933813425,-0.15670020977464064,0.0020925429655165467,-0.1482713744402128,0.1066308790406114,-0.059905383141931924,-0.06631764427587195,-0.02399802747709481,-0.032635236070736456,-0.05909217324107885,-0.3212201010798545,0.2988473255947036,0.027060054016642663,VirusIdentification,3
81,81,"metaviromics reveal unknown viral diversity   bite midge culicoides impunctatus
biting midges culicoides species  vectors  arboviruses   responsible   emergence  spread  schmallenberg virus sbv  europe     likely   involve   emergence   arboviruses  europe improve surveillance  better understand  risk require  better understand   circulate viral diversity   bite insects   study  expand  sequence space  rna viruses  identify  number  novel rna viruses  culicoides impunctatus bite midge use  metatranscriptomic approach  novel metaviromic pipeline call metavic  develop specifically  identify novel virus sequence signatures  high throughput sequence hts datasets   absence   know host genome metavic   protein centric pipeline  look  specific protein signatures   read  contigs generate  part   pipeline several novel viruses include  alphanodavirus   segment  novel relative   hubei sobemolike virus  two rhabdolike viruses   chuvirus  identify   scottish midge sample  newly identify viruses  find   phylogenetically distinct   previous know  find expand  current knowledge  viral diversity  arthropods  especially   understudy disease vectors
sample collection  sequence three haematophageous midge pool culicoides spp form   midges   collect  july   two sit locate within  loch lomond  trossachs national park scotland  two pool     collect   oak woodlands immediately surround  scottish centre  ecology  natural environment scene °” °”  third pool  collect   edge  cashel forest near livestock  disperse cottages °” °”  midges  morphologically identify  culicoides impunctatus   abundant culicoides species find   area  midge species  identify use  interactive identification key  culicoides ceratopogonidae females   western palearctic region   midges   crush  pestle  rna  isolate    midges use   trizol follow  standard rna extraction include isopropanol precipitation use glycogen  carrier  truseq illumina strand library preparation  carry   input    rna per sample follow  manufacturers protocol briefly rna  mildly fragment follow   reverse transcription step  doublestrand dna dsdna  synthesise  dsdna  atailed follow  adaptor ligation  amplification use  pcr cycle libraries  quantify pool  load   illumina miseq pairedend read  generate  read length      yield     pair read  midge pool     respectively  raw read  assemble contigs sequence  submit  european nucleotide archive  bioproject number prjeb33833  accession number lr701640lr701660  metagenomic analysis use metavic pipeline read   sample  collate  analyse use  metavic pipeline    design  identify viral sequence  metagenomic datasets   absence   know host genome  pipeline  documentation  available    however metavic   apply directly   virus metagenomics study  metavic pipeline  divide  two major components figure  firstly read  clean  nonviral content  remove secondly  curated read  assemble use  novo approach  read  preprocessed  remove  illumina sequence adapters use trim_galore  small  large subunits ribosomal rna rrna sequence  identify  remove use   silico ribosomal sequence identification tool ribopicker version     silva rrna database version    read  translate  search   refseq protein databases use  diamond  blastx approach  diamond output   turn parse  identify  remove sequence  match  know bacteria invertebrates mammal rodent phages plant vertebrates primates  synthetic construct sequence read pair  match  know viral  environmental sequence  read    match  know sequence   refseq database  use  evalue    extract  keep   analysis   end   clean pipeline sequence  confirm   properly pair use prinseqlitepl   clean sequence   submit   second component   metavic pipeline  perform   novo assembly   novo assembly step  carry  use two  bruijin graphbased assemblers spade version    idbaud version    multiple kmer value range      two assemblers   develop  reconstruct genomes  uneven coverage  depth   typically  case  viral metagenomic sample   assemble contigs   two tool   consolidate use garm version    assembly merge pipeline  use mummer3   find overlap  two assemblies  join   contig consolidation step  perform  generate supercontigs   assemblies  step  useful  construct longer stretch  sequence   also help  identify assemblerspecific misassemblies  unique regions   genomes   shorter contigs generate independently  separate assembly tool  contig reconciliation also help  improve assembly metric value   n50 read  align back   contigs  supercontigs use bowtie2   assembly statistics  generate use weesamv1  unmapped read pair  extract  retain  viral read  might   assemble  contigs  order  check  assembly quality quast  analysis  perform   contig assembly   supercontigs contigs longer   nucleotides   supercontigs generate  garm   combine  classify use diamond    refseq protein database kronatools   use  create  interactive html output  visualise  format result generate  diamond result obtain   metavic pipeline   investigate  identify viral signatures   contigs  contig match viruses   run   previous   miseq run  exclude   analysis table   protein domain identification  contig sequence  match viruses  translate use getorf    six frame keep open read frame orfs   minimum length    local interproscan  version  analysis  perform  search  protein domains present   orfs generate   contigs interproscan domain search  apply  identify  know domain signatures within  orfs  put  newly identify sequence   context  currently know viral genomes  orf sequence  contain viral signature domains  analyse use blastp   evalue    top  hit  extract  top hit  use  produce  set  sequence  phylogenetic analysis  metadata  extract   genbank file   sequence use  customise python script  collate detail  protein accession protein description genome accession refseq genome accession source host  country  origin   sequence multiple sequence alignments  perform use mafft   convert  nucleotide alignments use pal2nal   alignments  use  compute  best substitution model base   bayesian information criteria bic use jmodeltest   substitution model  subsequently use  reconstruct  maximum likelihood phylogeny use raxml   node support evaluate use  bootstrap replicate",-0.21289805817333132,0.1987082293423756,0.09085735743547876,0.058084051291059174,0.042956375295308415,-0.01458190039534261,-0.0922023119406424,0.05119374658770303,-0.0130608618915589,0.1066535435846777,0.008730524622036944,-0.02270418833275991,0.13838650894339208,-0.030088632993775045,0.12534294667617454,0.05733102541673904,0.1233172676672663,0.11660784652536772,-0.013618456372725112,0.08467969800551216,-0.050515019796885455,-0.15986877299759042,0.11537961428274413,0.01300780601170543,0.0032108206631519,-0.15684080723576346,0.10198812332826776,-0.06218348843251149,-0.045520197037704185,0.02290773518676809,-0.0648788369345394,0.1986979251480268,-0.1381565818786107,-0.0493958300402896,0.2553342318450337,0.051265504300086334,0.050184722872475135,-0.01414032817478806,-0.09325100267245497,-0.0927071743389265,-0.07575619698852881,-0.13206794667836316,-0.14139967566664488,-0.10165496881682327,-0.04722107142382362,0.04814161041285843,0.08405822734892755,-0.09627381428658914,-0.18083282372363926,-0.246960629206816,0.08425662609682019,0.045245147236114884,0.055797921475506836,0.46738822197287605,0.004382640358012218,-0.9043075877568358,-0.07849070092227746,-0.2308807466490581,0.821634846277287,0.1904191418679419,-0.10425746840638013,0.3735070483453644,0.01965056792893386,0.06348700640744276,0.533389989393098,0.0728180437376753,-0.019314990893071336,0.017430088795455437,0.2548432466694964,-0.20171693211720726,-0.028617493370880508,-0.02268548556981463,0.15583052650621682,-0.14765058111568746,0.11251522143115894,-0.06295316471391682,-0.13221450036560947,-0.11903052327356167,-0.3418969310082301,0.007329693234634477,0.15822900191949932,-0.011980447217870456,-0.3367817351691328,0.031651650530788084,-0.6335803163567462,0.0928076701887351,0.22799325050278146,-0.0694402031872615,-0.12645026305176366,0.0736844729877821,-0.10030864044727587,0.02792972845196204,-0.10393463464430383,-0.08570399405635053,-0.08082967689744644,-0.07584004216410171,-0.10109712951937568,-0.30489693043705124,0.3183464449267931,0.052585389454510405,VirusIdentification,3
82,82,"mepic metagenomic pathogen identification  clinical specimens
nextgeneration dna sequence technologies  lead   new method  identify  causative agents  infectious diseases  analysis comprise three step first dnarna  extract  extensively sequence   specimen  include  pathogen human tissue  commensal microorganisms second  sequence read  match   database  know sequence   organisms    individual read  derive  infer last  percentages   organisms' genomic sequence   specimen   metagenome  estimate   pathogen  identify  first  last step  become easy due   development  benchtop sequencers  metagenomic software  facilitate  middle step  require computational resources  skill  develop  cloudcomputing pipeline mepic ""metagenomic pathogen identification  clinical specimens""   pipeline unnecessary base  trim   read  human read  remove   remain read similar sequence  search   database  know nucleotide sequence  search  drastically speed   use  cloudcomputing system  webpage interface   use easily  clinicians  epidemiologists  believe   use   mepic pipeline  promote metagenomic pathogen identification  improve  understand  infectious diseases
nextgeneration dna sequence technologies  lead   new method  identify  causative agent  infectious diseases  hospitalize patients   outbreaks   directly sequence millions  dnarna molecules   specimen  match  sequence     database pathogens   infer  analysis comprise three step first  nucleotide sequence   specimen  include  pathogen human tissue  commensal microorganisms  read use  nextgeneration sequencer second  bioinformatic process   read  organisms    individual read  derive  infer last  percentages   organisms' genomic sequence   specimen  estimate   pathogen  identify although  first  last step  become easy due   development  benchtop sequencers  metagenomic software  middle step still require computational resources  bioinformatic skill  facilitate  middle step  develop  cloudcomputing pipeline   easy  fast  prototype   pipeline   use   metagenomic search  pathogens  various clinical case   report metagenomic analyse  clinical specimens  successfully identify francisella tularensis   abscess   pathogen  streptococcus spp   lymph node   possible causative candidate  kawasaki disease   heterogeneity    pandemic influenza  virus ah1n1   lung    outbreak   adults  myalgia  majority  infect  human parechovirus type   typically cause disease  young children   recent food poison outbreaks   due  raw fish consumption  flounder parasite kudoa septempunctata  discover   causative agent    case  pathogen identification  primarily due  metagenomic analyse use nextgeneration sequencers   workflow  metagenomic pathogen identification use mepic  first step  perform   user dna andor rna  extract   specimen   sputum feces  abscess  blood   library  dnacdna  prepare  sequence  library  sequence use  benchtop nextgeneration sequencer   sequence read  upload   mepic pipeline via  secure internet connection  pipeline accept input file  fastq format    standard  nextgeneration sequence analysis  use illumina miseq sequencers san diego calif usa   second step  upload read  process   mepic pipeline fig  unnecessary adapter sequence  low quality base  trim   read use  fastqmcf program   eautils package  humanderived read  detect  comparisons   human genome use  bwa  program   fig  screenshot   mepic pipeline  box   user specify  nextgeneration sequencer read  upload  box  detail  set  trim adaptor sequence  low quality base   read  box  criteria  set   exclusion  human read  box   user choose  program  search  database  know sequence mepic number  human read  count   read   remove   downstream analysis     remain read similar sequence  search   database   know nucleotide sequence ncbi  use  megablast   bwa program  base   information   database sequence  match   read   infer  gene  virulence gene  organism  escherichia coli   read  derive   run time   pipeline  primarily allot  search  database  know sequence  require time   drastically shorten  split  job  run  parallel use  cloudcomputing system  local server respectively  take    one core   ghz   min   core  perform megablast search    nucleotide database   year   one million read  length    run time vary accord   sample source  condition  blood sample à90z  read  derive  human  remove   preprocessing step  accordingly  time  database search   remain read  reduce human derive read  less  sputum sample   normal feces ¿  accordingly demand  database search time   final step   workflow  user download  database search result   local  include  read annotate   organism  gene function  summarize  taxonomic  functional informa  fig  color online analytic result   case  saffold virus  detect   pharyngeal specimen dna  rna  extract   specimen  sequence  taxonomic view  megan software saffold virus  detect   rnaseq read   case    read  derive   virus   sufficient  detect  virus   patient  read map   reference genome  saffold virus  horizontal axis represent  position   viral genome   vertical axis represent  abundance  map read  read cover  whole   genome color bar indicate  nucleotides   patient' strain   reference strain differ  plot  make use genome jack software  businessfieldbioinformaticssolutionproductsgenomejack  tion   read  metagenome browser   use   megan    one useful free software program fig   existence  quantity  pathogenic organisms  virulence genes  inferable   number  detect read   proportional   number   correspond nucleotide sequence   original specimen  develop  simple metagenomic analysis pipeline  remove ambiguous  hostderived short read  rapidly identify diseasecausing pathogens  hospitalize patients   outbreaks  mepic pipeline   webpage interface    use easily  clinicians  epidemiologists     bioinformatic skill  locally require equipment include  benchtop nextgeneration dna sequencer   desktop   view  result  adoption  cloud compute  metagenomic pathogen identification  propose   pathseq software   require bioinformatic skill  cloud compute  mepic pipeline  contrast manage  computational aspects   background  sequence similarity search   database    computationally demand step  metagenomic study  one solution   thin  database use   approach  metaphlan system   speedily identify bacterial  archaeal organisms however  opt  maintain  entire database  rely  augment  computational power  hasten  analysis  clinical applications require finer taxonomic distinction  example  distinction  eneterohemorrhagic  commensal  coli  critical within  broad possible applications  metagenomics  pipeline  tailor  clinical use metagenomic pathogen identification use nextgeneration sequencers surpass conventional detection systems  sensitivity  approach  directly sequence nucleotides   specimen  particularly powerful  unculturable  slowgrowth pathogens  mycobacterium whereas conventional pcrbased detection  miss new variants   know pathogen due  mismatch  predesigned primer set   novo dnarna sequence approach overcome  limitation metagenomic analysis  also identify  causal agent    know   pathogenic    quantitative sensitivity  metagenomic approach   show   comparable  rtpcr   mepic virus detection   major drawback  metagenomic pathogen identification   cost  nextgeneration sequencers  reagents although  sequencers remain expensive  versatile clinical  research utility  restrict  infectious diseases  push  widespread implementation  research institute  hospitals  rapidly decrease reagent cost  reach approximately   one million read  would  appropriate  pathogen identification  current methodology  metagenomic pathogen identification  base  sequence match  know pathogenic speciesstrains  enable detection  unknown pathogens  abundant dataset  ``disease cases''  ``normal flora controls''  necessary   number  read   organism   proportional   amount   dna   specimen  much larger  case  control infection   organism   suspect  development   pathogen discovery  require  accumulation  metagenomic data  diseasecausing  normal flora   invention  analytic tool  believe   use   mepic pipeline  promote metagenomic pathogen identification  improve  understand  infectious diseases  source code  instal   local server  available   author upon request  website   pipeline    sequence read   pharyngeal specimen  include  saffold virus  available   ddbj sequence read archive  accession number dra000973",-0.18320812567883246,0.1870988423115005,0.0948005288807438,0.07471010634729353,-0.014093588910047682,-0.03922877680574507,-0.04370732954591334,-0.04345168439193423,0.053906856879900884,0.09004962411283766,-0.034859052868201755,-0.043518222330861216,0.14781346786555966,-0.08349231036271912,0.1740038491843734,0.01401280283579791,0.07378795522499086,0.1275799907631993,-0.009613623981120045,0.04315542396775877,-0.07453218523089443,-0.19671875457201027,0.07773441890290436,0.023842685680742413,-0.0024616067340293038,-0.06673767229054088,0.1592934633657793,-0.14644330093534125,-0.07989327738603326,0.004954242380475849,-0.003256812197483109,0.2994740722816249,-0.15840219846331122,-0.07139024900565206,0.2141765961085604,0.08398767667117332,0.0210004184448805,0.0003606713279833247,-0.09124437339960424,-0.07871006488466474,-0.09659344611295986,-0.11493049726907255,-0.15228826185907215,-0.13855946854752033,-0.031695233137445315,0.0325245039606968,0.10779145160251327,-0.14631933630754734,-0.2274125242844233,-0.2651698850019714,0.21226280340768147,0.044222924164527146,0.02865023042152013,0.4914394649178856,-0.0011576064112327562,-1.0105502923352805,-0.005367903253779962,-0.21231793557867956,0.9202779141316848,0.18463679660817434,-0.12520391864556865,0.3576834160471313,0.02778725277830045,0.05632931482992156,0.5688714321317653,0.10457520676517072,0.017137497970767208,-0.04725200680545072,0.30544424291551525,-0.19274267694345326,-0.03438674821091599,-0.03624482387833548,0.09105000323653747,-0.090514001914506,0.1856924553901011,-0.02670802858287621,-0.15573979327634266,-0.14604691909950746,-0.39520593814393995,-0.0333018550700217,0.2499833358043676,-0.016937393405546917,-0.3802166336071021,0.027257912506963924,-0.8508748749935386,0.1090856017723966,0.2940560625742924,-0.0685450371646976,-0.2229199231414196,-0.014388862227161344,-0.11647798285663995,0.03618644913960732,-0.036411705483120525,-0.05150457830537702,-0.032411176916167066,-0.04755969020698103,-0.07973082891189384,-0.3986546889209421,0.30612321504738177,0.021952001260510418,VirusIdentification,3
83,83,"viralpro  tool  identify viral capsid  tail sequence 
  sequence data continue  outpace annotation information  also  problem   exacerbate  organisms  underrepresented   annotation databases    case  nonhumanpathogenic viruses  occur frequently  metagenomic project thus    need  tool capable  detect  classify viral sequence  describe viralpro  new effective tool  identify capsid  tail protein sequence    cornerstones toward viral sequence annotation  viral genome classification
data  build  dataset  respectively    nonredundant capsid  nucleocapsid sequence  noncapsid sequence  randomly choose   phage nonstructural sequence seguritan       ncbi protein database  query  nonphage nonstructural proteins see supplementary materials  merge  set  sequence   train set  ivireons mcp1 denote  ivcapsid  obtain  positive   negative sequence  refer   result dataset  cprotrain use   process  build  dataset   positives tail sequence   merge   train set  ivireons tail  ann  obtain  positive   negative tail sequence  refer   result dataset  tprotrain  denote  ivtest  test set  phage protein sequence describe  seguritan     use fold cross validation   train set  assess performance   train set one   fold  use   validation set  produce  plot  figure  feature  identify capsid  tail protein sequence  use  average amino acid composition  feature  well  average secondary structure composition three feature  predict  sspro magnan  baldi   addition  build  profile hide markov model hmms  locally probe  sequence  hmms  build use hmmer eddy   multiple sequence alignment  contact fragment  capsid proteins—  essentially pair  fragment   close   tertiary structure see supplementary materials  whose structure   show   well conserve even  distantly relate homologs galiez  coste   evalues   different hmms  linearly combine use coefficients   obtain use  rankboost algorithm freund    finally  hmms yield three feature  boost linear combination  hmm evalues  evalue   best hmm hit   number  hmm hit evalue    better finally  train  svm chang  lin     feature",-0.19627577095173748,0.2405078357058533,0.026492422184088087,0.07122165422211557,0.012658948310019586,-0.03534765172149711,-0.007102867608714924,-0.016967220925694745,-0.023406212274360176,0.14262323476992947,0.04261055817880712,-0.034764362497555226,0.1835876967689185,-0.021849315490061104,0.16436203131952246,0.09880588019748013,0.03902801499395762,0.1894354335041779,0.04325817904635114,0.07865272414864309,-0.0401038781195979,-0.19741376394080934,0.05071619854952465,0.0631951106666906,-0.04876077267491327,-0.1509467766701475,0.13986942274402206,-0.08256256390963025,-0.05568551394350877,0.01178280588695717,-0.02790660125784726,0.29811378349643824,-0.17960067500630644,-0.04470143187791109,0.20281949606915506,0.00888749885047792,0.08281434544568393,0.02520621122929874,-0.07065223529817688,-0.05790847333586827,-0.08878641098818972,-0.14257772266054167,-0.14339904365092265,-0.13306311014477135,-0.06878466208484149,0.08660858820486289,0.0713773402341709,-0.10940035912302017,-0.21703652350307007,-0.25516661867458723,0.11781933911819785,-0.004186833058577657,0.09101287201797002,0.5441862758336551,0.05176282509608232,-0.9390637326357424,-0.032003445907077134,-0.08123476714858373,0.8044006960941541,0.2030645535411876,-0.21589665650858875,0.3804212535204891,0.02161352741907057,0.12713702067681246,0.5199838715055395,0.1218114773215079,0.08475034227657237,0.032492469509090995,0.2422430854468081,-0.14398337385871904,-0.06286715450966199,-0.07255741266921263,0.10736936362360247,-0.10054232803917172,0.18059553906021505,-0.06388873471519066,-0.1029267938348196,-0.16249026786754744,-0.3170341818480933,-0.092982198654724,0.11391519628083895,0.03623117629951179,-0.4140840998460889,-0.06842854288219155,-0.7525875181859771,0.0715312773147723,0.21280701957555528,-0.11216727340431422,-0.21266040328152527,-0.03971588409243264,-0.19083730430160992,0.10597087609919176,-0.11041964067696224,-0.0987364554515221,-0.02241703379749252,-0.0644715646931889,-0.12349212657185207,-0.3926433980068029,0.2331394716056576,0.0700583229296147,VirusIdentification,3
84,84,"readscan  fast  scalable pathogen discovery program  accurate genome relative abundance estimation
readscan   highly scalable parallel program  identify nonhost sequence  potential pathogen origin  estimate  genome relative abundance  highthroughput sequence datasets readscan accurately classify human  viral sequence    million read simulate dataset   min use  small beowulf compute cluster   nodes
 software first index  host  pathogen database sequence   choose kmer value  base   principle discuss  baezayates  perleberg byp  kmer value  allow   detect  mutate sequence  maximum error  mutation rate     string  length   search phase  describe  figure  divide  input sequence  manageable chunk   chunk  process  parallel  chunk  map   host  pathogen reference simultaneously use smalt aligner  result   map procedure  filter  per cent identity cutoff  read   classify  several bin namely host pathogen ambiguous  unmapped  classification  base   alignment score report  smalt  direct acyclic graph represent  set  task   dependencies  abstract    result  pass   gnu make   desktop computer  makeflow       multicore cluster  efficiently execute  task  parallel  speed   overall throughput  makeflow abstractions   key  make  program highly portable  execute directly without  modification  load share facility lsf sun grid engine  various  load levelers  memory  resource requirements   alignment task  compute use  formula provide   smalt aligner   value  pass   appropriate job scheduler smaltlike  short read aligners   inherent maximum limitation martin      size   database    index  limitation  overcome  split   database  manageable part    part   exceed  random access memory limitation   particular compute node  help  workflow  accommodate multiple human reference  improve  accuracy  human read removal  also multiple pathogen reference group  taxon like bacteria virus protozoa  fungi choose  appropriate chunk size  control  speed   entire search phase   sequence similarity  reference sequence   pathogen database   read may map  multiple reference   nonunique map hence  result statistics file  cluster  ncbi taxonomy tree   gra  particular species  report   sum   gra   reference sequence   species",-0.2164891359438612,0.22499004532768266,0.17523803349997086,0.11541501392507185,0.04848558295369995,-0.038096043797188686,-0.0849503755717623,-0.025608624220860132,0.001792682358592918,0.14271310937262818,0.051330808305382634,-0.006371521165750561,0.18758527126076596,-0.1755500522499047,0.1891843986694849,0.02399735062664893,0.08957417317486199,0.2076775927972366,0.01985576216115574,0.0659755869915402,-0.095407226159957,-0.25371432057843113,0.09730475449627687,0.041643416391294034,0.06434576989506073,-0.15942140898914658,0.10722116847649556,-0.05053263538601724,-0.09962849013920112,-0.056009490725542,0.005185254283291711,0.2837472875545989,-0.14148893204136667,-0.08667463441716708,0.2494105701758103,0.06065839308906685,0.056164347724089486,0.04517864004116167,-0.0265993886135799,-0.10962603358546567,-0.07847392186820136,-0.12952924861085854,-0.08806307968254921,-0.07936347429032056,-0.09842853320779713,0.07861750035557304,0.1286580184532795,-0.13602270554276236,-0.2605860069994709,-0.2357878907721236,0.2150393871296811,0.01969153635516043,0.07437896009783303,0.6194224551330659,0.006185982568157752,-1.0499163118683184,0.04522151060783389,-0.18607255172471265,1.0525852932795798,0.1899436556400773,-0.13084050205576536,0.2733701597224519,-0.04633856697182637,0.07689145538494234,0.6048672648466891,0.08044119795787,0.015299753397068178,-0.05380670056514315,0.32256097490740515,-0.14986374443436612,-0.1354175786327687,-0.012027967543955045,0.1168183707873554,-0.09927726872741584,0.21423401195550634,-0.04376352561336138,-0.13567987599460388,-0.1575302360182501,-0.382715091871267,-0.010041125715360977,0.21231266903222687,0.0026018019628033717,-0.4439465684011917,-0.03940019894724338,-0.8749430457828566,0.12757284261566715,0.32030763248489663,-0.19659625818696275,-0.08141884829224595,0.036782544378101266,-0.1838493248916083,0.13490806315332354,-0.07317093210217122,-0.09183716326052407,-0.017263944014716384,-0.057294790135611874,-0.04384482869698497,-0.4063269811105618,0.3327265539979139,-0.02064970934192057,VirusIdentification,3
85,85,"magicblast  accurate rnaseq aligner  long  short reads
nextgeneration sequence technologies  produce tens  millions  read often pairedend  transcripts  genomes   program  align rna   genome  accurately discover introns especially  long read  introduce magicblast  new aligner base  ideas   magic pipeline magicblast use innovative techniques  include  optimization   splice alignment score  selective mask  seed selection  evaluate  performance  magicblast  accurately map short  long sequence   ability  discover introns  real rnaseq data set  pacbio roche  illumina run   six benchmarks  compare    popular aligners additionally  look  alignments  human idealize refseq mrna sequence perfectly match  genome  show  magicblast   best  intron discovery   wide range  condition   best  map read longer   base   platform   versatile  robust  high level  mismatch  extreme base composition  reasonably fast   align read   blast database   fasta file   accept  fastq file  input  automatically retrieve  accession   sra repository   ncbi
algorithm overview  magicblast algorithm   structure similar     blast program   read  data  batch  build  “lookup table”    index  word locations   read base  default   scan  database sequence usually  reference genome  match   lookup table  attempt  extend select initial match   length specify   user   default  result match form  seed  computation  local gap alignments collinear local alignments  combine  splice alignments  order   use   seed  original  base match must  completely contain within one exon  cannot span two exons consequently exons shorter   seed length cannot  capture    rare less    refseq exons     recognize  align  parallel   know transcriptome  pair read  best alignments  select base   alignment quality   pair  example  one read   pair map equally well  two genomic sit   second read map best   single site  read pair   report  map uniquely   position dictate   second read   way  specificity   map truly reflect  number  base sequence   whole fragment   base specificity     pairedend read   present  detail description    step figure  present  overview   step repeat filter  genomes contain intersperse repeat  gene families  complicate correct placement  read   genome  avoid seed  ambiguous position magicblast scan  reference sequence  count base word  word  appear   reference database    userspecified number  time  default    index   lookup table    never form  seed alignment  make  procedure  efficient  word present   read  count  cutoff number   select experimentally   best tradeoff  sensitivity  runtime  rnaseq additionally magicblast specifically mask  base word  contain  least      effectively avoid seed  polya tail  approach  similar  soft mask   blast program local gap alignment magicblast compute  local alignment  extend exact word match base  default   read   reference sequence  use  simplify greedy alignment extension procedure previously use  magic  start   seed  alignment  extend   first mismatch next  attempt  characterize  mismatch   substitution insertion  deletion  one  three base  recursively test  quality   alignment   follow  base     apply successively  table  candidate alignment operations table    associate requirement  meet  requirement    specific number  base must match within  give number  base follow  apply operation  first operation whose requirement  meet  apply   alignment   algorithm proceed   next position   sequence  single substitution  report   requirement  satisfy  list  alignment operations   associate condition use  magicblast figure  show  example alignment extension first   two match   algorithm move   right  two position   sequence   mismatch   encounter  algorithm try successively  alignment operation  check  requirements  first operation  substitution  require nine match base follow  mismatch fail  second operation  insertion  require ten consecutive match succeed   apply   alignment   last step    match  use  xdrop algorithm   stop  extension   position  record  run alignment score  algorithm stop   end   sequence    current score  smaller   best score find  far      penalize gap alignment operation threebase gap  table   algorithm  backtrack   position   best score   read align   reference     mismatch  method  faster   memory efficient   dynamic programmingbased extension procedure use   blast program moreover  approach facilitate collection  traceback information  little additional cost  method   tune   give sequence technology   expect rate  mismatch  gap simply  adapt table   example  roche   pacbio  insertions  deletions   frequent  substitutions one could switch   modify table  compute  alignment score use  follow system    match pair  base     base substitution zero  gap open either  read  reference sequence      base  gap extension insertion  deletion  user  modify  mismatch  gap penalties  quality coefficients present   fastq file   impact   alignment score    export   sam output  half  time  match base   place  either side   gap   gap  slide  equal score  avoid difficulties  snp detection magicblast  convention shift  slide base upstream   gap   orientation   target splice alignments splice alignments  find  combine collinear local alignments   read   reference sequence magicblast construct  chain  local alignments  maximize  combine alignment score   update  alignment extents    splice alignment  continuous   read   intron donor  acceptor sit  whenever possible consistent   canonical splice signal  two local alignments  continuous   read possibly   overlap   first search   canonical splice site gtag  ctac   alignments meet   site   find   alignment   score   least   search successively   minor splice sit   complement gcag  ctgc atac  gtat     noncanonical site  first site find  accept  alignment score threshold    choose  minor  noncanonical splice sit  rare  pair  dinucleotides  frequently find   genome   result  read shorter   base magicblast conservatively  call gtag introns magicblast also attempt  produce splice alignments   read  several local alignments separate  one  ten unaligned base first  look   splice signal within four base   end   leave alignment   find  fix  begin   candidate intron second  search   correspond end  intron signal  offset  ensure  continuous alignment   read allow   one additional insertion  deletion   fail  procedure  repeat   end   intron fix   search   signal indicate  start   intron   candidate splice signal  find  alignments  trim  extend   splice signal  benefit   method    correctly identify introns even   presence   substitution insertion  deletion close   intron boundaries   procedure   sensitive   produce many spurious alignments magicblast  allow  gtag signal   situation  splice alignment  score    score system   local alignment    reward  penalty  splice sit   preference  give  continuous versus splice alignments  map rna   genome magicblast   support  use   annotation file   twopass method  desire one  map    genome    annotate transcriptome  use  universal score system  magicblast  select  best alignment   genomic  transcriptomic   fragment   paper  map    genome output magicblast return result   sequence alignmentmap sambam format     tabdelimited format similar   tabular format   blast program   less standard  richer  easier  mine",-0.18394176245263744,0.18540713205911,0.145655192404793,0.06917886219993566,0.0023462808536462445,-0.006940591890994182,-0.11328369211978682,0.0885805761339428,-0.023283625571579883,0.11384671902383812,0.038733639366204886,0.012392887810295048,0.1411613452424086,-0.10741726365252974,0.1410073552402277,-0.004219699395007967,0.04319025430001547,0.16904826492924369,-0.062473385517348226,0.09200725173301476,0.00011879818487855395,-0.18609032824538094,0.03963921029193146,-0.0070530994960382514,0.0181469643359044,-0.19160927046790932,0.0008712270847558548,-0.1604804033579837,-0.014223268175407368,-0.05392798069895397,0.00036213126351904813,0.3020214378630044,-0.17583408926456826,-0.08334793920191574,0.2334182024221393,0.0844735461346596,-0.008339771236487836,-0.0625937234221872,-0.13277593005670718,-0.095366747724219,-0.08892037261266153,-0.1478624764361911,-0.02503701162507297,-0.09665697360410097,-0.12168142443780587,-0.021823463154416863,0.12617694780798344,-0.16031046472911542,-0.18859476918783466,-0.4083277369555821,0.15088562787408294,0.03800692822373168,0.054520428370166456,0.6237130167279915,0.032432223242091024,-1.254793044005055,0.02139594841496639,-0.18778052081755475,1.034258832606221,0.21904931328575986,-0.19120187585383752,0.33813840821884306,-0.04578561869590087,0.06136065747415735,0.5929527278919466,0.013826783096990355,0.02418071670607397,0.06375103324876827,0.14202800316187286,-0.23431118691238526,-0.07766721668704864,-0.0666215078942644,0.0975835103771325,-0.16049432605968275,0.20751555150372394,-0.040107574010330514,-0.16035367011292173,-0.13341248889301655,-0.3515027851994351,-0.07953543535874202,0.2404090763155887,-0.04334300531820413,-0.37817637638274426,-0.052540714479507686,-0.9340972449052579,0.04116809150374528,0.21719396606144706,-0.10288210076515143,-0.10836064341886098,-0.04339637734353476,-0.18188298045365348,0.11621739087110786,-0.13059174197925522,-0.08897999626802927,-0.17424680306623708,-0.09101828365623524,-0.0674484229660878,-0.2735340611846424,0.2961275562348809,0.09863791980142753,Mapping,4
86,86,"mgmapper reference base map  taxonomy annotation  metagenomics sequence reads
 increase amount  species  gene identification study rely   use  next generation sequence analysis  either single isolate  metagenomics sample several methods  available  perform taxonomic annotations   previous metagenomics benchmark study  show   vast number  false positive species annotations   problem unless thresholds  postprocessing  apply  differentiate  correct  false annotations mgmapper   package  process raw next generation sequence data  perform reference base sequence assignment follow   postprocessing analysis  produce reliable taxonomy annotation  species  strain level resolution  invitro bacterial mock community sample comprise   genuses  species   strain  previously use  benchmark metagenomics classification methods  apply  postprocessing filter  obtain  correct taxonomy assignments  species  genus level  sensitivity  precision    obtain  strain level annotations  comparison  mgmapper  kraken  species level show mgmapper assign taxonomy  species level use    sequence read compare    kraken   methods identify  species   false positives extensive read count statistics  provide  plain text  excel sheet   reject  accept taxonomy annotations
 mgmapper package consist   pipeline  script  process fastq file  either single  pairedend read  perform sequence map  taxonomy annotation  user define reference sequence databases mgmapper utilize  number  publicly available program cutadapt   trim  adaptor removal bwamem   samtools   produce  process  reference base sequence alignments  one  many reference sequence databases  short summary   procedure  describe   pairedend sequence data follow   detail outline   section “fastq map procedure” initially  filter step check  properly pair read follow  trim  adaptor removal  biological relevant read  obtain  always map   phix bacteria phage  continue   subset  read    align   phix genome commonly use   control  illumina sequence run next sequence read  map  user define reference sequence   properly pair read  accept provide   read pass  lower alignment score threshold  relative alignment length  map read   reference sequence databases  human bacteria fungi etc  read may align  reference sequence  different databases  depend   map mode bestmode  fullmode explain    best hit  identify  use  assign taxonomy taxonomy annotations ftpftpncbinihgovpubtaxonomytaxdumptargz  add via lookup   premade kyoto cabinet database  contain key value pair  form   reference sequence name  key  full taxonomy path  strain  superfamily clades  value finally  postprocessing step section “postprocessing” identify confident assignments  strain species genus   user define taxonomy clade   superfamily mgmapper  map sequence read   nucleotide sequence database   genomic  gene sequence databases    database  map   perform  either bestmode  fullmode  bestmode read  assign   one reference sequence     best hit   observe  map   databases specify  bestmode map best hit  identify base   highest alignment score  fullmode read  assign   reference sequence even   better hit  see  map  another database typically  fullmode  use  search  sequence   gene database  may   subset  another database   full genome database analyze  sample   genomic bacterial composition  antimicrobial resistance genes   situation  mgmapper   run   bacterial database specify  bestmode map     time specify  antimicrobial resistance gene database  fullmode map  reason    resistance genes   may   subset   bacterial genomic sequence   want  assign  sequence read   bacteria genome  also  resistance gene   databases  specify  bestmode map bacteria antimicrobial genes   read    assign  one   databases   identical alignment score  observe  priority    database   specify first fastq read map procedure  mgmapper pipeline analysis    four main step  preprocessing  raw read  remove potential positive control read  map  read  one   reference sequence databases  filtration  alignment hit iii identification  best hit   postprocessing  taxonomy annotations  preparation  excel  text file  insertsize distribution size normalize abundances read  nucleotide count statistics depth  coverage  schematic flowchart   pairedend map process  show preprocessing  raw read  optional trim  filter  raw read  perform  use   cutadapt  program users  skip  step  read  already trim default set   read  initially trim  search  adaptor sequence equivalent   cutadapt option—  addition  read  discard unless  minimum   nucleotides remain  trim trim read  next pair   singleton read  remove  use  pairedend version  mgmapper   follow another clean process  read  potential phix control  adapterligated libraries  remove via bwamem   samtools    may originate   control  illumina sequence run   outcome   clean set  read   believe  originate   biological sample  interest  number  read   set nophix dataset  set    use  calculation  r_abundance  read count abundance measure  map  read  reference sequence databases  alignment base filter fastq read  first extract   nophix set  map  one  several reference databases via bwa mem— procs— database mark shorter split  secondary hit    remove  pip  samtools view      pairedend mode  samtools view     singleend mode  keep properly pair read  map read respectively next read  insufficient alignment qualities  remove base  userdefined minimum alignment score mas  minimum fraction  nucleotides  assign    state   cigar format    indicate  match  mismatch  userdefined threshold  fraction  matchesmismatches fmm   relation   full length   read  pairedend map  read  remove   one     fulfill  filter criteria default settings   mgmapper program  mas    fmm     step properly pair read may align    one reference sequence locate  different reference sequence databases  bestmode  read pair    assign  one reference sequence section “identification   best hit” iii identification   best hit  pairedend sequence   forward   reverse fastq read  align   reference sequence    associate alignment score  sum  alignment score sas  use   measure  identify  best hit   readpair typically  input query read  map  multiple reference sequence databases  bacteria virus fungi human  others thus  readpair may map  multiple reference sequence  different databases   bestmode  taxonomy annotation   assign  one best hit namely  one   highest sas score  singleend read map  several databases  best hit   one   highest alignment score  case   read  readpair achieve identical alignment score  reference sequence  different databases  priority  give   order    databases  specify   user  thus  read  readpair  still  associate  one single reference sequence  output  postprocessing  result  fastq read  map  multiple userdefined reference sequence databases  tabseparated file  produce   database include reference sequence hit  read count statistics provide  strain level  strain  name accord   header name originate   fasta file   use  make  database  tabseparated file  compose   columns  read count statistics  annotations   latter  taxid  taxonomy clade name   clades  strain species genus family order class order  superfamily  tabseparated file contain  unprocessed result  obtain   bwamem  map  samtools mpileup   false positive annotations  likely   present  subset  confident map result  obtain   specify clade level strain species …superfamily via  postprocessing procedure describe   section  postprocessing  combination  four criteria iiv  use  identify  positive taxonomy annotation identifiers highlight  italics  also describe  table   minimum readcount    mismatch ratio   define  mismatchesnucloetides iii s_abundance  size normalize abundance    unique read count fraction   define  readcount uniqreadcount  strain level  four criteria  impose  species level  criteria   use   precycle  identify  lowest s_abundance   select species  new s_abundance threshold  use   second round  criteria   omit  genus level  higher  criteria    iii  use taxid value  use  identify strain belong    species  species belong    genus etc  identifiers  show  table   sum  clade level higher  strain   s_abundance value   species   sum   strain s_abundance value   likewise  r_abundance size seq_count nucleotides cover position coverage depth readcount readcount uniq  mismatch",-0.19024677839300175,0.21742381611934528,0.16474720918900496,0.07207973863242625,-0.019506450096224474,7.113494126459371e-05,-0.10222436005878296,0.04561210698803171,-0.04134672466983685,0.11294805644014495,0.03714262192544481,-0.02643189359791891,0.1467257090898837,-0.03490144086529192,0.11907621800880387,0.0011637045297214538,0.08847203224689476,0.12841894983082172,-0.016535491054082873,0.05958385230827246,-0.04142731851338248,-0.2134723402726187,0.03799179817575148,0.021386325696641662,-0.01993538376184241,-0.197667008249466,0.08977826782095975,-0.16858641612647332,-0.03868848705997819,-0.048803189764266335,0.02104304456018878,0.2582203213745439,-0.1598240029341794,-0.060681189269222086,0.21049157751983924,0.12255246364825632,0.04210667589493642,-0.01748391962849161,-0.11300646778024714,-0.10747721775051183,-0.1104210474942483,-0.1471594776840873,-0.03492829964384901,-0.11380124684147362,-0.09349956308936024,-0.018536171186278382,0.05934930953765261,-0.13877589209175933,-0.22409855597584216,-0.3627201097442487,0.1948407911180035,0.05274009317278458,0.061484144731558575,0.5657499112227052,-0.00906490878788536,-1.1044846770525678,0.021666891386396527,-0.2415621949969504,0.9507572559641178,0.2298998819540195,-0.16734021986280626,0.3321426361556851,-0.04975584395915336,0.007289355187171585,0.6157959335704833,0.02371662951182421,0.0111246969731104,0.0522900654769112,0.17141138515339568,-0.20291455121676075,-0.06669741883618578,-0.02747211119865376,0.11060298505564196,-0.12084461408230282,0.17835649979967194,0.028511290986410445,-0.18622807452668194,-0.13912470999571205,-0.3605792302879999,-0.09654196451692584,0.17638304447406994,-0.04882702279424218,-0.3782642741750412,-0.08700407917738982,-0.8095083798734537,0.03814117563990849,0.22136531729398629,-0.16272152560826902,-0.08057734166470676,-0.00021619335242992272,-0.20356022582500025,0.058884538358481626,-0.10641399302036443,-0.0746515860342041,-0.12186539152369473,-0.06776290350010526,-0.1085452792429996,-0.3373929776075157,0.3008859915968817,0.07357334479132444,Mapping,4
87,87,"tandem repeat analysis  dna sequence base  improve burrowswheeler transform
 enormous amount  short read generate   new dna sequence technologies call   development  fast  accurate read alignment program  first generation  hash tablebased methods   develop include maq   accurate feature rich  fast enough  align short read   single individual however maq   support gap alignment  singleend read  make  unsuitable  alignment  longer read  indels may occur frequently  speed  maq  also  concern   alignment  scale    resequencing  hundreds  individuals  implement burrowswheeler alignment tool bwa  new read alignment package   base  backward search  burrowswheeler transform bwt  efficiently align short sequence read   large reference sequence    human genome allow mismatch  gap bwa support  base space read   illumina sequence machine  color space read   solid machine evaluations   simulate  real data suggest  bwa   faster  maq  achieve similar accuracy  addition bwa output alignment   new standard sam sequence alignmentmap format variant call   downstream analyse   alignment   achieve   open source samtools software package
 bwt   reversible blocksorting transform  operate   sequence   data symbols  produce  permute data sequence    symbols   single integer {}    let  denote  ndimensional bwt function   denote  inverse  bwt  since  sequence length isevident   source argument  functional transcript istypically drop give     notations bwtx  bwtn denote  character andinteger portion   bwt respectively  forward bwtproceeds  form   cyclic shift   original datastring  sort  cyclic shift lexicographically thebwt output  two part  bwt   sequence “googol”  original data sequencein bold appear  row    order figurestep   final column   table contain  sequence“looogg” hence bwtgoogol  looogg  constructingsuffix array  bwt string    googol string  iscirculated  generate seven string    lexicographicallysorted  sort  position   firstsymbols form  suffix array         theconcatenation analogy   bwt process   consider table constructionfor         step     place column   front  columns  step     odder  result length  string lexicographically step   place  order list   first  column   table   consider string    substring    position   occurrence      occur   interval   suffix array      suffix    prefix  sort together   experiment  achieve  first objective   increase  search speed  accuracy  tandem repeat  discover   bwt require  linear complexity make  algorithm   space  time complexitythroughout  work space  time complexity appear   single result since  algorithms allow easy tradeoffs   two  contrast   original bwa algorithm  extension code  universal however  result code appear    expensive  space  time complexity  particular allow   grow    tandem repeat sizex  onlognlogn  value similar  size   sequence length  hence increase search accuracy apply prefix trie algorithm   new larger tandem repeat result  worst case oxmn  on2lognlogn space  time complexity therefore  result  significantly reduce complexicty    hand  also manage  realize  second objective use  lz77 algorithms optimize bwt  replace  repeat occurrences  genome data string  reference   single copy   data string exist earlier   uncompress data stream  pair  number call  lengthdistance pair encode  match  spot match  encoder keep track   amount    recent data    last      32kb  data keep   stricture call  slide window  lz77 algorithm  encoder keep  data  look  match   decoder keep data  interpret  match  encoder refer   experiment  larger  slide window  longer back  encoder may search  create reference  discover     acceptable  also useful  bwa  allow lengthdistance pair  specify  length  actually exceed  distance hence bwa  able  align longer tandem repeat encode   search pointer  continue find match pair past  end   search window therefore  nucleotide character   first match  offset   forward   end   search window must  match input    thepreviously see nucleotide character  comprise  single run unit  length   must equal   prefix trie test whether  query  quarry sequence   exact substring   wild sequence  equivalent  find  node  represent        time  match  symbol     edge start   root  allow mismatch  exhaustively traverse  trie  match    possible path consequently significant improvement  time complexity onlogn   overall search performance   improvedbwa hence quick search  tandem repeat sequence   genome",-0.191599713914518,0.2332639975919281,0.09192658421021847,0.11267694210746905,0.0022328948083717532,-0.045715871561991965,-0.09408358123186483,0.057173007900977665,-0.01936174909791884,0.0930741530484394,0.02385438126795044,-0.04618015358455769,0.14329317758829102,-0.07716618947027176,0.11550787750181643,0.007853917423572793,0.031042145907318824,0.19232250030334988,-0.03184642479125712,0.06688001826389793,0.05258289372746682,-0.17946074987727068,0.017543292519435084,0.005522917830259414,0.05423874325808012,-0.13930216470317966,0.040145317679334026,-0.13133717166980402,-0.03487349403361362,-0.07754759775314203,-0.006761008107049919,0.2627796136830757,-0.15176714968637914,-0.10258895047071917,0.20974703182474588,0.09180596167366398,0.020322578488786176,-0.0031153257378546922,-0.057412701594404175,-0.11747648511467365,-0.05757076319443169,-0.16126044687887378,-0.042523205536338995,-0.09766735791777753,-0.11482165555679713,0.0015356339952976106,0.14231602315998612,-0.136805107045409,-0.1496990445566307,-0.3776590675611137,0.13383641262456925,0.020753601620231783,0.0845171947895889,0.6512899281759117,0.06363645974606452,-1.2826602063078836,0.004719923030525271,-0.14581677968876525,1.0169092243241549,0.21778511569396328,-0.1699953258335095,0.31019109318574034,-0.1004518283227446,0.06930093795872873,0.5917590436811961,0.03690492846952701,0.06862283458640622,0.02955025859803238,0.16961896228816398,-0.1728351000911553,-0.05183658981784263,-0.014530731901735684,0.05904945627962415,-0.16246728353340786,0.23462615872267634,-0.02892525760438042,-0.10776066081047787,-0.1201050599094644,-0.3349078798908866,-0.05566252024712141,0.24238535747581166,-0.048814040474983784,-0.3725583366639807,-0.07588637337667516,-0.8516070992883289,0.061769379581705475,0.21992353728273886,-0.16689438707937762,-0.07341814347140875,-0.06711751500502892,-0.20618204087824435,0.09743390141945407,-0.1377047309950875,-0.07166615388721127,-0.14785019777136274,-0.13301773018021187,-0.09775546218923016,-0.30619042185355433,0.3365242244357973,0.08998696298206325,Mapping,4
88,88,"soap2  improve ultrafast tool  short read alignment
soap2   significantly improve version   short oligonucleotide alignment program   reduce computer memory usage  increase alignment speed   unprecedented rate  use  burrow wheeler transformation bwt compression index  substitute  seed strategy  index  reference sequence   main memory  test    whole human genome  find   new algorithm reduce memory usage       improve alignment speed   time soap2  compatible   single  pairedend read additionally  tool  support multiple text  compress file format  consensus builder  also  develop  consensus assembly  snp detection  alignment  short read   reference genome
nextgeneration dna sequence technologies include illumina solexa  absolid   dominant tool  genomic data collection various applications   develop use  technologies  promote biological research   detect genetic variation  whole genome  target region resequencing refine gene annotation  whole transcriptome sequence profile mrna  mirna expression  study dna methylation one   common key data analysis step   applications   align huge amount  short read onto  reference genome new efficient program   develop  meet  challenge   alignment among  soap short oligonucleotide alignment program       use widely   type  analyse due   fast speed  richness  feature   improvement  sequence throughput   launch  big research project much faster shortread alignment methods  require  handle  data analysis   largescale sequence production  example   genomes project  aim  create   detail  medically useful human genetic variation map  generate     sequence use nextgeneration sequence technologies  even  fastest program currently available one would need  cpu months  align  short read onto  human reference genome additionally new methods   need  support longer read   exist methods  primarily design   short read  typical lengths shorter     improvements  sequence chemistry  data process algorithms  illumina genome analyzer   generate     highquality read  longer read  expect   near future    develop  improve version  soap call soap2  new program use  burrow wheeler transformation bwt compress index instead   seed algorithm   use   previous version  index  reference sequence   main memory use  bwt substantially improve alignment speed additionally  significantly reduce memory usage big eukaryotic genomes always consist   large number  repetitive sequence     human genome suffix tree  suffix array  consider   appropriate methods  index dna sequence    one alignment  need   repetitive sequence  multiple identical copy   genome  complexity  space  time   index construction  limit  algorithm usage   small genomes   recent development  compress index  reduce  space complexity   bytes   bits among    bwt burrow  wheeler   reversible data compression algorithm   find     efficient  space complexity  bwt   bytes     memory  ram  require  index  whole human genome  algorithm   use  efficient wholegenome comparison  index  smithwaterman local alignment   human genome lam    use    alignment method  determine  exact match  construct  hash table  accelerate search   location   read   bwt reference index  example   use  13mer   hash   reference index would  partition   block    search interactions  sufficient  identify  exact location inside  block  inexact  mismatch  indel alignment  apply  splitread strategy  allow one mismatch  read  split  two fragment  mismatch  exist    one   two fragment    time likewise  split  read  three fragment  search  hit  allow two mismatch  enumeration algorithm  use  identify mutation sit   read  pairedend alignment mode  first independently align  two read belong   pair  search   pair  hit   correct orientation relationship  proper distance similar  soap  preferentially select  best hit   read  read pair    lowest number  mismatch  small gap  general practice  user  also choose  option  report  hit  satisfy  select preset similarity rate   analyse  guarantee alignment accuracy  recommend allow   two mismatch  one continuous gap   highquality part   read   lowquality regions   read   end   contain  higher rate  sequence errors  provide  option  allow  mismatch within  define  end region since sequence read length  get longer  longer  soap2 program   compatible  read lengths      evaluate  performance   software   dataset contain one million read pair generate   human asian individual wang    although soap2  design  improve illumina  sequence  read length     choose    read length   evaluation   compatible   tool soap lir    maq lih      recently develop bwtbased alignment tool bowtie langmead    soap2 take    build  bwt index   human reference genome    time slower  build  seed index   implement  soap thus  prebuild  index   hard disk   load   ram directly  start  new alignment job   genome  memory usage  reduce     soap     soap2 soap2     time faster  soap  maq  similar amount  read align table  soap2  bowtie  comparable speed  align singleend read  bowtie cannot always find  best alignment hit  cannot align pairedend read langmead       make aware   alignment sensitivity  determine  sequence quality   parameter set   alignment tool   percent  read align would vary  different datasets soap2 support multiple input  output file format  reference sequence   load  either  text   gzipped fasta format   query read    either fasta  fastq format  output format include  soap tabdelimited text table  gzipped text table  sequence alignmentmap sam format   binary equivalent bam   recommend    genomes consortium   con format  fit   assembly viewer  soap2  specifically design  ultrafast alignment  short read onto  reference sequence  largescale resequencing project   develop  companion assembler  consensus assembly   sequence individual base   alignment   read   reference sequence  assembler   include   soap software package   also freely available   website     detect snps  compare  assemble sequence   reference genome  assembler use bay theorem  infer  genotype   base pair   align read  sequence quality score  estimate snp rate   sequence individual   reference genome  use  prior probability  raw sequence qualities  recalibrated accord   alignment  read generate  potential duplicate clone  remove  finally  genotype  call   posterior probabilities   phredlike score transform   probability  indicate  accuracy",-0.21162463075334684,0.23352918330097236,0.12969111982373902,0.13705971734045802,0.0229029321880606,-0.11164663190424633,-0.08134374603458765,0.04553788256079043,-0.006757126660033598,0.16687867839789114,0.005471306211725509,-0.050158690902244014,0.1570692831235359,-0.13189529321991902,0.17546096266349934,-0.0041604590816633775,0.06337859438164002,0.20512989737496465,-0.01426165564528977,0.10206188812311263,-0.04549852096722961,-0.2346590256132564,0.05600081553609021,0.01660017493985972,0.015723725774925264,-0.1809347732765252,0.07738479711036435,-0.1461522463948524,-0.06808934640739506,-0.01189164016961441,-0.03083813202562137,0.3135034538487562,-0.17974982326876604,-0.06396362459350187,0.2676193406628635,0.06881772266946026,0.02894247040260415,0.017313684173728115,-0.08020128426224253,-0.15015140527120718,-0.07350848716975382,-0.19384067836551366,-0.0803577601120381,-0.07558254672689257,-0.15935427724929016,-0.000843820029917031,0.11076277271597146,-0.1659832507885577,-0.1996663494124722,-0.36983202062093373,0.13842137077051125,0.019394098036188502,0.07932077612633169,0.6322924031870766,0.03897282148324648,-1.2368464187487411,-0.023116984275711627,-0.19239126838510856,1.0853192576938595,0.196786697341608,-0.15027366600094408,0.3292181260948264,-0.03877561871096555,0.0884161041608859,0.6018812400986467,0.06825343306185573,0.020456376664424684,0.023764552090019063,0.25656772894642743,-0.15709798680213913,-0.03293283592129896,0.02519569181610888,0.11757917493735676,-0.1475925966886814,0.1994432604498109,-0.0203861925552999,-0.14025217028582038,-0.13509068416371034,-0.3893511141282059,-0.05368753657202726,0.2518003657588467,-0.01798033242845266,-0.40405697676374197,-0.05793158050579161,-0.9415783264268436,0.11264112927391205,0.2679500201448014,-0.17212794627525674,-0.13118260364738124,-0.03730332882256684,-0.1635489325923056,0.12179975337440957,-0.12700423924729234,-0.07327853510614042,-0.10728751479235007,-0.09919556136746854,-0.09105524126690877,-0.3588832916784308,0.3856273856741445,0.059631213978903724,Mapping,4
89,89,"map short dna sequence read  call variants use map quality scores
new sequence technologies promise  new era   use  dna sequence however    technologies produce  short read typically    tens  base pair   use  read effectively require new algorithms  software  particular    major issue  efficiently align short read   reference genome  handle ambiguity  lack  accuracy   alignment   introduce  concept  map quality  measure   confidence   read actually come   position   align    map algorithm  describe  software maq   build assemblies  map shotgun short read   reference genome use quality score  derive genotype call   consensus sequence   diploid genome    human sample maq make full use  matepair information  estimate  error probability   read alignment error probabilities  also derive   final genotype call use  bayesian statistical model  incorporate  map qualities error probabilities   raw sequence quality score sample   two haplotypes   empirical model  correlate errors   site  read map  genotype call  evaluate  simulate data  real data maq  accurate efficient versatile  userfriendly
single end read map  map read efficiently maq first index read sequence  scan  reference genome sequence  identify hit   extend  score   elandlike  cox unpubl hash technique maq  default guarantee  find alignments    two mismatch   first     read maq map  read   position  minimize  sum  quality value  mismatch base    multiple equally best position  one    choose  random   article   call  potential read alignment position  hit  algorithm maq use  find  best hit  quite similar   one use  eland  build multiple hash table  index  read  scan  reference sequence   hash table  find  hit  default six hash table  use ensure   sequence  two mismatch  fewer   hit  six hash table correspond  six noncontiguous seed templates buhler      give  read  example  six templates          nucleotides     index        default maq index  first     read   typically   accurate part   read  alignment maq load  read  memory   apply  first template  follow   read maq take  nucleotides    position   template hash    bite integer  put  integer together   read identifier   list    read  process maq order  list base   bite integers   read    hash integer  group together  memory  integer   correspond region   record   hash table   integer   key  call  process index    time  maq index  read   first template  also index  read   second template   complementary   first one take two templates   time help  matepair map    explain   section    read index   two templates  reference   scan base  base   forward  reverse strand   subsequence   reference   hash   two templates use  index    look    two hash table respectively   hit  find   read maq  calculate  sum  qualities  mismatch base    whole length   read extend     seed without gap  current implementation   read length limit    maq  hash  coordinate   hit   read identifier  another bite integer   score  hit  ⋅     score    consider   pseudorandom number  differentiate hit  identical     multiple hit      hit   smallest    identify   best effectively select randomly   candidates   read maq  hold  memory  position  score   two best score hit   number     mismatch hit   seed region   scan   reference  complete  next two templates  apply   reference   scan      templates  leave use six templates guarantee  find seed hit     two mismatch   also find   hit  three mismatch  addition maq  use  templates  guarantee find  seed hit  three mismatch   cost  speed   configuration   seed hit  four mismatch  also find though  experience    hit   useful  practice single end map qualities maq assign  individual alignment  map quality  map quality    phredscaled probability ewing  green    read alignment may  wrong  example    imply       probability   read  incorrectly map   section   consider  simplistic case   read  know  come   reference   ungapped exhaustive alignment  perform  practical model  alignment  heuristic algorithms   present   supplemental material suppose    reference sequence    read sequence    assumption  sequence errors  independent  different sit   read  probability pzxu   come   position  equal  product   error probabilities   mismatch base   align position  example  read  map  position   two mismatch one  phred base quality        pzxu        calculate  posterior probability psuxz  assume  uniform prior distribution pux  apply  bayesian formula give     sum  quality value  mismatch   best hit    correspond sum   second best hit    number  hit    number  mismatch   second best hit ′   minimum number  mismatch    seed    average base quality    seed   log10  p1k   probability   perfect hit   kmismatch hit coexist give   sequence    estimate  alignment detail deduction   equation  give   supplemental material   also worth note   minimize  sum  quality value  mismatch base maq  effectively maximize  posterior probability psuxz    statistical interpretation  maq alignments  sequence real sample read may also  different   reference sequence due   existence  sequence variants  different sample  strain  variants behave   similar manner  sequence errors  map purpose  therefore   alignment stage   set  minimum base error probability   rate  differences   reference   read however  strategy   approximation    differences   reference  read  best position might consistently give wrong alignments even     sequence errors   invalidate  calculation  map qualities  would  possible   iterative scheme  update  reference   estimate   new sample sequence   first map   remap   update reference pairedend read alignment maq jointly align  two read   read pair  fully utilize  matepair information   alignment   pairedend alignment mode maq   default build six hash table   end  table  total  one round  index maq index  first end  two templates   second end also  two templates four hash table two   end   put  memory   time   scan   reference   hit   read  find   forward strand   reference sequence maq append  position   queue  always keep  last two hit   read   forward strand   hit   read  find   reverse strand maq check  queue   mate  test whether  mate   hit   forward strand within  maximum allow distance ahead   current read    one maq  mark  two end   pair   way maq jointly map  read without independently store   potential hit   end   end maq   hold  memory two hash table correspond  two complementary templates       read  strategy guarantee   hit     one mismatch   always find   round   scan hold  hash table  memory would help  find pair contain  mismatch    would also increase memory footprint pairedend map qualities  derive  single end map qualities   two different case   pair   wrongly map   first case one   two end  wrongly align     correct  scenario may happen   repetitive sequence appear twice     short region   second instance  pair  wrong   end  wrong    time  maq     unique pair map    end hit consistently    right orientation within  proper distance  give  map quality   qs1qs2   read assume independent errors    multiple consistent hit pair  take  single end map qualities   final map qualities detect short indels maq first align read   ungapped alignment algorithm describe    find short indels  utilize matepair information give  pair  read  one end   map  confidence    end  unmapped  possible scenario    potential indel interrupt  alignment   unmapped read   unmapped read   apply  standard smithwaterman gap alignment smith  waterman    region determine   align read  coordinate   size   region  estimate   distribution    align read  take  mean separation  read pair plus  minus twice  standard deviation  smithwaterman    apply   small fraction  read  short regions efficiency    serious issue consensus genotype call  default maq assume  sample  diploid  calculate  posterior distribution  genotypes  call  genotype  maximize  posterior probability  consensus call maq first combine map quality  base quality   read  incorrectly map  sequence differences infer   read cannot  reliable therefore  base quality use  snp call cannot exceed  map quality   read maq reassign  quality   base   smaller value   read map quality   raw sequence base quality  first calculate  probability  data give  possible genotype  consensus call     sequence errors   two different nucleotides   legitimately see therefore   consider   two  frequent nucleotides   position  ignore others  errors assume   observe data   consist   nucleotides    nucleotides ′  ′∈{acgt}   ≠ ′   three possible genotypes  〈〉 〈′〉  〈′′〉   true genotype  〈〉    errors   base let  probability  observe  errors  αnnk  therefore 〈〉  αnnk similarly   〈′′〉  αnk   true genotype  〈′〉  probability   approximate   binomial distribution 〈′〉  nk2n    assume  prior  genotypes  〈〉  〈′′〉      〈′〉     calculate  posterior probability pgd  genotype  give  observation    estimate genotype    argmaxgpgd   quality   10log10  pĝd     probability  observe  heterozygote  usually use      discovery  new snps      infer genotypes  know snp sit  principle  sitespecific    use give know allele frequencies     ith smallest base error probability  ′   function    vary little     unknown parameter     control  dependency  errors  deduction   equation   calculation  ′   present   supplemental material take  form like equation   inspire  cap3 huang  madan     arbitrarily set    principle    estimate  real data  practice however  estimate  complicate   requirement  large data set  snps  know   inaccuracy  sequence qualities   dependencies  map qualities  also   approximation make  derive  equation  estimate    try different value  select  one   give  best final genotype call  find      reasonable value  illumina genetic analyzer data simulate diploid genomes  short read maq also generate  silico mutate diploid sequence  add random mutations   know reference sequence  human reference genome   contain heterozygotes    resequence  human sample  map read   reference genome   see  homozygous  heterozygous variants  comparison   reference   sample   reference come    population    potential polymorphic site  allele frequency    probability  observe  heterozygote       observe  homozygous variant             consequently   condition   site  different   reference  probability   heterozygote  always  regardless   allele frequency  assume  sample come    population   reference base   observation   simulate  diploid genome  follow  first use  reference genome   two preprocessed haplotypes   generate  set  polymorphic sit randomly select two thirds    heterozygotes  take  rest  homozygotes   heterozygous site  randomly select one haplotype  mutate  base  another one   homozygous site  mutate  haplotypes  substitutions  indels   simulate   way  simulation ignore linkage disequilibrium  variants although coalescentbased simulation hudson  give   accurate longrange picture  procedure describe   sufficient   evaluation   variant call method   single individual   know sequence pairedend read   simulate  insert size draw   normal distribution   base qualities draw   empirical distribution estimate  real sequence data sequence errors  introduce base   base quality  sufficiently large data   able  estimate  positionspecific distributions  base qualities   correlation  adjacent qualities  well  orderone markov chain  construct base   statistics  capture  fact  lowquality base tend  appear   ′end   read   appear successively along  read alignment  apply biosystems solid read solid read  present   color space  comprise four color   color represent four type  combinations  two adjacent nucleotides  solid sequence machine give  last primer nucleotide base   color read sequence  information make  possible  write   nucleotide read sequence base   mean  color however  single color error  completely change  nucleotide sequence follow  error map read   color space  preferable  map   nucleotide space  map read   color space  need  convert  reference sequence  color sequence   perform  alignment   color space   color alignment  nucleotide alignment  main difference    complement   color  identical    therefore   color space read come   reverse strand   reference  need   reverse without complementation  alignment program   adapt  perform   alignment  little effort another difference   pairedend read  solid sequence  two end   read pair  always come    strand instead  two different strand like illumina sequence maq  able  map solid matepair read   reference     trim   primer nucleotide base   follow color  currently maq cannot work  color sequence  nucleotide sequence    time trim  first color  equivalent  use read   shorter    greatly affect  alignment result",-0.19717894577511924,0.20956144637939345,0.13383253122163696,0.12661811504531914,-0.07182620747820577,0.015136427423402215,-0.0665714386930882,0.06711743476528591,-0.036574741129803086,0.10599705529480448,-0.02432077047286973,-0.0023406739013730484,0.17674290572678478,-0.0961361976442424,0.169729033365806,-0.05994078082279972,0.03540715355558073,0.2345924919210981,-0.02070671737876024,0.08207082869126094,0.05666217947913368,-0.2302532516260259,0.043456786544167035,-0.04164649691299534,-0.005618609535237718,-0.21516333896141127,0.0751302778705743,-0.1644465177642034,-0.050749535547922664,-0.0957577169069838,0.013496318065068302,0.2811453451863424,-0.1762741841665095,-0.09976206810575386,0.24055023153099275,0.07172186635118205,0.03701710400670298,0.048321501701847326,-0.0917044325002505,-0.13283994042883207,-0.04703172059358016,-0.12923381900509046,-0.05428288409318284,-0.12645635749690393,-0.17975907638594868,-0.029809044830892594,0.1468124523386737,-0.1682522699626082,-0.2740569980019273,-0.3924352762584044,0.17791737546791506,0.0039807838481297425,0.06688731529468456,0.6195773943185685,0.03652132948438786,-1.1874680644511406,0.08390941656393927,-0.1707744020573147,0.9479859246122396,0.2252909638570635,-0.14702806771057753,0.2801456443104599,-0.0852127177985555,0.08273796908015245,0.620791023096984,0.055846300696563086,0.0277757411359849,0.03131817905107158,0.1562202274429203,-0.17414456566688974,-0.10681888067869603,-0.046699094693280346,0.11189490173703426,-0.104225948156362,0.25758959123728753,-0.026172687107098292,-0.14006683756819308,-0.1967699528222197,-0.3618287800643102,-0.07422914581503681,0.21977628623697984,-0.03022498130110238,-0.4245866674771174,-0.07685581255198036,-0.8604440243636554,0.06843170061559675,0.23904262970942666,-0.14450958965541738,-0.12529675571498713,-0.056435793403391575,-0.2429844489416512,0.09158710580844334,-0.10344896815163716,-0.14530891437521753,-0.13589769151488826,-0.0717042070758221,-0.0844941923307901,-0.3110732590788163,0.2719552089991737,0.0833281193766365,Mapping,4
90,90,"use quality score  longer read improve accuracy  solexa read mapping
secondgeneration sequence   potential  revolutionize genomics  impact  areas  biomedical science new technologies  make resequencing widely available   applications  identify genome variations  interrogate  oligonucleotide content   large sample  chipsequencing  increase  speed sensitivity  availability  sequence technology bring demand  advance  computational technology  perform associate analysis task  solexaillumina  sequencer  produce tens  millions  read range  length  ~    single experiment accurately map  read back   reference genome   critical task  almost  applications two source  information   often ignore  map read   solexa technology   ' end  longer read  contain  much higher frequency  sequence errors   basecall quality score  investigate whether  source  information   use  improve accuracy  map read  develop  rmap tool   map read   wide range  lengths  allow basecall quality score  determine  position   read   important  map  apply rmap  analyze data resequenced  two human bac regions  vary read lengths  vary criteria  use  quality score  result indicate  significant gain  solexa read map performance   achieve  consider  information  ' end  longer read  appropriately use  basecall quality score  rmap tool   develop  enable researchers  effectively exploit  information  target resequencing projects
design   rmap algorithm   section  describe  algorithmic strategy use  rmap  treat  map problem  approximately match  set  pattern   text   set  pattern   read   text   genome  problem   well study  several general algorithmic strategies  emerge  solve  see    detail treatment  major motivation  develop  rmap algorithm   incorporate basecall quality score  weight mismatch  improve map accuracy  addition   high map accuracy rmap  design   restrictions   must  capable   map read  length exceed  base   applications discuss   introduction  allow  number  mismatch   control   restrict   small fix number   complete map task  reasonable time constraints  widely available compute hardware  algorithm implement  rmap use  filtration method describe    read  length   map     mismatch  read  partition     contiguous seed  seed   substring   read   length ⌊  ⌋       mismatch   map       seed   read  map must   least one seed   mismatch  algorithm first identify locations   genome   seed match exactly exact match    much  quickly  approximate match  evaluate  approximate match   read   genomic region  need      regions surround  exactlymatching seed  efficiently implement  filtration strategy rmap preprocesses  set  read build  hashtable   refer    seedtable index   seed  table entry   particular seed list  read contain  seed along   offset   seed within  read   set   read   length    mismatch  allow   search  seed table  size o4nk   map proceed  scan  genome   window  size equal   seed size  segment   genome  test   seed  hash  segment  determine  set  read  must  compare   entirety   larger genomic region surround  segment   genome currently  scan    common strategy  implement  filtration stage  approximate match  influence   size   genome   time complexity  rmap  therefore linear  importantly  space complexity  rmap  independent   size   genome  step  compare  full read  portion   genome   seed   find  implement  require time   logarithmic   length   read  comparison take advantage  bitwise operations   read  encode   binary format see additional file   supplementary method  series  logical operations produce  vector indicate  locations  mismatch   read   genomic segment  compare   weight   bitvector indicate mismatch compute use  wellknown technique describe   rmap  sufficiently fast  several million read   map   mammalian genome  one day   computer   single processor  portion   reference genome  maintain  rmap   size   seed table dominate  space requirements   requirements  sufficiently small rmap   run  widely available hardware  include  nod typically use  cluster computers  allow  process   easily  effectively parallelize  simply partition  set  read   test data set generate  randomly sample one million   segment simulate read   hg18 genome  randomly change    base   read  current implementation  rmap  able  map  read back   hg18 genome   minutes use roughly    memory",-0.2522470414904306,0.23518746334037344,0.12957331104681705,0.21865495100535234,0.022229291782851383,-0.08606914891895619,-0.10656536243486164,0.06818418099839405,-0.02530935545356068,0.15185153641333968,0.02280880443269031,-0.08366454341311884,0.14625713359301326,-0.1535082426699399,0.1074292670005782,-0.06268914386215757,0.06248829585370806,0.23536662946143602,-0.09463357304519056,0.05587630746338297,-0.02379591841771103,-0.2382999304390978,0.09996610931771367,-0.041796003642957665,-0.04106165834887447,-0.19140680432182686,0.10357158233904663,-0.18468334728352007,-0.07648811761806856,-0.052110004542234536,-0.0675442670878564,0.2752175700439051,-0.2252710625299883,-0.060217679299753135,0.21064646573498014,0.07476884864402511,0.03716888065922402,0.005360101626994198,-0.10255313538672294,-0.11085248555001967,-0.11534665047656745,-0.2089767099438605,-0.10530601855220192,-0.12765049264656708,-0.16720196264106882,0.0011882951227615945,0.14363364735468434,-0.15584812966956044,-0.21471724230008585,-0.3999428282806869,0.18731212572567849,0.026146585025879392,0.044526908974041685,0.7193369551780907,0.05703059462436666,-1.3721687024500329,0.0241923689694993,-0.24019643826956302,1.21710298049113,0.1877606940269128,-0.16405588908085467,0.3913212752417808,-0.06222677718837717,0.0709962201260222,0.6465589660553687,0.061466938501860774,0.038721188426761186,0.042133534880978166,0.2501523214570411,-0.11943028505501227,-0.0370598436133926,-0.021848661601860143,0.1071267883406322,-0.13479772567071074,0.21038694628034996,-0.0714014694077538,-0.16324510310625875,-0.10492608139055153,-0.4207420409502982,-0.04292252989698147,0.35394209537250443,-0.019986381589072098,-0.4481033315344522,-0.041046504985869814,-1.0571267145740637,0.10544851292134434,0.2944948697918067,-0.16471841910970395,-0.16014557032887006,-0.027110690711946092,-0.16544432563943487,0.1475835146231796,-0.1368194568392081,-0.13391429212403155,-0.1745565408594249,-0.041891905791999307,-0.08712362044110812,-0.33835688498391603,0.44012612259864586,0.12574244013333502,Mapping,4
91,91,"fast  snptolerant detection  complex variants  splice  short read 
nextgeneration sequence capture sequence differences  read relative   reference genome  transcriptome include splice events  complex variants involve multiple mismatch  long indels  present computational methods  fast detection  complex variants  splice  short read base   successively constrain search process  merge  filter position list   genomic index  methods  implement  gsnap genomic shortread nucleotide alignment program   align  single  pairedend read  short      arbitrarily long length   detect shortand longdistance splice include interchromosomal splice  individual read use probabilistic model   database  know splice sit  program also permit snptolerant alignment   reference space   possible combinations  major  minor alleles   align read  bisulfitetreated dna   study  methylation state  comparison test gsnap  speed comparable  exist program especially  read  ≥    fastest  detect complex variants  four   mismatch  insertions     deletions    although snp tolerance   increase alignment yield substantially  affect alignment result    transcriptional read typically  reveal alternate genomic mappings   read simulations  bisulfiteconverted dna show  decrease  identify genomic position uniquely      read      reads
 view alignment   search problem   space  genomic regions   reference sequence  combinations  regions  gap  allow although  reference sequence may consist  chromosomes contigs transcripts  artificial segment  simplify  discourse  refer     genome search involve  step  generate filter  verify candidate genomic regions   efficiency depend  design  generation  filter step  produce   candidates  possible several alignment program include maq     rmap smith    seqmap jiang  wong   razers weese    preprocess  read   generate  filter candidate genomic regions  scan  read index   genome  large genomes    efficient  preprocess  genome rather   read  create genomic index file  provide genomic position   give oligomer genomic index also permit part  read   align  arbitrary genomic regions need  longdistance splice detection index need       reference sequence   result index file usable   new dataset oligomers   lengths   index use  suffix array   compress bwt equivalent  use  bowtie bwa  soap2   represent  reference sequence compactly      humansized genome   billion  however    single oligomer length   need   algorithm  simple hash table ning     qgram index rasmussen    apply   genome  suffice fig   data structure consist   offset file  lookup table   possible qmers  pointers   position file  occurrence table contain  list  genomic position   qmer   search algorithm  work  efficiently   important   position list   position file  presorted  allow intersections   compute quickly among multiple qmer lookups  intersection process also require  position   position list   adjust  run time   location   give read   correspond   diagonals   alignment matrix  genome  read although  alignment algorithm could potentially work  another data structure  provide genomic position   give qmer  suffix array would require  additional step  sort  position list  run time  set   sort list   merge  time  log      sum  list lengths  use  heapbased multiway merge procedure knuth   merge procedure  produce    list  candidate genomic regions  also information   count  read location   position list  support  region  support information  provide evidence   number  mismatch   read   therefore  use  filter  candidate regions  use multiway merge effectively  algorithm depend  another idea   successive score constraints   give read  program  design  report  best alignment  alignments    lowest score base  mismatch plus  open gap penalty   indel   splice therefore  search process  constrain successively   increase score level  start     exact match  end either   successful alignment       maximum score level specify   user  addition  find  best alignment  constrain search process  also find suboptimal alignments  continue  search  successive score level beyond  first  optimal one  yield  alignment  algorithm could also find  exhaustive set  alignments    give score level  search   score level  report  result depend   score constraint    read length   multiway merge process   formulate  two different ways  generate  filter genomic regions  low value   involve none    mismatch relative    apply  merge procedure base   span set  oligomers  filter genomic regions base   count  qmers  support  region  higher level   involve  mismatch  apply  merge procedure base   complete set  oligomers  filter genomic regions base   pattern  qmers  support  region   count  patternbased criteria provide lower bound   number  mismatch present   read  part   read   lower bind exceed  give score constraint   allow mismatch  read may  filter   need   verify   genome  determine  actual number  mismatch  hash table  relatively large require    represent  humansized genome  every overlap oligomer  index accordingly soap     require    memory  process  humansized genome although modern computers generally  sufficient physical memory  query  large hash table smaller data structure  speed  program  use memory page  cache resources  effectively   reduce  size   hash table  sample  genomic oligomers   index   table   program  index 12mers every     genome  reduce  size   human genomic hash table      result  algorithm  design  use  hash table sample every    still achieve full sensitivity   every overlap oligomer  index  hash table index scheme   extend  align major  minor alleles equally well  snptolerant alignment  ease  discussion  refer   alleles   reference sequence  major   correspond alternate versions  minor regardless   actual frequencies   population   hash table represent  genome  qmer piece   represent  enormous space   combinations  major  minor alleles   relatively straightforward way  construct  snptolerant hash table  scan  genome  process  sample genomic qmer  contain one   snps  generate  possible combination   major  minor alleles contain within  duplicate  genomic position   generate qmer finally  resort  position list   qmer fig   lookup   hash table   combination  major  minor alleles   qmer   give genomic position   contain  desire position  experience show   snptolerant hash table   slightly larger   original   incorporate   million snps  dbsnp version   human genome version   hash table increase  size       construction algorithm require   computer  sufficient memory  store  hash table thereby require     humansized genome verification   snptolerant manner  discuss  section   span set generation  filter  span set   minimal set  12mers  cover  read fig   structure exploit  pigeonhole principle   number  nonsupporting 12mers—  fail  contain  give position   correspond position list—provides  lower bind   number  mismatch   read however implementation   pigeonhole principle  complicate   use  sample   hash table  create uncertainty   phase   align read relative   sample genomic 12mers therefore  program must construct six span set one   shift          forward  reverse complement directions fig   addition sample hash table cause genomic position information   available   intervals    thereby cause information  incomplete  12mers  overhang past read boundaries  handle  case  program compute  position list   12mer  overhang  end   read       substitute  possible nucleotides   overhang position  take  union   result position list another complication    span set  often contain 12mers  overlap  address  issue  consider  overlap pair  12mers    single element   span set   position list equal   intersection   two constituent position list fig   result set  elements  nonoverlapping   pigeonhole principle  hold   nonsupporting elements imply  lower bind   mismatch   region may  filter     may  several choices   pair  12mers  overlap  create  single element  program heuristically select  12mer   longest position list  union  position list   site   overlap   intersection operation   12mer  likely  eliminate  largest number  position  subsequent consideration although  could use  span set elements  generate candidates   proceed   verification step   make  algorithm faster   designate  elements  generate candidates fig   reserve others   separate filter step fig   division  labor  intend  reduce   log  complexity   heapbased priority queue   linear     check  sort list  length    presence   give position   filter step      logarithmic time olog    binary search process consequently  method perform  heapbased merge   position list  generate elements  count  number  elements  support    result candidate regions   count  high enough  allow  possibility    fewer total elements   nonsupporting   candidate region undergo  filter step  check    filter elements  support  algorithm eliminate  candidate     total elements show nonsupport otherwise  region undergo  verification step  determine  actual number  mismatch   make implementation   span set method efficient  various ways first  program select elements   shortest position list  generate elements   longest ones  filter elements   every position  generate elements must  process       filter elements need  second  maintain  pointer   filter element  advance  pointer    check  support  use  gallop binary search hwang  lin  third filter elements  involve unions  intersections  position list need    set operations compute explicitly    represent instead   constituent position list  support check  perform  appropriate disjunctive  conjunctive search  need allocation   total elements  generate  filter purpose depend   constraint score level   allow mismatch  least    elements must  generate  guarantee   least one generate element  support   candidate region     generate elements     find empirically         efficient  allocate    elements  generate purpose   requirement  two support elements greatly reduce  number  candidate regions generate   span set method require  least    generate elements       exact  onemismatch constraints    use  detect   limit number  mismatch relative  read length   limit  total number  elements  span set elements  nonoverlapping   three shift     mod   ≤⌊  ⌋ therefore        indicate   span set method   apply  constraint level       ≤≤ ≤  ≤≤  ≤⌊⌋  ≥  complete set generation  filter  handle greater number  mismatch   detectable   span set method  employ  strategy base   complete set  overlap 12mers  complete set method work   constraint level   allow mismatch  long   read  candidate region   consecutive match  12mer   phase   many    one sufficient condition   consecutive match    number  mismatch  ≤⌊⌋    level  mismatch gsnap   exhaustive algorithm mean    guarantee  identify  report  available alignments   genome   many mismatch candidates  generate  perform  multiway merge  position list   read locations   single forward  single reverse complement pass keep track   read location  12mers  support  candidate region  pattern  support 12mers provide  lower bind  mismatch   read   support 12mers  read locations separate     minimum number  mismatch    ⌊⌋ fig    entire read   sum  lower bound   patternbased lower bind calculation fig  specifically   read  length    pattern  support 12mers  read locations  …   lower bind  mismatch  ∑i0n⌊pipi⌋    pnl  make  complete set method  efficient  note   merge process must process every position   position list   therefore  slow   nonspecific 12mers  extremely long position list    help localize  read   gain efficiency  ignore  nonspecific 12mers define currently    position list     time  mean position list length  lower bind formula must  modify accordingly  compensate   miss 12mers essentially  assume    support  strategy  potentially fail  align read  portion  read   nonspecific  repetitive nucleotide pattern  necessary  map  read  successfully align  read  program provide  option   greedy strategy   nonspecific  repetitive 12mers  initially ignore   subsequently include   alignment   find",-0.19739375805502807,0.1835676531201256,0.1162764936370556,0.1542490094158269,0.00043964907618276037,-0.02175869048437829,-0.1332952128451628,0.08939604421149637,0.0021108275936806897,0.12458106983754345,0.023660522985600813,-0.0013939584422783524,0.1688532392411777,-0.10716549756471068,0.11991884832717845,-0.0800341835259186,0.00791723627235293,0.20032108089819267,-0.06389115399928699,0.03770314590987183,0.04167131070896764,-0.19438470644353065,0.043746390176352616,-0.030707581402441737,-0.04487104924916696,-0.20577912928134787,0.0417624313871641,-0.1977625267979616,-0.0416535056854128,-0.0747401089849197,-0.00634244807046272,0.25071690551581105,-0.16953380978072755,-0.12355189813305532,0.20538650301505365,0.10776505235116927,0.053790085753608566,-0.026567121874312774,-0.13597009691293352,-0.06644940506392981,-0.07152901470453442,-0.16598102577831303,-0.02957973721786402,-0.09711991099700076,-0.1228482476754032,-0.008208813787410583,0.1474482660128178,-0.1512665253077798,-0.21040688478319414,-0.37060019690178186,0.15958632651885388,-0.024388505333027912,0.0723203829320732,0.6312150232585183,0.0529169998259521,-1.2115676807029647,0.07097657617665462,-0.21256373186741828,1.0354999080957736,0.23619388965707197,-0.19891822591918185,0.3099178601823309,-0.05907753609513462,0.07389109442535532,0.6225434664988378,0.027256677266924788,0.03141279398034528,0.05134265712099032,0.1932117549373823,-0.2079275222992817,-0.05844007073548496,-0.08183795825473271,0.09327109796862464,-0.11303466992251868,0.2238239498197229,-0.018897179647020118,-0.16317893529023209,-0.13774898358182433,-0.37929133592005393,-0.06356851081477989,0.23918141161891124,-0.04694066377939866,-0.3695950427585665,-0.05334191406439583,-0.9274126403672877,0.07976455002356612,0.2270093883193719,-0.12628633019596558,-0.09512719236880396,-0.0488883967323037,-0.22435544345199185,0.09709997331271604,-0.14942269089458254,-0.10114912516802696,-0.14456445446406838,-0.0808140419635867,-0.06564538911185866,-0.3075050678680532,0.3337844877830232,0.0661805907184459,Mapping,4
92,92,"stampy  statistical algorithm  sensitive  fast map  illumina sequence reads
highvolume sequence  dna  rna   within reach   research laboratory   quickly become establish   key research tool  many workflows    short sequence “reads” result   sequence run  first “mapped” align   reference sequence  infer  read    genomic location derive  challenge task    high data volumes  often large genomes exist read map software excel  either speed  bwa bowtie eland  sensitivity  novoalign      addition performance often deteriorate   presence  sequence variation particularly   short insertions  deletions indels   present  read mapper stampy  use  hybrid map algorithm   detail statistical model  achieve  speed  sensitivity particularly  read include sequence variation  result   higher useable sequence yield  improve accuracy compare    exist software
building  hash table stampy uses  new open‐addressing hashing algorithm  encode  genome section   hash table contains    long‐word  byte entries  entry consisting   genomic coordinate   additional  bits  auxiliary data  support fast searches  high load factors   hash table occupies     fit mammalian‐size genomes   3x109    table  every fifth position  entered    scheme ensures   store  position  bits  sufficient leaving room   auxiliary bits required   fast search algorithm see section   details    eligible position  “hash”  constructed   15bp dna word observed   position   reference genome    done  first encoding   nucleotides   ‐bit word   dividing   reverse‐complement symmetry  subjecting    transformation  maps words related  reverse‐complementing    ‐bit word  words     related  distinct ‐bit words   reduce clustering within  hash table  word   pseudo‐randomized  multiplying modulo  large prime    side effect    words 0x1fffffff  0x1ffffffe become unused  hashes  words therefore  available  use  flags see    smaller genomes  smaller hash table  used   resulting hash   reduced modulo  power    limit  hash values   size   hash table  note    size different ‐mers unrelated  reverse complementation may hash    value although   extremely unlikely   full‐length hash table  avoid entering extremely long hash chains related  repetitive sequence  positions  first scanned  hashes occurring    times noted   candidate mapping positions   chains  costly  consider   unlikely  result   unique mapping position  presence  flagged   hash table  one   unused words 0x1fffffff   actual locations   entered   hash table  improve search times hash chains  entered roughly  order  decreasing length   ensures  longer chains  less frequently interrupted   elements  shorter ones reducing search times  optimizing cache use   longer chains   relatively frequently accessed   use  quadratic probing sequence  achieves  good balance  reducing clustering  making reasonably good use  caching1  addition   longest chains  use linear probing   optimize cache usage  long chains  entered first  issue  clustering  virtually absent  cache usage  long chains  particularly poor   quadratic probing scheme   presence   second unused word 0x1ffffffein  primary position   probe sequence signals  use  linear probing   initial position  already occupied  algorithm falls back  quadratic probing   improved hash table supporting fast searches   scanning algorithm spends    time looking  ‐difference matches section  many hash lookups performed   mapper   unsuccessful   unsuccessful search   standard open addressing hash table  slow   probe sequence  traversed   empty slot  found   density  empty slots  low  high load factors  stampy uses  hash table  addresses   adding flag bits indicating whether  entries exist   chain   chain   defined   smallest prefix   probe sequence  contains  elements inserted   hash bucket    flag bit    present  chains  include  least one element  additional sentinel bit  used  ensure   search algorithm   enter empty chains  order   hash slots  probed  given   probe sequence hki  standard hash tables     arbitrary function   object   probe index   long     {…}  {…}   permutation  however  use   sentinel bit  requires   probe sequence  determined   hash 'khk rather    object     standard probe sequences linear  quadratic probing satisfy  requirement  double hashing    another choice  minimizes clustering   bad cache performance  random hashing    simplest form  hki  '  '' mod   ''   permutation  balance  opposing needs  low clustering  good cache behaviour stampy uses mainly quadratic probing supplemented  linear probing  long chains scanning  read  find candidate locations   single read  overlapping 15mers   read  considered   addition every ‐base mismatch “‐neighbour”  considered   reads longer    ‐neighbours  considered   reduced fraction  initial ‐mers half    reads       third  reads  50bp    simulation experiments showed   resulted  negligible loss  sensitivity   considerable reduction  computational time data  shown  addition  15mers  contain  single  character   possibilities   position  considered    15mers   15mers  contain    single  character   considered  searching  hash table   initial hash table entry corresponding   15mer  flagged   high‐ count flag  15mer    considered   repeat mask table  read locations    scanned   reason  kept  later use   specifically   read 15mer  marked  repetitive  corresponding location  marked   phred score   ‐neighbours   marked   phred quality   mutated base     one 15mer mutated  otherwise  repetitive  minimum phred score  used   values  used  calculate  mapping posterior  details see section    phred score   representation   probability    integer using  formula ‐10log10    non‐repetitive 15mers  positions   genome   entered   hash table  match  15mer   reverse complement together   orientation  retrieved  similarity filtering  avoid excessive numbers  potential candidates  neighbourhood similarity filtering step  included   stage   “fingerprint”  computed  three ‐ nucleotide words close    overlapping  15mer  falling within  read   fingerprint comprises  counts      nucleotides within   positions   counts   corresponding positions   putative genomic location   implied orientation  obtained   sum  absolute differences     counts   implied absolute difference   counts  computed   similarity statistic   property   increases      every single‐nucleotide change  every incremental 1bp insertion  deletion  longer insertions  deletions   opportunity  cause  drastic changes   statistic   potential problem  mitigated   fact   indels  copy number changes  short tandem repeats  homopolymer runs    statistic  relatively insensitive  locations    fingerprint match value   exceed  set threshold  considered   threshold  reduced    one‐mismatch 15mers   similar approximate mismatch thresholds  used    nucleotide positions   considered independent  whether  original read 15mer  one   ‐neighbours generated  candidate location  simd alignment locations  pass  similarity filter   considered  full‐length alignment    stage  number  candidates often exceeds     use   highly efficient implementation   alignment algorithm  imperative  stampy uses  single instruction multiple data simd implementation  banded affine‐gap alignment   implementation traverses  dynamic programming table diagonally allowing  optimal exploitation   parallelism provided   x86 simd instructions   dynamic programming table  held  registers rather   memory   expensive cache misses  avoided  since   first instance  complete read  considered  derive   reference  needleman‐wunsch global alignment rather   smith‐waterman local alignment  computed   requires aligning  possibly low‐quality end   read containing relatively many mismatches  handle  cases appropriately  algorithm computes  mapping quality score  phred units  accounts  nucleotide quality scores  well  gap opening  extension    probability represented   base quality phred scores  term corresponding   expected divergence   reference  default equivalent   probability  ‐ per nucleotide  added   alignments  distinction ought   made  read errors polymorphisms  substitutions  algorithm uses  30bp diameter band allowing insertions  deletions    15bp   fully considered   stage   limited number  bits available  simd registers  accumulate  score puts  limitation   maximum read length    considered   single alignment   implementation reads        consider  single­end reads realignment stampy reports  best‐matching candidate mapping location   case  ties  deterministic pseudo‐random choice    process  generating candidate mapping locations described    result   candidate    candidate  judged     similar   best match  random sequence  mapping location reported  best‐matching candidate  ‐aligned    model  used   simd alignment     larger band    diameter  default enabling  correct identification  insertions  deletions indels       length     likely alignment comes within     edge   dynamic programming band  read   ‐aligned  double  bandwidth    way alignment   presence  large indels  improved without  large increase  computational time   general case  alignment algorithm   stage allows flushing  indels   leftmost  rightmost possible location  desired behaviour   selected  command‐ line options   desired alignment posteriors per alignment column  also  computed   use   forward  backward algorithms ref durbin     certain cases  additional information allows potential indels   edge  reads   identified   computation   information  relatively costly   switched   default  single­end reads mapping posterior stampy computes  mapping posterior phred score  “mapping quality”   standard bayesian fashion  computing  posterior probability   reported location  incorrect   first instance   formula  ‐ pread  lopt    pread      lopt   maximum likelihood mapping location   sum runs   candidates considered    alignment model considers read errors single‐nucleotide polymorphisms  substitutions  short indels  accurately estimates  probability   read  mapped incorrectly   errors  caused  near‐repetitiveness   genome  combination  read errors  mutations   result  approximate    possible mapping locations  considered   sum  consequently  resulting posterior   include  possibility   correct mapping locations   considered among  candidates   broadly  may happen  three reasons   read contains highly repetitive sequence   15mers   entered   genome hash table   read   low quality andor  divergent   reference  single‐nucleotide  short indel mutations   every 15mer entered   hash table     nucleotide difference   read  iii  sequence   represented   reference stampys model accounts   three possibilities  sections     describe  model      short  longer reads respectively section  describes  model  iii adding  probabilities   three events   naïve posterior  results   final mapping quality   reported   phred score capped     addition  iii  deemed likely  mapping  reported   read   example   situations handled   model consider  read   highly repetitive genomic region   read error within  read may cause  spurious hit elsewhere   genome  however    repetitiveness  location   deemed   reliable since  cumulative likelihood   repetitive loci   require one read error  overcome  single higher likelihood   spurious hit   similar situation occurs   genome carries  mutation   otherwise repetitive region   case  read   mapped correctly     reason    map    deemed   reliable  single­end reads failing  find candidates  non­overlapping 15mers  described  two reasons  failing  identify  correct candidate locations    read  highly repetitive   15mers    entered   hash   read errors  divergence cause  read 15mers      mutation removed   reference 15mer   section describes  algorithm  estimate  probability  either event occurring   way  read  scanned changes   length   read  described  section   model  dependent   read length   simplicity  case   ‐neighbours  considered   15mers within  read  case     considered   one‐third   15mers  distinguished  intermediate case   ‐neighbours  half   15mers  considered  approximated   model  case  first consider case   ‐neighbours   third  read 15mers  considered   precisely  algorithm considers ‐neighbours   consecutive block   overlapping 15mers   read   subsequent    read 15mers  considered     consecutive block  five 15mers  ‐neighbours  considered      contribution  sensitivity    read 15mers  ignored   model    effects  indel mutations  sensitivity suppose   correct mapping location   whole read      15mers  genomic loci   multiples    entered   genome hash table  15mers  read position    mod      possibility  matching    algorithm described     stated assumptions  follows   happens precisely    block  five overlapping 15mers   read  next possibility occurs exactly       means   possible matches involve non‐overlapping adjacent 15mers    offset   known  required probability    probability   non‐overlapping adjacent read 15mers  offset      mutations    corresponding 15mer   reference  repetitive   included   hash table   final probability  computed  computing  compound probability   offset   taking  bayesian average using  uniform prior   possible offsets  compound probability    product   probabilities defined    15mers   offset    calculate  relevant probability  one 15mer write    error probability  base    15mer   …   probability   mutation read error  substitution occurs   15mer     ‐   write       ­   probability  two   mutations wrt  reference    zp1  remains  include  probability  missing  candidate   repetitiveness    read 15mer  marked  repetitive   hash table  probability  taken        approximation   possibility   true reference 15mer   repetitive    mutated   highly repetitive one  ignored    read 15mer   repetitive  one   ‐ neighbours    probability   true reference 15mer  repetitive  estimated   probability   mutation  occurred      correct   strict bayesian sense   prior   read deriving   repetitive sequence   weighed explicitly   alternative simulation experiments show   procedure  effective  reducing false positive rates  estimating well‐calibrated priors see main text  results    data required   procedure  collected   scanning stage single­end reads failing  find candidates  overlapping 15mers  model deals   case  relatively short reads   case ‐ neighbours   overlapping 15mer  considered   analysis   situation  complicated    dependency structure introduced   overlapping 15mers   non‐uniform distribution  read errors described   quality scores  approximate  situation  considering    contiguous subsection   read  probability        mutations  known   mutations     occur   conditional   certain number  mutations occurring   distributed uniformly along  subsection   simulation  used  estimate  probability  conditional   length   subsection   number  mutations occurring every overlapping 15mer fully within  read subsection    unspecified offset  overlaps   mutations       case would  correct candidate   consider  particular independently     mutations  least one 15mer  guaranteed  overlap    mutation   read  length      seen  considering    length‐ read two non‐overlapping ‐mers fall wholly within  read        ‐mers   yield  correct candidate  least  mutations  required    considering  algorithm  section   means  stampy  guaranteed  consider  correct mapping location   read    fewer mutations   first      mutations   true  reads     longer  generally  probability   identifying  correct candidate  estimated  follows  first  probability  precisely  mutations among  positions  independently  probability   mutating  €   qim     ∉{  ∏ … }       ≤ ∑       qik      ∏ ≤    ∑   ∏   last sum  ‐fold products  inefficient  calculate  written particularly     increase  however  sum may  recognized   elementary ‐ degree symmetric polynomial    variables ‐ …     computed   power sums using newtons identities since     calculated efficiently        represents  probability  precisely  mutations occurring among   positions  longer reads  often occurs  sections   poor quality   happens predominantly   far end   sequence  low‐quality bases  occur anywhere   read   localized issues   air bubbles   flow cells focusing  optical alignment problems   order   obtain  overly pessimistic estimate   probability  missing candidates particularly  long reads stampy considers every ‐  ‐ subsection   read calculates  probabilities     mutations following  algorithm   estimates  probability  missing  true candidate conditional  finding    subsection  consideration  since  simulation assumes  fewer   mutations occur  subsections  considered   probability     mutations exceeds    cutoff  found  provide accurate estimates  practice data  shown   final reported probability   minimum   probabilities   subsections   considered  effect  repetitive 15mers  modelled  adding    repeat mask probability obtained   algorithm  section  similar   procedure described  section   single­end reads random matches  models      bayesian models   sense   full description   process  generated  reads  attempted  however   read   represented   reference  instance   derived   contaminant  generative modeling approach fails  algorithmically  unique best match may exist     biologically meaningless  identify  cases  hypothesis‐testing stage forms  last part   mapping quality model   stage assesses  likelihood   read   random sequence    sequence similarity   candidate mapping results  finding  best match   random sequence   question  complicated   alignment procedure  considerably increases  chances  finding fairly good matches  random suppose   best alignment   read   nucleotides    align   reference   mismatches include  insertions   deletions   quintuplet lnmid forms  summary   complexity   alignment   estimate  size   search space  need  compute  number  alignments  similar complexity consider  quintuplet   fixed  denote  set   alignments characterized   quintuplet   particular locus  strand      alignment  ∈  implies  particular sequence    nucleotides   aligning positions   read  denote  set   locus strand pairs   reference    suppose   set   {    ∈    ∈  } may  considered   drawn uniformly   set   sequences  length     likelihood  randomly obtaining  match    good   best alignment    fact found   since  alignment implies  matches   loci  alignments  potentially  considered  second approximation holds   ‐ ≪   ‐   order   greater  likelihood  finding  random match  comparable quality  nearly    stated assumptions   mentioned    case  mapping  reported  formula  assumes  every alignment  equally probable  specifically    random read mismatches insertion starts  ends  deletions  occur uniformly along  read    addition assume  deletions    size uniformly     set maximum     calculate  note     mismatches   distributed among  aligning locations 2id positions    chosen within  read  length     start  end  alignment  place  deletion   deletion lengths   chosen  addition  mismatching nucleotide   position    chosen  approximation  total number  possibilities thus becomes €                            size   reference   factor  accounts   choice  strand   formula  approximate     consider  fact  deletions cannot occur  insertion starts  ends  practice  situations arise  often  incorrectly mapped reads   case  overestimation  conservative note   insertions run  either end   sequence one less insertion start  end position needs   chosen  2id   replaced  2id­   formula    similar consideration   apply  deletions   cannot occur   read boundaries nucleotides   uniformly chosen    possibilities  rather often  biased somewhat towards      account     formulas   use   ‐ instead        somewhat less    account    bias using  formula   exp‐ log  ‐ ‐ log ‐      content   instance    value   used  paired­end reads paired­end candidates  paired‐end pathway follows  single‐end one   including  point  calculating  single‐end mapping quality     reads independently   candidates  obtained   reads  paired‐end read  reported  unmapped   best locations   single reads  close together   genome defined   implied insert size within  standard deviations   mean  resulting paired‐end mapping positions  considered    addition  single reads map sufficiently uniquely    posterior probability  less      mapped incorrectly due  near‐repetitiveness   addition  estimated probability    found  correct candidate  sufficiently low    less    paired‐end mapping location  report     conditions   met stampy creates  shortlist  pairs  mapping locations    candidate locations   member   read pair  locations  together constitute    single‐read posterior mapping probability  extracted    maximum   locations  subject   minimum        locations  mate  aligned   reference around  location implied   library insert size distribution plus  minus  standard deviations   alignment model used    single‐end reads  contains  additional term modeling  likelihood   implied insert size  helps  disambiguate  mapping position  locally repetitive reads   addition   list  novel pairs  pairing   top‐ scoring single‐end mapping locations  added      close together  score corresponding   prior probability   physical insert overlapping  breakpoint  structural variation  could give rise   configurations  added   prior probability  user‐specified   3x10‐ phred   default  close  defined   distance    likelihood   insert size   insert size model approximated   gaussian distribution becomes less   prior probability   structural variant  posterior mapping quality  calculated   product   single‐end mapping qualities  case   top‐scoring single‐end hits  selected   pair   single‐end posterior   anchoring read   cases",-0.03590731131147168,0.03985002498408787,0.02574684331960087,0.033698039815891465,0.004068808542917111,-0.02473084736661411,-0.004409547233110899,-0.005685368416746581,0.002338516978171382,0.028141346131547243,-0.0037533949481882924,-0.00048202076167972,0.01865028603024706,-0.015276377130043022,0.026732144428899998,0.014136403912597875,0.014771135592902147,0.030422735054797107,0.0007034713716663943,0.01964563141488796,-0.005606689392646522,-0.037493241398974704,0.006383424037454243,0.004381591260601832,-0.00042908833411985954,-0.02745693626165881,0.01897463492856077,-0.017361422823435425,-0.01865457570460077,0.00023382509686819316,-0.002732242167248954,0.03761206675941745,-0.046615327030052375,-0.012885348042789386,0.04343292467897842,0.012410399461847276,0.010457682512401615,0.007325142321613744,-0.010328594305832323,-0.017070370189243844,-0.011356284499116655,-0.01907433057203889,-0.035089026234944365,-0.020237519169358512,-0.028301861084094118,-0.009601119739471056,0.03550674432973423,-0.02226374758797441,-0.0349936718705643,-0.058646631599576386,0.03822956200489782,0.013531732816323869,0.015098679063883859,0.10157857231849443,-0.0013880378921437672,-0.20130403030571747,-0.0026229510060798967,-0.027238989085986168,0.16070612098009865,0.02810488291537013,-0.0330907364509192,0.06846453054566626,-0.007048106832820692,0.011506164602172624,0.09834575309674927,0.00296954597269114,0.00839105200543693,-0.00018273439563028972,0.0646824835581176,-0.01593509147666134,-0.00348687510211174,0.010031797280228492,0.028543481580269186,-0.03538584277137286,0.03575645686882268,-0.00797743472623267,-0.015110522405140929,-0.017452170848156562,-0.06217395061236105,-0.017939260328636953,0.031146172353367363,0.0016088619993026119,-0.06583927039808207,-0.010476494237680923,-0.15351300994906794,0.02188812889764277,0.05289804767970563,-0.04118880946926942,-0.022248788180194767,0.005540244141881021,-0.031343923848114685,0.013365493608263048,-0.01577546180957936,-0.013494532972137315,-0.017865291991847887,-0.01353673931640485,-0.01964830246336237,-0.07066259395300963,0.05458616683405245,0.024318125453459502,Mapping,4
93,93,"shrimp2 sensitive yet practical short read mapping
 report   major update version    original short read map program shrimp shrimp2 primarily target map sensitivity   able  achieve high accuracy    reasonable speed shrimp2 support  letter space  color space absolid read enable  direct alignment  pair read  use parallel computation  fully utilize multicore architectures
shrimp2 index  genome use multiple space seed project  read  identify candidate map locations cmls  ultimately investigate  cmls   smithwaterman algorithm  major difference   original shrimp  shrimp2    former index  read switch   genome index similar   read mappers  langmead      durbin    nacu  result   dramatic speed increase   allow   add  pair map mode  utilize multithreaded computation   detail   methods describe  see  original shrimp paper rumble     well   supplement genome index shrimp2 start  project  reference genome use several space seed ilie  ilie   seed  apply   genome location obtain  space kmer  every seed  every kmer  genome index contain  list  locations   kmer   find use  seed ubiquitous kmers   long list  discard     help identify cmls ram usage  genome index  load  ram  lookups  perform  run   read set  index   genome  length    seed  weight  take  4wn bytes   default parameters     index   human genome hg19 take   shrimp2 provide tool  break  genome  piece  fit   target ram size  overhead introduce  split  insignificant  demonstrate   supplementary material use one node      way split  hg19 versus one node      way split result   slowdown project  read several thread  use  map  read  parallel  read  project use  space seed   genome locations   kmers appear  look    index  kmers   match diagonals   matrix   genome  lay     axis   read    axis generate cmls give  length   score  list  match diagonals  scan  genomic windows   give length   alignment   give score   read   genome   construct  two diagonals   cml  generate  every  window  process  analogous  qgram filter rasmussen     cml generation step  one   major differences  bfast  shrimp  bfast use  larger number  long seed  generate cmls base   single seed match shrimp2   original shrimp require multiple seed match   read   reference  allow   effective use  seed  smaller weight  length  improve sensitivity pair map mode   mode  read  every pair  analyze  map together  cml  one  analyze    cml    exist within  specify range   first  rescue mode  available  remap pair  anomalous space smithwaterman alignment  cmls  eventually investigate   smithwaterman  string match algorithm smith  waterman  similar   original version  shrimp shrimp2 support full alignment  indels   letter space  colorspace data  solid read  align  genome   four possible translations   read thus allow  sequence errors see homer    rumble    shrimp2 use  cache heuristic  speed   alignment  read  repetitive regions  alignment  compute  hash   target region  store  together   score  start    first check   identical region  already  align     reuse  score  result  discussion  compare shrimp2  three  lead read map program bfast homer    bowtie langmead     bwa   durbin   generate  datasets  contain    pair colorspace read      respectively simulate   human chromosome   read contain variants snps  indels  well  sequence errors distribute accord  typical nonuniform error profile   solid machine  average percolor error rate  map  datasets   pair  singleend read  read pair  map uniquely   map   highest score  unique  map  correct    within     location   read   read   pair  simulate   define recall   fraction   read pair   map correctly  precision   fraction   uniquely map read pair   map correctly  figure   present precision  recall   algorithm   figure   demonstrate  runtimes   tool   datasets     short read map program  find  bfast    one directly comparable  shrimp2  provide high sensitivity even  highly polymorphic read practical speed  wealth  feature   test shrimp2 achieve similar  better sensitivity   polymorphism class   run time    time faster  bfast   include bowtie  bwa   comparison  program primarily target speed    match  sensitivity  shrimp2  bfast  highly polymorphic read  also evaluate  speed  shrimp2  real  solid data  estimate    coverage  hg19  unpaired   color space read   map   nod    core     ram   days",-0.2693285760187583,0.2625643915455888,0.11975070575157976,0.10782985292145812,0.02876677110174472,-0.026921064005489284,-0.051427232414703525,0.041362360624582255,-0.026367095306174447,0.16855407223720387,0.054996720652046215,-0.05616815685905971,0.1441878203994893,-0.06828422716130922,0.17983618220445466,0.00790799414216477,0.06177361462023536,0.21169375885335304,-0.02456709916380373,0.0616691795987333,0.0468950962953497,-0.2266552541715996,0.05349408959252725,0.01047044349940963,0.043412303829295486,-0.19571347842490627,0.05197459405451615,-0.12652903722282782,-0.040383927343801584,-0.050223446127652886,0.027467803442175327,0.278600132577379,-0.18811722192913294,-0.062098114971224326,0.2367865722352072,0.06653559347792379,0.0053887446037714035,0.005196219353709114,-0.05940890261185362,-0.09686697667981374,-0.0514761213184768,-0.18295799011357025,-0.06934305390019595,-0.08511829804602428,-0.17322983447473872,0.009394235765354402,0.1255177691088321,-0.20510510376323315,-0.17524643788889108,-0.3549236708817442,0.15834637919955402,0.04023219136395029,0.06889010820105025,0.6497856272981708,0.046738604004121616,-1.3054639938152357,0.030584614487091183,-0.16374193852232372,1.0677011760790611,0.22029861299505896,-0.17992246626107153,0.365952288247165,-0.07312418707292741,0.12069095795590233,0.5842503877374422,0.03442052311978466,0.06520272587775475,0.03901003056849204,0.1992029225638577,-0.1529950188596836,-0.052758538836807915,0.005191200235076533,0.09941518373604337,-0.1304058073255596,0.23456262666238864,0.0052250098736551474,-0.13377614318258094,-0.12644871111642852,-0.3425462074961712,-0.07169894965806307,0.2495188473360364,-0.0411044618360101,-0.3774114353937729,-0.07522896584567706,-0.9338383059628764,0.06659846179847577,0.2507417978939266,-0.13544247990459887,-0.10355738190225797,-0.03219294246821131,-0.17628710480133172,0.12527277601530906,-0.12078388338421565,-0.12508168624081287,-0.16682209487193986,-0.09973794948585146,-0.10471276633924882,-0.3135455458894646,0.3579923132494917,0.05556116905907624,Mapping,4
94,94,"mrsfastultra  compact snpaware mapper  high performance sequence applications
high throughput sequence hts platforms generate unprecedented amount  data  introduce challenge  process  downstream analysis  tool  report  best map location   read provide  fast way  process hts data    suitable  many type  downstream analysis   structural variation detection    important  report multiple map loci   read   purpose  introduce mrsfastultra  fast cache oblivious snpaware aligner   handle  multimapping  hts read  efficiently mrsfastultra improve mrsfast  first cache oblivious read aligner capable  handle multimapping read  new  compact index structure  reduce    overall memory usage  also  number  cpu operations per alignment  fact  size   index generate  mrsfastultra   time smaller    mrsfast  importantly mrsfastultra introduce new feature    able   obtain  best map loci   read   return  read      map loci within  error threshold together   loci   user specify  furthermore mrsfastultra  snpaware    map read  reference genome  discount  mismatch  occur  common snp locations provide  dbsnp  significantly increase  number  read    map   reference genome notice      feature  implement within  index structure    simple postprocessing step  thus  perform highly efficiently finally mrsfastultra utilize multiple available core  processors    tune  various memory settings  result show  mrsfastultra  roughly five time faster   predecessor mrsfast  comparison  newly enhance popular tool   bowtie2    sensitive   report  time   mappings per read  much faster six time     multimapping mode furthermore mrsfastultra   index size  2gb   entire human reference genome   roughly half    bowtie2
mrsfastultra   seed  extend aligner   sense   work  two main stag   build  index   reference genome  exact anchor match    compute  anchor match     read   reference genome   index  extend  match   leave  right  report  overall alignment    within  user define error threshold index   index step mrsfastultra slide  window  size          read length     user define error threshold   reference genome  identify  occurrences   kmer present   genome  small value   mrsfastultra' genome index   array   possible kmers  lexicographic order   kmer  index keep  array   locations  kmer  observe   reference genome  case  value    prohibitively large   prefix  user define size    kmer  use  index    ℓmer  locations   reference genome   sort  respect     ℓmers follow   fact   applications even keep track     ℓmers follow  particular ℓmer   necessary   hash    ℓmers via  simple checksum scheme   compact  index  reference genome   first convert    bite per base encode  genome sequence  store   byte long machine word imply   machine word contain  base  addition  index   reference genome actually   keep every occurrence   kmer  rather keep  many occurrences   kmer  present   genome  actual locations   kmers seed  recalculate  time  reference  load  reduce   requirements  mrsfastultra significantly one may think    set  would increase  overall run time   search step   save   reduction significantly offset  cost  recalculate  kmer locations   fly overall  storage requirement   index  construct   human reference genome  2gb include  reference genome sequence   represent  fold improvement   index storage requirement   original mrsfast search   step mrsfastultra process  read   input hts data set  compute  locations   reference genome    align   read within  userdefined error threshold  mrsfastultra   fully sensitive aligner mean   guarantee  find  report  map locations   give read within  mismatch mrsfastultra achieve   partition  read     nonoverlapping fragment  length    give error threshold  due   pigeon hole principle  least one   fragment    exactly match kmer   reference genome   location  read   map   search step  validate whether  location   reference genome   exact kmer match   read  indeed  map location  order  perform  search step  fast  possible mrsfastultra load  genome index see    main memory  compute  locations   kmer onthe fly— significant save     kmer  number  locations   reference genome  already store   index thus   preallocate  require memory   array  keep  locations   give kmer   extend reference genome index  set    main memory  remain memory  allocate   read   subsequent stage mrsfastultra retrieve sufficiently many unprocessed read   fit   main memory  search    reference genome simultaneously alternatively  user  specify  upper bind   memory usage  read  also index  respect      nonoverlapping fragment  size   extract   read basically   possible fragment  length   read index keep  read   fragment number   direction  fragment  observe   read   read index  set   compare   reference genome index   divide  conquer fashion  per mrsfast  order  achieve cache obliviousness   word   possible kmer  list   occurrences   reference genome  compare   list   occurrences among  read   divideandconquer fashion rather  linear fashion  ensure  optimal cache performance   level   cache structure within  factor    mrsfastultra aim   fully sensitive  need  verify whether  reference genome location   correspond read     kmer  indeed  alignment within  user define error tolerance note   value   set        big  create  index    entry  every possible kmer   four letter deoxyribonucleic acid dna alphabet thus  primary index  perform   prefix  length      kmer   locationsreads  share  prefix   sort accord     ℓmer succeed  prefix   achieve  hash    ℓmer   simple checksum scheme   result  divideandconquer comparison  reference genome locations  read  perform   entries     ℓmer    checksum value   succeed   ℓmer  comparison   genomic location   read involve  calculation   ham distance   read   kmer location   genome extend   appropriate length towards leave  right  calculate  ham distance mrsfastultra apply another filter  compare  number         read   genomic locus   total number  symbol differences         need  compute  ham distance explicitly      least   —  error threshold  comparison   original mrsfast  new search strategy significantly reduce  number  ham distance calculations    main bottleneck   search step  combine  reduce  due  compact index representation   introduction  new filter  imply  five factor reduction   overall run time  search snp awareness  user   option  set mrsfastultra  tolerate know snp locations   mappings    mode snps   alignment location simply   contribute   error count   ham distance computation provide   snp location' base quality   userdefined threshold    match  alternate allele   feature mrsfastultra parse dbsnp file  vcf4 format   generate  compact structure   use  map although conceptually simple  feature  highly desire  users   significantly reduce  number  read     map  anywhere   reference genome   mode mrsfastultra report  number  snps  addition   number  mismatch per map location best  limit map mrsfastultra provide  user  option  return  single best map locus per read—  perform much faster  compute  map loci  per bwa bowtie2 srmapper  others  best map location   reference genome  consider   one    smallest number  differences   read    case   tie one  choose  random  assign  low map quality  addition mrsfastultra   option  return  map loci  read  map     locations within  userdefined error threshold  feature help  users  control  map multiplicity—  grow prohibitively   downstream analysis parallelization mrsfastultra  design  utilize  parallelism offer  contemporary multicore architectures  map task  simply partition  independent thread     execute   single core  efficiency purpose   lock use   thread   allocate memory  ",-0.214337840958758,0.22744495451562946,0.12804925102785694,0.1264041811813056,0.02285920465466836,-0.037846088791232683,-0.14848929860176202,0.039627904579096825,0.014124875060598178,0.1327077529706122,0.00900760999228042,-0.02187395919185282,0.1590469879006154,-0.121148434941863,0.1272400265929793,-0.08572223821917009,0.06266536083525044,0.2155715058821055,-0.07530613620156394,0.09821041324589393,0.03595864148416093,-0.2294732179999087,0.0402734766959908,-0.07091623244812212,0.010293312104230573,-0.18181295594572006,0.02548801181841097,-0.17954905016447642,-0.01840020104986043,-0.07293754699131058,0.00942644363815026,0.3029841519411923,-0.1442337483587507,-0.08777917993809682,0.2314150411419505,0.0973797963910766,0.05985848626816554,-0.01613232431312402,-0.06412345892876957,-0.1484983865797642,-0.06543745240196586,-0.18834756533092853,-0.037798993323981775,-0.11951192971439828,-0.16025422566539807,0.008650593138301075,0.14773286551382148,-0.17113324700469212,-0.23260962245034825,-0.41758331355048456,0.14319877993745495,-2.378574890578217e-05,0.06532680156292099,0.6821564406543319,0.015888059944998412,-1.3356410998270891,0.05677344571402083,-0.2172664935370434,1.1356123232058777,0.1896913101080146,-0.14127463289026662,0.3386828861682157,-0.10666505453912184,0.10382702164549147,0.6139545294900216,0.046884370798211984,0.027118445774786015,0.03127251187214193,0.2310593975898733,-0.2257692114153592,-0.05641692589952221,-0.05596368339757532,0.11422151955346516,-0.14528717069448954,0.2402931410193321,-0.005917534077237233,-0.13141103952237573,-0.14961979636232892,-0.3697952601811823,-0.04933264517210058,0.24019467025451985,-0.04039499350838412,-0.4126165013879129,-0.041100646552171424,-0.964274333199598,0.08636270278760695,0.2288303493033545,-0.1592336506474651,-0.1139400309575798,-0.022039837266501074,-0.2335251492897909,0.10422334164480268,-0.10328017614132666,-0.12448570992074948,-0.17493889608440788,-0.13691188429566253,-0.06827827489567803,-0.3314867532822237,0.39118941084995773,0.10505044318848834,Mapping,4
95,95,"bammatcher  tool  rapid ngs sample match 
 standard method use  highthroughput genome sequence facilities  detect mislabelled sample   use independently generate highdensity snp data  determine sample identity however     become commonplace   multiple sample sequence    source    analysis  somatic variants use match tumour  normal sample   directly use  genotype information inherent   sequence data  match sample  thus bypass  need  additional laboratory test   present bammatcher  tool   rapidly determine whether two bam file represent sample    biological source  compare  genotypes bammatcher  design   simple  use provide easily interpretable result   suitable  deployment  early stag  data process pipelines
 facilitate sample match use exist ngs data   develop bammatcher  tool  provide rapid pairwise comparison  binary sequence alignmentmap bam file     compare  sample genotypes  predetermine genomic locations bammatcher   follow feature first   easy  use    deploy  early stag  process pipelines second bammatcher   fast  limit genotypecalling  predetermine position  comparison  two sample   make   min use  provide default set  variants intel xeon   ghz  bammatcher cache sample genotype data subsequent comparisons involve previously calculate sample   much faster   thus significantly reduce overall process time  large cohorts third bammatcher  flexible   compare different type  ngs data include wholegenome sequence wgs wholeexome sequence wes  rnasequencing rnaseq data   appropriate genome reference  suitable list  snps  provide bammatcher  also  use  nonhuman genomes bammatcher   python command line tool python   linux operate systems  rely  external third party tool  genotype call  currently support  genome analysis toolkit  mckenna       freebayes  garrison       samplespecific input data require  bammatcher  map read data thus    use  early stag  process pipelines  facilitate early detection  sample mislabelling  default bammatcher compare sample genotypes   exonic snp sit extract    genomes database    genomes project consortium    global minor allele frequencies      require users  also substitute  customise list  loci bammatcher  write  output report  supplementary figure     file txt  html    command line  shortform tabseparated output  also available useful  batch process although  snps  use  comparison genotype comparison   site   carry    coverage    depth threshold default    sample thus  report number  sit compare  typically fewer    subclassification  genotype discordance  particularly useful  compare wgs  wes data  rnaseq data   latter  involve allelespecific expression",-0.2192204772157872,0.2603384272537214,0.09719075466087584,0.04040295707230317,0.05316708944651219,-0.0631219612860537,-0.07128169048797993,0.025014519724286498,0.033681245917018425,0.13770950226945447,0.04048558772402875,-0.07519025639680392,0.17951292153079426,-0.08383538168755934,0.18384371908441027,-0.06100716904434871,0.10012336606853343,0.17225294293197332,0.004293856705152529,0.08666734966484116,-0.0403357871827927,-0.2489213212281763,0.09175404453344528,0.01688287403692115,-0.06636002118342575,-0.2069275662961832,0.12943249901365292,-0.08329835588835735,-0.022069443032105868,0.04432243246744892,0.0078073832642366284,0.30690213239335634,-0.22360235148981367,-0.06942253582182023,0.3328085263029665,0.08110605264974242,-0.000583206008044765,-0.02207285884094048,-0.09692397916768776,-0.07779286166236914,-0.08754934729919077,-0.1029806906930815,-0.09230537213660044,-0.08721346084890451,-0.0932174906273313,0.015091868318082331,0.14987211053611393,-0.17629812325677893,-0.19533555317197016,-0.3283371346447855,0.19017081666599087,0.07985606929287314,0.05885621972637192,0.5246535421131139,0.055077441402356785,-1.1335306309480615,-0.000852129263605209,-0.22850413773298026,0.9826229972804479,0.16122105694097275,-0.11946866669313748,0.3050955731837832,0.013602980727111882,0.11512698177273008,0.5992901654012422,0.03498920635753708,-0.03262193047223573,-0.004131230928172218,0.2611597704656541,-0.11295694590823604,-0.06762528775244449,-0.032369151001671044,0.11468487685395187,-0.15449272091698615,0.17942321907352418,-0.035661300640563144,-0.09447979681352353,-0.0928891520474126,-0.39298797608353203,-0.0756461875559019,0.2923382627053256,-0.07224688034809933,-0.3754873786646714,-0.00816811256462391,-0.8975713401834698,0.14460110419647804,0.3013350175386493,-0.12860322009494646,-0.12291374563752235,0.016039885017194815,-0.1850506847704503,0.17106918796421364,-0.11234023161802163,-0.08000109387571587,-0.0917543586370773,-0.08119153146176263,-0.09020592403063114,-0.3214749915852271,0.3588892129433163,0.039226368224688564,Mapping,4
96,96,"target identification  genomic regions use tagdb
 introduction  second generation sequence technology  enable  cost effective sequence  genomes   identification  large number  genes  gene promoters however  assembly  dna sequence  create  representation   complete genome sequence remain costly especially   larger   complex plant genomes   develop  online database tagdb  enable researchers  identify pair read sequence  share identity   submit query sequence  tag   use  design oligonucleotide primers   pcr amplification   region   target genome  ability  produce large number  pair read genome tag use second generation sequence provide  cost effective method   identification  genes  promoters  large complex  orphan species without  need  whole genome assembly
  develop  online system   identification  visualisation  second generation pair sequence tag match  query sequence  relatively simple   concept  system provide  powerful mean  interrogate  vast quantity  data produce   latest sequence technologies   userfriendly  intuitive manner enable  identification  clone  novel genes   surround genomic regions   demonstrate  application  tagdb  gene  promoter discovery  genomes  complete genome sequence  unavailable  highlight  ability  amplify  sequence less conserve genomic regions   promoter sequence use pair sequence tag   one tag may align significantly   query sequence  tool   apply   species  pair read sequence data  available   current datasets  limit    species  generation  short pair read sequence data  become increasingly common   approach  likely  become  standard method   discovery  genes promoters  genetic variation   wide range  species   current tool  specifically design  illumina pair read similar data produce   sequence platforms may also  host identification  brassica wd40 orthologs   kbp fragment   arabidopsis genomic region begin   upstream   transducinwd repeat family gene at3g51930 refer   atwd40  use  query  currently available tagdb datasets table ​table1 pcr primer pair  design  brassica rapa tag align   query sequence   amplification   wd40 genomic region  brassica rapa  chiifu table ​table2 pcr products     amplify     brassica rapa  chiifu dna use   forward  reverse oligonucleotide primer    phusion hot start highfidelity dna polymerase finnzymes  phusion  buffer finnzymes    mgcl2     dntp   ptc thermocycler  research cycle condition  °   sec follow   cycle  °    °     °   min   final extension  °   min amplify products  visualise   light   taeagarose gel contain ethidium bromide  use  generuler™   marker   size standard pcr products     clone use  pgem®teasy promega  pcr®xltopo® invitrogen vector systems respectively  sequence use   sp6  m13r primers   internal primers      table ​table2  wd40_3pseqr 'tggaagagattaggtgaaatgtga'  consensus sequence   brwd40 region    generate  geneious pro    contig assembly  sequence products alignments  dotplots window size  threshold   generate  geneious pro use muscle   clustalw   default settings",-0.15658945744847738,0.19912556736720585,0.11363704870561335,0.09383822430568146,0.046061408834834464,-0.07372201496716305,-0.0354231158809188,0.014897808600406202,-0.012284507424225509,0.1079750064108048,-0.0722983711597694,-0.060764603702077265,0.08655405953422493,-0.1060138053614126,0.13568814378940894,0.03249883363117951,0.06839017365316903,0.16380036443962093,0.01939744182252491,0.03520177870097707,-0.052693330654448964,-0.21504514981510334,0.08334457564704252,0.04291494135321757,0.011734832748345235,-0.10188708703274728,0.08437186867107406,-0.09600162422899064,-0.08160537309226046,0.018104512379492926,-0.014507836597229398,0.2784923571457396,-0.19389493868870636,-0.048575659371442086,0.2988659034143049,0.01247651412430678,0.03424498050232526,-0.02602798207178428,-0.07226914208297272,-0.1137309658298562,-0.05445796791416816,-0.1700308897419062,-0.10425790770896498,-0.15972702410296644,-0.1059766334235115,-0.02404604245658,0.111206265875383,-0.06512100790919226,-0.21300964897585947,-0.2847313646624233,0.11113989117512772,0.03128698620671018,0.04972219539051025,0.5190686060843734,0.01998303118835529,-1.0718267956266396,-0.041761197386129864,-0.193233691340284,0.922673249237835,0.15575941374494698,-0.10352016834682208,0.358392905661373,0.03669036705245448,0.09492655589628188,0.5947273355970151,0.04302559943035302,0.003116939363405487,0.01459349610524838,0.21825211438667125,-0.1841929880326004,-0.02206007344160716,0.01870487545005892,0.09393986731901798,-0.12626983703623484,0.11704234750560237,-0.08047063050668705,-0.10816519514085526,-0.061616509209675374,-0.3862913604589359,-0.0337753990566982,0.2436489871937101,-0.09379944925005597,-0.35437562690603397,-0.004712903865041014,-0.8389381015393174,0.1561533797870338,0.21477692393552947,-0.12479898094927636,-0.10092447783093578,-0.015690143885969086,-0.09146098671173723,0.10788715636383668,-0.06449047895030208,-0.08738193673029693,-0.053987719722536534,-0.07138445971387103,-0.14167418996366166,-0.3350081635535066,0.3295749001184876,0.07427900008345201,Mapping,4
97,97,"hga  novo genome assembly method  bacterial genomes use high coverage short sequence reads
current highthroughput sequence technologies generate large number  relatively short  errorprone read make   novo assembly problem challenge although high quality assemblies   obtain  assemble multiple pairedend libraries   short  long insert size  latter  costly  generate recently gageb study show   remarkably good assembly quality   obtain  bacterial genomes  stateoftheart assemblers run   single shortinsert library   high coverage   paper  introduce  novel hierarchical genome assembly hga methodology  take  advantage    high coverage  independently assemble disjoint subsets  read combine assemblies   subsets  finally reassemble  combine contigs along   original read  empirically evaluate  methodology   lead assemblers use  gageb bacterial datasets consist    illumina hiseq    illumina miseq read  coverage range     result show    evaluate datasets  use  evaluate assemblers   use  assemble  disjoint subsets hga lead   significant improvement   quality   assembly base  n50  correct n50 metrics
 refer  gageb  data   download   sequence read archive  nihs national center  biotechnology information use  follow srr accession number  sphaeroides miseq srr522246 hiseq srr522244  abscessus miseq srr768269 hiseq srr315382  cholerae miseq srr769320 hiseq srr227312  cereus miseq data  download   illumina website gageb  downsampled  data  collect   coverage  hiseq data    coverage  miseq data    clean  raw data  remove adapter sequence  trim  read base  q10 quality   raw downsampled   clean dataset  available  gageb website      datasets   consider   paper  test genomes   paper  multiple chromosomes andor plasmids  cholerae  two chromosomes  cereus   abscessus  one chromosome  one plasmid   sphaeroides  two chromosomes  five plasmids  order  compute  correctness  assemblies  use  follow strain  reference genomes  cereus atcc  genbank accession number nc_003909 nc_005707  abscessus atcc  nc_010394 nc_010397  sphaeroides  nc_007488 nc_007489 nc_007490 nc_007493 nc_007494 nc_009007 nc_009008   cholerae  biovar eltor str n16961 nc_002505 nc_002506 ■■■ assemblers  test  method use eight open source genome assemblers   also test  gageb aby  cabog  mira   masurca  sga  soapdenovo2  spade   velvet   order  describe  methods   use metrics   use  quast tool       common  accurate tool  evaluate  analyze assemble result namely   use  follow metrics number  contigs n50 na50 ng50 nga50 genome fraction  duplication ratio global misassemblies local misassemblies # mismatch per  kbp mp100k # indels per  kbp ip100k  # unaligned length   descriptions   metrics  refer  reader  quast   well  add  descriptions  additional file  hierarchical genome assembly hierarchical genome assembly method include  follow step firstly  read  partition   disjoint partition       partition  assemble independently  assemble  partition sequentially   parallel   partition assemblies   assemble together  form combine contigs  merge together  form merge contigs lastly  merge contigs   combine contigs   reassemble   whole read  figure ​figure11 depict  diagram   step flow diagram represent  basic assembly flow   hierarchical assembly flow  basic flow represent  assembly   read   dataset together hga flow use merge contigs represent  flow  partition  read   dataset   disjoint partition  assemble  partition independently    contigs   partition assembly   merge together lastly reassemble  merge contigs   whole read   difference  hga flow use merge contigs  hga flow use combine contigs   instead  merge  contigs   partition assemblies    combine assemble together   paper  use velvet  assemble  contigs  method   mainly compare   basic assembly process   show  fig ​fig  involve assemble  whole read together   output  assembly result  denote  basic assembly  bkmer   kmer   kmer length use   assembly     coverage   read partition step  main motivation  partition  read set  smaller partition   gain lower coverage data    expect  obtain  graph  less complexity   result resolve  assemblys ambiguities    efficient  true   higher coverage  may get longer contigs  lower coverage  mostly  contigs    errors  term  global  local misassemblies mp100k ip100k  unaligned contigs  order  show  experimentally  add  table s3s9 additional file   row  present  average value    partition   metric     compare   basic flow result  result show    assemblers    genomes  average value  local misassemblies global misassemblies mp100k  ip100k    partition  less   value   basic flow  flow   without partition  read dataset specially  hiseq datasets      shorter read hence  graph complexities  critical   step  combine  contigs contigs assembly   reassembly step   contigs   longer   less errors  term  local misassemblies global misassemblies mp100k  ip100k  result   step    efficient  accurate    give contigs    correct  longer  first step   method   partition  read set  split  whole read set  read   disjoint partition   partition    read  perform several experiment  find  many partition  produce  observe     constraints   many partition  produce  long    ≥ coverage     partition   general  partition coverage    constraint   consider   step   many partition   produce contigs assembly combine step  assemble   partition  merge  partition assemblies together  form  merge contigs  assemble combine  together form  combine contigs initially  assemble  contigs   partition use minimus2     analysis  several experiment  find  minimus2  actually mislead  combine contigs despite   improvement  term  na50  minimus2s result   significant increase   duplication ratio  misassemblies events  occur   input data   short read  instead   long read contigs   minimus2 compute  pairwise alignment    read    contigs  would mean     two   contigs   true align   contiguous   reference   share  xmer  may  repeat  minimus2  output  contigs  one contig moreover one   contigs may  likely  share xmer truly  falsely   contigs   result   lead  output   contigs  multiple time   eventually increase  duplication ratio  addition assemble true   contiguous contigs  increase  number  global  local misassemblies hence  improvement   result  na50  mostly false positive  clear  string graph assemblers   sga would  work effectively  assemble contigs  contigs may start overlap   middle   contigs     cover  string graph  definition   compute  overlap   end   read contigs   case   switch  assemblers  use   bruijn graph among  assemblers   base   bruijn grapg   take contigs  input data  test  assembler   best contigsonly assembly result  find velvet   best choice moreover  several experiment  vary  kmer length use  run velvet  assemble  contigs kmer value    well  provide  expect coverage   input data  velvet       number  partition lead   best contigs assembly result  result  run velvet  contigs assembler   comparisons   result  minimus2  provide  additional file  table s11  denote  result  combine contigs  ckmer       number  partition    coverage   partition  kmer   use kmer   assembly   partition   denote  resultant contigs  merge  partition contigs  mkmer   reassembly step   step  merge  combine contigs   reassemble    read   accomplish     select  assembler  take long sequence contigs   input  assemble contigs  well  assembler preferably   base   bruign graph   reason spade  velvet   convenient candidates  test     two genomes spade produce better reassembly result  velvet detail   test   comparison result  provide  additional file  table s12  s13 hence  reassembly result   paper  perform use spade assembler  denote  step  hgakmer contigs  kmer   kmer length   use   reassembly process contigs  whether  merge contigs   combine contigs   general    follow flow bkmer hga preprocessing flow mkmer    ckmer   hga reassembly flow hgakmer mkmer    hgakmer ckmer   reassemble  read  long sequence contigs  several advantage firstly  contigs  produce   assemble   read together   combine  merge contigs   assembly  different partition     correct  refine  term  errors much longer also    redundant contigs mean     already produce   assembly    whole read instead   assemble  several disjoint subsets hence   structurally different  well    produce   subset    read    reassemble  moreover  experience  reassemble contigs   produce   read dataset     dataset   improve  assembly  even  deteriorate  new assembly secondly reassemble long sequence contigs may lead   different connect components  get connect finally   path find process  may increase  chance  select  true paths  traverse  longest path  induce   long sequence   input data   explore  justify  advantage   reassembly step  perform  simple test   real dataset   abscessus bacteria  dataset  use   study   describe   next section  assemble  real hiseq dataset   abscessus along   genome   abscessus  use spade assembler   range  kmer lengths      na50 result   assembly  kmer       length   genome   abscessus  indicate   assembly  contigs   read   computationally indeed effective  could lead   optimal assembly    correctness   contigs  better  reassembly result",-0.17171092919291553,0.22056887648098925,0.08659967835570913,0.10861402573558963,0.030138228153394363,-0.017373292530603275,-0.0888555720072665,0.07114256613038718,-0.016385379306033367,0.0692372410680385,0.05445733897020097,-0.030630200743196126,0.14955095019869982,-0.05010115623741785,0.10520112781830956,-0.030657989362235183,0.04401966714265993,0.1887045530195952,-0.032689366002369734,0.05284483873867736,0.02153393944170512,-0.1625613886297722,0.08413800243116931,-0.008875372781714037,0.004135758031203638,-0.1711228390412498,0.06351077761895238,-0.1613656674778172,-0.030718149662536037,-0.04057792517884568,-0.01814858795704657,0.22808894681991165,-0.13720906774829364,-0.12356719537401326,0.17201888077873112,0.11117362983056082,0.050041314011581454,-0.004277196833446776,-0.08056566796251488,-0.08327679141602427,-0.06168212678891196,-0.1330112579103032,-0.08159441305318324,-0.11242704849544756,-0.1308823769479462,-0.03630592094606285,0.13501181841089716,-0.14483595659496173,-0.16968394717809027,-0.3065291322013632,0.13526742492944216,-0.01190757830358377,0.060314455431375126,0.5442365926489957,0.017285244667406368,-1.0851203863731442,0.03899123478103967,-0.15284273843494858,0.8616694366168891,0.15197840468848633,-0.17058405300776175,0.2916736199671471,-0.061740481159637574,0.08079536363062036,0.5378608582956897,0.03281978640113798,0.05806614182647464,0.02193929108343725,0.1957395847488361,-0.1836868248692912,-0.034310413192144264,-0.004999754164371581,0.06962197630732196,-0.08990003753898376,0.1927152402378775,-0.03086483733284866,-0.11173806608273536,-0.13320198745388548,-0.3457330186677769,-0.0654257254899917,0.1688144294470156,-0.02208493438433536,-0.33925117618890765,-0.020686527444636376,-0.7892778367619947,0.02879339015814708,0.1623320106253165,-0.11322080026554272,-0.12374714047041795,-0.04149958897197773,-0.17681916295324654,0.08560754074421748,-0.12030615288613905,-0.10249023115093724,-0.1402349189605828,-0.10618727493467753,-0.06439280313662109,-0.28536766277824155,0.27501304902886664,0.09190252320743178,Assembly,5
98,98,"velvet algorithms   novo short read assembly use  bruijn graphs
  develop  new set  algorithms collectively call “velvet”  manipulate  bruijn graph  genomic sequence assembly   bruijn graph   compact representation base  short word kmers   ideal  high coverage  short read   data set apply velvet   short read  pairedends information  one  produce contigs  significant length    n50 length  simulations  prokaryotic data   n50  simulate mammalian bacs  apply  real solexa data set without read pair velvet generate contigs      prokaryote      mammalian bac  close agreement   simulate result without readpair information velvet represent  new approach  assembly   leverage  short read  combination  read pair  produce useful assemblies
velvet parameters velvet  implement    test   bite linux machine  result  velvet   sensitive   parameter   mention previously  optimum depend   genome  coverage  quality   length   read one approach consist  test several alternatives  parallel  pick  best another method consist  estimate  expect number   time  unique kmer   genome  length   observe   set   read  length    link  number   traditional value  coverage note    relations formula experience show    parameters   set          practice give  limit number  possible value     common  try  various value  parallel  choose  one  produce  highest n50 contig length  tour bus algorithm decide whether  merge two paths base  three thresholds firstly  paths must contain less   nod secondly  respective sequence must  shorter     thirdly  sequence must   least  similar experimental data  experimental trials  run  human bac bcx98j21  illumina  read  available  illumina  info@solexacom    read come    tile  lane   flowcell    select  illuminas inhouse “purity filter” velvet  run   hash length      coverage cutoff    experiment   suis  run   sanger center  strain   data  available      read come    tile   single lane  first lane   flow cell  use   read   pass  purity filter    filter  supply   solexa software velvet use  hash length     final coverage cutoff    test  coverage               respectively   read  data set   publicly available   short read archive      service comparative test  run  ssake version  vcake version  sharcgs euler version   velvet version   settle different definitions   consider contigs longer    ssake  vcake  run  default options simulations simulations  run   coli k12 genome genbank u00096  cerevisiae chromosomes   viii sgd1 assembly  elegans chromosome   position    ws170 assembly human chromosome   position    ncbi  assembly  first  unpaired simulations  run  coverage depths               read  randomly place  randomly orientate   genome errors  simulate  random mutations uniformly distribute   read   rate    pair read simulations   run  random  read   coverage     read  pair  insert lengths vary   standard deviation   alignments  scscs onto  reference    exonerate slater  birney    nonequivalenced regions ner model exonerate  able  jump   buffer regions  connect  scscs thus form long alignments",-0.12903225265546805,0.17912506636025174,0.08665679331196265,0.12047543139507373,0.003574550096980399,-0.00974728239286277,-0.03891350810778224,0.0663426628926148,-0.09505971833028727,0.06229428078565333,0.01688303072108991,-0.004138784565859371,0.17747080543233704,-0.033207941692736415,0.15702216908956568,0.01359835013333294,0.08366814497030442,0.19824905018839573,-0.03502183881290774,0.011143826695366038,0.033716852948483485,-0.2048184744330744,0.11246544883715816,-0.008232229055008955,0.03240191036524872,-0.1710283656501108,0.10249135482642384,-0.1693903521914035,-0.03282443430481685,-0.023920728070661427,0.02904656944227301,0.2853050551522109,-0.1488219550370963,-0.07766594582858186,0.2804816563113127,0.1395846877164311,0.004713582567637787,0.030992212351993655,-0.07792793751383821,-0.09291415586653684,-0.04226477885748156,-0.11195958163466356,-0.11485184298983465,-0.13058192815528147,-0.15785321112101278,0.018369894525838187,0.08763259842060506,-0.18859791895374656,-0.22490915331472125,-0.2727496735891327,0.1398753784167477,0.04292884150675187,0.05183134427501096,0.5384954032301903,0.0015904459256368376,-1.1571935595571994,0.04124933440626288,-0.11937217708418353,0.9287804361375877,0.21284990031622228,-0.1744499674145805,0.3024078688356611,-0.019913858219774237,0.08959388870952859,0.561106538027525,0.06327661831397563,0.028173193006465837,0.0030690674587256373,0.1560786086310529,-0.18033517632090176,-0.10761983614945267,-0.021063616917365132,0.10605909889188804,-0.12811731257217213,0.1757789277181857,-0.0415058552639352,-0.1121968184903057,-0.17877120040926253,-0.35088398492377665,-0.0992988530251508,0.1976436338140047,-0.031367880396493186,-0.34409071682124504,-0.03239431581046018,-0.8005532523901719,0.12586944007056042,0.2406318902345892,-0.1475229768620597,-0.0926233650257604,-0.02942252788382272,-0.2072412627014435,0.10365705697072876,-0.1365155770883171,-0.10120199522624414,-0.14140453987030518,-0.0712910920754075,-0.1042786211680828,-0.288359604186068,0.2916359718785518,0.06672118062360419,Assembly,5
99,99,"metavelvet  extension  velvet assembler   novo metagenome assembly  short sequence reads
 important step  metagenomics analysis   assembly  multiple genomes  mix sequence read  multiple species   microbial community  conventional pipelines use  singlegenome assembler  carefully optimize parameters  limitation   singlegenome assembler   novo metagenome assembly   sequence  highly abundant species  likely misidentified  repeat   single genome result   number  small fragment scaffold  extend  singlegenome assembler  short read know  velvet  metagenome assembly   call metavelvet  mix short read  multiple species  fundamental concept   first decompose   bruijn graph construct  mix short read  individual subgraphs  second  build scaffold base   decompose  bruijn subgraph   isolate species genome  make use  two feature  coverage abundance difference  graph connectivity   decomposition    bruijn graph  simulate datasets metavelvet succeed  generate significantly higher n50 score   singlegenome assemblers metavelvet also reconstruct relatively lowcoverage genome sequence  scaffold  real datasets  human gut microbial read data metavelvet produce longer scaffold  increase  number  predict genes
information obtain   dna sequencer   set  sequence fragment call read  rather   entire genomic dna sequence therefore genome assembly  require  reconstruct  original genome sequence  sequence read although  read  short   possible  reconstruct longer sequence call contigs   identify  overlap  read  merge  read genome assembly  generally perform   follow step   large amount  read sufficient  cover  genome  give   assembly program overlap exist   read   contigs  obtain  merge  read  term coverage   position   contig  define   number  read  overlap   position  coverage   contig  define    average  coverages   position   contig  input   set   nucleotide sequence  dna fragment  overlap  every pair  sequence  calculate  pairwise alignment  pair  sequence  significant overlap  merge  obtain  longer sequence   step     repeat first  briefly review   bruijn graphbased assembly method  single genomes   velvet assembler upon   method  base second  describe  extension  velvet  metagenome assembly  bruijn graphbased assembly  previous conventional assembly method  base   socalled overlap graph   read  assign   node   edge connect two nod   correspond read overlap  assembly problem  reduce  find  path visit every node exactly    overlap graph    hamiltonian path problem however  hamiltonian path problem  nondeterministic polynomial timecomplete npcomplete furthermore  overlapgraphbased assembly method cannot work effectively  apply   short read generate   nextgeneration sequencer     many short overlap  short read     overlap  false therefore several  novo assembly methods base   bruijn graph   propose  short read generate  nextgeneration sequencers            bruijn graph   data structure  compactly represent  overlap  short read  notable difference    bruijn graph   overlap graph     mer word  length   instead   read  assign   node  thus  size    bruijn graph become independent   size   input  read  detail definition   bruijn graph  show  give  set  sequence read   bruijn graphbased assemblers first break  read accord   predefined  mer length   clear  two adjacent  mers   read overlap      nucleotides second  direct graph  bruijn graph  construct   give sequence read  follow  overlap     mer  encode   node   direct graph     mer  represent   direct edge   graph   mer  encode   direct edge  connect  node label  first     mer    mer   node label  second     mer   construct  bruijn graph  read  map   path traverse  graph therefore  assembly reconstruction   target genome    bruijn graph   reduce  find  eulerian path brief outline  velvet    bruijn graph representation  velvet   bruijn graph  implement slightly differently    node represent  series  overlap  mers  adjacent  mers overlap      nucleotides  node  label   sequence   last nucleotides    mers  figure   furthermore  node  attach   twin node  represent  reverse series  reverse complement  mers  read  opposite strand   input read  order set  overlap  mers  define next  order set  cut whenever  overlap  another read begin  end   uninterrupted order subset  original  mers  node  create two nod   connect   direct edge  two nod  connect  last  mer   origin node overlap      nucleotides   first   destination node new direct edge  create  trace  read   construct graph second velvet execute three function simplification  node merge  remove tip  remove bubble  error removal simplification merge two nod  one node   one outgo edge      one incoming edge  tip   define   chain  nod disconnect  one end  remove  bubble   define  two redundant paths  start  end    nod  contain similar sequence  merge  tip  bubble  create  sequence errors  biological variants   single nuleotide polymorphisms snps   coverage   node  define   coverage   contig assign   node finally two function pebble  rock band  call  construct  scaffold   repeat resolution use pairedend information  long read information   function velvet distinguish  unique nod   repeat nod base  node coverage  repeat node represent  sequence  occur several time   genome simply put  repeat node    cross point  two paths  multiple incoming  outgo edge note   multiple genome assembly  nod   cross point  two paths   necessarily repeat  nod  sometimes share   genomes  two closely relate species  represent orthologous sequence conserve sequence   rrna sequence  horizontal transfer sequence extension  metagenome assembly  metavelvet assembler consist  four major step  construction    bruijn graph   input read  detection  multiple peak   mer frequency distribution  decomposition   construct  bruijn graph  individual subgraphs  assembly  contigs  scaffold base   decompose subgraphs  step    give set  mix sequence read generate  multiple species metavelvet construct  main  bruijn graph use velvet function  step  metavelvet calculate  histogram   mer frequencies  detect multiple peak   histogram    would correspond   genome  one species   microbial community  expect frequencies   mer occurrences  show  follow  poisson distribution   singlegenome assembly      expect  mer frequencies  metagenome assembly  show  follow  mixture  poisson distributions    hence metavelvet approximate  empirical histogram   mer frequencies   mixture  poisson distributions  detect multiple peak   poisson mixture furthermore metavelvet classify every node  one peak   poisson mixture  step  metavelvet distinguish  subgraph compose  nod belong    peak    subgraphs   main  bruijn graph metavelvet identify share nod chimeric nod  two subgraphs  disconnect two subgraphs  separate  share nod  step  metavelvet build contigs  scaffold base   decompose subgraphs use velvet function  essential part  step    design  develop  algorithm  identify  separate chimeric nod   main  bruijn graph  two species contain  common  similar subsequence   genomes  main  bruijn graph contain  node assign   subsequence  two incoming edge  two outgo edge one   come  one species    come    species    hand   genome  one species contain  repeat subsequence    subsequence  multiple occurrences   genome   bruijn graph also contain  node assign   repeat subsequence  two incoming edge  two outgo edge   nod   main  bruijn graph must   one incoming edge  one outgo edge  distinguish  chimeric node   repeat node  method use coverage difference although  origin nod  two incoming edge   repeat node     mer frequencies  origin nod  two incoming edge   chimeric node belong  two different species  hence  different  mer frequencies  formal definition  chimeric node  give   cross node satisfy  follow three condition  necessary condition  number  incoming edge     number  outgo edge    sufficient condition  origin nod  two incoming edge      belong  two different peak   destination nod  outgo edge      also belong    two peak   origin nod  iii sufficient condition  chimeric node   confluent node coverage   two origin nod  precisely  node coverage   candidate chimeric node      cov    cov    cov    cov          cov    cov    cov    cov         cov represent  node coverage   node      parameter  metavelvet call allowable coverage difference   candidate  chimeric node  identify  candidate node  check  consistency  pairedend information   significant amount  pairedend read connect  origin node   incoming edge   chimeric node   destination node label differently   origin node    pairedend read connect  origin node label    destination node label   vice versa  show  figure    candidate node  discard  detail procedure  metavelvet   follow  might  think   substep    chimeric node could   highest expect coverage however  contigs  chimeric nod   short compare   unique nod therefore  lengthweighted frequencies  coverage value   chimeric nod   form  significant peak  construction    bruijn graph    give set  sequence read generate  mix species construct   bruijn graph  call velvet first stage function  detection  multiple peak  kmer frequencies  calculate  empirical distribution  lengthweighted frequencies  node coverages   node coverage  assign   node  velvet   construction    bruijn graph  figure    approximate  empirical distribution   mixture  poisson distributions  detect multiple peak   poisson mixture   highest peak  expect coverage  choose   primary expect coverage   next highest  choose   secondary expect coverage  classify every node  one distribution   poisson mixture  calculate  posterior probability   node coverage value  decomposition    bruijn graph  decomposition  connectivity decompose  initial  bruijn graph  connect subgraphs  decomposition  coverage value   coverage   node belong   primary expect coverage  node  classify   primary node subsequently  primary nod  label      nod  label     chimeric node  detect   two incoming edge whose origin nod  label     two outgo edge whose destination nod  label       coverage value mostly equal within  difference  default   average   sum   coverage value   two origin nod   sum   two destination nod second check  consistency      label   two origin nod  two destination nod use pairedend information   consistency  satisfy resolve every chimeric node  separate  node  two nod   one incoming edge  one outgo edge whose origin  destination nod    label  show  figure    separate  chimeric nod  decompose  result graph  connect subgraphs    connect subgraph consist       predefined parameter  default  set    nod label   subgraph  unmask   subgraphs  mask  assembly  contigs  scaffold  apply  velvet function   unmask subgraphs  build contigs   apply pebble  rock band function  build scaffold  remove  unmask subgraphs  recursively apply step    remain  bruijn graph   node remain",-0.21344615211072446,0.2051291621896145,0.08482840771576364,0.17801290919800122,0.029686203092808693,0.010297123918011594,-0.1275627042910033,0.0954391415744433,-0.01637741189373479,0.12694297724033465,-0.010648839118290846,0.04792781606099683,0.21021267491949355,-0.02737573906874973,0.16704081660495396,-0.03962358692979874,0.03003276674832817,0.22797743907327486,-0.008806845738491909,0.044960499481833865,0.04596699701481792,-0.2180025213423555,0.04248941056446287,-0.0428910274806509,0.010639691258276723,-0.17465755040175282,0.07911841449445776,-0.1847057544588022,0.01002827472083768,-0.09337304987839412,0.009341062156623869,0.2738852036599395,-0.14926675445071666,-0.08782854391571313,0.2168044141095853,0.06666716123829047,0.060051656514406214,-0.0293459559572312,-0.06789061508447647,-0.11472623110844513,-0.08146902051354019,-0.13544776986224724,-0.061954469732901925,-0.08693966595456004,-0.11689625421813242,0.006777132067379657,0.13947207803378672,-0.11278817629655312,-0.2837415724983184,-0.32743738460871197,0.13555368652363142,0.008284294484693505,0.12076240194680755,0.6285145091361761,0.035991003222074616,-1.2327130614760753,0.040044552476579086,-0.2128025575473981,1.0276061411474973,0.26686729975634776,-0.17169264163574752,0.3492067148446501,-0.039329109016219034,0.04552877535644842,0.6874893231853231,0.04495776845812032,0.052937713214626834,0.03675978555187213,0.15819131851767199,-0.2325067212650463,-0.10426521280442352,-0.058583225417014675,0.1113783960594247,-0.14483307780672425,0.2424069683360931,-0.10305738931789687,-0.13560759776769435,-0.17318031425613348,-0.3726216450027407,-0.05338030419701532,0.1603412182257297,-0.058966458528717236,-0.4149624198981344,-0.04188737240780427,-0.8633082332140575,0.10395019090421856,0.2213054528766095,-0.144611699680785,-0.1031223033146601,-0.048565603259628734,-0.2433031288613501,0.08757640415681399,-0.1819265379518197,-0.09281835957073084,-0.16402584320342498,-0.1173805155816858,-0.10840879309163363,-0.3456602710886055,0.283737745003341,0.07638871924065002,Assembly,5
100,100,"rnnotator  automate  novo transcriptome assembly pipeline  strand rnaseq reads
comprehensive annotation  quantification  transcriptomes  outstanding problems  functional genomics  high throughput mrna sequence rnaseq  emerge   powerful tool  address  problems  success  dependent upon  availability  quality  reference genome sequence thus limit  organisms      apply   describe rnnotator  automate software pipeline  generate transcript model   novo assembly  rnaseq data without  need   reference genome   apply  rnnotator assembly pipeline  two yeast transcriptomes  compare  result   reference gene catalog   organisms  contigs produce  rnnotator  highly accurate   reconstruct fulllength genes   majority   exist gene model  furthermore  analyse reveal many novel transcribe regions   absent  well annotate genomes suggest rnnotator serve   complementary approach  analysis base   reference genome  comprehensive transcriptomics  result demonstrate   rnnotator pipeline  able  reconstruct fulllength transcripts   absence   complete reference genome
library construction  sequence  candida rnaseq library construction  sequence  describe elsewhere  read quality filter  duplicate read removal conditionspecific read  pool together  identical read  remove  remove duplicate read read error filter  perform use  rare kmer filter approach  frequency   kmer  calculate use  hash table  read contain rare kmers   use   assembly rare kmers  define    occur less  three time   set  unique read several rare kmer read filter strategies  test  order  determine  effect   read filter  three filter strategies    filter apply  filter apply  remove duplicate read  iii filter apply  remove duplicate read additional file   order  filter  duplicate read removal  significant since  kmer   likely    low abundant kmer  duplicate read removal    discover  filter read prior  assembly reduce  runtime  memory require   assembly   cost  slightly decrease  assembly quality multiple velvet assembly  assembly  short read illumina sequence  velvet assembler  use  conjunction   amos assembly package   eight run  velveth  execute  parallel    hash length    next eight run  velvetg  run  parallel  parameters cov_cutoff   exp_cov  auto prior  merge contigs  duplicate  remove  contigs  combine   single fasta file  minimus2 pipeline   lightweight assembler   part   amos package  run use refcount    parameters default split contigs use strand rnaseq  protocol use  split misassembled contigs use strand rnaseq read include  split contigs  long stretch  less  three map read   longer  one read length  orient contigs   correct mrna sense strand orientation iii generate  consensus contig  count  number  acgt residues   base position bwa   use  align  read   assemble contigs align contigs   reference  ucsc blat software   use  align contigs   genome  transcriptome reference  yeast datasets  maximum intron size  set     case   best hit  take unless   multiple bestscoring hit  score   alignment  calculate   formula   match  mismatch  recommend  similar strategy  use  align gene model  contigs sc5314   take  best score hit detect gene fusion events gene fusion events  detect  first align contigs   reference genome outline  genomic coordinate   align contig  compare   genomic coordinate  every annotate gene  contig  gene  consider overlap   share  overlap   longer     gene length contigs contain two    genes  identify  contain  gene fusion event compare   assemblers  perform  singlerun velvet assemblies   oases assemblies hash length   use    base pair read lengths   parameters  set   default parameter set contigs      length  use  comparison   assemblers   multiplek assemblies eight velvet assemblies  first perform  order    fair comparison   rnnotator assemblies   hash lengths  use  run velvet           multiplek script   run use  eight velvet assemblies  input",-0.23380649352593455,0.17852849167628354,0.11430848096537155,0.15108963295282066,0.015752893369087678,-0.029985066040610082,-0.06414549278083424,0.07283621499191524,-0.07198281682088463,0.1259569192542018,0.02758937570267421,-0.02945445341050115,0.14727320903553984,-0.05448699865419802,0.12431925988326277,0.0328117775468108,0.08030759074932171,0.19124583683362725,-0.01276994605748178,0.04305685593290892,-0.020700669057396613,-0.2322188964124538,0.07159172202899264,0.011763058225703863,0.01378191084577105,-0.19680840072309613,0.06537908196643802,-0.12224309754947947,-0.021840513520799455,-0.0570266742993576,-0.003721368844863664,0.26035273726836783,-0.17333875032443788,-0.08442421234262566,0.2121553915329168,0.07276652175654523,0.04801006323476839,-0.0024418924936654572,-0.1275972683722965,-0.0886234450353007,-0.04580656829952764,-0.1593552981612758,-0.1057697989369452,-0.10482447381722383,-0.1661605615072792,-0.011939554381717602,0.11513697870899565,-0.1821133714404582,-0.2730742928175988,-0.3140002074457395,0.11213441445336987,0.012407988580998478,0.0671538412760004,0.5735240859481004,0.03566411278398636,-1.2039829893276477,-0.007218646502488444,-0.19767050999694336,0.9802679924143112,0.2385738155484681,-0.20145090859899253,0.372928553674784,-0.012196255815971613,0.0523992319448063,0.5879305464814568,0.0228989079547847,0.032238304645414974,0.04755884918168338,0.18605660304574406,-0.21114471820446773,-0.04972640075361713,0.01617762264517001,0.14457849015192722,-0.11748484176340808,0.19570328407168675,-0.016615295225483738,-0.16511777199458522,-0.16022894305025792,-0.3752278070031211,-0.0654580061424436,0.2163720445157204,-0.05330030353934878,-0.3790510745249434,-0.007140976591752127,-0.8593549448325155,0.09468660689293383,0.261351932617776,-0.18351662742870992,-0.14428150352328406,-0.035493873382130496,-0.15260121683613995,0.11077174081558633,-0.14464113267691325,-0.07958609413785431,-0.12620836338495964,-0.06932672435909303,-0.06219676788498321,-0.3277704429466469,0.3311105612187813,0.07254231632806551,Assembly,5
101,101," fast hybrid short read fragment assembly algorithm 
 shorter  vastly  numerous read produce  secondgeneration sequence technologies require new tool   assemble massive number  read  reasonable time exist shortread assembly tool   classify  two categories greedy extensionbased  graphbased   graphbased approach  generally superior  term  assembly quality  computer resources require  build  store  huge graph   high   article  present taipan  assembly algorithm    view   hybrid   two approach taipan use greedy extensions  contig construction    step realize enough   correspond read graph  make better decisions    assembly  continue  show   approach  achieve  assembly quality  least  good   graphbased approach use   popular edena  velvet assembly tool use  moderate amount  compute resources
input  taipan   multiset  read   length   consist   original read plus  reverse complement  minimal overlap parameter     threshold    store   hash table  hash table allow efficient process  query   form get_overlapping_readsst   dna string   ∈{… }  return  read   whose prefix  match  suffix    taipan assemble  new contig  choose  read     seed  seed  iteratively extend  ′ direction  one base   time    either insufficient overlap read   repeat  find subsequently   algorithm  use  ′ direction  algorithm  extend contig   ′ direction   single base work  follow  set   overlap read  retrieve   hash table  call get_overlapping_readsst   ∈{… } afterwards  direct overlap graph    construct   ∈  suffix    match prefix      ∈{… } ′   ′   build  remove  associative edge    ∈  associative   exist two  edge    ∈  set  consist   vertexdisjoint paths  ′  determine   analyze  determine  singlebase extension   use threshold   follow    contain  least two paths    length  ≥  ∈{ }   repeat  find  extension    terminate    contain exactly one path   length  ≥     extend   first nucleotide   first read      contain  path   length  ≥     insufficient overlap read  extension    terminate   none    case apply ′  enlarge along  path    rule   recursively apply    maximum   step   enlarge graph   assembly   new contig  read  exactly match  contig  remove     hash table  implementation  taipan gain efficiency   fact    slightly change  subsequent extensions   use  sort trie data structure  represent ⊥    choice  seed  affect assembly result taipan select  unassembled read  highest occurrence  seed  order  minimize extensions  read contain sequence errors",-0.21059209923675684,0.2165964467248636,0.09418175414889232,0.17657231247340816,0.038626161580655856,-0.017611035478087917,-0.11971656721046504,0.11167183878898783,-0.055420457684834085,0.1410832750455787,0.032599143338822086,-0.012658739987749695,0.1592721446456077,-0.08050275938668554,0.1427057518144249,-0.07541201020164105,0.03331843998915117,0.2161692457427437,-0.07079065769738961,0.1090177565485993,0.08240575014497152,-0.22177200778692385,0.04963236835707599,-0.04032597393753739,0.022601916371578615,-0.15982143761080114,0.035027586857766094,-0.24743470065073955,-0.005283219785529322,-0.09240756205482674,0.004396783473480138,0.3017434160976249,-0.17197265520337082,-0.133760587877727,0.16512584889954138,0.11352608344930645,0.03744941428470026,-0.08420735729270659,-0.07806859045965775,-0.13735875567709582,-0.09004614274904486,-0.18614196535600055,0.003131306859792121,-0.12517307856718876,-0.08608771791443272,-0.017040488755832313,0.10974379864499152,-0.1686701529265736,-0.1470962046386419,-0.3913834505004897,0.11906150404352694,0.001231957870047717,0.09260908797677117,0.6783617316257387,0.01823215328373148,-1.32585527051595,0.07680999892043128,-0.16465209465726124,1.137856622392844,0.22211372522378087,-0.2253464646618384,0.3161617188736619,-0.1324822471374535,0.09923167242024128,0.6785538578045643,-0.01073869424622639,0.06172717488065939,0.07596449510310778,0.15013575230425755,-0.2400560218818663,-0.05822778090721061,-0.018532909281064,0.07151074252639471,-0.1835509502811224,0.2740339916185587,-0.029720638023545257,-0.15129877446867926,-0.16462801052083315,-0.37247949103558703,-0.07271799866949939,0.2656275385303334,-0.04367286985507235,-0.39818351143843583,-0.09696288740087766,-0.9066348615645742,0.060704262485073525,0.2493982605353397,-0.16454196245259872,-0.11036768752715684,-0.05531472469946103,-0.21403810770494772,0.04746263148470981,-0.1664900849171404,-0.08856558598511452,-0.1608336221217455,-0.14516582516496004,-0.06840117698274775,-0.320643428918196,0.36499238669473133,0.10109563698712183,Assembly,5
102,102," novo transcriptome assembly  abyss
whole transcriptome shotgun sequence data  nonnormalized sample offer unique opportunities  study  metabolic state  organisms one  deduce gene expression level use sequence coverage   surrogate identify cod change  discover novel isoforms  transcripts especially  discovery  novel events  novo assembly  transcriptomes  desirable transcriptome  tumor tissue   patient  follicular lymphoma  sequence   base pair  single  pairedend read   illumina genome analyzer  platform  assemble  million read use aby    contigs    longer   maximum contig length     represent   million base pair  unique transcriptome sequence  roughly    genome
patient sample  transcriptome data belong   patient  present   years  age  bulky stage   intraabdominal follicular grade  nonhodgkin lymphoma base   inguinal lymph node biopsy  stag bone marrow biopsy reveal  lymphoma initial treatment consist  eight cycle  cvpr cyclophosphamide vincristine prednisone  rituximab chemotherapy  produce  partial response however within  months symptomatic progression  lymphoma  evident within  abdomen   repeat inguinal lymph node biopsy reveal residual grade  follicular lymphoma  obtain inform consent   patient approve   research ethics board  material   biopsy  subject  genomic analyse include whole transcriptome shotgun sequence wtss  library construction  sequence rna  extract   tumour biopsy sample use allprep dnarna mini kit qiagen usa  dnasei invitrogen usa treat follow  manufacturer' protocol  generate three wtss libraries one  amplify complementary dna cdna another    amplify cdna  normalization   last  unamplified cdna  follow  wtsslite  normalize wtsslite libraries doublestranded amplify cdna  generate    rna  templateswitching cdna synthesis kit clontech usa use superscript reverse transcriptase invitrogen usa follow  amplification use advantage  pcr kit clontech usa   cycle reactions custom biotinylated pcr primers contain mmei recognition sequence  use  facilitate  removal  primer sequence  cdna template  wtsslite library construction normalize cdna  generate  2μg    amplify cdna use trimmer cdna normalization kit evrogen russia follow  amplification use   biotinylated pcr primers   single  cycle reaction  advantage  polymerase clontech usa  normalize  amplify cdna pool generate    duplexspecific nuclease dsn enzyme dilution  choose    template  wtsslite normalize library construction   wtsslite  normalize wtsslite libraries  removal  amplification oligonucleotide templates   cdna end  accomplish   bind   streptavidin bead invitrogen usa follow  mmei digestion  supernatant  digest  purify  prepare  library construction  follow roughly    cdna template  sonicated   min use  sonic dismembrator  cup horn fisher scientific canada  size fractionate use  page gel    size fraction  excise  library construction accord   genomic dna sample prep kit protocol illumina usa use  cycle  pcr  purify use  spinx filter tube fisher scientific  ethanol precipitation  library dna quality  assess  quantify use  agilent dna  series  assay  nanodrop  spectrophotometer nanodrop usa  dilute     unamplified wtss library  use   rna  purify polyarna fraction use  macs mrna isolation kit miltenyi biotec germany doublestranded cdna  synthesize   purify polyarna use superscript doublestranded cdna synthesis kit invitrogen usa  random hexamer primers invitrogen usa   concentration     cdna  shear  library  construct  follow   genomic dna sample prep kit protocol illumina usa  sequence derive cdna libraries  use  generate cluster   illumina cluster station  sequence   illumina genome analyzer  platform follow  manufacturer' instructions  run seven lanes    two amplify libraries  generate   single end tag set read  seven lanes   unamplified library  generate   pair end tag pet read  assembly method  assemble  read use aby simpson     aby algorithm  base    bruijn digraph representation  sequence neighborhoods  bruijn    sequence read  decompose  tile subreads  length kkmers  sequence share  base  connect  direct edge  approach  introduce  dna sequence assembly  pevzner      follow  others butler    chaisson  pevzner  jackson    zerbino  birney  although memory requirements  implement  bruijn graph scale linearly   underlie sequence aby use  distribute representation  relax  memory  computation time restrictions simpson      bruijn graph capture  adjacency information  sequence   uniform length  define   overlap   last   first  character  two adjacent kmers aby start  catalog kmers   give set  read  establish  adjacency represent   distribute data format  result graph   inspect  identify potential sequence errors  smallscale sequence variation   sequence   read error  alter   kmers  span   form branch   graph however since  errors  stochastic  nature  rate  observation  substantially lower    correct sequence hence    discern use coverage information  branch  low coverage   cull  increase  quality  contiguity   assembly   especially true  genomic sequence  transcriptomes however sequence coverage depth   function   transcript expression level  represent therefore  cull need   perform  extra care accordingly   assembly stage  apply trim   false branch   absolute coverage level    threshold  fold    analysis stage  evaluate assembly branch use  local coverage information  well  contig lengths  instance   neighborhood   contig  branch  contig     coverage level       contig lengths     respectively      significantly higher      shorter   threshold   assume     false branch  repeat read errors  smallscale sequence variation  approximate repeat  alleles result     branch merge back   trunk    bruijn graph  call  structure bubble  remove    assembly since  may represent real albeit alternative sequence   location  preserve  information  carry  record    special log file along   variant  leave   assembly contig   coverage level  log entries  later use  postulate effect  allelic variations  expression level   false branch  cull  bubble remove unambiguously linear paths along   bruijn graph  connect  form  single end tag assembly set contigs  branch information  also record   subsequent pair end tag assembly pet stage   analysis   set stage every kmer represent   assembly contigs   unique occurrence use  information  apply  streamline readtoassembly alignment routine  use  align read pair   infer read distance distributions  pair  libraries  form  read set   identify contigs     certain neighborhood define   distributions  adjacency   neighborhood information  use   pet routine  merge set contigs connect  pair unambiguously  keep  list   merge set contigs   pedigree information   fasta header  backtrack  adjacency neighborhood  pedigree information along   contig coverage information  also use   assembly visualization tool abyssexplorer figure  show  abyssexplorer representation   set contigs   neighborhood note    edge   nod  polarize  accordance   directionality   contigs     mer overlap   respectively   interactive view   user doubleclicks   contig  direction  node connection polarizations flip  reflect  reverse complement pair end tag often resolve paths along set contigs    subsequently merge   pet stage  indicate  merge contigs  dark gray paths   viewer  one   contigs contribute   merge  select  abyssexplorer representation encode additional information include contig coverage indicate   edge thickness  contig length indicate   edge lengths  wave representation  use  indicate contig length    single oscillation correspond   userdefined number  nucleotides  long contig result  pack oscillations  obscure  arrowhead indicate  direction  resolve  ambiguity  envelope   oscillations outline  leaflike shape   thicker stem   shape mark  start   contig   thinner tip point   end  example contig       long contig   much longer   shortest contig       direction  still evident   shape   thinner tip point   right  perform  parameter search  assembly optimization  vary  value   range         set stage figure  show  key statistics   assemblies   function    pick  best assembly        number  contigs drop significantly       number  contigs    longer   increase  indicate  substantial improvement  contiguity beyond   number  contigs   categories keep decrease     assembly n50",-0.14850514668007062,0.16359476442957052,0.04787194579399216,0.09081370367018966,-0.02091877018740466,0.004265036978013426,-0.05858304950453655,0.11089567187108612,-0.021312683131913663,0.1097875593707286,-0.03792688845397359,-0.01477593124075454,0.10305396657501044,-0.032366560613684474,0.20324023967374527,0.03993181458900909,0.02127127658924051,0.1310476352745791,0.03145038635340972,0.02128398648110797,-0.041875185305543114,-0.21331331285224744,-0.007594653691295601,0.02403033320552896,0.02592134935802658,-0.0962128282443324,0.1045841672870412,-0.14064079304487132,-0.017370926773573974,-0.07296021382230974,0.04104628924630377,0.2187663706386435,-0.15249069582634864,-0.05817903690412835,0.1660520998186121,0.06929404819514913,0.060693986173680436,0.009958699815848498,-0.09025454015341314,-0.09225292433367407,-0.034491976490728334,-0.1543564381563726,-0.11815275333210895,-0.1117341589154056,-0.13913677601502406,0.013472256656257404,0.12230237359432755,-0.11755357602460645,-0.17817648933869312,-0.2836222888194141,0.13560485568917946,0.008754369815963508,0.08371082236862057,0.5120670169920093,-0.01855353162848544,-1.0150970204199885,0.020475480896035955,-0.20788155575021486,0.8559960850713902,0.20849652129010995,-0.11344521702678675,0.32563897211752296,0.029492034770213376,0.10945567735853236,0.5084767097025421,0.05195237512181352,0.028525058903393536,-0.022482386463055032,0.16732962892546654,-0.20862576706161173,-0.06317950878776378,-0.00562174711799977,0.1577607791586087,-0.10372797915072562,0.17483217436471749,-0.050451995714387535,-0.11170702326022428,-0.1604387599409978,-0.2974886973683767,-0.07568482723848068,0.13071574735127994,-0.026079758214899832,-0.33564908186040565,-0.008933758636619006,-0.7334822247215312,0.09409027719439884,0.22309564033391535,-0.12208332768215445,-0.10743853121535103,0.0020189572141949656,-0.1959833523685504,0.09629835036347026,-0.11719980999186495,-0.07036507839488018,-0.056818254047079235,-0.12846349136954224,-0.040477384494379424,-0.3210741025199649,0.2669524505261037,0.06776890536216465,Assembly,5
103,103,"allpaths  novo assembly  wholegenome shotgun microreads
new dna sequence technologies deliver data  dramatically lower cost  demand new analytical methods  take full advantage    short read   produce  provide  initial theoretical solution   challenge   novo assembly  wholegenome shotgun “microreads”   genomes  size      generate highquality assemblies   coverage  pair base simulate read model  real illuminasolexa read  bacterial genomes  campylobacter jejuni  escherichia coli assemble optimally yield single perfect contigs  larger genomes yield assemblies   highly connect  accurate assemblies  present   graph form  retain intrinsic ambiguities    arise  polymorphism thereby provide information    absent  previous genome assemblies    jejuni   coli  assembly graph   single edge encompass  entire genome larger genomes produce  complicate graph   vast majority   base   assemblies  present  long edge   nearly always perfect  describe  general method  genome assembly    apply   type  dna sequence data   short read data  also conventional sequence reads
kmer terminology pevzner     kmer   genome   sequence   consecutive base   kmer   adjacent  kmer  write  →        mer   genome whose first  base    whose last  base    follow     overlap     base  take  kmers  vertices   adjacencies  edge one obtain  graph call   bruijn graph   relate   distinct   unipath graph describe next unipath  unipath graph definitions informally  “unipath”   maximal unbranched sequence   genome  relative   give minimum overlap  formally consider   bruijn graph    sequence   length ≥   genome  expressible   sequence  successively adjacent kmers         case   lengthu               outdegree one         indegree one   cannot  lengthen without violate  constraints    “unipath” fig  branchpointfree circle  also unipaths  give kmer    occur   one unipath  every kmer   unipath  represent  one   instance     sense every kmer   lie  exactly one unipath two unipaths    “adjacent”   last kmer    adjacent   first kmer    allow   define  graph   call  “unipath graph” whose edge   unipaths sequence graph  represent knowledge   give genome use  direct graph whose edge  dna sequence  call  structure  “sequence graph”  unipath graph   compute exactly   genome  approximately  read  one example    assemblies  allpaths produce  connect component   sequence graph   connect component     graph    physically connect subgraph   disconnect   vertices  edge  include within   sequence graph may  divide   connect components   haploid genome whose sequence  completely know   one connect component   chromosome   component   branch    component   single edge    case branch represent  uncertainty   exact genomic sequence   diploid genome homologous chromosomes  merge   graph generally lead  bubble fig   place    polymorphism formally  fix   “sequence graph”   direct graph whose edge  sequence   property  whenever  →  →   edge  end   first edge perfectly overlap  begin   second edge  exactly    base  case     allow   case  edge abut    overlap note    represent edge  sequence  adjacent kmers   last kmer   first edge  adjacent   first kmer   second edge   computationally convenient  value     change  adjust  edge sequence  sequence graph   natural output format  fasta file   edge sequence  header line   form formula      vertex indices   edge  →  note   overall number  vertices  arbitrary  vertex number   contain  genomic information   indicate  edge  juxtapose   graph error correction  correct errors  read use  approach relate  pevzner      read  either keep    edit   discard   process     follow create  list   kmers   read     read  length    list       entries  give kmer occur  certain number  time   list let  denote  total number  entries   list  occur  time   list  example   list           would    expect  graph      sharp peak  low  especially    arise primarily  incorrect kmers  contain sequence errors   smooth hump  higher  arise primarily  correct kmers   contain sequence errors let    first local minimum   expect  lie   “sharp peak”  “smooth hump”    kmers  multiplicity less    incorrect whereas  kmers  multiplicity  least   correct  call  highfrequency kmers “strong”  consider various value       compute   thus define strong      value     kmers   read  strong  leave  read   otherwise     attempt  correct  read  make  “change” one  two substitutions  could  allow   process would take longer  change  assign  probability base   quality score   change base  consider  change  make   kmers   read strong    value    probable change   time  likely   next  probable change  make   probable change otherwise  discard  read kmer number  database  allpaths genome sequence  represent  one  three ways   sequence  base via kmer number  describe     sequence  unipaths  fix    fix collection   dna sequence close  reversecomplementation  “numbering  kmer space”   assignment   unique integer   kmer  appear      kmer appear     instance must  assign   integer  regard  number  “good”   tend  assign consecutive number  kmers appear consecutively   genome   reasonable  assume   exist   good number    know  sequence   genome  could walk    begin  end number kmers        change  number    hit  kmer   already  assign  number     know  genome  advance  need  algorithm  take read  input see methods “kmer number algorithm” give  good number   kmers    dna sequence     may  translate first   sequence  kmers    correspond sequence  kmer number            thence   sequence  close intervals  kmer number        call  “kmer path”  good kmer number thus enable  compact representation   sequence    importantly  kmer paths  compute may  represent   searchable database   form   sort vector  pair       kmer path interval      identify  kmer path  whence  come give  sequence    represent   kmer path  database allow rapid identification   sequence    share  kmer   software note see kmerpath{cch}  kmerpathinterval{cch}  implementation kmer number algorithm first  fix  terminology  collection  read  give  distinguish   kmer   “occurrence”   kmer   read   reverse complement  give kmer may occur several time     assign   kmer number   describe  process  define kmer number   three step give two sequence  “maximal perfect alignment”     choice   window  equal length   sequence    base   respective windows match exactly     windows cannot  extend  either direction without violate  match  build certain maximal perfect alignments   read  also  reverse complement    build   alignments  would  computationally prohibitive rather   give kmer  occur   read   reverse complement  consider  set     occurrences   pos  “”   numerical identifier   read “”   orientation    read  forward  reverse  “pos”   start position    read   define  “canonical” occurrence      element     lexicographically first read   call  canonical read associate      occurrence    create  maximal perfect alignment   read   give occurrence   read   canonical occurrence seed    alignments  share   sense  two different kmers may ultimately contribute    alignment      reduce  number  alignments   manageable level  methodology   step  adapt   algorithm  batzoglou     find  proper alignments  read seed   kmer  occur    give number  time   read assign temporary number   occurrences  kmers   read   reverse complement  temporary number system assign different number  occurrences    kmer  number  occurrences  read  consecutively start   number   continue  consecutive number   occurrences  read    forth      number   occurrence   kmer   read   number   reverse complement kmer   reverse complement read  set         large fix constant unless  kmer   palindrome   case  number  set   use  alignments  step   map kmers   arbitrary read  kmers   canonical read associate   kmers  assign  number via step  thereby cause  occurrences   give kmer     number software note see readstopathscorecc  implementation unipath generation  build  unipaths  kmer paths see methods “kmer number  database”  unipaths    convert  sequence  need  kmer path   sequence  kmer path intervals  first step  generate unipaths   find   kmer path intervals   appear       string together  intervals  form  unipaths  find  intervals  make   unipaths  note   interval   kmer path database  kmer number         path    come start   first kmer number   first interval   table  set  goal  find  longest branchless interval  kmer number contain  kmer number   form  kmer path interval   unipath    start   first interval  contain  kmer number  branchless interval  posit begin   first kmer number   interval  end   last kmer number   interval  proceed forward   database look  intervals  extend  posit interval   indicate branch within  lengthen  shorten  posit interval accordingly  soon   interval   database  encounter  begin   posit interval end work   posit interval  complete     unipath interval since  subsequent intervals   database   intersect  posit interval  process  repeat   next highest kmer number  yet   unipath interval   kmers remain   unipath intervals  hand    simple matter  build  unipaths       take  first last kmer number   give unipath interval look     database thereby determine  possible predecessors successors     exactly one join  give unipath interval   one   leave right  iterative join process produce  unipaths  paths definition give  read pair     library  fragment size distribution  ±  give   give  fix constant  typically   path across  read pair  closure   sequence  start   end    length             cover  read  perfectly match     way  one  walk     use overlap  read    ≥   one path across  read pair   paths across  read pair  mean   paths    obtain   way   find  paths across  give read pair first  assign numerical identifiers   read   set   use   search include  read   pair   find  minimal extensions   read   set conceptually    read  extend  give read  distinct ways   smallest amount  read  exactly one minimal extension read   multiple minimal extensions border  branch   genome  search  closure   minimal extensions therefore branch     branch  determine   content   genome  define  extension  must choose  direction without loss  generality  consider extensions   right  extension   read  align perfectly   give read    overhang  give read   right   end    base    identifier greater     give read  minimal extension   extension  cannot  find transitively      minimal extension       extension       also  extension    also find  subsumptions   read  read  subsume    align perfectly   overhang    leave  right  computation  minimal extensions  subsumptions    collectively   large set  pair    cross use   set  read    case  localize assembly   perform  depthfirst search   minimal extensions begin  one read   pair  terminate  branch   search either    read  encounter   suitable distance either directly  indirectly   read  subsume    maximum distance      exceed  make  result   search usable  solutions  store   graph structure    nod  read annotate   offset   start   search   read  consideration   extend   read   already lead  solutions  read   current search path  add   solution graph   last read  link   previously encounter extend read share  search result   read   allow   optimization   read  already  see   give offset     part   solution graph  branch   search   prune find seed unipaths  find  seed unipaths  idea   start   unipaths  iteratively remove unipaths   set   give iteration  test unipaths  removal   order  favor unipaths  higher copy number  secondarily   shorter unipaths  see   give unipath   remove  use read pair  find  closest unipaths   set     leave    right   give unipath  infer  distance   leave  right neighbor   distance  less   threshold set      give middle unipath   remove  iterations continue    unipaths   remove   set software note see unipathseedscc  implementation shortfragment pair merger  start   set  shortinsert pair   neighborhood    secondary read cloud  goal   condense  set reduce   smaller set  pair    process make  residual pair  informative   lengthen  “reads”   reduce     separation     end  first translate   natural  highly compact local representation    shortfragment read pair   neighborhood  specifically  use  read   neighborhood  define local unipaths  exactly   way  approximate unipaths   entire data set  define  read may   express   sequence  local unipaths   read   fall   unipath end  extend    end   unipath furthermore every read pair   representation  term  local unipaths  might look like  follow formula   local unipaths  symbolize        convenience   notation mean   predict gap   read   ±  kmers  right read   reverse complement    closure   read pair   form     wxxy   ellipsis  fill  local unipath symbols  local unipath   expressible   sequence  global unipaths  assign   local unipath  minimum   predict copy number     constituent global unipaths  “local copy number”   upper bind   number  time   local unipath  appear   genome   tool  hand  shortfragment read pair  admit  certain calculus  enable  condensation   smaller set  pair whose read  longer  whose separation sds  smaller  hence  tend   fewer closure  example suppose   pair formula    local copy number one     kmers long   may merge  two pair together yield  single pair formula one  whose read  longer  whose separation   smaller via several similar rule  shortfragment read pair may typically  condense   much smaller   specific set  relatively easy part  haploid genomes   common    shortfragment pair  reduce   single “degenerate” pair  example formula     length  def  kmers—   read pair    closure   closure    assembly   neighborhood filter  solexa read read  filter base   intrinsic quality  remove nonpassing read  describe   definition   pass read  solexa system report  intensity   possible base acgt   position   read  define  read   “passing”      first  base   read  intensity   call base   least    ratio   intensity   call base   next highest intensity   least  artificially pair solexa read  dna isolate   coli k12 mg1655   weinstock lab  baylor university  sequence  solexa  combine  read   lanes  six flowcells {} {} {} {} {} {} pass read  select    “filtering  solexa reads” section  except   require intensity ≥ nonpassing read  discard   align  read   reference pick  random one   best placements   read   align  place  randomly   reference thereby ensure  every read  place  order   read  randomize   select simulate read pair  describe   text prior  assembly  trim  read use  follow procedure    read  find   read    gapfree endtoend alignment    length ≥ seed   mer  four  less errors  call  base   “supported”   exist two  read  different orientations  offset  agree   give base treat   base  “errors”  trim base   end      two errors remain",-0.17858541739956285,0.1865842408536521,0.13877165603515526,0.16583521214099894,0.0010492229268725523,0.024124879871421125,-0.11483325163603475,0.0722508842932913,-0.02015738661600212,0.09208538642911483,0.015337408076049712,0.002454587364967783,0.1935242866768284,-0.048626220167578234,0.15336518722453507,-0.08561027707890367,-0.00011090631490560933,0.2150864682199316,-0.07095681576049195,0.03606143646976242,0.05668514955574167,-0.1704189661809376,0.040571086292574415,-0.009321613897527777,0.004084949359061446,-0.1780032465353324,0.06162839714101026,-0.19686411506085924,-0.0013483657796923565,-0.1026872670192331,0.023406321117206544,0.2636667767672446,-0.1416150559551526,-0.13381196171833762,0.16819770895042166,0.10746945946837992,0.05362450370544206,-0.06134756851210035,-0.08446935305463005,-0.11970203610254485,-0.05063641534157362,-0.1403733931737064,-0.053761960457273716,-0.13159319596341154,-0.115812998915641,0.004858544807343251,0.16795980188166212,-0.0917717260421504,-0.18645940215661225,-0.33952128745952953,0.1566866523372689,-0.006102118265684184,0.03745997935553988,0.5709639631148434,0.025610381777797536,-1.1545369405037635,0.08071455688057097,-0.1870289366145172,0.9624420109499944,0.20494600256202605,-0.17480441666762098,0.2967557513987519,-0.08635263271424394,0.05492818813383345,0.6056089756433477,0.040296725662891206,0.07681250482972149,0.02763237034665285,0.14666669986434328,-0.2184797408763716,-0.0837686348246192,-0.051814306209985145,0.09926308041607776,-0.14810290638547371,0.22449612330943025,-0.05679695968406899,-0.14304219734944576,-0.1547821347109191,-0.32945515272040754,-0.07971772940215079,0.1590042167879569,-0.040829337461147634,-0.3921571735931316,-0.05177683736603849,-0.8073842786762178,0.051277381978244836,0.20206879840742495,-0.12510619352102142,-0.07527744230823159,-0.05077203846448541,-0.22086289245751106,0.09811346092584557,-0.1341718528911554,-0.10044904780681484,-0.15340407813813212,-0.1044558384601501,-0.05006237045470255,-0.2691184523388756,0.27510090658184805,0.1050154058923744,Assembly,5
104,104,"oases robust  novo rnaseq assembly across  dynamic range  expression levels
highthroughput sequence  make  analysis  new model organisms  affordable although assemble  new genome  still  costly  difficult   possible  use rnaseq  sequence mrna   absence   know genome   necessary  assemble  sequence  novo take  account possible alternative isoforms   dynamic range  expression value  present  software package name oases design  heuristically assemble rnaseq read   absence   reference genome across  broad spectrum  expression value   presence  alternative isoforms  achieve   use  array  hash lengths  dynamic filter  noise  robust resolution  alternative splice events   efficient merge  multiple assemblies   test  human  mouse rnaseq data   show  improve significantly   transabyss  trinity  novo transcriptome assemblers
 oases assembly process explain  detail   illustrate  figure  consist  independent assemblies  vary  one important parameter  hash  kmer length     assemblies  read  use  build   bruijn graph    simplify  errors organize   scaffold divide  loci  finally analyze  extract transcript assemblies  transfrags     individual kmer assemblies  finish   merge   final assembly contig assembly  oases pipeline receive  input  preliminary assembly produce   velvet assembler zerbino  birney    design  produce scaffold  genomic readsets  initial stag namely hash  graph construction   use indifferently  transcriptome data   run  stag  velvet  produce  preliminary fragment assembly contain  map   read onto  set  contigs however  later stage algorithms pebble  rock band  resolve repeat  velvet   use   rely  assumptions relate  genomic sequence zerbino    namely  coverage distribution   roughly uniform across  genome   genome   contain  branch point  condition prevent  algorithms   reliable  efficient  rnaseq data  contig correction  read  contigs produce  velvet oases proceed  correct     set  dynamic  static filter  first dynamic correction   slightly modify version  velvet' error correction algorithm tourbus tourbus search   graph  parallel paths     start  end node   sequence  similar enough  path  lower coverage  merge   path  higher coverage irrespective   absolute coverage   sense  tourbus algorithm  adapt  rnaseq data  fluctuate coverage depths however  performance issue  velvet version  tourbus  visit  node  mean     exhaustively compare  possible pair  paths give  high coverage  certain genes   complexity   correspond graph  numerous false positive paths   necessary  oases  exhaustively examine  graph visit nod several time  necessary  addition   correction oases include  local edge removal   node  outgo edge  remove   coverage represent    sum  coverages  outgo edge    node  approach similar   one present  yassour     base   assumption   high coverage regions spurious errors  likely  reoccur  often finally  contigs  less   static coverage cutoff  default   remove   assembly  rationale   filter    transcript    low coverage cannot  properly assemble   first place    expedient  remove    assembly along  many low coverage contigs create  spurious errors  scaffold construction  distance information   contigs   summarize   set  distance estimate call  scaffold  describe  zerbino      read    bruijn graph   split  several contigs  distance estimate   connection  two contigs   support   span single read  pairedend read  total number  span read  pairend read confirm  connection  call  support  connection   support   least one span read  call direct otherwise   indirect connections  assign  total weight   calculate  add    support span read   probabilistic weight   span pair proportional   likelihood  observe  pair read   observe position   contigs give  estimate distance   contigs  assume  normal insert length distribution model  scaffold filter much like  contig correction phase several filter  apply   scaffold static coverage thresholds    low coverage sequence   dynamic coverage threshold  adapt   local coverage depth  coverage   longer indicative   uniqueness   sequence contig length  use   indicator base   decrease likelihood  high identity conservation   function  sequence length whiteford    contigs longer   give threshold  default    label  long  treat   unique    nod  label  short connections   low support  default   lower    weight   first remove two short contigs    join   direct connection   intermediate gap  short   long contig    connect   direct connection finally connections  long contigs  test   modify version   statistic present  zerbino     estimate  many read pair  connect two contigs give  respective coverages   estimate distance separate  see supplementary material indirect connections   support lower   give threshold  default    expect count  thus eliminate  locus construction oases  organize  contigs  cluster call loci  illustrate  figure   terminology stem   fact    ideal case   gap  coverage  overlap  exterior sequence complicate matter   transcripts  one gene   assemble   connect component  contigs unfortunately  experimental condition  equivalence  components  genes cannot  guarantee     expect  loci sometimes represent fragment  genes  cluster  homologous sequence scaffold construction take place  two stag similarly   approach describe  butler    long contigs  first cluster  connect components  long nod   higher likelihood   unique therefore   assume  two contigs  belong    component also belong    gene   locus  add  short nod   connect  one   long nod   cluster  transitive reduction   loci   follow analyse  function properly   necessary  remove redundant long distance connections  retain  connections  immediate neighbor  see  figure   example   common  two contigs    consecutive   locus  connect   pairedend read  connection  consider redundant   connect two nod   connect   distinct path  connections    connection   two paths  comparable lengths  transitive reduction implement  oases  inspire   one describe  myers      adapt   condition  short read data  particular short contigs   repeat  even invert within  single transcript  form loop   connection graph    occasional situations arise  every connection come    node   transitively reduce  another one thus remove     break  connectivity   locus  avoid   limit  impose   number  remove connections  two connections   capacity  reduce    shortest one  preserve  extract transcript assemblies  sequence information   transcripts   contain   loci  loci   fragment   alternative splice events  cause   bruijn graph    branch oases therefore analyse  topology   loci  extract full length isoform assemblies  many case  loci present  simple topology    trivially  uniquely decompose  one  two transcripts  define three categories  trivial locus topologies fig  chain fork  bubble   isolate    branch point  straightforward  resolve  three topologies  easily identifiable use  degrees   nod oases therefore detect   trivial loci  enumerate  possible transcripts        exact method  apply  specific case  additional robust heuristic method  apply   remain loci refer   complex loci oases use  reimplementation   algorithm describe  lee   efficiently produce  parsimonious set  putative highly express transcripts assume independence   alternative splice events  extension   algorithm  quite intuitive since    direct analogy    bruijn graph build   transcripts   gene   splice graph  note  heber    use dynamic program  enumerate heavily weight paths   locus graph  decrease order  coverage  either   contigs   locus  cover   specify number  transcripts  produce  default     transitive reduction phase  algorithm    slightly modify  allow  loop   putative splice graph   locus loop  problematic   presence  prevent  propagation   dynamic program algorithm    contigs   locus   loop  detect   break   contig  connect  loop   rest   locus    leave  minimum number  branch point  describe   supplementary material  merge assemblies  oasesm  bruijn graph assemblers   sensitive   set   hash length   transcriptome data  optimization   complex  transcript expression level  coverage depths  distribute   wide range  way  avoid  dependence   parameter    produce  merge transcriptome assembly  previously generate transfrags  oases oases  run   set  kmin…kmax value   output transfrags  store  predict transfrags  run   interval   feed   second stage   pipeline oasesm   user select kmerge   bruijn graph  kmerge  build   transfrags  remove small variants   tourbus algorithm  transfrag   graph   identical  include  another transfrag  remove  final assembly  construct  follow  remain transfrags   merge graph",-0.2091468615882082,0.20410827864707776,0.11493201818291947,0.17393464822417784,-0.011173841767391491,-0.010491142008929515,-0.14356977988032385,0.06367867920967134,-0.0074010801582511014,0.11538826831265375,-0.007803940191715441,0.016377226410919283,0.1753607769723394,-0.0937541052455024,0.16970204287124524,-0.03968409563963455,0.019418079350706042,0.18690320682337688,-0.03210717789534717,0.046814149047214426,0.05506379823631378,-0.23098052279252676,0.07158387297269457,-0.0563600292930203,-0.013395253024784046,-0.17662451129394074,0.05457197382699795,-0.17799326261026158,-0.032695458379995115,-0.07642185078441369,0.004829787798478156,0.2558822286309744,-0.1666797327178803,-0.1077717258050958,0.19213348336400346,0.1386310925083624,0.05923901274973741,-0.0009289384216730301,-0.0940779349393512,-0.09136322453359466,-0.07897565767663567,-0.15284121202280124,-0.0604755577869644,-0.13072169785525514,-0.14663962787227458,-0.005217335345097407,0.18507434011323476,-0.12095830219421475,-0.24609295408789106,-0.3867507780338144,0.17602782229116107,0.009064497027567715,0.08531392986453128,0.6395512478222175,0.024521141023292045,-1.2686455932106302,0.08588327873292176,-0.19662799069639,1.0788521996321383,0.2240277451809136,-0.16436088829371984,0.3540269813067269,-0.05356918160202356,0.04494252254236195,0.6544891942610952,0.0061532905268531215,0.07174104786052002,0.0012576522254844444,0.17830393410119086,-0.246414708867606,-0.08714561045776084,-0.060691987221080886,0.1213261789619806,-0.15545722845567045,0.2477560129823924,-0.05657167113349304,-0.11778938204878375,-0.188600798938991,-0.3821137845004917,-0.07591801028489502,0.20591731556048976,-0.038791793235827286,-0.4045480254022657,-0.03903283327097876,-0.9224126710058199,0.09645353469805283,0.2020670384101351,-0.10813419225244124,-0.10540477828276144,-0.04029043886066061,-0.21825679732511832,0.09594024896740484,-0.1826522937713955,-0.10630603049751414,-0.15086915771386,-0.08289262943396042,-0.11059547712869784,-0.3469631963322238,0.3255022062741864,0.08996754112620849,Assembly,5
105,105,"spade  new genome assembly algorithm   applications  singlecell sequencing
 lion' share  bacteria  various environments cannot  clone   laboratory  thus cannot  sequence use exist technologies  major goal  singlecell genomics   complement genecentric metagenomic data  wholegenome assemblies  uncultivated organisms assembly  singlecell data  challenge   highly nonuniform read coverage  well  elevate level  sequence errors  chimeric read  describe spade  new assembler   singlecell  standard multicell assembly  demonstrate   improve   recently release evsc assembler specialize  singlecell data   popular assemblers velvet  soapdenovo  multicell data spade generate singlecell assemblies provide information  genomes  uncultivatable bacteria  vastly exceed  may  obtain via traditional metagenomics studies
  outline  four stag  spade  deal  issue   particularly troublesome  scs sequence errors nonuniform coverage insert size variation  chimeric read  bireads  stage  assembly graph construction  address  every ngs assembler   often refer    bruijn graph simplification  bulgebubble removal  eulervelvet  propose  new approach  assembly graph construction  use  multisized  bruijn graph implement new bulgetip removal algorithms detect  remove chimeric read aggregate biread information  distance histograms  allow one  backtrack  perform graph operations  stage  kbimer adjustment derive accurate distance estimate  kmers   genome edge   assembly graph use joint analysis  distance histograms  paths   assembly graph  stage  construct  pair assembly graph inspire   pdbg approach  stage  contig construction  well study   context  sanger sequence ewing    since ngs project typically feature high coverage ngs assemblers generate rather accurate contigs although  accuracy deteriorate  scs spade construct dna sequence  contigs   map  read  contigs  backtrack graph simplifications see section  previous study demonstrate  couple various assemblers  error correction tool improve  performance pevzner    kelley    ilie    gnerre    however  error correction tool  quake kelley    perform poorly  singlecell data since  implicitly assume nearly uniform read coverage chitsaz    couple velvetsc   errorcorrection  euler chaisson  pevzner  result   tool evsc   article spade use  modification  hammer medvedev    aim  scs  error correction  quality trim prior  assembly  pair assembly graph approach differ  exist approach  assembly  dictate new algorithmic solutions  various stag  spade thus   describe several variations   bruijn graph lead  construction   pair assembly graph cover stag   ",-0.18426511356154004,0.16143472976101614,0.07471459640844448,0.12831188837141805,0.01913290679064655,-0.06911309761800677,-0.07241782506902678,0.04041350917148127,-0.041412991582340485,0.1150557047347664,-0.012689023978404095,-0.05357276477372727,0.14108008764058075,-0.06263851579656271,0.12477581410895328,0.052374124599973086,0.06709609251922449,0.1958842355306449,-0.02961422154503698,0.01740494082316857,-0.03923514639153272,-0.2358492541894619,0.08490090059420106,0.059819019448351926,-0.001629433690293415,-0.18151871714036208,0.05706510884385254,-0.13842480443606808,-0.08832287189827577,-0.06795636826490581,-0.027725108292557903,0.26902110745148683,-0.17613364537875795,-0.061465851816575275,0.17275136067607516,0.09168295914156213,0.012456298571684073,0.007297932286117528,-0.1078992634042594,-0.0876179124033582,-0.10410071743929104,-0.10793440513787916,-0.17773657637157453,-0.049305426644639584,-0.19210039646037527,-0.008366011402796249,0.12282258003503335,-0.13102133914394104,-0.20762455550469205,-0.291598568752257,0.15629972111389695,0.0039606648371429045,0.05116560346874837,0.5531083592893304,0.017995821223971812,-1.0610382188816327,0.041531220496304935,-0.1582305099034833,0.8503894520671786,0.18188715045627665,-0.154416865948745,0.2955787963592573,-0.009195103950647486,0.09483802453992336,0.5201737208593938,0.0286545374229349,0.0122141195539813,0.014573825417539557,0.2102297046372818,-0.1652612039926336,-0.06884845564664166,0.016779327611407466,0.054711143609381764,-0.1225768011340217,0.12278751002977024,-0.06826284918430689,-0.09564754419859398,-0.01892029483727104,-0.3986981865761147,-0.06494536437849338,0.19735764816365636,0.0035343906640805103,-0.2992545926679127,-0.060148913579099385,-0.8436989175659176,0.1074994794080487,0.24215343657918775,-0.1413151961688355,-0.15285610096856347,-0.02313413500921121,-0.0971604455136568,-0.0030373525294487844,-0.13024680529330931,-0.06521264759672654,-0.10348907142776896,-0.06003704743862555,-0.13670823914376465,-0.3337894693847645,0.2718205721293752,0.07153044071841383,Assembly,5
106,106,"soapdenovo2  empirically improve memoryefficient shortread  novo assembler
   rapidly increase amount   novo genome assembly use nextgeneration sequence ngs short read however several big challenge remain   overcome  order     efficient  accurate soapdenovo   successfully apply  assemble many publish genomes   still need improvement  continuity accuracy  coverage especially  repeat regions  overcome  challenge   develop  successor soapdenovo2    advantage   new algorithm design  reduce memory consumption  graph construction resolve  repeat regions  contig assembly increase coverage  length  scaffold construction improve gap close  optimize  large genome benchmark use  assemblathon1  gage datasets show  soapdenovo2 greatly surpass  predecessor soapdenovo   competitive   assemblers   assembly length  accuracy  also provide  update assembly version    asian  genome use soapdenovo2   contig  scaffold n50    genome   kbp   mbp respectively   fold  fold longer   first publish version  genome coverage increase      memory consumption   lower   point  largest memory consumption
 increase use  next generation sequence ngs  result   increase growth   number   novo genome assemblies  carry  use short read although   several  novo assemblers available  remain room  improvement  show  recent assembly evaluation project   assemblathon    gage  since  publication   first version  soapdenovo     use  assemble many large eukaryotic genomes  report  indicate areas  would benefit  update include assembly coverage  length  soapdenovo2   soapdenovo  make   six modules  handle read error correction  bruijn graph dbg construction contig assembly pairedend  read map scaffold construction  gap closure  major improvements   make   soapdenovo2   enhance  error correction algorithm  provide  reduction  memory consumption  dbg constructions  resolve longer repeat regions  contig assembly  increase assembly length  coverage  scaffold   improve gap closure  data show  soapdenovo2 outperform  predecessor   majority   metrics benchmarked   assemblathon   well  gage   addition  able  substantially improve  original assembly   asian  genome     use soapdenovo improvements  soapdenovo2 deal  sequence error  ngs data  inevitable especially  genome assembly applications  outcome   could  largely affect  even  small amount  sequence error hence   mandatory  detect  revise  sequence errors  read  assembly  however  error correction module  soapdenovo  design  short illumina read    consume  excessive amount  computational time  memory  longer read  example    memory run  two days use fold   pairedend illumina hiseq  read thus   skillful exploitation  data index strategies  redevelop  module  support memory efficient longkmer error correction  use  new space kmer scheme  improve  accuracy  sensitivity see additional file  supplementary method   figure s1s3 simulation test show   new version run efficiently  correct  read authentically see additional file  table     dbgbased largegenome assembly  graph construction step consume  largest amount  memory  reduce   soapdenovo2  implement  sparse  bruijn graph method  see additional file  supplementary method   read  cut  kmers   large number   linear unique kmers  combine   group instead   store independently another important factor   success  dbgbased assembly  kmer size selection use  large kmer   advantage  resolve  repeat regions whereas use  small kmers  advantageous  assemble low coverage depth  remove sequence errors  fully utilize   advantage  introduce  multiple kmer strategy   soapdenovo2 see additional file  supplementary method   figure  first  remove sequence errors use small kmers  graph build    rebuild  graph use larger kmers iteratively  map  read back   previous dbg  resolve longer repeat scaffold construction  another area  need improvement  ngs  novo assembly program    original soapdenovo scaffold  build  utilize  read start  short insert size   follow iteratively  large insert size  kbp  although  iterative method greatly decrease  complexity  scaffold  enable  assembly  larger genomes  remain many issue  result  lower scaffold quality  shorter length  example   heterozygous contigs  improperly handle  chimeric scaffold erroneously build   smaller insert size  read   hinder  later step  increase  scaffold length  add  read  larger insert size   false relationships  contigs without sufficient  information support  create occasionally  improve   soapdenovo2  main change   scaffold stage   follow   detect heterozygous contig pair use contig depth  local contig relationships   condition   contig  higher depth   heterozygous pair  keep  scaffold  reduce  influence  heterozygosity   scaffold length  chimeric scaffold   build use  smaller insert size library  rectify use information   larger insert size library    develop  topologybased method  reestablish relationships  contigs   insufficient  information support see additional file  supplementary method   figure s5s7 short read enable   reconstruct large vertebrate  plant genomes   assembly  repetitive sequence longer   read length still remain   tackle  scaffold construction contigs  certain distance relationship  without genotypes amid  connect  wildcards  gapcloser module  design  replace  wildcards use  context   read information  soapdenovo2   improve  original soapdenovo gapcloser module  assemble sequence iteratively   gap  fill large gap   iterative cycle  previous release  gapcloser consider   read  could  align  current cycle  method could potentially make   incorrect selection  inconsistent locations  insufficient information  distinguishment due   high similarity  repetitive sequence  soapdenovo2  develop  new method  consider  read align  previous cycle  allow  better resolution   conflict base  thus improve  accuracy  gap closure",-0.202870662631661,0.19955678357121845,0.10137076226645148,0.15434380122926086,-0.01418610222598848,-0.1274658606449763,-0.1545367200614419,0.07089328269901064,0.002408458603701244,0.14050920753817386,0.004068438588680389,-0.02807973894979417,0.16348829651649188,-0.1404248719837051,0.09680526642193096,-0.10588424827437848,0.033050885099607206,0.16051944356887055,-0.05707861695710259,0.04322204407808992,0.013941318703194459,-0.236972007577618,0.058988172249131214,0.034887283447509014,-0.012152116952929646,-0.23512051209962614,0.005179176208912395,-0.1959613930123548,-0.07657232236194735,0.011373236643654916,-0.03975365489876519,0.2745264200028032,-0.19456556622734447,-0.08734038004690471,0.14062749744945904,0.12418414210274932,0.061048834655278675,-0.024970989371649918,-0.18400477825819206,-0.07190492022510929,-0.1252324433756682,-0.1974371073312068,-0.07117668301293936,-0.08626422810018994,-0.08685937500403572,-0.00520987465880656,0.17242400178763395,-0.16624463157262653,-0.17093349309075467,-0.4465547251864336,0.09729276594977516,-0.0057805914532703655,0.03796220106790618,0.6767963346280158,0.05353040703533528,-1.3455609532399102,0.03812455866485834,-0.2291535193057886,1.1046633702815356,0.1815860115249719,-0.20497939467342804,0.3125753862519438,-0.07031157455950354,0.12455137146869676,0.6013468560879118,0.02124427002388984,0.02919767661563432,0.03380979157596205,0.2721008400991559,-0.1943081860341287,0.03740845757449279,-0.042557869739151405,0.02864044204043845,-0.15635054968918366,0.2124973111141784,-0.023296023450869445,-0.13780138535114625,-0.030956483523671825,-0.4351642992192257,-0.036075033526867625,0.26497177573425384,-0.0209591523501634,-0.38643458545246784,0.0007081822430094082,-0.945806843942264,0.0475762342956538,0.21220582832737514,-0.09920749518283023,-0.18331914419308304,-0.07310582595324376,-0.13390428271067015,0.049372932684782427,-0.156924080956184,-0.11645791026763615,-0.18956063013756647,-0.06372205202331922,-0.05927154363753895,-0.2887435502923715,0.3891779979349425,0.07015288388744617,Assembly,5
107,107,"assemble millions  short dna sequence use ssake
novel dna sequence technologies   potential    three order magnitude  sequence throughput  conventional sanger sequence  emerge  instrument  available  solexa ltd produce millions  short dna sequence     due  ubiquitous repeat  large genomes   inability  short sequence  uniquely  unambiguously characterize   short read length limit applicability   novo sequence however give  sequence depth   throughput   instrument stringent assembly  highly identical sequence   achieve  describe ssake  tool  aggressively assemble millions  short nucleotide sequence  progressively search   prefix tree   longest possible overlap   two sequence ssake  design  help leverage  information  short sequence read  stringently assemble   contiguous sequence    use  characterize novel sequence targets
dna sequence   single multi fasta file  read  memory populate  hash table key  unique sequence read  value represent  number  occurrences   sequence   set  prefix tree  use  organize  sequence   reversecomplemented counterparts   first eleven ′ end base  sequence read  sort  decrease number  occurrences  reflect coverage  minimize extension  read contain sequence errors  unassembled read   use  turn  nucleate  assembly  possible ′  kmer  generate     use   search   word length  smaller   userdefined minimum     kmer   perfect match   ′ end base  read    latter case   extend   unmatched ′ end base contain      remove   hash table  prefix tree  process  cycle  progressively shorter ′ kmers  repeat  every extension   since  leftmost search  possible   prefix tree   possibilities   exhaust   ′ extension  complementary strand   contiguous sequence generate contig  use  extend  contig   ′ end  dna prefix tree  use  limit  search space  efficiently bin  sequence read   two ways  control  stringency  ssake  first   stop  extension   kmer match  ′ end    one sequence read    lead  shorter contigs  minimize sequence misassemblies  second   stop  extension   kmer  smaller   userset minimum word length  ssake output  log file  run information along  two multi fasta file one contain  sequence contigs construct    contain  unassembled sequence read",-0.2565721758924025,0.2071116050356068,0.09008004829936128,0.15020738783225948,0.0870445776755722,-0.03759715435735416,-0.11206279907408837,0.05281567491391408,-0.034795780774272436,0.14868403076294012,0.033705647763729626,0.003999434152085865,0.11610839524286608,-0.05492747494385445,0.11186560639845472,-0.05695628890368555,0.044410591858572185,0.19671108255528716,-0.05481299435653325,0.015516918137603041,0.10457383699249476,-0.19437791690870654,0.05459103056138182,-0.016799934821236612,0.09923308055149392,-0.1819222566372316,0.024622772976207283,-0.1154452283068427,-0.015577899175696075,-0.030442591961244558,0.008222662284970284,0.24231022576069725,-0.11925985681425247,-0.10927474307328727,0.17574108693619825,0.043954235847507205,0.02534272798137473,-0.08310371344975595,-0.12025098692891853,-0.08699157062385764,-0.04866705588730318,-0.16179959388578674,-0.04200254683549117,-0.05213792907473232,-0.04638365875206156,0.030453647746305382,0.19209228912368415,-0.153314757206577,-0.18837390571300472,-0.34770586208490256,0.06989527857430013,0.001158353142506842,0.0813378757281628,0.6747784454658229,0.0545249576938139,-1.2248471380909904,0.007820493262261152,-0.17763901258087053,1.0625568912364542,0.20915706548527985,-0.17770156478280633,0.3642379789679711,-0.04763816395508391,0.06195571724092588,0.5754279260573509,0.03745862190511876,0.05895918921201624,0.04375932955798427,0.15278514520947026,-0.2327667351221732,-0.038493647959798434,-0.05051539771791015,0.08029823785182089,-0.1535253875340069,0.22063166813001905,-0.036465245598394966,-0.15509383051456618,-0.21830360700675688,-0.3977079672239987,0.001432073996069708,0.2431139840777697,-0.0328681794835055,-0.35593224254303746,0.004243787610903382,-0.8677903571693085,0.09707606913704823,0.2556718809131001,-0.10890059176599606,-0.1071610410660339,0.006616912037342055,-0.2005584180488118,0.13629087528845826,-0.13282137145454595,-0.1495938976727692,-0.15970668738009408,-0.12200489101399267,-0.08690033610244947,-0.27468860112130644,0.3517544717261834,0.07846418635537182,Assembly,5
108,108,"gaml genome assembly  maximum likelihood
resolution  repeat  scaffold  shorter contigs  critical part  genome assembly modern assemblers usually perform  step  heuristics often tailor   particular technology  produce pair  long read  propose  new framework  allow systematic combination  diverse sequence datasets   single assembly  achieve   search   assembly   maximum likelihood   probabilistic model capture error rate insert lengths   characteristics   sequence technology use  produce  dataset   implement  prototype genome assembler gaml   use  combination  insert size  illumina   read  well  pacbio read  experiment show    assemble short genomes  n50 size  error rat comparable  allpathslg  cerulean  allpathslg  cerulean require   specific combination  datasets gaml work   combination   introduce  new probabilistic approach  genome assembly  demonstrate   approach  lead  superior result  use  combine diverse set  datasets  different sequence technologies
recently several probabilistic model  introduce   measure   assembly quality     author  show   likelihood consistently favour higher quality assemblies  general  probabilistic model define  probability prra   set  sequence read   observe assume  assembly    correct assembly   genome since  sequence    stochastic process    natural  characterize concordance  read   assembly  give  probability  observe  particular read   work instead  evaluate  quality   single assembly  use  likelihood   optimization criterion   goal  find high likelihood genome assemblies  adapt  model  ghodsi      describe   section basics   likelihood model  model assume  individual read  independently sample  thus  overall likelihood   product  likelihoods   read prra  ∏∈rprra  make  result value independent   number  read  set   use   main assembly score  log average probability   read compute  follow lapar  ∑∈rlogprra note  maximize prra  equivalent  maximize lapar   read  errorfree   position   genome  sequence equally likely  probability  observe read  would simply  prra  nr2l     number  occurrences   read   substring   assembly     length    thus    length   two strand combine  ghodsi     show  dynamic program computation  read probability   complex model account  sequence errors  algorithm marginalize   possible alignments     weight    probability   certain number  substitution  indel errors would happen  sequence  particular  probability   single alignment   match position   errors substitutions  indels  define   m2l     ϵsϵm     sequence error rate however  full dynamic program   time consume   practice  several best alignments contribute significantly   overall probability  approximate  probability  observe read    estimate base   set     best alignments    genome   obtain  one   standard fast read alignment tool     number  match   jth alignment     number  mismatch  indels imply   alignment  formula assume  simplest possible error model  insertions deletions  substitutions    probability  ignore  content bias  course much  comprehensive read model  possible see   pair read many technologies provide pair read produce   opposite end   sequence insert   certain size  assume   insert size distribution   set  read    model   normal distribution  know mean   standard deviation    mji  sji   number  match  sequence errors  alignment  respectively  dj1    distance   two alignments  observe   assembly  alignments      two different contigs   inconsistent strand prdj1 j2μ   zero read    good alignment    read  read pair   align well      result  probability prra   low  approximation   set  highscoring alignments  even yield zero probability  set   empty  extremely low probabilities  dominate  log likelihood score ghodsi    propose  method  assign   read  score approximate  situation   read would  add   new contig   assembly  modify  formulas  variable read length  use score eckℓ   single read  length   eckℓ1ℓ2   pair  read  lengths    value     scale constants set similarly   ghodsi     alternative score  use instead   read probability prra whenever  probability  lower   score multiple read set  work  specifically target   scenario    multiple read set obtain  different libraries  different insert lengths  even  different sequence technologies  use different model parameters   set  compute  final score   weight combination  log average probabilities  individual read set   ⋯   lapar1  ⋯    w1lapar1   ⋯   wklapark           experiment  use weight      datasets   lower  weight  pacific biosciences read  otherwise  dominate  likelihood value due   longer length  user  also increase  decrease weight   individual set base   reliability penalize spuriously join contigs  model describe    penalize obvious misassemblies  two contigs  join together without  evidence   read   observe   make  likelihood function applicable   optimization criterion   best assembly  need  introduce  penalty   spurious connections  say   particular base    assembly  connect  respect  read set      read  cover base   start  least  base       constant specific   read set   set  treat  pair  read  one long read   assembly contain  disconnect base  respect   penalty   add   lapar score    scale constant properties  different sequence technologies  model   apply  different sequence technologies  appropriate settings  model parameters  example illumina technology typically produce read  length    error rate     smaller genomes  often   high coverage  illumina read use pair read  mate pair technologies   possible  prepare libraries  different insert size range   tens  kilobases   instrumental  resolve longer repeat   align  read  propose assemblies  use bowtie2  similarly   process read   roche  technology   characteristic  higher read lengths hundreds  base pacific biosciences technology produce single read  variable length  median length reach several kilobases   error rate exceed     length make  ideal  resolve ambiguities  assemblies   high error rate make  use challenge  align  read  use blasr    calculate  probability prra  consider    best alignments find  blasr    blasr alignment  also add probabilities  similar alignments   neighborhood  specifically  run  band version   forward algorithm   consider  alignments   band  size three around  guide alignment produce  blasr complex probabilistic model like  one describe  “probabilistic model  sequence assembly”  previously use  compare  quality  several assemblies    work  instead attempt  find  highest likelihood assembly directly  course  search space  huge   objective function  complex  admit exact methods   describe  effective optimization routine base   simulate anneal framework   algorithm  find  maximum likelihood assembly consist  three main step preprocessing optimization  postprocessing  preprocessing  decrease  scale   problem  create  assembly graph  vertices correspond  contigs  edge correspond  possible adjacencies  contigs support  read  order  make  search viable   restrict  search  assemblies    represent   set  walk   graph therefore  assembly graph   build   conservative way   goal    produce long contigs  rather  avoid errors inside    optimization step  start   initial assembly  set  walk   assembly graph  iteratively propose change  order  optimize  assembly likelihood finally postprocessing examine  result walk  split     shorter contigs    multiple equally likely possibilities  resolve ambiguities  happen  example   genome contain long repeat  cannot  resolve     datasets   rest   section  discuss individual step   detail optimization  simulate anneal  find  high likelihood assembly  use  iterative simulate anneal scheme  start   initial assembly    assembly graph   iteration  randomly choose  move  propose  new assembly ′ similar   current assembly   next step depend   likelihoods   two assemblies   ′  follow  lapa′ ≥ lapar  new assembly ′  accept   algorithm continue   new assembly  lapa′  lapar  new assembly ′  accept  probability elapa′rlapart otherwise ′  reject   algorithm retain  old assembly    next step  parameter   call  temperature   change  time  general  higher  temperature   aggressive move  permit  use  simple cool schedule    t0lni   ith iteration  computation end     improvement   likelihood   certain number  iterations  select  assembly   highest lap score   result   reduce  complexity   assembly problem  classify  contigs  either long      short  concentrate  order  long contigs correctly  short contigs  use  fill  gap   long contigs recall   assembly   set  walk   assembly graph  contig  appear    one walk    present   single walk multiple time preprocessing   initial assembly  obtain  assembly graph  use velvet  basic error correction  unambiguous concatenation  kmers  settings  produce  short contigs   also give  much lower error rate   regular velvet run gaml   default settings  use  long contig   separate walk   start assembly   simulate anneal procedure postprocessing  assembly obtain   simulate anneal procedure may contain walk   evidence   particular configuration  incoming  outgo edge   assembly graph  happen  example   repeat  longer   span   longest pair read   case  would  several versions   assembly      similar likelihood score   postprocessing step  therefore apply  repeat interchange move  every possible location   assembly   likelihood change result    move  negligible  break  correspond walk  shorter contigs  avoid assembly errors fast likelihood evaluation   time consume step   algorithm  evaluation   assembly likelihood   perform   iteration  simulate anneal  step involve alignment   large number  read   current assembly however   small part   assembly  change   anneal step    use  significantly reduce  run time next  describe three optimizations implement   software limit read alignment  affect regions   assembly since   small portion   assembly  affect   step   keep  alignments   previous iterations   align read   regions  change  determine  regions  split walk  overlap windows  window contain several adjacent contigs   walk windows    short  possible  adjacent windows  overlap   least 2ℓr base     length   longest read   result  alignment  completely contain   least one window even   presence  extensive indels  determine  window boundaries   simple greedy strategy  start   first contig   walk   extend  window   least 2ℓr base beyond  boundary   first contig  next window always start   latest possible location  ensure  sufficient overlap  extend  least 2ℓr base beyond  end   previous window   window  keep  position  edit distance   alignments   anneal step  identify  windows   assembly  change since  last iteration   glue together overlap windows  align read   sequence   improve  heuristics  avoid repeat alignments  read  interiors  long contigs   part   assembly never change  particular   window start   long contig   realign read   last 2ℓr base   contig  similarly  use   first 2ℓr base   long contig   end   window reduce  number  read  need   align  first improvement eliminate    assembly  read map  contrast  second improvement reduce  set  read  need   realign     read   align   change part   assembly  use  prefiltering step  find  read   likely  align   target sequence   current implementation  use  follow three options   filter   simplest approach  look  read  contain  kmer usually      target sequence  store  index   kmers   read   hash map   anneal step  iterate   kmers   target portion   assembly  retrieve read  contain   approach   memory consume   identifier   read  store   kmer   read   second approach  save memory use minhashing  give hash function   minhash  set   define    minx∈ahx   read   calculate minhash   set    kmers thus  identifier   read  store   hash table     anneal step  calculate  minhash   substring   target sequence  length   retrieve  read     minhash  important property  minhashing   prma       jaba∩∪   jaccard similarity  two set      statement hold   hash function   randomly choose   family   minwise independence property  mean   every subset  elements   element      chance    minimum hash note  string    small edit distance   high jaccard similarity   kmer set  therefore  high chance    hash    value use minhashing   use several minhashes  different hash function  improve  sensitivity   filter   cost  additional memory   implementation  use  simple hash function  map kmers  bite integers  first represent  kmer   integer   base correspond  two bits   xor  integer   random number finally  perform mix similar   finalization   murmur hash function   external file  hold  picture illustration etc object name  13015_2015_52_figa_htmlgif  choose  finalizer   murmur hash function  fast  result   collisions    minhash independent   find   perform well  practice  illustrate  specificity  sensitivity  minhashing   compare  minhashing approach  index  kmers      evaluate lap   allpathslg assembly  staphylococus aureus use read set sa1 describe  “experimental evaluation”  align    whole  aureus genome index  kmers result   alignments find  examine  candidate position use minhashing  three hash function   able  find  alignments  examine  candidates position since  read   low error rate kmer index retrieve practically  relevant alignments   sensitivity  minhashing  approximately   minhashing   examine position yield  alignment whereas specificity  kmer index    also minhashing use  time smaller index note  minhashing  previously use   similar context  berlin     find similarities among pacbio read however since pacbio read   high error rate  author   use  high number  hash function whereas  use    hash function  filter illumina read    low error rate  gaml  filter pacbio read   completely different approach   base  alignments rather  kmers  particular  take  reasonably long contigs  least  base  align   pacbio read since blasr  find alignments   contig   read overlap   around  base  use  alignments   filter final computation   likelihood score   read  properly align   new version   assembly   combine  alignments   final score   implementation  need  handle several issue   correctly compute likelihood  read  align  multiple walk assign  special likelihood  read without  good alignment  avoid double count  read  align  regions cover  two overlap windows    walk   improve  run time  consider  read   influence    recent change  consecutive iterations  keep  alignments   sequence window   assembly  recompute  alignments  affect windows  outline   also keep  likelihood value   read   read pair recall   likelihood   read   read pair   sum  likelihoods  individual alignments   iteration   identify  walk  remove  add   calculate likelihoods   read alignments   walk use store  newly compute alignments   use  value  adjust  likelihood value  individual read subtract  remove walk  add  new walk   step  also handle pair read identify pair  alignments  correct distance  orientation finally  sum likelihoods   read   dataset  compute  total likelihood score",-0.19922848655566106,0.19034627044145114,0.12248793484334385,0.1896661590258734,-0.04015341720109926,0.01180444405008995,-0.13373279492217816,0.08471374779700462,-0.04899913672701084,0.1288648988287133,0.006469949547705199,-0.0241095895042906,0.1562864473146815,-0.1073686320808678,0.13650241185181514,-0.06283400362355908,0.0020662210543986427,0.211215194601386,-0.058931468798885826,0.0569154819808964,0.0435243123961905,-0.2028255690796676,0.037115574370173314,-0.05460295610768727,-0.023424415286541392,-0.193363695415754,0.03315554474789964,-0.2034484629570737,-0.05178755802129603,-0.10214943247964467,-0.0064196045575631655,0.26990540521600803,-0.15920581848542573,-0.0863565662766508,0.1793411368514199,0.11453948684101098,0.07360922836431591,-0.023694419352704842,-0.08489039927173117,-0.12763793294470194,-0.08460568802984696,-0.1530439263020625,-0.020938066508102083,-0.100500652352197,-0.16901022501306928,-0.0006221796254033014,0.1301228324624427,-0.14395733153743118,-0.2140429729938272,-0.39699300107210017,0.1668114608915367,-0.00242787667187789,0.04068227584510342,0.6352173550115618,0.03157602088180619,-1.2407020709180168,0.08285035203157769,-0.17789709044055402,1.02340462600829,0.1923302852973992,-0.1828377082971828,0.30119485714740624,-0.10238935701271323,0.06998766233591099,0.6147647569136402,0.00855595810576652,0.05625799932784708,0.023176863221884718,0.1502136804029161,-0.1981378373558436,-0.07260802285017275,-0.06021950244273809,0.0849799196880838,-0.11269484590258252,0.1997910132603847,-0.034033295142411886,-0.14627362332591284,-0.14875722540114966,-0.3390649533667681,-0.07707619619990441,0.2008598441631158,-0.02920703889601252,-0.3764318749215215,-0.06388609728022199,-0.8899729347438353,0.05884243693326301,0.1920138717201497,-0.12244358961986945,-0.11161268935316328,-0.08009140529750676,-0.21400349805649665,0.09033390821120424,-0.12754837369899713,-0.11917891395067695,-0.16943315290812158,-0.0835567988006719,-0.08266968985522045,-0.2663914066586014,0.33129858992375605,0.10495919523897357,Assembly,5
109,109,"skesa strategic kmer extension  scrupulous assemblies
skesa   debruijn graphbased denovo assembler design  assemble read  microbial genomes sequence use illumina comparison  spade  megahit show  skesa produce assemblies   high sequence quality  contiguity handle lowlevel contamination  read  fast  produce  identical assembly    input  assemble multiple time     different compute resources skesa   use  assemble   read set   sequence read archive  ncbi   realtime pathogen detection
 present  algorithm design  skesa  important implementation detail design  test set use  run time  assembly quality comparisons  command line use    run  compare skesa  spade   megahit  assessment  assembly quality   use quast  attempt  use misfinder   remilo   neither work reliably  misfinder  remilo work result  similar    quast algorithm design  skesa  flowchart describe  main modules  skesa  show  fig    read input  write output  four main part   skesa algorithm   follow trim  read detection  parameters  user  specify  option  whether  read  pair  single   compute resources available   parameters  determine internally  skesa unless explicitly specify assembly use  specific kmer size   iteration  assembly process use  debruijn graph   kmer size   empty  current set  contigs multiple kmer size  use short kmers  assemble lowcoverage areas   genome  long kmers  resolve repeat mark read  module decide read   use    longer need  future iterations  trim  read  rest   skesa process use trim read    overload “read”  mean trim read   step  input  pair read  iterate use kmers   mate length  read still available  assembly   miniassembly perform treat  mat  end  contigs assemble read  use  generate three set  kmers   longer   mate size     expect insert size  explicit error correction  read    skesa   heuristics  skesa  handle  errors   typical illumina read set next  describe    five modules read trim kmer size    use  count frequency  kmers   read set   kmer  see   least  fraction  read default    consider suspect  use  trim read start   first kmer   mate  check  consecutive kmers  first occurrence   kmer flag  suspect trim  rest   mate parameter detection skesa build  histogram  frequency  kmers   minimal kmer length kmin default  see  trim read use  histogram  decide  peak   distribution around  peak likely correspond   kmers   genome  assemble  distribution  use  estimate  genome size    peak  detect     entire distribution  use   estimate   additional peak present  distributions around  peak  usually due  noise repeat  plasmids  example figs     two part   histogram  srr2821438 generate  mers  account   noise  highcoverage read set  minimum frequency count cmin  compute  maxtg∗     total length  read  kmers  count   minimum count  ignore   assembly  program also compute cmax  maxtg∗ choice  kmer lengths  make  skesa use kmin number  step  default   maximal kmer length kmax  kmax  determine use  average   mate lengths aread  count  kmers kmax  initially set  aread   average count  kmers  current kmax    desire count cmax  kmax  iteratively reduce  aread base   kmax  average count   least cmax  find  kmax     time kmin   additional kmers  kmin  kmax  choose   odd integers   spread evenly otherwise  kmin  use   assembly   warn  iterations  disable  print  pair run   insert size    provide    estimate use  random sample   read  unambiguous assembly     read   two mat  end  contigs  attempt use kmin use  length  read assemble insert size   estimate three additional kmer size add  additional iterations  25kmax 25kmaxi    program also use    maximal insert size expect   read assemble use  specific kmer size   kmers  length   frequency  least cmin  generate   main peak   histogram   frequency  generate kmers  detect  leave low end   distribution around  main peak  call  valley   iteration   kmers  count   valley  use  start new contigs  valley  set  zero   main peak  find   histogram   stage  attempt  extend  end   contig   next base result  three possibilities   kmer extension  possible   one kmer extension  possible  iii   alternate choices   first case  end   contig   reach    extension  possible   second case  contig  extend  one base    extension   new kmer produce  addition   base   previous kmer last kmer   end   contig  also possible use   criteria use  extend  previous kmer   new kmer   third case  choices  count   threshold  extension default   respect   maximum count   choice  consider  noise  drop    one choice  extension survive  count base filter potential illumina strandspecific systematic error signatures  evaluate  program    compare count observe   strand     choice  count balance   strand  choices  count see  predominately one strand  drop    one choice  extension survive  strandbased filter  choice  use  find paths   extend   maximum  maxk step   one path survive    keep  others  remove  dead end    one path survive  contig break  create   contig reach  stage   extension   longer possible  last kmer base  remove  ensure   sequence build  verify  assemble   directions   process  contig extension suppose contig    extend   base  result  last kmer     include   program check    already present   contig      exist   extend use      exist      end   program merge    otherwise    extend  ensure   kmer  include      assemble contigs   iteration   kmer mark read  use   iteration  read    kmer locate deeper  buffer zonem inside  contig  mark  use   cannot contribute  new information value      flank   set  kmax  read  remove   input read    ones assemble   pair  generate kmers larger   mate size otherwise   set  zero connect pair read  input   pair read   iterations use kmers   mate length  program attempt  unambiguously connect read    mark  use start   last kmer   first mate  first kmer   second mate  paths   maximal insert size  assemble similarly  assembly  reverse complement   first kmer   second mate  reverse complement   last kmer   first mate  attempt   produce  one path  sequence     paths except  reverse complement  assemble sequence  use  generate longer kmers  pair   inside  buffer zone  sequence   contig  use  generate long kmers",-0.22996120220692506,0.19164857618221687,0.13340732383758536,0.10729826951343244,-0.02604008931184894,0.013870372405428249,-0.11202842039979416,0.12992357582361674,-0.032747267892359405,0.11182324383247258,0.04608263019793506,0.0373995726208046,0.1701824466735004,-0.08525949570446692,0.1563204363911766,-0.07056672239098055,0.03715489235584191,0.2076942662263875,-0.09433552927331564,0.042907314882854576,0.05555355117319088,-0.20882961217249776,0.052873154936743716,-0.017773207446062488,0.02437593686025076,-0.16983497934576508,0.04003666221015637,-0.14519340285834664,0.007876385934650898,-0.10556328768063143,-0.0011094311593453688,0.23436176122471306,-0.11213866188552167,-0.05230615064461619,0.2046088917113656,0.12878059503012174,0.05814586008682141,-0.0324734325617038,-0.07888099289266393,-0.1107313126233278,-0.1044538715488984,-0.1372894548111021,-0.04126218152212397,-0.110992352189175,-0.10184641261745628,0.0018274150022048632,0.09201105241663754,-0.21982651311454587,-0.20917039460518624,-0.3719232891280814,0.18579375271781765,-0.026365014839644447,0.03357840245228325,0.6363911469466984,0.026278478380067853,-1.251783121812382,0.06224813379893272,-0.18684847231609106,1.0774258544379525,0.2465187085392997,-0.15111758181441912,0.3414762932470004,-0.07135351612312912,0.07337494108440548,0.6400780949597087,0.047847745170543805,0.0690240325759454,0.028467079345939745,0.13674802115138876,-0.197830573278118,-0.04733704507376262,-0.06732978428039571,0.037307515976838124,-0.17262179697622898,0.2540796198789833,0.012153458900364308,-0.1108305865144036,-0.14956741051443306,-0.35516622042492163,-0.050457776160830435,0.25539235374034713,-0.04195425270510645,-0.4143014547768338,-0.05141134811484994,-0.8701771526721884,0.048989533212493525,0.2496954807138536,-0.11212760430022048,-0.09239624663866286,-0.025286911211602776,-0.21577983570509945,0.14397347059325669,-0.13132303593522698,-0.13893716136507436,-0.20911526717611886,-0.07938545620839657,-0.05874654283618619,-0.22641067845457846,0.31773519803657485,0.05733192941165882,Assembly,5
110,110,"short read fragment assembly  bacterial genomes
  last year highthroughput sequence technologies  progress  proofofconcept  production quality   methods produce highquality read   yet  produce read comparable  length  sangerbased sequence current fragment assembly algorithms   implement  optimize  matepaired sangerbased read  thus   perform well  short read produce  short read technologies  present  new eulerian assembler  generate nearly optimal short read assemblies  bacterial genomes  describe  approach  assemble read   case   popular hybrid protocol  short  long sangerbased read  combined
error correction  read  assembly proceed  several step error correction graph construction graph correction  assembly  transform paths   correct graph  contigs base miscall  indels  inevitable  sequence project    necessary  detect errors  read  accurately determine  finish sequence   past     assembly  map read   consensus sequence pevzner    introduce error correction   assembly  demonstrate   greatly simplify  assembly       standard preprocessing step  assembly use  multiple alignment  read tammi      cluster  align read prior  assembly batzoglou     htsr sequence construct multiple alignments  short read   time consume    correct errors  read prior  assembly use  method call spectral alignment     use  multiple sequence alignment  method take  read    set  ltuples graphic call  spectrum  find  minimum number  substitutions insertions  deletions   require  make every ltuple   belong  graphic  set graphic  choose  count  frequency   ltuples present   read   sequence project  select tuples  occur  multiplicity   threshold  call solid ltuples  iterative solution    describe  pevzner    follow   dynamic program solution  chaisson     dynamic program solution   allow  efficient search  insertions  deletions     particularly well suit  fix errors  read generate  pyrosequencing    errors  bias toward indels   approach implement  eulersr  faster    higher rate  error correction   approach describe  chaisson     choice  appropriate parameters  fix errors use   minimize  number  erroneous ltuples remain  read   affect correct  lowcoverage sequence consider  sequence project  produce  read  average length    genome  length   average number  read cover  ltuple           approximately distribute   poisson  parameter   minimize  number  correct sequence consider   erroneous  pick  multiplicity       expect ltuples cover  less   read  probability  ltuple   genome  cover  time  formula    poisson  parameter    typical highthroughput sequence project   bacterial genome   million base   million  read    one hundred mers expect   cover less  five time furthermore   gross simplification   sequence  random      random error rate  erroneous ltuples  expect   make solid  coincident errors  bruijn graph construction    massive scale   data  short read assembly   necessary  perform assembly  linear  close  linear time although   possible  construct   bruijn graph  linear time memory efficiency     premium  short read assembly  run time   bruijn graph construction  implement  several stag      trade linear time  methods  run  sort list thus   logn time  reduce memory requirements   genome  length    bruijn graph   vertices   edge regardless   number  read   data set  find  set  vertices    bruijn graph use  efficient hash structure  linear time proportional   number  read    data set   represent  vertices   sort list   tuples allow   discard  memory overhead   hash structure require   time access  next generate adjacencies  query  vertex list    binary search  every adjacent pair  ltuples   set  read   represent  graph   adjacency list   bruijn graph use  maximum   *    bytes     memory allocate   vertex  bytes   current implementation  subsequent phase  form  condense  bruijn graph  every simple path consist  vertices  indegree  outdegree   substitute   single label edge   read  use  generate   bruijn  thus  condense graph every   tuple   read map   unique edge  position   condense  bruijn graph  use   define  path  edge   read   assign  weight  every edge equal   number  read map   edge  paths  use  graph correction  find  eulerian path    bruijn graph  correspond   assemble genome  bruijn graph correction  read cover every   tuple   genome   errorfree  generate  bruijn graph  would represent  repeat graph   genome  minimal repeat length    however  error correction  small number  errors remain result   add  remove edge  compare   repeat graph  example  single mutation   read  create    extra edge    bruijn graph  goal   construct  graph * give    assume every   tuple   original genome  sequence correctly   least one read  *   subset   vertices  edge   graph  real read  thus  may perform additional error correction  detect  remove erroneous edge   graph   adapt  methods  graph simplification  abruijn graph  pevzner     perform graph correction   bruijn graph  distinguish  two methods  graph simplification aim  capture  repeatconsensus  mosaic structure   genome   goal  graph correction   simplify   bruijn graph   erroneous edge  remove     example  graph simplification repeat  high similarity  typically merge   single edge correspond   repeat consensus sequence  correct  bruijn graph contain  separate path   distinct repeat sequence   abruijn graph  construct   set  pairwise alignments gap  substitutions   alignment create undirected cycle call “bulges”  inconsistencies   alignment create direct cycle call “whirls” pevzner     cycle  call “short”   girth  less   fix parameter   algorithm  generate  abruijn graph employ  heuristic  find  graph  represent  largest possible set  consistent alignments  solve  maximum subgraph  large girth mslg problem pevzner      problem  hard  arbitrary girth value  heuristic  use  replace  abruijn graph   maximum span tree  successively add edge   original graph   span tree     create  cycle  girth less    similar approach  remove short cycle  use  fragment assembly    bruijn graph one property    bruijn graph   every vertex   reachable   direct path   source vertex   one source vertex exist  shortfall   bulge removal method  abruijn graph      bruijn graph  replace   undirected maximum span tree certain vertices may   reachable   source  direct paths although  path straighten heuristic pevzner     use   abruijn graph construction  repair edge  unreachable vertices  circumvent  problem entirely  replace   bruijn graph   maximum branch chu  liu  edmonds  use  method describe  georgiadis   branch  direct paths   source vertex   vertices  “alignments”  find   vertex  perfectly match sequence  length  direct cycle  rarely erroneous    cover long lowcomplexity regions  example homopolymeric  dinucleotides  check  see whether add  edge   maximum branch form  cycle  distinguish  direct  undirected cycle  add  edge   branch     create  undirected cycle  girth    direct cycle  length   tandem repeat   detect  whirl    bruijn graph typically direct cycle  two edge  show  figure  top find  number  copy multiplicity   tandem repeat   difficult problem   assembler  example  multiplicity  perfect tandem repeat  length longer  half   read length cannot  infer   bruijn graph   result infer  multiplicities  tandem repeat usually amount  errorprone coverage analysis   tandem repeat  multiplicity   expect     coverage   repeat  multiplicity   avoid potential errors cause   coverage analysis short read technologies often produce uneven coverage   reduce  fragmentation due  tandem repeat  assume    two copy   perfect tandem repeat  construct  assembly   path  traverse  repeat twice  show  figure  bottom   procedure may underestimate  copy number  tandem repeat  find   lead    errors  therefore believe     practical approach  least   information  coverage  specifics  errors  short read technologies become available read   map  edge    delete  graph correction  thread   remain edge let  path    read             remove edge  search   alternative path        start   end  edge     sequence correspond      sufficiently similar  replace       path  find  addition  bulge  whirl removal  also apply two additional techniques  remove erroneous edge erosion  describe  pevzner     lowweight edge removal erosion remove short source  sink   graph lowweight edge removal  typically  way  detect lowquality chimeric read although  htsr sequencers   use clone libraries sequence errors   end  read create erroneous edge similar   create  chimeric read    bruijn graph   correct  apply  equivalent transformation describe  pevzner     resolve repeat   shorter   length   read   matepair information exist  cut paths    cover repeat   operation similar   xcut pevzner     matepair information  available  postpone  cut operation  apply equivalent transformation  matepairs",-0.22097531396553147,0.20072408035979314,0.10942563959746328,0.1524315625402762,0.0045032012115070776,-0.016163564973302017,-0.11029545531941867,0.10562746880186888,-0.02061979854021981,0.1467643482381858,0.02591208945690028,0.04173502107491008,0.15014694224122585,-0.10080686932451956,0.14604517805599138,-0.06520532869959078,0.00016549438231106217,0.21058644214241826,-0.029751089352939013,0.040761416168034234,0.0428445565679066,-0.21624516455781526,0.04545724525481319,-0.0030656365165428285,0.00940248453303449,-0.1749013090413533,0.07558533471072988,-0.17159747753892873,-0.05227262885622054,-0.12516017583177147,-0.01721091858657917,0.2571619283924025,-0.14674279222195094,-0.11830382528204605,0.18249096416861524,0.09765636982391553,0.04902834535672585,-0.044482340194022175,-0.07466097333367623,-0.09989936774894502,-0.06345630715124928,-0.15731516459285105,-0.06914190472510083,-0.09577899073251764,-0.139186660859145,-0.0035567432176468365,0.13440561830476674,-0.15870014016612688,-0.24132787134358774,-0.35877855381721946,0.16601720501593645,-0.03478037510444035,0.030856303060755732,0.6319611530084754,0.03803428711770783,-1.1979121759601914,0.07467077568235575,-0.159584963956076,1.020118243011742,0.20897121609365146,-0.1908192314188933,0.2823315783074215,-0.0823477951215078,0.09301902981995784,0.6301867886668104,0.022668959100798747,0.05274822301614293,-0.003119313979780964,0.1701480679845048,-0.2359712231299905,-0.08500911425443762,-0.061718966977281374,0.07962535447943944,-0.1014157174441316,0.25200044363854396,-0.06907417905817198,-0.1482923614196667,-0.15970151307312325,-0.3395224552798155,-0.044720365850885936,0.2520871134277305,-0.035357240138013,-0.4085425358167111,-0.054296759260708115,-0.8674716390763182,0.07520313704473151,0.2360754060953086,-0.1215341728531359,-0.10395505543275073,-0.06619636238233294,-0.2074975543873184,0.10542738710862047,-0.16564433224456998,-0.11526830716003485,-0.15012059296259625,-0.14185559554981486,-0.05994203357642953,-0.314849720757586,0.3103326343842113,0.04314725663629068,Assembly,5
111,111,"allpaths  small genomes assemble accurately   high continuity  short pair reads
 demonstrate  genome sequence approach finish quality   generate  short pair read use  base fragment   base jump read  five microbial genomes  vary  composition  size     allpaths2 generate assemblies  long accurate contigs  scaffold velvet  eulersr  less accurate  example  escherichia coli  fraction   stretch   perfect   allpaths2  velvet   eulersr
allpaths  first test  simulate data    describe modifications   need    work well  real data removal  sequence artifacts   discard  read pair   read   pair consist      base   illumina platform  pair  nearly always artifacts   sequence process    run   sufficiently abundant   cause problems   assembly algorithms trust kmer identification  identify putatively correct  'trusted' kmers   read base  quality score  affect   create unipaths    correct errors  describe    kmer  appear   read  find   instance   read  examine  collection  read quality score   give base   kmer  base  call trust    enough good score default  score   least   entire kmer  call trust     base  trust rehabilitation  kmers  short fragment pair     pair    path  trust kmers  one end        path  use  untrusted kmers  rehabilitate  kmers change  status  trust unipath creation  find  kmers   read whose first  last kmer  trust  unipaths  mathematically define   trust kmers together   kmers  define adjacencies   trust kmers error correction    modify  use  new definition  trust kmers unipath graph shave   initial unipath creation   many case   read errors result  short terminal branch within  graph  shorter   kmers   remove provide     longer alternative branch unipath recovery  code identify unipaths    represent   assembly extend  unambiguously  possible   add    assembly typically  find small regions   relatively high copy number allpaths computational requirements  five genomes  assemble   processor dell server     memory    code  parallelize  wallclock time   assemblies   aureus  hours  coli  hours  sphaeroides  hours  pombe  hours  crassa  hours",-0.2142279583254769,0.2781147473116195,0.12235744297654637,0.07606627789716566,-0.019042586949804142,0.007544932628591214,-0.06092926781294086,0.06702284294841511,-0.06182256889859995,0.12385463998202355,0.02652830634746821,0.03461847934992083,0.17617839992256654,-0.0828038182229765,0.1181128959081346,-0.032387240408288866,0.11570860558459835,0.20811556796843728,-0.049939502335731835,0.09627887200068444,0.02088608492856785,-0.19057338087699344,0.07062524987324592,-0.028074830112558215,0.015223985940458313,-0.1652392332682446,-0.006558652193615994,-0.20118542502243672,-0.018108416960251728,-0.03454860196478905,0.04101287891727782,0.2725362922620749,-0.17862162459641695,-0.09651775236556967,0.17628239159070466,0.11167775597798847,0.00589280181354092,-0.031160477479364,-0.06700016781988162,-0.09911876241188317,-0.11518170528523175,-0.1959281379897748,-0.037984288163152684,-0.13056332359631215,-0.14294639641847162,-0.030605772835570536,0.1976892020943905,-0.1739201218670895,-0.1740572625410653,-0.3451334671583027,0.1422787828431014,-0.019884136842841644,0.048895911292563515,0.6351750698060759,-0.018969568728859867,-1.331403413607228,0.031908295543924464,-0.20368683469001084,1.1192944899922417,0.27412433122555097,-0.19973185820478734,0.4203901047495404,-0.09650324252659397,0.07069662975057238,0.6139853365704298,0.04158785053108248,0.11123648487602272,0.02115873879482669,0.159083597503242,-0.2410722829187439,-0.041957818532189835,0.05480282136329239,0.04752253095465412,-0.12979607372845134,0.29002024554196865,0.0010566302049424376,-0.1572894494973063,-0.059360665613184524,-0.38762282389047137,-0.0561519306333315,0.2326358273366256,0.005060185802980296,-0.432934075736651,-0.034415536109478236,-0.9511891883159536,0.06718736567849955,0.28985905941996365,-0.1225241828769926,-0.15133242797587187,-0.0367861190352649,-0.1058906413975262,0.07143030120360275,-0.09490378335899403,-0.0752261008796913,-0.1608396859313812,-0.1143549170345068,-0.06182021280570376,-0.3777751854110149,0.29304436714418475,0.0781674797316232,Assembly,5
112,112,"extend assembly  short dna sequence  handle error 
inexpensive  novo genome sequence particularly  organisms  small genomes   possible use several new sequence technologies    technologies     illumina' solexa sequence produce high genomic coverage  generate   large number  small read    prior work show  partial assembly   perform  kmer extension  errorfree read  algorithm  unsuccessful   sequence error rat find  practice  present vcake verify consensus assembly  kmer extension  modification  simple kmer extension  overcome error  use high depth coverage though    simple modification   previous approach  show significant improvements  assembly result  simulate  experimental datasets  include error
whole genome sequence  sarstor2  pseudomonas syringae  tomato str dc3000 dc3000 come  genbank ay274119  ae016853 respectively random 30mer simulate read  generate  different coverage level   whole genome sequence   simulations include errors  base   sequence  randomly  independently change  another base   fix probability three lanes  solexa sequence  dc3000 whole dna  also provide baltrus   unpublished data  use  test assembly  lanes combine     base     read make  coverage depth    vcake algorithm initially  vcake assembly process  nearly identical  ssake except  two multifasta file separately populate bin  set hash table   pool  read divergence   ssake method occur  extension   seed sequence  set vcake find  exact kmer match   ′ end   sequence    userdefined minimum   first  base   kmer  use  efficiently search bin   return key  check   remainder   kmer  match perfectly  push   array  number  time equal   value key   sequence  bin   ssake  bin hash table consist   tree hash table key   first  base   read   reverse complement follow   sequence    value contain  number  appearances   read   reverse complement allow efficient search  reach  minimum kmer length    total match sequence occurrences repetition  read include  less   userdefined value    algorithm  proceed    case vcake extract  kmer match    lower userdefined length    read  still  find  kmer match   userdefined length   consider  last group may  one mismatch  overlap   kmer   first  base  last procedure halt   total sequence occurrences   find   minimum overlap   reach   give sequence match two different kmer frame  contig extension   side  terminate  array  match sequence   consider  sequence offer  vote   first overhang base call   read  vote  total   base exceed  threshold  representation   add   contig however  contig   terminate   number  read call  second  common base exceed  userdefined threshold   value  represent  number  occurrences    base call   consider  indication  duplication   sequence elsewhere   genome rather  due  sequence error  user may also define  number  find read     algorithm terminate  contig   use  high representation  read   give sequence suggest repetitive sequence   genome regardless  contig termination  sequence retrieve  occur completely within  contig  delete   bin  set extension proceed one base   time   match  find   contig  terminate  one    reason   contig   reverse complement  extension   opposite end  perform    method  program finally output  contig   file  multifasta format  begin    unused seed  set",-0.24247977097619175,0.214148714398285,0.13339977195616534,0.1389775931956155,-0.014687968182888832,-0.00727387977417047,-0.04577261158213813,0.16835222910395162,-0.053468960495985235,0.0800801898391607,0.06601516136901872,0.038510478744808334,0.15171744920129035,-0.08255631681109378,0.1660756618206791,-0.06426199292193405,0.017818470302896173,0.2266946505983737,-0.03798817504681282,0.09010060344236064,0.0687117205473923,-0.1755225357745646,0.11553637591114865,0.014644271476130347,0.035849651553458074,-0.19274280578646732,0.07201775283936193,-0.18502527488139914,-0.02463242725606702,-0.0769550533387148,-0.010490256913494794,0.2817323211165072,-0.17787509209886718,-0.1135991514499491,0.19025902001728764,0.1062023880755684,0.02323120650744029,-0.05607806393584492,-0.12233542553012206,-0.12757062533979907,-0.09389689116049377,-0.19073626876150446,-0.06626296135386926,-0.12777346594021746,-0.08702258082413726,-0.029811796106318355,0.11008901311673552,-0.20065765975981348,-0.2088590140252456,-0.4251736112574672,0.17961114144646653,-0.008549813585191527,0.06820384602578282,0.6623636362252429,0.0015532602182265335,-1.4008928761251418,0.01436345874989296,-0.2481620606073799,1.1163925713192964,0.2873736527277894,-0.2078276233133853,0.3714606615979517,-0.027419667854202072,0.061579931845806325,0.6645435269935714,0.0168554349654062,0.048666813139610826,0.04668565190000022,0.11961820967696316,-0.22228236220475725,-0.09072335493564264,-0.0232864043914471,0.04745237201759843,-0.191687648675368,0.2280620255863623,0.0077746595831259206,-0.17359848113333368,-0.14967660531817506,-0.4442437199496792,-0.03801461902056711,0.3109452978411248,-0.04302673201192531,-0.3717763723769024,-0.0453654420530702,-0.98854085423712,0.035429619442712626,0.26193705450871263,-0.10154253103217914,-0.12687439769826026,0.011056212807792084,-0.20016833392711467,0.06884522422664233,-0.1843231653077893,-0.032645896847266244,-0.19579541955403434,-0.09955933711528048,-0.063601381605943,-0.2719981800422401,0.3721428294757418,0.030100056785158813,Assembly,5
113,113,"sharcgs  fast  highly accurate shortread assembly algorithm   novo genomic sequencing
 latest revolution   dna sequence field   bring    development  automate sequencers   capable  generate giga base pair data set quickly   low cost applications   technologies seem   limit  resequencing  transcript discovery due   shortness   generate read  order  extend  field  application   novo sequence  develop  sharcgs algorithm  assemble shortread mer data  high accuracy  speed  efficiency  sharcgs  test  bac insert  three eukaryotic species  two yeast chromosomes   two bacterial genomes haemophilus influenzae escherichia coli  show  merbased bac assemblies  n50 size  kbp  drosophila  arabidopsis   kbp  human  simulations take miss read  wrong base call  account  assemble  contigs  length     one single contig could   align errorfree   reference sequence  generate mer read   genome  helicobacter acinonychis   illumina  sequence instrument  assemble  contigs cover    genome   n50 size   kbp   exception  five contigs  differ   position relative   reference sequence  contigs match  genome errorfree thus sharcgs   suitable tool  fully exploit novel sequence technologies  assemble sequence contigs  novo  high confidence   outperform exist assembly algorithms  term  speed  accuracy
 sharcgs algorithm consist   filter step  avoid read  sequence errors  assembly step  generate contigs   final contig merge step include computation  quality measure filter  confirm read sharcgs obtain  large set  read  equal length optionally augment  quality score per base call   input thereby   adapt  cope   substantial number  read  sequence errors   error rate per base call      mer read contain errors pcorrect  probability   single read contain  sequence errors   estimate   product    base call  correct independently thus equation image  perror represent  error rate per base call    read length  order  assemble reliable contigs  suggest remove unconfirmed lowquality read   assembly  consider  read   confirm   follow two condition hold read  generate multiple time  overlap partner exist without quality score sharcgs simply filter  read generate  least  time    parameter   filter step  quality measure  available  first filter step  modify sharcgs  filter  read  high minimal quality value quality value   occurrences   read      opposite strand  combine similar  phrap ewing  green    maximum  use   confirmation come    strand   sum  use  confirmations   opposite strand  minimal quality threshold    parameter   filter variant  read  generate   high coverage  wrong read may pass  first filter step  instance  simulate  mer read   error rate   per base call   kbp target sequence  coverage   observe    wrong read among  generate twice  simulations  second criterion allow  removal  virtually  wrong read leave    first filter step   expense  discard   correct ones   second filter step  algorithm remove read  lack partner  perfectly match overlap  minimal overlap use  search  match partner   parameter   filter step   choose larger  half   read length  consider read   confirm   least one match partner exist     end thus    cover entirely  least twice read contain sequence errors   unlikely  find partner   side   filter step sharcgs generate reverse complement   confirm read  keep  one copy   read  start  core assembly algorithm  core assembly algorithm  core assembly algorithm  base   contig extension scheme use  prefixtree  look  potential extensions efficiently read  use  turn  nucleate novel contigs  contig  elongate   end  long   find read   prefix  minimal length  perfectly match  end   contig  algorithm try  extend  current contig   second part   match read  first check  strand  ambiguities  ambiguities occur  part   sequence  repeat   end   repeat  prefix  two read  match   repeat sequence   suffix  match  different part   sequence  cannot  arrange unambiguously   case  elongation   contig  terminate  search  ambiguities use prefix  minimal length extract     last  position   putative contigs end    prefix  use  search   read  start    prefix    read must match perfectly   end   putative contig  apply  approach   able  detect ambiguities although several read   row may  miss   input data   elongation   contig   ′ end   terminate  compute  reverse complement  try  elongation    end   way merge contigs  several assembly run  generation  quality measure set  filter parameters   stringent level discard large amount  data   input  result assembly   short contigs  read   many position   target sequence  unavailable  include weakly confirm read   assembly    difficult  filter read contain sequence errors  read however would stop  algorithm  assemble long contigs since read contain sequence errors cause spurious ambiguities  contig break due  confirm read  sequence errors tolerate  weak filter  unlikely  occur    position   contig break cause  miss read  application  strong filter criteria     run  core assembly algorithm automatically  weak medium  strong filter parameter settings   parameter set  core algorithm  generate contigs contain   target sequence sharcgs attempt  merge contigs  different core assembly run  find exact overlap  least  long   read length  quality measure  supply   raw read sharcgs compute quality measure   position   contigs  adopt  paradigm describe   phrap documentation ewing  green    give position    contig sharcgs find  cover read  select  best quality measure observe         opposite strand  add  two quality measure  obtain  final value finetuning parameters   introduce two parameters   algorithm  confirmation level  filter incorrect read   minimal overlap use   second filter step  well    contig elongation step  proper set    crucial   assemblers reliability  thus  provide automate conservative settings  describe   optimal set   parameters depend   length   target sequence  use  abundance  read generate several time   fingerprint   target sequence length  expect  number  read generate  time   distribute accord   binomial distribution  parameters   number  read generate    probability  read correctly   give position   target sequence  probability   give  pcorrectn     length   target sequence   input data   count  number  read generate  time      maximum likelihood approach  determine  combination  error rate  target sequence length   probably cause  distribution  read confirmations observe   input data  estimation  accurate  simulate data within    real sequence length accord   target sequence length   determine  confirmation level    strong filter   weak filter read pass  filter    expect  observe one read per position   target sequence     expect      correct read moreover    expect   able  assemble input data  decent quality    half   read  miss  minimal overlap    core assembly algorithm  check  ambiguities  well   minimal overlap use   second filter step  detect unreliable read depend   lengths  gap expect   input data   context  call gap run  consecutive position    confirm read  available  probability    gap  least  length  start   give position depend   number  available read navail   length   target sequence   follow equation image  pmiss   probability   confirm read  available   give position  number   gap expect   whole target sequence      suggest set  minimal overlap omin    expect number  gap larger    omin      read length implementation   implement  step   describe algorithm  perl  test  script  version    script language  program run   linux shell without installation  additional software  modules full documentation   user introduction  include   script  may  view  call  program without  parameters  assembly   bac  size  kbp typically take  min   intel xeon ghz bite linux machine  correspond memory footprint   program  smaller     ram  assembly   coli take less     use    ram   amd opteron ghz bite linux machine  filter step   assembly   acinonychis take    use    ram  assemblies   acinonychis  four different  level   final merge take    total  use    ram evaluation  order  evaluate  performance   algorithm   simulate short read   number  sequence compute contigs  match  back   reference sequence since  method  particularly valuable    novo sequence  bac insert  choose three eukaryotic bac libraries   clemson tbac library choi     arabidopsis thaliana rpci hoskins     drosophila melanogaster  rpci osoegawa     homo sapiens   selection  sequence bac insert  target sequence  collect  sequence bac insert   libraries   ncbi nucleotide database  version   december   sort  sequence  length  choose  successive bac insert sequence     three data set    average sequence length     species   kbp  kbp   thaliana  kbp   melanogaster   kbp   sapiens  order  mimic  real situation  sequence even  closely  add  sequence   clone vector pbace3     test sequence  filter  contigs match   vector  evaluate  assembly result shortread generation  silico   implement  program  simulate short read  input target sequence parameters   perl script   read length  number  read   average error rate per base call  script generate read   position   target sequence  equal probability  decide   base call independently   constant error probability whether   generate correctly  introduce  error  simulation program decide  equal probability  one   three possible substitution errors",-0.19908279407383064,0.18344228238158952,0.14110834947918438,0.10603514432960706,-0.0631054531033564,-0.030242615601196395,-0.03943522831738303,0.03965083348851794,-0.03429303711896642,0.1127226651010798,0.0006569581761245997,0.01291088942478565,0.14064829859010736,-0.08173492823127765,0.15478075131009292,-0.061180173772849525,0.043989935348243664,0.2262088447774741,-0.023846062328579904,0.10777123382524978,0.018289374725835077,-0.24975481098160435,0.08492772998980624,0.012466842567434251,0.01612805082670433,-0.12839564678373094,0.02477540450485544,-0.16513027669596694,-0.0526356768020489,-0.006860321418113382,0.011602767802634202,0.28593217402057863,-0.18235572377483336,-0.08982941814267235,0.2428921987029709,0.10291849130349194,0.03163283570542288,-0.007139166062742436,-0.11620169812065215,-0.14718619716740092,-0.09670667359239714,-0.1409841405352501,-0.08220326852310801,-0.10466859191550026,-0.10790357378180802,-0.031258512260763614,0.15355438423120782,-0.1970479568004233,-0.2427317828718323,-0.3994834602001398,0.14702092193941446,0.021854724992070532,0.048191363632352914,0.6236051976350214,0.03650151380188138,-1.2275145550245057,0.008793570019742495,-0.18688493804270245,1.0247550112427306,0.20238592500931848,-0.1724449060386191,0.3097798644584029,-0.07965516613693617,0.1068017048642879,0.6256027306615413,0.02260240667965263,0.03135267185733756,0.038082208510513964,0.1590546077565118,-0.20726985313744808,-0.050593111067122915,0.0003165105513824101,0.09449691285301899,-0.16201278525005414,0.22658006075995235,0.0042757577794923386,-0.18990459684919056,-0.14083674759790735,-0.3965978531682824,-0.04466366523969472,0.2864092926344931,-0.06143942361862825,-0.4508667482203878,-0.04497564774468917,-0.9391226381277308,0.0636299556309393,0.26968743190017463,-0.1082225697807693,-0.12215603914123578,-0.05492258709859565,-0.1766692575846734,0.12083634656857604,-0.11122811617015926,-0.10951210627649473,-0.13992258532997892,-0.1028502795315399,-0.07026044733105427,-0.315847320202403,0.3096471967103576,0.06403035989265142,Assembly,5
114,114," novo bacterial genome sequence millions   short read assemble   desktop computer
novel highthroughput dna sequence technologies allow researchers  characterize  bacterial genome   single experiment    moderate cost however  increase  sequence throughput   allow  use  platforms  obtain   expense  individual sequence read length  must  assemble  longer contigs   exploitable  study focus   illumina sequence platform  produce millions   short sequence    base  length  propose   novo assembler software   dedicate  process  data base   classical overlap graph representation    detection  potentially spurious read  software generate  set  accurate contigs  several kilobases  cover    bacterial genome  assembly result  validate  compare data set   obtain experimentally  staphylococcus aureus strain mw2  helicobacter acinonychis strain sheeba     publish genomes acquire  conventional sequence     fragment  also provide indications   broad coverage achieve  highthroughput sequence might allow   detection  clonal polymorphisms   set  dna molecules  sequenced
edena  base   classical overlap layout assembly framework pop     addition  include two feature  improve  assembly   short sequence exact match  detection  spurious read  exact match choice  include  two reason first  inherent sequence errors result   significant number  spurious overlap impair  correct sequence determination allow approximate match would significantly increase  number   nonspecific spurious overlap second exact match  drastically faster  approximate match  use  appropriate index overlap  millions  short read   compute    minutes  key step  edena   summarize  follow first  short read data set  process  remove redundant information second  overlap   minimum size  compute   overlap graph  construct third  graph  clean  remove transitive  spurious edge   resolve bubble finally  contigs   minimum size   unambiguously represent   graph  provide   output  program assume   read    length reduce read redundancy due   high level  oversampling achieve   illumina genome analyzer  significant number  read  represent several time   data set  first process  data set  order  keep  single copy   read  step reduce  size   data set without lose information   achieve  index  read   prefix tree  give read   reverse complement  consider     read   merge    tree key read  contain ambiguous base symbols  discard since  cannot  handle   exact match procedure since identical read  merge    tree key  nonredundant set  read   produce   tree structure  occurrence frequency   read  observe   initial data set  keep  order  compute  coverage depth   contigs  quality control purpose overlap phase  overlap phase  perform  index  nonredundant read data set   suffix array manber  myers   structure reveal exact match  exact overlap   low memory cost  set  reveal overlap  load   bidirected graph structure kececioglu  myers  myers    read  correspond   vertex  two vertices     connect   bidirected edge     overlap bidirected edge   arrowhead   end   independently  direct      vertex   end   edge subsequently   four different ways  connect two nod depend   relative orientation       side   read   involve   overlap  arrowhead  direct       overlap imply  leave end             imply  right end     edge  label   overlap size  order  build  valid read assembly vertices must  traverse use two oppose arrowhead orientations enter    inarrowhead  leave    outarrowhead indicate   correspond read  spell   direct strand  traverse    outarrowhead   inarrowhead indicate    spell   reverse direction  minimum overlap size   determinant parameter   assembly success  small value  increase  frequency  overlap  exist  chance  create significant branch   graph    hand  large value  increase  number  read    overlap  one   side  lead   paths   graph remove transitive edge due   high oversampling achieve   illumina sequence technology  great majority  edge   overlap graph correspond  transitive edge  edge   essential  represent every possible sequence   graph  example consider two paths  →  →    →   path  →   transitive   bypass   represent   sequence   first path   illustrate   point  view   multiple alignment  figure  transitive edge removal   essential procedure  reduce  graph complexity   factor   oversampling rate  calculate  nlg     number  read    size   genome  sequence    length   read clean   graph  transitively reduce overlap graph contain  significant amount  branch paths  compromise  production  long contigs  branch paths  cause  genomic repetitions sequence errors  clonal polymorphisms see result without additional information branch paths cause  genomic repetitions cannot  fix however  propose  simple  efficient method  fix  latter two problems  step   key   success   edena approach base call errors  read cause short  paths  clonal polymorphisms create small bubble   overlap graph  clean operations identify  feature   local graph exploration start   branch node  first clean operation remove  nod   involve  short  paths fig   underlie idea   edge lead   read  contain  sequence error  rapidly reach    branch node  thus explore   possible path elongations    depth   nod   path  depth   exist  nod  mark  removal    paths   detect mark nod  remove   value   cutoff    branch path  consider   valid  determine   value       good compromise see result  second clean operation identify short bubble   graph fig   bubble   cause  nonexact repetitions   genomic sequence however    bubble could  cause  single base substitutions carry   subset  dna molecules contain   analyze sample see result  use  term  pbubble  refer  bubble   cause   single base substitution   word  pbubble represent  base alternative   assembly  length   pbubble                     read length   minimum require overlap size respectively  branch path  explore    length  detect pbubbles  resolve  remove  nod   less cover side  pbubble  therefore resolve   simple nonintersecting path correspond    cover path despite  fact   polymorphisms   represent   final assembly  information   keep   separate file strict  nonstrict assembly modes  additional clean operation significantly increase  size   contigs  also generate   misassemblies  clean operation correspond   “nonstrict” mode   implement  edena   base   fact  longer overlap   reliable  shorter ones  branch node  examine    edge  edge maximize  overlap value   keep  operation allow clean ambiguities   edge correspond   maximum length overlap  unique   graph clean operations  finish  set  contigs  produce  spell  sequence model   nonintersecting simple paths    nod    outdegree  exactly one  traverse strain  culture condition  aureus strain mw2  obtain  narsa   grow  mueller hinton broth      bacterial cells  rinse twice     trisedta      respectively suspend      contain  μgml lysostaphin ambicin apply microbiology inc  incubate   min  ° dna   extract  purify accord   dneasy kit qiagen dna purity  quantity  assess use nanodrop wholegenome sequence   illumina genome analyzer technology  genomic dna   aureus strain mw2  sequence use  solexa technology  mayer  farinelli   kawashima  patent application wo98 accord   manufacturers protocol illumina briefly    genomic dna  physically fragment  nebulization     fragment  endrepair  ligation   adaptors  products  purify  agarose gel  recover    products quality control  perform  clone  library   topo plasmid  capillary sequence    clone  sample   use  generate dna colonies  dna cluster use two channel   flowcell  dilutions      respectively  flowcell   submit   cycle  sequence reaction   illumina genome analyzer illumina data  analyze use  solexa data analysis pipeline  software   quality filtration use standard parameters  obtain  total   million read    base  length",-0.17085088320491634,0.18916955305016545,0.08618288679042807,0.17356930451212713,-0.019049279756159575,-0.06488542402491355,-0.0915992440903758,0.052774333105358034,-0.003718826451888645,0.1401636446943978,0.015127960530092872,0.004303353786446065,0.14299222991318955,-0.059056952744806525,0.15530394242427042,-0.06276953989101282,0.03624428500440981,0.1870079750632755,-0.023110217911104326,0.02683987708913768,-0.001196682279233832,-0.2362878676750753,0.031111195993312375,0.005217800549293185,0.003690810979579585,-0.09926285155633667,0.0904261581213999,-0.1814265993558409,-0.025704427116763698,-0.06005089283760929,-0.007478525675833225,0.2726771122195298,-0.18154735291932134,-0.09357853916463868,0.18990811076830846,0.049730711121319694,0.06965110853247075,-0.031024132125887526,-0.1056690578219896,-0.10564161695088316,-0.08353892770856731,-0.1518269413047756,-0.07751088297465837,-0.12056740645532417,-0.1340611168543853,0.0076871747846703935,0.13750368646929512,-0.15758018642355384,-0.21563220435742245,-0.33805844655529743,0.18127096191452569,0.03183786878776063,0.06299357810001596,0.6228618269017617,0.016963830262041055,-1.1543392673011377,0.04450586482949824,-0.2053258848317663,0.9993660755186196,0.19364538080443305,-0.13763697832235114,0.2826199380504192,-0.060324445510765615,0.0951157560959144,0.5942840346101537,0.05684726931496961,0.06120906984433532,0.01869241055423753,0.16381727173378838,-0.2524513061932591,-0.05195486587753655,-0.009699099987790168,0.07908791421557754,-0.13737910498404898,0.20645817959265986,-0.046139559341617016,-0.11851172141551253,-0.1553401930358665,-0.3536411291358611,-0.05824838932098664,0.206624639611018,-0.05863316595106925,-0.3900281379178884,0.012043357577107578,-0.8642435313780309,0.10259091032694197,0.28968436252662394,-0.08165128847362517,-0.131720563300313,-0.015039013790286496,-0.1963125309810121,0.07038999356621181,-0.13000390387297306,-0.09639269395405987,-0.12864511256689676,-0.09022185068846826,-0.05592516873211387,-0.33914521085897864,0.30754661789551063,0.07828988592751908,Assembly,5
115,115,"idba   practical iterative  bruijn graph  novo assembler
  bruijn graph assembly approach break read  kmers  assemble   contigs  string graph approach form contigs  connect two read     overlap nucleotides  approach must deal   follow problems falsepositive vertices due  erroneous read gap problem due  nonuniform coverage branch problem due  erroneous read  repeat regions  proper choice    crucial   single    always  tradeoff  small  favor  situation  erroneous read  nonuniform coverage   large  favor short repeat regions  propose  iterative  bruijn graph approach iterate  small  large  explore  advantage     value  idba outperform  exist algorithms  construct longer contigs  similar accuracy  use less memory   real  simulate data  run time   algorithm  comparable  exist algorithms
given  set  read  denote   bruijn graph   fix     instead  use  one fix  idba iterative  bruijn graph short read assembler iterate   range   value    kmin    kmax  maintain  accumulate  bruijn graph    iteration   first step   kmin   equivalent   graph   delete  vertices whose correspond kmers appear     time  set       practice depend   coverage   input read   read theorem   appendix show   kmers   likely   false positives  construct      first construct potential contigs    identify maximal paths   …     vertices  indegree  outdegree equal   except     may  indegree   outdegree  respectively note   path   vertices represent  potential contig  length       remove  read    represent  potential contigs     read   substrings   contig   read cannot  use  resolve  branch   construction     consider  remain read   potential contigs     perform two step  convert       edge        convert  edge   vertex represent  kmer xi1 xi2 … xik xjk  xi1 xj1 …xjk   connect every two  vertices   edge   correspond two consecutive kmers  support  one   remain read  potential contigs      correspond kmer exist note   practice    need         jump       case    convert  path  length      vertex  theorem    appendix  show   set     may get high quality contigs   increase  expect  quality  contigs  drop    always better  use  small   choice    represent  tradeoff   efficiency   algorithm   quality   contigs      follow  algorithms   remove deadends potential contig shorter      one end   indegree  outdegree  represent  path    length    note  remove  deadend may create  deadends  procedure  repeat    deadends exist   graph  deadend contigs  likely   false positives   discuss   appendix  fact    remain false positive vertices   first filter step   remove  dead end   accuracy   contigs produce  idba  high  obtain hkmax  merge bubble  bubble  two paths represent two different contigs go    vertex     vertex    two contigs differ   one nucleotide  scenario  likely   cause   error   snp like  assembly algorithms   merge  two contigs  one  base  matepair information  connect  contigs  much  possible  use  similar algorithm  aby  report  final set  contigs note   probability  remove  true positive vertex   filter step   low theorem   appendix  give  analysis  long  kmin   filter threshold   set   reasonable value      example   length read  sample   genome  length   coverage  error rate   probability  filter   true positive vertex  h25      expect number  false negative vertices        small even   case   expect number  false negative vertices  large say    still relatively  small  compare   genome size thus  simplicity  analysis  assume    false negative vertex  hkmin  filter step  remove  large portion   false positive vertices    remain false positive vertices  remove  later step  deadends  probability  remove  correct contig   deadend  also small see theorem   appendix    exact calculation   probabilities  probability  determine  deadend wrongly       example  consider due   gap problem  contig  appear      small  might    contig  '  ' however  idba   contig  appear     must   contig    contain  theorem     contig information  carry        increase  branch   resolve   gap solve    small  previous iterations   preserve  memory use  idba       use    exist tool    false positive vertices  remove   filter step line   algorithm idba  idba use  compact hash table  represent  bruijn graph implicitly   edge represent  one bite  although idba construct hkmax  hkmin step  step  run time  idba   directly proportional   number   value  kmax  kmin accord  theorem   contig    also  contig   thus idba  need  check whether  branch     resolve   since read represent   contig  remove   iteration  number  read   iteration decrease  practice  half   read  remove  construct hkmin  idba run much faster  aby   three time slower  velvet  experimental result  genome  escherichia coli o157h7 str ec4115  ncbi   use  simulate experiment  genome length    read  randomly sample uniformly  coverage    experiment  generate read  error rat  read length   insert distance  note    repeat  experiment use  coverage    error rat    read length    result  similar    show  result   coverage   error  length read  also use  real data set namely bacillus subtilis  evaluate  algorithm  length   genome    read  sequence use solexa machine  coverage  read length   insert distance   estimate error rate   ",-0.18566968167821565,0.20926489770169032,0.14155668730514168,0.1355429899699767,-0.07001287251963123,-0.04135881864225887,-0.0980811235865324,0.06770578422594664,-0.02414346162571967,0.08039316585266286,0.017309797340369026,0.07980860066670699,0.15148926138968047,-0.03990798864282569,0.152076412414758,-0.05004594866697902,-0.003305376568195325,0.19558944198874856,-0.04232438433411352,0.05113711238179045,0.1308146599913016,-0.1818117956466846,0.036608546376087216,0.010548847856239952,-0.01864702974368508,-0.16045956138281547,0.05267874495599024,-0.21301838882010832,-0.028736169314167156,-0.09558505613588776,0.0437650455807505,0.2693122775103389,-0.13725855962966854,-0.07348652165929902,0.21885713091162895,0.11612404493114975,0.05734844603284728,0.015691174859195158,-0.0623444586385493,-0.14339748409111053,-0.08443972702750188,-0.14256618859161047,-0.06688198115884778,-0.1523510870721304,-0.17379194853371396,-0.033899514542237295,0.15965490511823166,-0.19424402128788645,-0.24584272518735484,-0.4298885453348648,0.19708406686726396,-0.019834400552071838,0.0732940085458033,0.6831726887206914,-0.006742431171005593,-1.3357093863287997,0.06732180664160599,-0.16403770973953544,1.030388101432684,0.2353847298277701,-0.19067396361534714,0.3224753805261571,-0.12096319726498965,0.07498543375087055,0.6229277547972742,0.08574060455694879,0.08494694812389117,0.029167691012844443,0.14477192812641573,-0.1993750793732364,-0.0998529715307775,-0.028422390024140688,0.04932499441808128,-0.13771496638197056,0.22334784810664127,-0.034153752338942,-0.12221992138383388,-0.1860061422926127,-0.4123059968220663,-0.07136526582083509,0.2365105583965377,-0.02015648231661709,-0.4581844083440956,-0.08599578276445037,-0.9238135725803052,0.013531020670294916,0.19283980612156235,-0.11406340723183485,-0.11984619364022475,-0.06553647927196862,-0.2254743267690311,0.0927437399214162,-0.1793511889757638,-0.1134713892366342,-0.19297497232786776,-0.09172779817670358,-0.06603819398107147,-0.3108824009867738,0.2804037891434167,0.041605259413093634,Assembly,5
116,116,"idbatran   robust  novo  bruijn graph assembler  transcriptomes  uneven expression levels
rna sequence base  nextgeneration sequence technology  effective  analyze transcriptomes like  novo genome assembly  novo transcriptome assembly   rely   reference genome  additional annotation information    difficult  particular isoforms    uneven expression level    make   difficult  identify lowexpressed isoforms one challenge   remove erroneous verticesedges  high multiplicity produce  highexpressed isoforms    bruijn graph without remove correct ones  notsohigh multiplicity  lowexpressed isoforms fail     result   loss  lowexpressed isoforms   complicate subgraphs  transcripts  different genes mix together due  erroneous verticesedges unlike exist tool  remove erroneous verticesedges  multiplicities lower   global threshold  use  probabilistic progressive approach  iteratively remove   local thresholds  enable   decompose  graph  disconnect components  contain   genes    single gene  retain many correct verticesedges  lowexpressed isoforms combine  exist techniques idbatran  able  assemble  highexpressed  lowexpressed transcripts  outperform exist assemblers  term  sensitivity  specificity   simulate  real data
similar  oasesm idbatran also adopt  idea  multiple   handle transcripts  different expression level however instead  generate   bruijn graph  find transcripts    value  accumulate  bruijn graph  build  capture  information   highexpressed  lowexpressed transcripts   iteration  accumulate  bruijn graph    fix   construct   input read   contigs construct  previous iterations   contigs construct  hks  treat  input read   construction    depth information  use  separate  bruijn graph  components ideally transcripts  different genes  decompose  different components   component alternative splice   detect  transcripts   reconstruct  accumulate information  reconstruct transcripts  use  input read   next iteration figure  show  workflow  idbatran  assemble  set  pairedend read   first iteration    kmin   equivalent    bruijn graph  vertices whose correspond kmers  multiplicity   least    default time   read   subsequent iterations sequence errors  first remove accord   topological structure     slightly different way   assemblers section   tip dangle paths    length shorter    likely   false positives     simpson    zerbino  birney  similar paths bubble represent  similar contigs    start vertex  end vertex  likely   cause  errors  snps     merge     simpson    zerbino  birney    depth information  contigs  components  use  decompose  graph  components section  paths  high support   pairedend read  reconstruct  transcripts   component section  errors   assemble contigs  correct  align read   contigs section   construct hks    length    path    convert   vertex   smer     edge  two vertices   correspond     mer appear    default time  read    contigs  ∪lck∪   represent  set  contigs lck   set  contigs construct  local assembly use pairedend information section      set  transcripts  consider    follow subsections  describe  step  idbatran  detail prune short tip  merge similar path many  novo assemblers remove tip short simple paths lead  dead end    bruijn graph  erroneous contigs  would   advisable  remove  tip  transcriptome assembly  transcripts   short could  several hundred base  compare  genomes remove one hundred base   end   genome may    problem  remove one hundred base   end   transcript may lose much important information  construct  accumulate  bruijn graph  idbatran  tip removal process  take place   iteration instead  remove  tip  produce shorter transcripts idbatran keep  longest tip  highest probability    correct path  remove   short tip   branch   graph idbatran check  outgo  incoming edge keep  branch  lead   longest path  remove   branch tip  lead  paths shorter   usually  correct branch lead  longer paths  tip   method preserve correct branch  transcriptome sequence data contain  errors  insertionsdeletions  genome sequence data idbatran identify  merge paths   start point  end point  higher   similarity include insertions  deletions  decompose  graph  iterate depth recall  tidba peng    also try  decompose   bruijn graph  components   base   observation     many repeat pattern  two transcripts  different genes  isoforms    gene share common exons thus  decompose  graph  different components     relatively  branch inside  component  relatively fewer branch  two components however erroneous kmers  highexpressed isoforms still cannot  remove effectively since components represent isoforms  different genes may  connect   erroneous kmers  form   large component prevent  assembler  determine isoforms   component instead  consider  number  branch  decompose   bruijn graph  components idbatran detect  remove erroneous paths connect two components  consider  lengths  sequence depths depths  short   paths use  probabilistic approach  depth   path contig   average multiplicity   kmer   path long contigs simple paths    bruijn graph  usually correct  long simple paths  unlikely   form  erroneous read  similarly  highdepth contigs   support  many read   contig whether  length  long  short  whether  depth  high  low cannot  judge  absolute value   length   contig depend   value     depth   contig depend   depths  neighbor contigs contigs    component since erroneous contigs  highdepth regions may  higher depths  correct contigs  lowdepth regions short   relatively lowdepth contigs  likely   erroneous    remove  removal take place   iterative manner chitsaz    peng       lowdepth errors  remove  short lowdepth contigs may  connect together  form long contigs increase depth cutoff progressively may help  preserve  lowdepth correct contigs idbatran remove contigs simple paths shorter    average sequence depth lower       threshold calculate base  value     depth distribution   connect component  contain  contig    large many correct contigs  remove  many true positive transcripts cannot  assemble    small many erroneous contigs   remove  transcripts  different genes may form  large component   correct transcripts  difficult  reconstruct  later step section  thus   select  largest threshold      many correct contigs  remove say  consider  correct exon  length  least     represent   simple path     bruijn graph however    sequence errors  read  may  branch    simple path  may  break  several shorter paths  length less   consider  particular edge →     correspond kmer  sample  time  may contain errors   another edge →    bruijn graph   least   multiplicity threshold use  remove erroneous kmers     kmers sample      error   last nucleotide     differ   last nucleotide thus introduce branch    probability   calculate  follow assume  probability   sequence error per base     probabilities   erroneous base  change    nucleotide      although  simple assumption   correct  real biological data  calculation   readily refine  different probabilities  probability    sample     last nucleotide change   particular nucleotide say   formula     sample  error     least     sample    error   last nucleotide since   three possible   existence probability   probability  branch    formula  order  estimate  value  depth   use  multinormal distribution  model  depth distribution   component     multiple isoforms say    component give  set  kmers  different multiplicities    component  assume  multiplicities   kmers  sample   normal distributions although  mean  standard deviation   normal distribution   estimate  expectationmaximization algorithm tanaseichuk     time   long    many kmers  components thus idbatran apply  approximation  cluster  kmers base   multiplicities  distance  two kmers equal  difference  multiplicities use kmeans cluster method  mean  standard deviation    calculate   cluster  set      experiment base   assumption       transcripts   components   final step let     normal distribution  depth  minimum mean depth value   probability   wrongly remove  correct contig  average depth ≤     formula note    exon  length  least   sequence depth   probability  branch  forumla⁠  value     select base   length  exons    large   select true positive kmers  paths  remove    small   select  true negative kmers  paths cannot  remove   select different value   depend   properties   data  use      experiment    select   calculate  largest    pfalse positive  lower   value say     remove  erroneous contigs without  many false positives algorithm  show  pseudocode   decompose step accord  peng      size   component  small  ≤    contigs  component  likely  represent isoforms   single gene    use   low depth threshold     tcomp  tcomp   average depth  connect component comp  prevent remove correct contigs  filter depth cutoff threshold   increase   factor   progressively   default   iteration short contig   remove   depth   lower   minimum  cutoff threshold    depth threshold   find transcripts algorithm  progressivecomponentdepthg     repeat    maxc∈gtc   component comp    sizecomp    calculate  else     tcomp   contig   comp  lenc      mint  remove             connect component    bruijn graph idbatran discover  paths start   vertex  zero indegree   vertex  zero outdegree   highest support  pairedend read  path  support  pairedend read   pairedend read   align   path   distance   align position match  insert distance   pairedend read  problem definition   simplify  follow transcripts discover  problem give   bruijn graph     set  vertices   edge   set  pairedend read   { }   ∈   insert distance   error  find  paths     maximum number  support pairedend read  ⊆   path    support pairedend read   iff  contain vertices      distance                since   problem   nphard problem see supplementary appendix idbatran perform  heuristic depthfirst search  find paths   zero indegree vertex   zero outdegree vertex  maximum support pairedend read   branch  path  many support pairedend read   consider   paths  practice idbatran report   tmax default  potential transcripts   zero indegree vertex   connect component idbatran apply  seed  extend method  align read  contigs paths   bruijn graph kmers   read appear    bruijn graph  consider  potential align position  idbatran  try  extend  end  alignment consider substitution error  note  insertion  deletion error   implement  idbatran easily however   number  substitution errors appear much    insertiondeletion errors idbatran consider substitution error   speed   alignment process  error correction  error correction step  perform  read  assemble contigs   assemble process  first read  align   contig  consensus   align read  replace  original contig  position   contig inconsistent   majority  align read   correct  align read  correct accord   align position  contigs  position   read  nucleotides inconsistent   consensus   correct  error correction step  reduce  number  erroneous read  branch    bruijn graph  local assembly let    set  contigs  extract  begin  end   contig     form  set  contigs ' assume  insert distance  pairedend read satisfy  normal distribution   idbatran perform local assembly peng      last    base   end   contig   pairedend read  one end align   since  read   far away  contig    mix  read  one end align    miss kmers   reconstruct   contigs   extend longer  estimate expression level since idbatran  design  assemble read  reconstruct express transcripts sophisticate algorithms    apply  estimate  expression level   transcript idbatran also provide  estimate expression level   transcript  align read   transcript rpkm read per kilobase per million map read  estimate  divide  total length  read uniquely align   transcript   total length  regions  transcript uniquely align  read",-0.18388743960698933,0.19822146470616048,0.13883128008616494,0.1445216715466499,-0.05300825709511685,-0.02508251556757574,-0.0989240870503396,0.060886729646550064,-0.022747678574447115,0.12053653778289433,0.013752751597605323,0.050768208897692686,0.1306039314015352,-0.07733395584966156,0.16231121951144645,-0.0612125853908514,0.003545529743973657,0.18344609178967014,-0.022300806178555576,0.07812774939573096,0.07853940834695522,-0.1857123117816045,0.0503533395159123,0.025137866912543667,0.01001184935261645,-0.16815628320735554,0.07068045610046612,-0.20845960363607774,-0.007526045713581511,-0.09066133735976707,0.047262847527405984,0.2532136107100357,-0.17102600578821714,-0.09862458650793264,0.16973166714755458,0.08950662267772923,0.04990013755860178,-0.000650390257893635,-0.06542770533512036,-0.08778962484232597,-0.09416108616069127,-0.17579004250737482,-0.06394137644425467,-0.15376448690220132,-0.13067591691105482,0.008145406809498665,0.12600288855646707,-0.1521162854431351,-0.2422288641631179,-0.3872119669000701,0.13101312481157248,-0.025953384246037853,0.07625507150859878,0.643591000457301,0.017519395611677722,-1.1990996769381512,0.053097693335289485,-0.17668018446036454,0.9933692898960867,0.23308595920462336,-0.17734038914735006,0.3225266891341808,-0.0652576419256842,0.08200773062090651,0.5926132232556008,0.03865486121266338,0.0359742896780997,0.043706674622349465,0.15715825847134818,-0.2432245938196707,-0.09930373990622426,-0.03898216973503323,0.06812267698135675,-0.13797603185931825,0.20849908450149374,-0.04965704128959125,-0.1175838624678856,-0.18306582603336716,-0.3770588789629459,-0.060778296759832415,0.21099825748773565,-0.045437991503741684,-0.4279128438625619,-0.060284676584856235,-0.856204249094323,0.05870773195712304,0.2239602949800823,-0.10704951749040302,-0.10809800555517482,-0.040017618725902114,-0.1983700372436144,0.10610850869521066,-0.1701662081622628,-0.09044070674549806,-0.16642714110473886,-0.12222585108156855,-0.05117364763226405,-0.3214206778962496,0.2782948182938214,0.07477222160046487,Assembly,5
117,117,"metaidba   novo assembler  metagenomic data
nextgeneration sequence techniques allow   generate read   microbial environment  order  analyze  microbial community however assemble   set  mix read  different species  form contigs   bottleneck  metagenomic research although   many assemblers  assemble read   single genome    assemblers  assemble read  metagenomic data without reference genome sequence moreover  performances   assemblers  metagenomic data  far  satisfactory    existence  common regions   genomes  subspecies  species  make  assembly problem much  complicate  introduce  metaidba algorithm  assemble read  metagenomic data  contain multiple genomes  different species   two core step  metaidba  first try  partition   bruijn graph  isolate components  different species base   important observation    component  capture  slight variants   genomes  subspecies    species  multiple alignments  represent  genome  one species use  consensus sequence comparison   performances  metaidba  exist assemblers   velvet  aby  different metagenomic datasets show  metaidba  reconstruct longer contigs  similar accuracy
  section   describe  algorithm metaidba  assemble read  multiple genomes  subspecies  different species   two main step  metaidba  show  figure  initially step  sequence read  use  construct   bruijn graph use   bruijn graphbased assembler chaisson  pevzner  peng    simpson    zerbino  birney   simple path    bruijn graph might represent  contig   genome   species  subspecies     sequence appear  multiple species   bruijn graph  read  different species  interconnect  crbranches   second step step  base   assumption   genomes  subspecies    species share  similar regions   genomes  subspecies  different species metaidba divide   bruijn graph  many small connect components  remove crbranches   genome sequence  subspecies even    species   exactly    consensus contig may   represent   simple path    bruijn graph  may  represent   component  multiple paths due  spbranches   source vertex   single sink vertex    confine  variations   similar regions   genome  small components   merge  bigger components  represent longer consensus contigs use pairedend read step    last step  metaidba step   component  transform   multiple alignment  similar contigs  different subspecies    species  consensus contig  represent  similar contigs   subspecies   species  find  step  metaidba   describe  detail   follow section construct  bruijn graph  genome assembler base    bruijn graph approach chaisson    peng    pevzner    simpson    zerbino  birney    use  assemble read  form contigs    read    single genome   bruijn graphbased algorithm first divide  read  lengthk substrings call kmers  kmer  represent   vertex    bruijn graph    edge       length   suffix  kmer       length   prefix  kmer   kmers    occur adjacently   least one read   single genome assembly problem  simple path    bruijn graph represent  contig   genome   branch represent  repeat region   genome   error   read  idba genome assembler peng     use   implementation  idba iteratively increase  value    remove kmers   support  read  branch   resolve  longer contigs   genome   obtain however metagenomic data contain read  genomes  multiple species     crbranches    bruijn graph represent common regions occur  genomes  different species  subspecies  kinds  branch cannot  remove   single genome assembler  thus  short contigs   produce especially  sample  many subspecies    species thus additional step  require  resolve  branch  divide graph  connect components base   wellaccepted idea pop   genomes  subspecies    species   similar  genomes  subspecies  different species metaidba divide   bruijn graph  connect components    component represent  consensus contig   species   assumption  genomes  subspecies    species   similar   many similar regions along  genome  common kmers     appear  distinct   least one common kmer exist within  relative short region  length        hand  genomes  subspecies  different species seldom contain  common kmer  frequently base   assumption  divide   bruijn graph  components  solve  follow graph partition algorithm graph partition problem give  direct graph   graph partition problem   partition  graph  maximal connect components  satisfy  follow property   vertex    component    another vertex       start   outgo edge       least  path        length       every incoming edge       least  path        length     idea behind  formulation   graph partition problem   follow   kmer   reach another kmer     bruijn graph   path  length    start     outgo edge  vice versa kmers     likely  occur   genomes  subspecies    species  represent high similarity among  genomes   subspecies otherwise kmers    may occur  genomes  different species     separate  graph partition problem   solve   greedy algorithm  repeatedly check  outgo incoming edge   vertex     paths  length    start  end   outgo incoming edge   vertex   end  start  another vertex    outgo incoming edge  vertex   remove    bruijn graph  remove process   repeat   components satisfy  requirements  correctness   greedy algorithm  prove  theorem   process  remove  crbranches  well     spbranches result  many small connect components  close common regions kmers represent consensus contigs   single species  induction   number  remove edge   first edge e1u1 ′  remove   greedy algorithm edge       component  either    vertex     outgo edge    access    path    length        vertex      access ′  paths    length     end   incoming edge  ′ consider  kth edge ekukuk′ remove   greedy algorithm either    vertex     outgo edge    access    path  {…}  length        vertex      access ′  paths  {…}  length     end   incoming edge  ′ since  edge …     component edge       component    ▪  connect components  pairedend read  solve  graph partition problem larger components may  break   smaller components    erroneous read  common regions among different species   component  represent  consensus contig  subspecies   single species metaidba merge  components  larger components use pairedend read  pairedend read represent two read appear    genome  know order  distance insert distance one end   pairedend read  consider  appear   component   kmer   read appear   component   two end   pairedend read appear  different components  pairedend read  consider   support   two components   merge   larger component metaidba merge  components     least    support  pairedend read   two components  connect   shortest path  match   insert distance   pairend read    merge  unambiguous   merge    perform   component  enough support  connect    one component moreover   components  consensus contig longer  insert distance  consider   procedure  otherwise  component cause   repeat region shorter  insert distance   connect  multiple components  enough support  construct multiple alignment  consensus contigs since  genomes   subspecies    species  similar  small variants    difficult  determine long contigs simple path   subspecies   contigs  interconnect    bruijn graph instead  represent  contig   species   simple path  consensus contig   species   many subspecies  represent   component   usually  direct acyclic graph  exception    repeat region   contig  capture  small variants among  genomes  different subspecies    species  simple path   component represent  short contig   subspecies   relative position   short contigs   obtain   structure   direct acyclic graph  order  obtain  contig   single species   component multiple alignment   short contigs represent  simple paths  perform metaidba start   alignment   short simple subpaths   source vertex   component  progressively construct  alignments  longer contigs  reference   longest subpath   provide  information   genomes   subspecies   short subpaths  deletions   relative position   simple path   determine  alignment   simple subpath   find locally finally  component  represent   consensus contig obtain  multiple alignment",-0.20548908117355089,0.20766450875055265,0.1343650145177711,0.15913879664605665,0.019033581123906462,0.004854975265334361,-0.09987693285619767,0.047881252653714186,0.0275054956302412,0.06498152381357025,-0.009426457080624851,0.027540855589048827,0.20693349820828774,-0.004138751264533722,0.14795243677537084,-0.061935751926263466,0.016993313413980762,0.148470080414828,-0.08917659379315891,0.057749314445490925,0.0790763247502493,-0.19337087766856284,0.0862063964116661,-0.04356433849955233,0.009300312243274177,-0.189691823693426,0.04621751562934186,-0.2072489938917844,0.02053834063220112,-0.07475983355007153,-0.0009951182166297065,0.24578760240738295,-0.1023886978363746,-0.1154030731765042,0.21780074721021925,0.13063541204559015,0.08949609239421348,-0.02169139742230376,-0.08234170945909093,-0.09221655926941072,-0.15904953804086236,-0.13695940848174,-0.029554045299415056,-0.1277430945532579,-0.1241010938613566,-0.01161445756716763,0.19695385622828468,-0.1059729703909754,-0.20353961557871209,-0.3636723645556462,0.15362363954019898,0.0014796769770327955,0.09049860870867384,0.662789913591947,0.05290954473871976,-1.312890512467015,0.037023447250819526,-0.1942981391346228,1.055082028311239,0.2545747506553216,-0.18522483836460002,0.37344682577075256,-0.05982099410109953,0.08683170870896062,0.6282276858959128,0.022564970769499447,0.1026993593860728,0.045560356767336815,0.16820026754787393,-0.2059018712965589,-0.10318574387177554,-0.058460110506298485,0.06597393637696537,-0.16917061683374876,0.21330126992189416,-0.05826665690561355,-0.11976427724493632,-0.14445198299819784,-0.3939120896891052,-0.0374488384350187,0.21206559587564486,-0.029478133107677062,-0.39759701653474977,-0.03645627463473848,-0.9242580061887994,0.07501609600468667,0.18495686030855368,-0.08923412118490566,-0.08933770095600801,-0.04424762216741311,-0.16366751269966948,0.06815125107030183,-0.18134663585144292,-0.0668128823761043,-0.2016735098616896,-0.07505802410910381,-0.13849321893763308,-0.2982565834360453,0.30279119559107165,0.10625306208225367,Assembly,5
118,118,"idbaud   novo assembler  singlecell  metagenomic sequence data  highly uneven depth
nextgeneration sequence allow   sequence read   microbial environment use singlecell sequence  metagenomic sequence technologies however  technologies suffer   problem  sequence depth  different regions   genome  genomes  different species  highly uneven  exist genome assemblers usually   assumption  sequence depths  even  assemblers fail  construct correct long contigs  introduce  idbaud algorithm   base    bruijn graph approach  assemble read  singlecell sequence  metagenomic sequence technologies  uneven sequence depths several nontrivial techniques   employ  tackle  problems instead  use  simple threshold  use multiple depthrelative thresholds  remove erroneous kmers   lowdepth  highdepth regions  technique  local assembly  pairedend information  use  solve  branch problem  lowdepth short repeat regions  speed   process  error correction step  conduct  correct read  highdepth regions    align  highconfident contigs comparison   performances  idbaud  exist assemblers velvet velvetsc soapdenovo  metaidba  different datasets show  idbaud  reconstruct longer contigs  higher accuracy
 flowchart   major step  idbaud  show  figure  idbaud iterate  value    kmin  kmax   iteration  accumulate  bruijn graph    fix   construct   set  input read   contigs cks  lcks construct  previous iterations   contigs  treat  input read  construct    iteration idbaud also progressively increase  value  depth cutoff thresholds  remove  lowdepth contigs    get longer confident contigs    error  read  correct  align  read   confident contigs  miss kmers  read   recover   contigs lck reconstruct  local assemble   small set  pairedend read  one end align   confident contig information   miss kmers   pass    next iteration   contigs lck   construction  hks finally  output contigs  use  form scaffold use pairedend read information algorithm  show  pseudocode  idbaud  assemble  set  pairedend read   insert distance       first iteration  kkmin   equivalent    bruijn graph  vertices whose correspond kmers  multiplicity  least    default time   read    subsequent iterations  sequence errors  first remove accord   topological structure    deadend contigs  bubble step     deadend contigs tangle paths    lengths shorter    likely   false positives     simpson    zerbino  birney  paths bubble represent  similar contigs except  one position     start vertex  end vertex  likely   cause   error   singlenucleotide polymorphism snp     merge together  one contig hernandez    simpson    zerbino  birney   construct hks    length  path    convert   vertex ksmer     edge   two vertices   correspond ksmer appear    default time  read    contigs  ∪ lck   follow subsections   describe   step  idbaud  detail  progressive relative depth  sequence depth depth  short   simple path contig   ′    copy    use  algorithm     preserve    implementation   step  use  remove errors  depth   contig   average number  read cover  kmer   contig note  long contigs  usually correct  long simple paths  unlikely  form  erroneous read similarly  highdepth contigs   support  many read   contig whether  length  long  short  whether  depth  high  low cannot  judge   absolute value   length   contig depend   value     depth   contig depend   depths   neighbor contigs neighbor contigs   identify   adjacency    bruijn graph even though wrong contigs  highdepth regions may  higher depths  correct contigs  lowdepth regions short   relatively low depth less   fraction    neighbor contigs' average depth contigs  likely   erroneous    remove   still  risk  remove short  relatively lowdepth correct contigs   relatively lowdepth correct contigs  highdepth neighbor may  break  short contigs   wrong contigs  branch   base   observation   short  relatively lowdepth correct contigs usually  higher depths   short wrong contigs   filter   wrong contigs first  increase  depth cutoff threshold progressively  low  high   wrong contigs  branch  remove   lowdepth cutoff threshold  relative lowdepth correct contigs   link together  form long confident contigs    consider  read   next iteration  key idea  consider  depth progressively  relatively  show  algorithm   represent  depth  contig   tneighborc represent  mean depth  ' neighbor contigs  filter depth cutoff threshold   increase   factor  progressively   ~  geometric increase instead  absolute increase  use  velvetsc   depth cutoff threshold value improve implementation efficiency   threshold difference   sensitive   lowdepth value   highdepth value   iteration short contig   remove   depth   lower   minimum  cutoff threshold    relative threshold *tneighborc      range   graphic  local assembly idba make use   contigs contain  information   miss kmers  larger  construct   iteration   construction    bruijn graph  larger   miss kmers may  exist     read   might help  fill  gap    bruijn graph  larger   approach still   limitation     miss kmers  contigs contain  kmers   construct     gap   fill   branch  main contribution  local assembly   construct  contigs   miss kmers especially   lowdepth regions base   information  pairedend read  eliminate  branch introduce   part   genome  shall illustrate  main idea  local assembly   example fig  let  consider  construction    bruijn graph   base  two read …aact  actg…    simple path connect  3mers aac act  ctg idba  reconstruct  miss 5mer aactg  appear   read  form  simple path contain  however  give  figure   act   length repeat   genome  repeat regions  apart     insert distance    read cover  region …tactt… contain   repeat  3mer act    bruijn graph     two inbranches  two outbranches refer   leave diagram  figure   vertex  represent  3mer act vertices   ′  ′   3mers aac ctg tac  ctt respectively   situation even    increase      idba  part  graph   disconnect      miss critical 5mers aactg cannot  reconstruct    branch however  consider   bruijn graph   idbaud  align  pairedend read   contig acgatcgtagctga fig  whereas  read    end cover  repeat regions    …aact  actg… read cover   repeat region …tactt…   involve    far away thus local assembly  consider  read locally  produce  simple path contain  critical 5mer aactg  resolve branch      repeat graphic fig  example  reconstruct miss kmer  local assembly act   repeat region   genome   read contain aactg  tactt  resolve repeat branch  local assembly act   longer  repeat    simple path local contig cover aactg   reconstruct  local read open  new tabdownload slide example  reconstruct miss kmer  local assembly act   repeat region   genome   read contain aactg  tactt  resolve repeat branch  local assembly act   longer  repeat    simple path local contig cover aactg   reconstruct  local read fig  example  resolve repeat  iteration      repeat region   single kmer uvw  ′′ appear   genome   iteration repeat   resolve open  new tabdownload slide example  resolve repeat  iteration      repeat region   single kmer uvw  ′′ appear   genome   iteration repeat   resolve let    set  contigs simple paths    set  pairedend read     one read align   end   long contig   length  least twice  read length   crc stand   reverse complement  contig    unaligned end   align pairedend read  would cover  genome regions extend   insert distance beyond  end   long contig  extract separately assume  insert distance  pairedend read satisfy  normal distribution   idbaud group  last d3δ base  ccrc  rcrcrc together   locally assemble    set  local contigs lck use idba algorithm  without step      show  algorithm  since  read   far away   contig     mix    unaligned end  contig    unaligned end read     use  construct  smaller  simpler  bruijn graph whose simple paths represent   set  contigs lck might reconstruct    miss kmers   consider  read   next iteration thus  contigs   extend longer  longer   iteration  expect number  resolve branch   compute  theorem  appendix  error correction  reduce  errors  read error correction   erroneous base  perform base   alignment  read  confident contigs errors  read  correct      align  contigs  certain similarity say   read    multialigned  different contigs    consider  corrections  approach  error correction  especially effective  highdepth regions   confident contigs  wellsupported  many read  position   contig  label  confirm  one base type appear     read align   position  read align   contig region   position confirm   number  different base     correct accord   confirm base  preerrorcorrection step  improve efficiency   use  remove errors  highdepth regions   first step  idbaud   sequence depths  extremely uneven  medium kvalue  filter threshold   use  assemble read  form contigs  errors  read  correct base   alignment   output contigs  scaffold  read  finally align  contigs    build  scaffold graph    vertex  represent  contig   edge   represent  connection       support     default pairedend read   scaffold graph  build scaffold algorithm       apply   connect contigs",-0.171258427695125,0.19576435093031985,0.13033083926092826,0.1180787931200406,-0.03270393907896714,-0.046167095136579836,-0.1520957811834256,0.05723887781315516,-0.02324699547513784,0.08661924736793741,0.046327075226521436,0.016060248591359058,0.1389370023489705,-0.054603511741553465,0.11813325754806048,-0.048147918764855066,-0.00012345908372930582,0.15337977144665127,-0.03887596784901187,0.04524167711313295,0.086156318148855,-0.16695515868128893,0.07396683676286075,0.007189557224247155,0.017163969058511332,-0.13949873853445086,0.03923883656726952,-0.21086940325625325,0.008196444550546517,-0.06910767883243676,0.029142197567752787,0.244822995512393,-0.11883600589959085,-0.10357575889525604,0.15049840291587693,0.12183051443880895,0.0800189430960561,-0.006264203934577005,-0.06433794022893705,-0.0943917641563384,-0.09243495235100506,-0.13783248871458315,-0.04658593546536258,-0.13811787041058046,-0.12391060317101107,-0.016760196694006992,0.1525526013360466,-0.1116397898696395,-0.186755987266935,-0.3576036031420166,0.15542735755009526,-0.021584088954657733,0.055885641642273456,0.617160421196671,0.008869143636782128,-1.1979509918768516,0.06749823135768743,-0.17171871569208352,0.97383014128233,0.2279547814016522,-0.16657551505608584,0.31433377402296675,-0.11275631245479907,0.06100323266314942,0.5691668149231045,0.049491665878028064,0.07761107075386735,0.02859971868998275,0.1453846269327312,-0.19707067373935291,-0.08181210295243681,-0.0577901428690496,0.03751274831678341,-0.12135120904027626,0.22593356022375755,-0.07645126134418112,-0.10122635196653547,-0.10974564457823384,-0.3351733803604569,-0.044569018248495566,0.21504952905006472,-0.029856178266663324,-0.3427103149554767,-0.061308920524623674,-0.8299735350475443,0.03914551782099284,0.17876859073227422,-0.09033265349725476,-0.09921864026772052,-0.03748836857459077,-0.1837966237083377,0.0497499207234085,-0.16980877667016503,-0.0880241520480713,-0.17319778897903254,-0.06522787127900741,-0.07482828137306925,-0.29204053926915896,0.2808275752431237,0.0444235736527614,Assembly,5
119,119,"tidba   novo iterative  bruijn graph assembler  transcriptome
rnaseq data produce  nextgeneration sequence technology   useful tool  analyze transcriptomes however exist  novo transcriptome assemblers   fully utilize  properties  transcriptomes  may result  short contigs    splice nature share exons   genes  propose  tidba algorithm  reconstruct express isoforms without reference genome  use pairend information  solve  problem  long repeat  different genes  branch    gene due  alternative splice  graph   decompose  small components  correspond   gene   possible isoforms  sufficient support   pairend read   find heuristically  practice   novo transcriptome assembler tidba outperform aby substantially  term  sensitivity  precision   simulate  real data
different  genome assembly whose input read  sample   species genome  input read  mammalian transcriptome assembly  sample   express mrnas   mammal   total length  genes  much shorter   genome  first glance mammalian transcriptome assembly problem seem easier   genome assembly problem however   alternative splice  long pattern represent exons may occur  multiple mrnas isoforms    gene thus   bruijn graph   graph   vertex represent  kmer   edge         adjacently occur   read   branch  construct   mammalian transcriptome assembly problem     genome assembly problem therefore traditional  novo genome assemblers  would  work well   mammalian transcriptome assembly problem   would usually stop  branch result   short contigs  represent  part   exons instead   whole isoform besides many  novo genomic assemblers   remove  end   contig  increase  accuracy   mrnas  usually relatively short  ~5000nt  lengths  contigs decrease significantly  order  reconstruct  isoforms  different genes  develop tidba  first divide   bruijn graph  many connect components    represent isoforms   single gene  tidba determine  isoform   component use pairend information  construct connect components  observe  although  repeat pattern   whole genome    long  number  genes  contain   long repeat pattern  actually quite  table  show  number  genes  mouse2  repeat pattern  length  least   particular     genes    genes contain repeat pattern  length  least 90bp    construct   brujin graph  large   connect components  contain isoforms  single genes   also build  bruijn graph   reference mrna   mouse ucsc mm9 ncbi build   different value   figure  show  number  connect components  number  connect components increase   increase     connect components    bruijn graph         mrnas   mouse database  component contain  average  mrnas table  show  distribution   number  mrnas  components    mrnas   components contain     mrnas   majority contain  one mrna  current nextgeneration sequence technology usually  produce read  length    thus   impossible  construct   bruijn graph      singleend read directly even   read  long enough  would   lot  gap   graph  construct directly  order  solve  problem   first step tidba apply  idba algorithm   construct   bruijn graph    kmod       length   input read   second step tidba align matepair read  exact match   graph  confident connection  nod  connection  nod  validate  find  unique path   graph connect  pair  nod  length match  insert distance   pairend read within specify error note   connection  two nod   discard   number  paths    zero    one although  problem  nphard since      loop   graph  kmod    unique path   find  practice table  show  number  mrnas  lengthk repeat    see less        mrnas contain loop lengthk repeat   graph   unique paths  validation  record  resolve branch  treat  extra long read  idba  construct  bruijn graph  kmax ≥  ≥  note  idba need   tune specifically  transcriptome assembly tip removal   bruijn graph  perform use  short length  avoid remove  many kmers since transcripts  usually  short  addition  bigger threshold   use  filter  incorrect kmers due  sequence errors since  may filter   lowcoverage kmers   unlikely    recover mrnas  low converage  low expression level    wellexpressed mrnas  consider  discover isoforms  connect components   connect component    bruijn graph    kmax tidba discover  paths start   vertex  zero indegree   vertex  zero outdegree   highest support  pairend read  path  support   pairend read   pairend read   align  exact match   path   distance   align position match  insert distance   pairend read     error tidba perform depthfirst search   vertex  zero indegree   vertex  zero outdegree  decrease order  support   branch  practice instead  perform  complete depthfirst search tidba report    potential isoforms   zero indegree node   connect component note     parameter set   set   user  expect sensitivity  tidba give  lengthn mrna    lengthw exons       coverage  pairend lengthl read       error rate   nucleotide   read     evaluate   follow  probability     recover  tidba  one contig thus   conclude   mrnas   recover  tidba  high probability  long   coverage   mrna exceed  certain threshold  order  recover   kminmers   must exist    bruijn graph    kmin  every kminmer must  sample  least  time   error since     cn2l pair  read sample     probability   particular kminmer contain   pair  read    kmin        probability   kminmer    sample  time                                                   min min however    sample kminmers may contain error since  probability   kminmer contain error  min min             probability     kmin   kminmers   exist    bruijn graph    kmod     min min min min min                                                                     ∑ ∑                             exist    bruijn graph    kmod  exist   connect component       pair  adjacent exons    branch  probability      branch   resolve  pairend read similar    probability   pairend read connect two adjacent exons  sample                                                   mod mod   probability  two kmodmers one   one  pairend read  sample correctly      mod mod            probability   exist   connect component   min min                                                                         ∑ ∑                                  multiply  two probabilities give       calculate  sensitivity  find  mrna   lengthm exons  coverage   example give  length mrna   length exons   coverage   error rate     threshold        mrna   discover  probability ",-0.17283648821002215,0.19358108677826952,0.10909874302322148,0.14162577881911098,-0.048563899502924966,-0.03270911646298676,-0.10793642631182997,0.06530595435227345,0.002191718324158703,0.08646357648265418,0.004554904502432085,0.044951061972420166,0.15816243037665526,-0.09052943990177988,0.13771253278052126,-0.03851300651553578,-0.0023427035727460557,0.19887513924913947,-0.050947890532976686,0.09240223680090924,0.02563600507710362,-0.16498754687644476,0.048737672173956526,-0.021221786123027817,-0.002671158029342122,-0.14897174111683853,0.07393633171098675,-0.17321842460417733,0.005345839137185572,-0.0627919401043376,0.015415010496831706,0.2606379440904776,-0.14165001047937645,-0.06111992442311021,0.2009827033387208,0.08779718886055182,0.0210623560592972,0.02652576736323277,-0.09095308905186053,-0.0923031562835806,-0.07182890963546623,-0.14145211224700285,-0.07146812838578223,-0.1351514025761086,-0.1318055501803125,-0.01683460561343964,0.15262493870573554,-0.1556725285447303,-0.2273655799625784,-0.3896534622997731,0.1593497405976652,-0.008311073801653239,0.07619255856924509,0.5971561080336364,0.015094086860901572,-1.1833869267203327,-0.0074991518017163295,-0.1852187156631165,0.9810562555576324,0.23760787267111205,-0.1577985317393945,0.3528962020387149,-0.05997464863887419,0.051580911794897266,0.5666154179958135,0.07659805657709108,0.06389283820883268,0.041402729231372684,0.18628500955431568,-0.17880422229851925,-0.08787320340779085,-0.031968226296562034,0.10886367804636796,-0.1328059185042447,0.2267623341241334,-0.054300486100045314,-0.1295018691364223,-0.17896706306580906,-0.35765745740273913,-0.059217321404705425,0.1863356508094714,-0.04647371958546703,-0.4205988374859671,-0.06995553239135513,-0.8472593160177995,0.05134673174951685,0.1909001444518152,-0.10870213593847844,-0.09347789709216968,-0.018540094971083616,-0.193915326840296,0.1223316258644142,-0.1371554961705341,-0.12547221011320492,-0.17422210711811206,-0.09090799629080316,-0.07852778197169147,-0.3237902279417742,0.2926866872100315,0.06395404799089495,Assembly,5
120,120,"parallelize short read assembly  large genomes use  bruijn graphs
nextgeneration sequence technologies  give rise   explosive increase  dna sequence throughput   promote  recent development   novo short read assemblers however exist assemblers require high execution time   large amount  compute resources  assemble large genomes  quantities  short read  present pasha  parallelize short read assembler use  bruijn graph  take advantage  hybrid compute architectures consist   sharedmemory multicore cpus  distributedmemory compute cluster  gain efficiency  scalability evaluation use three smallscale real pairedend datasets show  pasha  able  produce  contiguous highquality assemblies  shorter time compare  three lead assemblers velvet aby  soapdenovo pasha' scalability  large genome datasets  demonstrate  human genome assembly compare  aby pasha achieve competitive assembly quality  faster execution speed    compute resources yield  ng50 contig size     longest correct contig size     ng50 scaffold size   moreover  human assembly  complete    hours   modest compute resources develop parallel assemblers  large genomes   garner significant research efforts due   explosive size growth  highthroughput short read datasets  employ hybrid parallelism consist  multithreading  multicore cpus  message pass  compute cluster pasha  able  assemble  human genome  high quality   reasonable time use modest compute resources
even though  bruijn graphbased assemblers successfully alleviate  pressure  memory space  execution speed  substitute read  kmers  contiguous sequence   base  nod compare   conventional overlaplayoutconsensus approach  memory consumption  execution time  still prohibitive  large genomes  example   genomic data   yoruban male individual  total number  nod   preliminary  bruijn graph  node correspond   distinct mer    billion  motivate   design  scalable assembler  large genomes   workable  modest  commonly use highperformance compute resources pasha   parallelize algorithm  large genome assembly  overcome  memory  execution speed constraints  use hybrid compute architectures consist  sharedmemory multicore cpus  distributedmemory compute cluster figure  illustrate  pipeline   assembler  pipeline comprise four stag  generate  distribute kmers  construct  simplify  distribute preliminary  bruijn graph iii merge bubble  generate contigs  construct  velvetlike  bruijn graph   scaffold  join contigs  scaffold   implement stag      suitable  parallelization    memoryintensive use mpi  make  program compatible   sharedmemory  distributedmemory compute systems  mpi process   comprise two thread     perform computations   assembly pipeline   perform communications  different process see     figure   well  file  operations  employ two thread   single process  intend  gain faster speed  overlap  local computation  remote communications  process  file   distribute   bruijn graph   network  computers  get  partition   graph   part store   different computer hence    need  large amount  memory   single computer make  algorithm workable even   compute cluster comprise  commonplace workstations  personal computers since  size   message   small send message onebyone  remote process  incur large communication overheads thus   message    timecritical  combine   packets  improve  communication efficiency     connect   bidirectional message queue  maximal number  message   queue  control   maximal capability threshold  thread  try  append  new message   queue   block   queue reach  threshold    resume   queue  space available  thread  try  retrieve  message   empty queue   block     least one message available  stag iii    exhibit limit parallelism   less memoryintensive  use  multithreaded design  compatible  sharedmemory systems figure  figure1 schematic diagram   pasha assembly pipeline  kmer generation  distribution   number  mpi process  distribute preliminary  bruijn graph construction  simplification   number  mpi process iii bubble merge  contig generation   scaffold full size image   proofofconcept implementation  source code  available  download     use part   source code  velvet  stag iii     algorithmic  data structure modifications  use  exist opensource code significantly reduce  development time  prototyping  algorithm   importantly  modifications make  two stag feasible  practical  execute   workstation  limit system memory    ram   workstation  well  provide better assembly qualities pasha support  standard fasta  fastq input format  singleend  pairedend short read  different insert size    assemblers require users  tune  number  parameters  gain  best assembly pasha  need  single parameter """"   kmer size make  relatively user friendly  describe pasha  detail  firstly define  term  facilitate  discussion give  sequence   length   define    ith base   sequence ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯   complement       kmer start  position  ≤≤   ⎯⎯⎯⎯⎯⎯   reverse complement      𝑆𝑐𝑖   canonical kmer    lexicographically smaller     ⎯⎯⎯⎯⎯⎯  kmolecule      pair  complementary kmer strand consist   canonical kmer     𝑆𝑐𝑖   noncanonical kmer      reverse complement  𝑆𝑐𝑖 kmer generation  distribution    bruijn graph  node correspond   kmer   edge  two nod  create      correspond kmers   suffixprefix overlap   base hence pasha start  construction   preliminary  bruijn graph   generation   kmers   input read data  mention  pasha employ  mpibased approach  kmer generation  distribute  among  process  distribution require   location   kmer  deterministic    efficiently compute   kmer  since  kmolecule   pair  complementary strand  location   kmer   reverse complement must     calculate  location     ⎯⎯⎯⎯⎯⎯ pasha first transform    ⎯⎯⎯⎯⎯⎯   correspond base representation  assign numerical value {   }  base {   }  determine  location     unlike aby  calculate  hash value     ⎯⎯⎯⎯⎯⎯   perform  xor operation   pasha compute  location   canonical kmer since  base representation   kmer  store   bite integer thus limit  maximum allowable kmer size    comparison   theoretically complete  one clock cycle   bite compute system  balance distribution  kmers among process  critical   performance   algorithm  term   execution time  memory space  unbalance distribution would cause  process  consume much  memory  kmer storage thus result   system failure due  memory limitations   compute nod  pasha  first calculate  hash value   use  linear congruential hash function   base presentation   canonical kmer      process    kmer  compute             number  process   experiment  location determination method  able  roughly balance  distribution  kmers    yoruban male genome assembly use  process  average number  local mers   process   ±   achieve memory efficiency  use  sparse_hash_set template class   google sparse hash library   distinguish  store kmers  pasha  process hold  local sparse hashset  store  kmers   process thread  load  read  disk  transfer  read  thread    message queue   short read  arrange  batch   message contain  batch  read  receive batch  read   queue calculate  hash value   kmers  store      local sparse hashset depend   hash value  cooperation   two thread overlap  computation   file  operations thus reduce  execution time since  kmer   reverse complement  consider equivalent   kmolecule   need  store  canonical kmer   sparse hashset  represent  kmolecule   read contain nonacgt base pasha convert  nonacgt base   base """"  velvet   simply discard  whole read  aby    complete  generation  kmers  process write  local kmers  disk  future use  construct  preliminary  bruijn graph  distribute kmer generation implementation  also  use directly   modification   tool   cuda_ec   quake   generate  count  occurrences  kmers  genomic data distribute  bruijn graph construction  precede stage  generate kmers    record  graphrelated information   kmer however  construct   bruijn graph  need    kmers   also multiplicity  linkage information  common approach   use  hashmap implementation use kmers  key  provide fast access   graphrelated information however  approach  result   large memory overhead conway  bromage  suggest  sparse bitmap data structure  represent   bruijn graph achieve memory efficiency   cost  execution time however  proofofconcept assembler functionally similar   stag     take   hours  yield  highly fragment assembly   n50 contig size      yoruban male genome hence  exclude    follow assessments  pasha  instead use  sort vector data structure  store  kmers   graphrelated information  process load  local kmers  disk  store    sort vector  sort vector  sort use  kmers  key  use   approach  aby  represent  linkage information  nod   linkages  compact   bits   bite represent  presence  absence     eight edge   two directions however  build  linkages  nod pasha employ  different approach   kmer  node aby check  existence   possible neighbour    possible base extensions   direction   neighbour exist  set  correspond bite  represent  existence   linkage  approach  effective    probability  introduce spurious edge  connect kmers    adjacent   read hence pasha build linkages directly   adjacency information  kmers   input read   linkage  two kmers  create      two kmers  adjacent   least one read  build linkages   process thread  load batch  read  disk  transfer      previous stage    read   iterate   kmer    identify  location  calculate  base representation   canonical kmer   kmer belong    set  correspond linkage bits calculate   base   sik    extension base   leave   right directions       index     range  correspond extension base   complement   invalid base  indicate   linkage  create   direction figure  show  four case   linkage construction  two adjacent kmers   read   process iterate  kmers   input read  communication  process  require   construction process  construct  linkages  compute  multiplicity   kmer    time  pasha two bytes  use  represent  multiplicity   kmer  complete  linkage construction   get  distribute preliminary  bruijn graph   node correspond   kmer figure  figure2 linkage construction  two adjacent kmers   read full size image graph simplification  preliminary  bruijn graph contain many linear chain  nod    merge  simplify  graph without loss  information  start  simplification   removal  spurious linkages generally   three major kinds  spurious linkages tip lowcoverage paths  bubble  tip   short  lowcoverage dead end   likely   cause  sequence errors   begin   end  read  lowcoverage path  cover one    read   likely    chimeric connection bubble  redundant paths  minor differences  might  due  heterozygosity internal read errors  nearby tip connect   stage   remove tip  lowcoverage paths leave  removal  bubble   follow stage prior   removal  longer tip  first remove lowfrequency deadend individual kmers  removal rely   assumption   majority  true kmers  occur  several read   multiplicity   true kmer  suppose     minimum multiplicity threshold    automatically estimate   multiplicities   kmers  removal work  conduct roundbyround   deadend kmers meet  removal condition   process  identify  kmers   deadend    multiplicity less     local collection  kmers   remove  kmers   linkages   graph  remove linkages  kmers  another process  pack  request message  let  forward   remote process  forward  request     process  handle  request   removal   specific linkages   local kmers    process  pasha  simply remove tip   shorter     process  generate  current linear chain  kmers start   deadend kmer  extend  chain   leave  right directions basebybase   chain  longer    chain  release  otherwise  kmers   chain   remove  well   linkages    extension   chain  link kmer exist locally  get  graphrelated information   kmer directly   local sort vector otherwise  pack  request message  let  forward    remote process    block  receive  response forward back     remote process  complete  removal  tip  graph  split  different linear chain  nod  process cooperate  parallel  generate  sequence correspond   linear chain  linear chain  generate use two step  first step generate linear chain start  deadend kmers   chain  extend   one direction  second step start   arbitrary kmer   chain must  extend  two directions   first step  process   extend  linear chain   active local deadend kmer  another deadend kmer  meet   case   check  location process     deadend kmer  avoid duplicate      ≠  might  generate  linear chain    time   algorithm   keep  linear chain     ≤     release  otherwise  process   conduct iteratively     local deadend kmers   process  second step  complete  assign process onebyone  generate linear chain   time  one process    allow  generate linear chain    process   wait  process request       start  twodirectional extension   local kmer   loop   deadend kmer  find   case  loop  simply break   output   linear chain   sequence  coverage  calculate  divide  sum  multiplicities   kmers   correspond chain   sequence length   coverage  lower   minimum coverage threshold  sequence   give  since   likely   generate  linear chain contain spurious connections  remain sequence  write  disk   use   next stage bubble merge  contig generation  stage consist  three step first  velvetlike  bruijn graph  construct   sequence produce   previous stage  build  velvetlike graph  form  node  well   twin node   sequence  create linkages  nod  align read  nod  two adjacent kmers   read belong  two different nod  create  edge connect      edge    otherwise update  information   exist edge  align read  nod    record  map information   read  employ  multithreaded implementation  accelerate  alignment  read  nod  multicore cpus   single read  align   graph nod   thread  lock  carefully employ  guarantee  mutual exclusive access  critical section   creation  update  link  nod secondly  detect  merge bubble   graph  ""tourbus"" method  velvet  employ  detect bubble  detect bubble  merge   single path   sequence   parallel paths meet  userspecified similarity requirement  pasha  directly use  source code   ""tourbus"" method  modify  condition  merge  two paths two paths  merge       twobasepair difference  length  ≥  identity finally  simplify  graph   removal  short tip  lowcoverage nod   generate contigs  nod scaffold  scaffold work aim  find  correct order   assemble contigs   join   scaffold  determination   order  contigs rely   map information  pairedend read onto  contigs    map information  transfer  scaffold linkages  contigs  pasha  scaffold work start   construction   velvetlike  bruijn graph   assemble contigs  align pairedend read   graph nod  extend  kmer base alignment algorithm  velvet  provide support  multithreading  map information   read pair   map locations  node identifiers  record   indisk database   two read successfully map onto  graph  similar multithreaded design    previous stage  employ  accelerate  graph construction  multicore cpus  complete  read map  median insert size  well   standard deviation   library  estimate   map information  pairedend read whose two read map onto   nod  employ  modify pebble algorithm     scaffold work  scaffold linkages  build   map information  pairedend read   indisk database velvet construct linkages   map information  read  read pair   single read   overlap    one node linkages   create   nod   read pair     overlap  nod  linkage  create  two nod  respectively  overlap   two read  pasha   use  map information  read pair  construct linkages   linkage  consider reliable     least three read pair  form  linkage speed optimizations   representation   preliminary  bruijn graph pasha employ  sort vector data structure instead   hashmap  store kmers   graphrelated information  reduce memory overhead  sort vector cause  increase   average search time  kmers give  kmers store   sort vector  average search time   logn generally longer   nearly constant search time   hashmap   case  build  acceleration table use   significant  bits     default   kmer  speed   search  acceleration table  result   memory increase  2rtimes  size  type integer bytes   expect  reduce  average search time  logn2r  stag     mpi process  two thread    one  communication     local computation  mechanism  expect  improve  execution speed  overlap communication  computation however   two thread communicate frequently along  memory allocations  deallocations    time  overhead incur  system call  memory operations may offset  performance obtain   overlap thus  use  tbb_allocator template class   intel thread build block library  manage  memory allocation  deallocation   communication      tbb_allocator template class  improve  execution speed   smart management  user memory allocation  deallocation",-0.18667586843586295,0.1902003477241195,0.09035825914765723,0.12698577070800252,0.03259723746187142,-0.05204756114899852,-0.12721125441016615,0.07119588292484885,0.0021057518114390773,0.13161451025659676,0.055523797364593036,-0.0072541338878191934,0.1674550208881614,-0.09157783154670647,0.13993558913989398,-0.07481432073027565,0.036467448229726585,0.20866632507259086,-0.03936701383812422,0.07381997824710812,0.02017930076146621,-0.21256821930507888,0.04926694764667934,-0.01330611377881233,-0.002673478587792161,-0.18240519271069244,0.028407200957617805,-0.13526069731369353,-0.04122087220220533,-0.06663718772370049,-0.00037966805632057244,0.2701888089126395,-0.1618157860796441,-0.09163635644544496,0.20875336955290066,0.0991212515882478,0.08538224807279678,-0.04002812920254749,-0.0451545249162478,-0.10879865655395984,-0.05293638830859495,-0.16582926351067,-0.04751617675669096,-0.09775288067242342,-0.12238300930358093,-0.019016620467828413,0.1397091399158469,-0.14344156843353734,-0.17661853228082033,-0.3370675799366981,0.11960997358753075,0.016047292113493615,0.0647303822751562,0.5963084723695404,0.07654191265917902,-1.1697112063116382,0.059116277777097284,-0.2025343846613063,1.05661939066834,0.18186134824641034,-0.15527673864036978,0.2496790173188836,-0.10222734309236607,0.08034208116239687,0.5481256965983563,0.05403779558602902,0.04788553002077405,0.02865572667441123,0.21270426497317252,-0.1980337700985012,-0.04119854713658031,-0.06291155958918923,0.1104480946860422,-0.16928617767395412,0.2131354938385288,-0.0326148705169436,-0.1192727853902085,-0.10170395052479804,-0.3454823791240651,-0.05023471230770316,0.2595359198070755,-0.016575199963071236,-0.3696097179463979,-0.02989926832308768,-0.8689383753526053,0.12100600410737905,0.2442979216905435,-0.13378556560067964,-0.1122362227714471,-0.0665147610265746,-0.17057638271692332,0.11986725983085833,-0.10929028485078712,-0.11015054048973333,-0.12915930644819534,-0.13057566455951825,-0.018251687687048827,-0.28321888604848666,0.3626132960512376,0.07566630418690719,Assembly,5
121,121,"ray simultaneous assembly  read   mix  highthroughput sequence technologies
 accurate genome sequence   desire species    prerequisite  genome research  important step  obtain  highquality genome sequence   correctly assemble short read  longer sequence accurately represent contiguous genomic regions current sequence technologies continue  offer increase  throughput  correspond reductions  cost  time unfortunately  benefit  obtain  large number  read  complicate  sequence errors  different bias  observe   platform although software  available  assemble read   individual system  procedure   propose  highquality simultaneous assembly base  read   mix  different technologies   paper  describe  parallel shortread assembler call ray    develop  assemble read obtain   combination  sequence platforms  compare  performance   assemblers  simulate  real datasets  use  combination  roche  illumina read  assemble three different genomes  show  mix sequence technologies systematically reduce  number  contigs   number  errors
ray  derive   work  pevzner      sense   make use    bruijn graph however  framework   rely  eulerian walk  generate  assembly  define specific subsequences call seed       algorithm extend    contig  define heuristics  control  extension process    way   process  stop    point  family  read   clearly indicate  direction   extension  example consider  graph  figure   suppose   seed   …       read  overlap  seed also contain     proceed  add    contig   contrary   choose  another direction    case     obvious winner  process  stop note   heuristics  give  higher importance  read  heavily overlap  contig   read   intersect  small number   last vertices   indeed  consider  read  overlap strongly   contig   construct   informative  assign  direction    extension  proceed  external file  hold  picture illustration etc object name  figjpg fig   subgraph    bruijn graph  figure show  part    bruijn graph   example short read   enough   assembly problem suppose   true genome sequence    form equation    length   read  pair read  smaller   equation  subsequence  hint  help  assembly algorithm  differentiate  true sequence   follow one equation     hand     read  start    end       possibility  solve  branch problem  measure  overlap level  function call offseti  equation   propose heuristics  therefore limit  length   obtain contigs   give better guarantee  assembly errors moreover  heuristics allow   construct greedy algorithms   sense    point  extend  contig    construct   end  construction   greedy choice   never  reconsider  inevitable  one want    algorithm  run  polynomial time  choice  favor  greedy optimization  motivate   nphard nature   problem pop   minimize run time  memory utilization  use  sequence data provide   read    bruijn graph annotation  read  annotate    attach   single vertex   graph  coverage distribution give  family  read equation   denote    family consist   read     reversecomplement sequence     precisely equation m10 moreover   integer   kmer  cconfident   occur  least  time   read   note   kmer  appear twice    read  count twice  define equation m11   function  associate   integer value   number  kmers   cover  time accord    propose  chaisson  pevzner   function   sum   exponentiallydecreasing curve   poisson distribution  first represent  errors contain   read   second   poisson distribution   read   subsequence pick among  subsequences around  particular length   almost uniform probability  graph   function equation m12   shape   function draw  figure — coverage distributions    baylyi adp1 dataset  show   figure  roche read illumina read   mix   equation m13   local minimum    call cmin follow   local maximum    denote cpeak basically cpeak   estimate   average coverage depth   genome  cmin   estimation   value   high probability  amount  incorrect data  lower   amount  correct data  external file  hold  picture illustration etc object name  figjpg fig  coverage distributions  figure show  coverage distributions  kmers    baylyi adp1 dataset  roche illumina  roche  illumina     minimum coverage   peak coverage  identify   roche illumina  roche  illumina coverage distributions  peak coverage  rocheillumina  greater   sum   peak coverage  roche   peak coverage  illumina  suggest   mix approach allow one  recover lowcoverage regions  annotated  bruijn graph give  family  read    bruijn parameter    coverage cutoff   associate annotate  bruijn graph note bruijnd    define  follow  vertices    graph   cconfident kmers   set  arc   compose   arc  two vertices    correspond   confident   mer  example          two kmers atgct  tgctg   vertices   graph       appear  least twice   read   moreover 〈atgcttgctg〉    arc   graph     atgctg appear  least    read     annotation  consider  first cconfident kmer   read    denote  kmer    remove   every read     associate    confidence value      vertex   confidence value      repeat   region   genome  usually cover  time  consider         coverage  belong   repeat region  regions   susceptible  generate misassemblies  avoid  regions    consider  correspond read   annotation  choice imply   algorithm may output contigs  shorter length    gain   quality   contigs   remain ' first note     subsequence   read     length      subsequence  length   start       cconfident    remain   complete  annotation       start position  subsequence    read  hence   give vertex  one  recover  read      first cconfident kmer note   annotation system   memory intensive since  read  annotate   moreover   position   read  recover   algorithm use  follow function  offset function give  walk equation m14   arc 〈 〉  define  ith offset value   accord   note offsetiw    number  annotations     vertex       subsequence       distance   start point     start point    equal    read    walk  concatenate   vertex   start position     read            example put         consider     single read   atgcatcg   since      mers   belong    bruijn graph also   vertex   atgca     annotation    consider  walk   〈atgca tgcat gcatc〉   vertex   catcg     offset1w      read  start  position      distance          read    concatenation   walk    new arc 〈gcatc catcg〉 note     subsequence   whose start position     exactly        since  length   walk       position          position     read           type  function  pair read except  since  fragment length  approximate     library   tolerate  certain difference   length    particular pair  read   average length    correspond fragment library—namely   formally   read pair     let  define  meta read r12   length  begin   end  revcompr2   compose  dummy letter   middle  give  walk equation m15   arc 〈 〉  define  ith pair offset value   accord   note equation m16     number  annotations     vertex     exist  pair read          subsequence  revcompr2   distance   start point     start point     meta read r12    walk  concatenate   vertex  differ   value      mathematically  start position     read              ±   state   want  give  importance  read    large overlap   contig   construct let  point     value    get smaller   offset function  magnitude   overlap  increase  give  partially construct contig equation m17  two possible arc 〈 〉  〈 ′〉    add     compare  offset value    ′ accord       clear winner  algorithm  choose  otherwise   stop  ongoing extension  seeds  propose algorithm start   walk      strong confidence    subsequences   genome sequence  particular walk  refer   seed  obtain   first consider   bruijn graph    high cutoff value  fix  cutoff  equation m18 cpeak correspond   average coverage  cmin    number  errors  lower   number  true sequence  consider   take  average   two   small amount  errors      bruijn graph equation m19  result stringent  bruijn graph suffer   huge loss   information contain   read   procedure   use  determine  seed  specifically  seed   set  maximum walk  equation m20   compose  vertices  indegree  outdegree   one   heuristics   section  present  heuristics    algorithm  base   rule    multiplicative value indicate  confidence require  perform  choice—  coverage increase  value decrease   vertex      coverage   least            coverage   least             coverage   least    vertex  relation   coverage   value   multiplicator     parameter  work well  various test datasets see section   value take    motivate   distribution  read   seeds—two read start consecutively   seed   nearer   local coverage  available give  walk equation m21  two arc    bruijn graph bruijnd    start   namely 〈 〉  〈 ′〉  say  rule   win  ′   three follow inequalities hold equation m22  accord  rule   win  ′    number  pair read  strongly overlap        time  correspond value  ′   total amount  pair read  overlap        time    amount  ′    pair read    maximal overlap         time   value  ′ recall   smallest   value    biggest   overlap   correspond read rule   replace  function equation m23   correspond function offseti   three equations   get rule  hence rule    exactly   type  measurement  rule  except   work  single read  rule  utilize  extend seed   ray algorithm  ray algorithm  present  figure   external file  hold  picture illustration etc object name  figjpg fig   ray algorithm ray   greedy algorithm    bruijn graph  extension  seed  carry    subroutine growseed  seed  extend use  set  rule    afterwards  extend seed  extend   opposite direction use  reversecomplement path   extend seed give two seed     reachability        necessary  sufficient condition   reachability     owe   property  reachability  seed  final merge step  necessary  remove things appear twice   assembly  technical point   implementation  data structure select  extract kmer information  read   splay tree sleator  tarjan — balance binary search tree base   splay operation kmers  store   bits—thus  maximum value    ",-0.16676920359746372,0.20003512237429,0.11968945790042987,0.1572214771391767,-0.015911949103539182,-0.00840441398862627,-0.1350762999100209,0.0665085873145868,-0.019163028129195098,0.07616003222215342,0.006168143777890004,0.028590429349062675,0.16918149720466008,-0.07190731890867434,0.10372340693109244,-0.05271707348223914,0.009034315221464051,0.2148735170875201,-0.05820939670896659,0.08847590038528426,0.030888144004808767,-0.19219194298928005,0.022480263185220683,-0.012379479273176534,-0.02242273091301893,-0.13996930145179645,0.05257271681311061,-0.18419119864304834,-0.019172139809259543,-0.09890673336834306,0.006013739668138536,0.2442481362187513,-0.1176870799831296,-0.09193095974053543,0.15846588585839844,0.09359935168288974,0.0755902423115276,0.0054237599817310465,-0.058218497118461235,-0.08377547985942896,-0.07341685515654699,-0.12341050327387032,-0.02926924856849875,-0.12119870126212763,-0.12801519405841624,-0.01950428029859828,0.17313755390385094,-0.1189042047553653,-0.2226309298863227,-0.3427373151398311,0.1435080969082579,0.0028886051009932873,0.08300778529600646,0.5982490815148389,0.03509515585913781,-1.1496809862953503,0.0684750609986863,-0.19159986644436114,0.9428783900082046,0.20769143997983505,-0.15034994357669293,0.2409153004481072,-0.1331451834261996,0.056317355151591864,0.5863799858462326,0.056373767617935035,0.050291531058285634,0.0494138633171501,0.14825379294628602,-0.1750612889824861,-0.07904054037520503,-0.06988868162281,0.07660632111539471,-0.1295933391113258,0.23362518337410534,-0.03669184317743035,-0.10228965796389633,-0.11928931299721338,-0.3748891182331454,-0.0712379993922216,0.19300450814350512,-0.04219617032615623,-0.393290809750775,-0.0810349311444558,-0.7919727150716104,0.014707487766097016,0.18266279950161732,-0.11828785520011285,-0.07398818772264779,-0.06188122791723915,-0.1926018586863725,0.07031454761737765,-0.1263324642416749,-0.09116909169047843,-0.1557862933324734,-0.08253107230811782,-0.07149888702165906,-0.2791811142342738,0.2767973810462872,0.07564790046359138,Assembly,5
122,122,"ray meta scalable  novo metagenome assembly  profiling
voluminous parallel sequence datasets especially metagenomic experiment require distribute compute   novo assembly  taxonomic profile ray meta   massively distribute metagenome assembler   couple  ray communities  profile microbiomes base  uniquelycolored kmers   accurately assemble  profile  three billion read metagenomic experiment represent  bacterial genomes  uneven proportion   hours   processor core use    per core  software  facilitate  process  large  complex datasets   help  generate biological insights  specific environments
thorough documentation  associate script  reproduce  study  available  additional file    publisher website    memory model ray meta use  messagepassing interface    core job   process run  many computers   experiment  node   processor core       per core   messagepassing paradigm  core    virtual memory   protect    process   data  distribute uniformly use  distribute hash table memory usage   single process   low   core job  maximum memory usage   process   average   assemblies metagenome assemblies  profile  compute  ray  additional file   colosse  compute canada resource ray  open source software   license   gnu general public license version  gplv3    freely available     ray   deploy  public compute infrastructure    cloud see    review  algorithms implement   software ray  heavily modify  metagenome  novo assembly   change  call ray meta namely  coverage distribution  kmers    bruijn graph   utilize  infer  average coverage depth  unique genomic regions instead  value  derive  local coverage distributions   parallel assembly process therefore unlike metavelvet  ray meta   attempt  calculate  use  global kmer coverage depth distribution simulate metagenomes   power law two metagenomes    genomes respectively  simulate  abundances follow  power law table     additional file  power laws  commonly find  biological systems  simulate sequence errors  randomly distribute  error rate  set     average insert length    second simulate metagenome  assemble   core computers  processor core interconnect   mellanox connectx qdr infiniband fabric mellanox inc   genome dataset message  rout    bruijn graph  degree   diameter   reduce  latency validation  assemblies assemble contigs  align onto reference genomes use  mummer bioinformatics software suite   precisely deltas  generate  nucmer use showcoords  contig  align  one single maximum   least  breadth  coverage  mark  misassembled contigs align  two part   begin  end   reference   count  misassembled owe   circular nature  bacterial genomes finally small insertionsdeletions  mismatch  obtain  showsnps color  distribute  bruijn graph  vertices    bruijn graph  distribute across process call rank  graph color mean label  vertices   graph  different color  add   graph   reference sequence  kmer   reference sequence  color   reference sequence color   occur   distribute  bruijn graph therefore  kmer   graph  zero one   color first  kmer   color indicate   kmer   exist   databases provide second  kmer  one color mean   kmer  specific  one   one reference genome   databases provide   least two color indicate   kmer   specific  one single reference sequence  reference sequence  assign  leave   taxonomic tree reference sequence   group  independent name space genome assembly  independent  graph color demultiplexing signal  similar bacterial strain biological abundances  estimate use  product   number  kmers match   distribute  bruijn graph   mode coverage  kmers   uniquely color  number  call  number  kmer observations  total number  kmer observations   sum  coverage depth value   color kmers  proportion  calculate  divide  number  kmer observations   total taxonomic profile  bacterial genomes available  genbank   utilize  color  distribute  bruijn graph table   additional file   kmer  assign   taxon   taxonomic tree   kmer    one taxon color  coverage depth  assign   nearest common ancestor gene ontology profile   bruijn graph  color  cod sequence   embl nucleotide sequence database  embl_cds   map  gene ontology  transitivity use  uniprot map  gene ontology    ontology term coverage depths  color kmers  add  obtain  total number  kmer observations principal component analysis principal component analysis  use  group taxonomic profile  produce enterotypes data  prepare   matrix use  genera  row   sample  columns singular value  leave  right singular vectors   matrix  obtain use singular value decomposition implement    right singular vectors  sort  singular value  sort right singular vectors  use   new base   rerepresentation   genus proportion  two first dimension  plot software implementation ray meta  distribute software  run  connect computers  transmit message   network use  messagepassing interface mpi   implement    mpi standard  implement  libraries   openmpi   mpich2    processor core task  divide  smaller ones  give   pool   workers thread pool   similar  char  charm     send message   virtual communicator  latter implement  message aggregation strategy   message  automatically multiplexed  demultiplexed  kmers  store   distribute sparse hash table  utilize open address double hash  collisions incremental resize  utilize   hash table   occupancy exceed   grow table locally smart pointers  utilize   table  perform realtime memory compaction  software  implement  top  rayplatform  development framework use  ease  creation  massively distribute highperformance compute applications comparison  metavelvet software versions use  metavelvet  velvet   ray   ray meta metavelvet  run  one processor core ray meta  run   processor core  human microbiome project sample srs011098 srs017227  srs018661       processor core  metahit sample ers006494 ers006497  ers006592 respectively   eight processor core per node  run time  metavelvet   sum  run time  velveth velvetg  metavelvetg  metavelvet sequence file  filter  remove  sequence     symbols  result file  shuffle  create file  interleave sequence  insert size  manually provide  metavelvet   kmer length  set    suggest   documentation peak coverages  determine automatically  metavelvet ray meta  run   kmer length     parameters  require  ray meta  sequence file  provide without modification  ray meta  overlap  assemblies produce  metavelvet   ray meta  evaluate  ray use  graph color feature  mismatch  allow  kmers overlap  compute  scaffold   least  nucleotides comparison  metaphlan taxonomic profile calculate  metaphlan   sample   human microbiome project  obtain  taxonomic profile  produce  ray communities   sample additional file  pearson' correlation  calculate   body site  combine taxon proportion   methods   taxonomic rank",-0.22727061578928415,0.21406331759235644,0.10692641559163914,0.08934977360673853,0.0631516772360113,0.0062843950704444896,-0.09446181864477694,0.054493304861810164,-0.02212076055741793,0.12945959267357515,0.03153980074079103,-0.07152073770962858,0.16295171726771907,-0.07963241067167523,0.15009045294766013,-0.006231475968190746,0.1067043897884621,0.21461514952164648,-0.017332969089133062,0.05438859400503036,-0.0521339128246984,-0.1943874698100813,0.09260627838949724,0.0019005545789401075,0.037889767404192615,-0.19616208218189107,0.14551378984422725,-0.0813562513593383,-0.07640449463742206,-0.0675950189212312,0.03160501257815348,0.2597746107651777,-0.17380366331930713,-0.06338814854042958,0.2244771312416462,0.09694851641511744,0.042121100377895536,-0.0013023405112452,-0.03850289262796601,-0.13196660106737368,-0.03794868462231337,-0.16464783446808232,-0.15021569338305446,-0.07240053062501042,-0.13767508813054175,0.024669669083369945,0.07079825864463134,-0.11103160990641224,-0.18615402132933456,-0.2438682690467308,0.1255131264525541,0.02298114455707774,0.0649164562497439,0.5477614928310661,0.011452642111957224,-1.0751753540986495,0.042558042737151934,-0.18188329972830167,1.0056386479226922,0.2115335298615596,-0.1417039421951002,0.2925347238020795,-0.05009719079196755,0.03123055026564445,0.5805369635647465,0.05596562457629605,0.028734908863033693,-0.013807115902671138,0.2954880752352167,-0.16353161765224727,-0.07637637170855423,0.012119623435963248,0.11475912689127506,-0.14756753201615316,0.15711004826023142,-0.03482727644260268,-0.08995356542574293,-0.13559698751107774,-0.3477658704590253,-0.040881091577466576,0.1800529222615296,-0.03150972295646883,-0.3720930322227572,-0.012900467737848444,-0.7747869742401825,0.13344841731595808,0.2706592664629145,-0.19801110343132924,-0.06969156401334928,-0.0031746766092633273,-0.13464036800370022,0.11119640059784884,-0.09705772858610176,-0.08577542354264674,-0.05048803410656448,-0.10236215989633993,-0.06617214172855146,-0.3245320380519056,0.3285391384144188,0.0638629998018685,Assembly,5
123,123,"megahit  ultrafast singlenode solution  large  complex metagenomics assembly via succinct  bruijn graph
megahit   ngs  novo assembler  assemble large  complex metagenomics data   time  costefficient manner  finish assemble  soil metagenomics dataset   gbps        single compute node   without  graphics process unit respectively megahit assemble  data   whole   preprocessing like partition  normalization  need  compare  previous methods  assemble  soil data megahit generate  threetime larger assembly  longer contig n50  average contig length furthermore    read  align   assembly give  fourfold improvement
megahit make use  succinct  bruijn graph sdbg bowe      compress representation   bruijn graph  sdbg encode  graph   edge   bits  support  time traversal   vertex   neighbor  implementation  add  bitvector  length   mark  validity   edge    support dynamic removal  edge efficiently   auxiliary vector  2kt bits     kmer size     number  zeroindegree vertices  store  sequence  zeroindegree vertices  ensure  graph  lossless despite  advantage construct  sdbg efficiently  nontrivial megahit  root   fast parallel algorithm  sdbg construction  bottleneck  sort  set  kmers    edge   sdbg  reverse lexicographical order   lengthk prefix kmers megahit exploit  parallelism   graphics process unit gpu cudaenabled  adapt  recent bwtconstruction algorithm cx1 liu     take advantage   gpu  sort  suffice   set  read  efficiently limit   relatively small size  gpus onboard memory  adopt  blockwise strategy  partition  kmers accord   lengthl prefix      implementation  kmers  consecutive partition  fit within  gpu memory  sort together leverage  parallelism  gpu megahit speed   construction   time   cpuonly counterpart notably sequence error  problematic   single base  sequence error lead   erroneous kmer singletons  increase  memory consumption  megahit significantly  cope   problem  graph construction    mers   input read  sort  count     mers  appear  least    default time  keep  solidkmer  method remove many spurious edge  may  risky  metagenomics assembly since many lowabundance species may   sequence   low depth thus  introduce  mercykmer strategy  recover  lowdepth edge give two solid   mers       read     outdegree     indegree     mers       read   solid    add    bruijn graph  mercykmers mercykmers strengthen  contiguity  lowdepth regions without  approach many authentic lowdepth edge would  incorrectly identify  tip  remove base  sdbg  implement  multiple kmer size strategy  megahit peng     method iteratively build multiple sdbgs   small    large    small kmer size  favourable  filter erroneous edge  fill gap  lowcoverage regions  large kmer size  useful  resolve repeat   iteration megahit clean potentially erroneous edge  remove tip merge bubble  remove low local coverage edge  last approach  especially useful  metagenomics  suffer  nonuniform sequence depths",-0.2081386356322948,0.19931158488268189,0.08803330662292559,0.12716741138681875,0.0019699764436885508,-0.044851309194438437,-0.15677642923775434,0.03669365849422082,-0.007324176823076243,0.14171855373603998,0.006759379254915168,-0.028277918054487244,0.1029859433792723,-0.08523329195596939,0.12378398483623446,-0.033533483349813896,-0.009541705233332151,0.1450232663519613,-0.024001345281036587,0.014562611795078406,0.0646784205645732,-0.17641620224158966,0.07094496723795397,0.045582612254004055,0.01324115094519873,-0.14039696259075932,0.033765360470654475,-0.11717636968557522,-0.010737957777488087,-0.04288215585113895,-0.014683873111939182,0.24164830786348745,-0.12000305773155864,-0.1188405695651216,0.19003875626897915,0.07587939631150356,0.06311945397859421,-0.040559803932104434,-0.07511871549976494,-0.1323050646123337,-0.05665512375327406,-0.1556069942730616,-0.040910914739121666,-0.09451867452176356,-0.1253485166515054,0.02997640246595038,0.16505641110620034,-0.11558715236660475,-0.14826647790908273,-0.33168006857213017,0.09539662636207223,0.006032266423419536,0.05029420030224964,0.6285088637269267,0.052415829122492985,-1.071662115490186,0.07165399229449924,-0.15316337371836894,0.8910595402366343,0.14256051457682886,-0.1815011953141064,0.1984766980613556,-0.10646419283698932,0.1011957380840137,0.5197228092741587,0.06228030185817924,0.026213532867493262,-0.003192458160343432,0.19118571222790248,-0.2171353987618306,-0.062307028417316675,-0.02306805636445996,0.0663386679630646,-0.13815196337630956,0.24882813357251965,-0.00599412822869615,-0.15380736416049093,-0.09443377697444304,-0.2920926842625279,0.016081589166941034,0.24999918481422084,-0.030233348367265725,-0.38555133607560577,0.019723937910911846,-0.7167761972626654,0.11192795240579208,0.24957664060911214,-0.09479152399798524,-0.1030581471244761,-0.07426640060191722,-0.1450805977839872,0.13398717758958406,-0.15443012572250495,-0.09906321458918886,-0.09922823140497763,-0.12140547665800012,-0.012355513106400548,-0.26501507329902496,0.2734972762561917,0.07433384271484374,Assembly,5
124,124,"omega  overlapgraph  novo assembler  metagenomics
metagenomic sequence allow reconstruction  microbial genomes directly  environmental sample omega   verlapgraph    enome  ssembler  develop  assemble  scaffold illumina sequence data  microbial communities omega find overlap  read use  prefixsuffix hash table  overlap graph  read  simplify  remove transitive edge  trim short branch unitigs  generate base  minimum cost flow analysis   overlap graph   merge  contigs  scaffold use matepair information  comparison  three  bruijn graph assemblers soapdenovo idbaud  metavelvet omega provide comparable overall performance   hiseq  dataset  superior performance   miseq  dataset  comparison  celera   miseq dataset omega provide  continuous assemblies overall use  fraction   compute time  exist overlaplayoutconsensus assemblers  indicate omega   efficiently assemble longer illumina read   deeper coverage  metagenomic datasets
 performance  assemblers  illumina hiseq  data  benchmarked use  realworld sequence dataset  genomic dna mixture   diverse bacterial  archaeal microorganisms  shakya       dataset  available  national center  biotechnology information ncbi sequence read archive sra accession number srx200676   microorganisms  list  supplementary table   fastq sequence  extract   sra format raw dataset use ncbi sra toolkit version   dataset contain  million pairedend   million singleend  read sickle     use  trim read use  phred quality threshold  filter  read shorter      discard read contain many  bbnorm      use  error correction  default settings  hiseq  dataset  assemble use soapdenovo idbaud metavelvet  omega   mer length  minimum overlap length  optimize   assembler base   n50 size soapdenovo best  mer length         idbaud   mer length range     step size   metavelvet best  mer length          omega best minimum overlap length          soapdenovo  run   metagenome configuration  describe  pop   idbaud metavelvet  omega  run  default parameters  performance  assemblers  illumina miseq  data  test use  simulate dataset   ninegenome synthetic community ten million pairedend  read   average insert size     simulate base   empirical error model use metasim  richter      supplementary table  list  nine genomes   relative abundances range      simulate read  preprocessed use sickle  errorcorrected use bbnorm  describe   maximum  mer length  metavelvet  increase    change  constant parameter   source code   unable  increase  maximum  mer lengths  soapdenovo  idbaud   hardcoded     respectively   mer length  minimum overlap length  optimize   assembler soapdenovo best  mer length           idbaud   mer length range     step size   metavelvet best  mer length           omega best minimum overlap length           assemblers  run  describe  celera  also test   miseq  dataset use  default set   metagenomics set     celera assembly use  default set  substantially better   use  metagenomics set  therefore  use  performance comparison  measure assembly accuracy contigs  scaffold   produce   assembler  align  reference genomes use burrowwheeler aligner bwa    durbin    alignments  use  generate  list  correct contigs contain   substitutions  indels  scaffold  two adjacent contigs  consider   correct   alignments    reference genome   correct orientation  separate apart  less   mean plus one standard deviation    mate inner distance   pairedend sequence data  performance  assemblers  compare  n80 n50 n20 largest contig length  genome sequence coverage   reference genome n80 n50  n20   minimum size thresholds  lengthsorted contigs  cover       total length   contigs respectively genome sequence coverage   percentage   reference genome sequence cover   assemble contigs n80 n50 n20  largest contig length measure  contiguity   correct contigs  different level genome sequence coverage measure  completeness   correct contigs different type  assembly errors  identify base   bwa alignment   contigs   reference genomes include  number  base pair  insertion deletion  substitution   number  chimeric contigs chimeric contigs  identify   fragment alignments  multiple noncontiguous regions   reference genome  multiple reference genomes  algorithm omega  develop   use objectoriented program omega  accept multiple input datasets  different insert size  variable read lengths  fasta  fastq format  assembly  scaffold  perform  eight step  fig   hash table construction  unique read  load   memory  index   hash table let    userdefined minimum overlap length  key   hash table  dna sequence substrings  length     read  insert   hash table  four key prefix  suffix  length      forward sequence  reverse complement sequence   read  value   hash table   array  pointers   read associate   correspond key  hash table  initialize   eight time   total read number hash collision  resolve use linear probe  hash table allow  nearly constant time search   read   prefix  suffix  read    substring  another read  call  contain read   identify  contain read  read   every proper substring   length   read   search   hash table  produce  short list  read  contain    prefix  suffix    compare  read   identify  contain read  read    contain read  use  coverage depth calculation  matepair linkage analysis  overlap graph construction  read  represent   vertex   bidirected overlap graph  edge  insert  two vertices   two correspond read   exactmatch overlap   least    bidirected edge represent  four different orientations   two read  overlap suffix  prefix  •→→•  suffix   reverse complement  prefix  •→•  suffix  prefix   reverse complement  •→•   suffix   reverse complement  prefix   reverse complement  ••   efficiently find  read overlap   read   every proper substring   length     read   search   hash table   retrieve read  compare   read     read   exact match  read    remain overlap  edge  insert   two read correspond vertices  insert  edge  read    transitive edge incident  read   remove use  linear algorithm  describe  haider   myers   briefly suppose    connect  two  read        also  edge      form  triangle     sequence represent   edge          sequence represent   path                 identify   transitive edge   delete remove  transitive edge significantly simplify  overlap graph without lose  information composite edge contraction   bidirected edge   traverse   directions  vertices   traverse   enter  vertex   inarrow  exit   outarrow  →•→    enter  vertex   outarrow  exit   inarrow  •   valid path   overlap graph represent  assemble dna sequence contain proper overlap read  appropriate orientation  sufficient overlap length  remove transitive edge simple vertices  exactly one inarrow  one outarrow represent  one possible way  traverse  simple vertices  read   simple vertex uniquely overlap  one  read  either direction  simplify  overlap graph  simple vertex   along   inarrow edge      outarrow edge      replace   composite edge       overlap graph  composite edge     contain  read    order read  edge           edge        arrow type       original edge          respectively simple vertices  merge  composite edge iteratively     simple vertex remain   overlap graph sequence variation removal sequence variations originate  uncorrected sequence errors  natural sequence polymorphisms  microbial communities many read  sequence variations   overlap    read   represent  isolate vertices   overlap graph read    sequence variation may overlap  one another  create small branch  bubble   overlap graph small branch  short deadend paths  contain  read bubble  two edge  connect   two vertices    arrow type  overlap graph  systematically traverse  trim  small branch  remove  edge contain less read  bubble  may create new simple vertices    remove  repeat  composite edge contraction minimum cost flow analysis  edge   overlap graph  associate   string copy number represent  many time  edge sequence  present   metagenome string copy number  edge  estimate base   topology   overlap graph use minimum cost flow analysis  describe  haider   myers   composite edge  sequence    set    minimum flow   require  edge sequence   present   metagenome  least   minimum flow  short edge    set    cs2 algorithm  goldberg    use  optimize  amount  flow pass  every edge    total cost   flow network   overlap graph  minimize edge    one unit  flow correspond  repeat regions share among multiple genomes  multiple place   single genome edge  zero flow represent short sequence    need  connect long sequence together   ignore tree structure   overlap graph  simplify use  flow  tree comprise two edge          merge   third edge       flow       equal   total flow             tree  reduce  two new edge            contain  read  vertex   edge     merge  adjacent edge  matepair support  insert size   pairedend dataset  estimate separately  accommodate  mixture  datasets  different insert size  overlap graph   stage  long composite edge  contain  read  many matepairs  insert size   pair  determine   relative locations   long edge   pool  estimate  mean       matepairs insert size   dataset matepairs  span multiple edge  use  merge adjacent edge   overlap graph     matepairs  possible paths  length within range             enumerate   paths   matepair travel  two adjacent edge           connection   two edge  consider   support   matepair  process  matepairs   connection            support    three matepairs  two edge  merge  one edge     contain  duplicate   scaffold  long edge  matepair support scaffold use matepairs    valid path   pair read   overlap graph    gap  genome coverage scaffold  attempt  every pair  nonadjacent edge    matepair  consider  support  scaffold  two edge   two read  uniquely map   two edge   appropriate distance apart  process  matepairs  scaffold  long edge  support    three matepairs  accept resolve ambiguity  coverage depth many unresolved vertices   overlap graph  two incoming edge  two outgo edge  often originate   short repeat region  two different genomes  two genomes may  different coverage depths  separate  edge  coverage depth  calculate  every position along  edge  estimate  mean      coverage depth along  edge  unique read   edge  consider  coverage depth calculation  pair  adjacent edge   unresolved vertex  merge            fig  overview  omega  prefix  suffix red section  every read  index   hash table  read  align use  hash table transitive edge green arrows  remove   unitig graph edge blue arrows represent unambiguous series  overlap read vertices red dot represent branch point  flow green number estimate  copy number  string   edge  matepair linkages orange dot line  use  build contigs   scaffold contain gap blue dot arrows  repeat region  two different genomes  edge   units  flow may  resolve use matepair support  show   coverage depth information open  new tabdownload slide overview  omega  prefix  suffix red section  every read  index   hash table  read  align use  hash table transitive edge green arrows  remove   unitig graph edge blue arrows represent unambiguous series  overlap read vertices red dot represent branch point  flow green number estimate  copy number  string   edge  matepair linkages orange dot line  use  build contigs   scaffold contain gap blue dot arrows  repeat region  two different genomes  edge   units  flow may  resolve use matepair support  show   coverage depth information finally omega report contigs  scaffold base   edge   overlap graph",-0.1824202762856956,0.2278822802851693,0.12712106495919234,0.13129475074325594,0.011984701408847566,-0.009254877839067114,-0.06937907704811946,0.0988234032684884,-0.05301709329895233,0.13937922238290415,0.05096969938053885,0.0010466924359725518,0.1421515819104499,-0.0556734212878273,0.1839520174627261,-0.0050252617000560145,0.04238315541288902,0.1679271243270951,-0.017128409883972462,0.02052690413550445,0.04015661017402936,-0.16939238780880492,0.034705536768659985,-0.0012347632659612455,0.0447131053294606,-0.193606060514815,0.09980720881831162,-0.14203386529483733,-0.04268087444698655,-0.10386286313853484,0.027971977405604014,0.21971659472374927,-0.13453219862692964,-0.05880290803592431,0.1818319196935722,0.07616847719761571,0.08824666400883578,0.01529603440706085,-0.07157792373698077,-0.06553444015597726,-0.05125528343537305,-0.19056125469133176,-0.08455927550627887,-0.06789115058880901,-0.10294086380898754,0.033097783137873836,0.08657648250119951,-0.1073849690822838,-0.2141855394416832,-0.25660859482476794,0.11879953843759343,0.02780037802492541,0.05976732429050599,0.5773056417862905,0.022011777729093542,-1.0857135326493168,0.052829314374990964,-0.16393279941833294,0.9521149433720658,0.23904879119760425,-0.15599295325117404,0.28994748864274233,-0.05030358947244984,0.1043418180153234,0.5455103847380692,0.05332884539915315,0.030114392986667127,0.0019066133479711614,0.1958038364985024,-0.15891520392479852,-0.10506565336960418,-0.00736809855287191,0.11293443297854495,-0.12075893442791327,0.2297589166237555,-0.033837823247019366,-0.07184818384045129,-0.12988874119657506,-0.28729875134166943,-0.044273970323362666,0.15306508529695506,-0.02850812939740883,-0.35759259985578457,-0.05669638371087319,-0.7292254544584956,0.08894528460361488,0.22169118142820068,-0.12345729302559624,-0.048239808849964934,0.03479534699448834,-0.20735840153418075,0.1292483935452281,-0.16932069814864614,-0.09896249223336374,-0.12339298149633456,-0.0941368868652479,-0.0578540225613933,-0.29861263399103083,0.3030596792055272,0.06011194653030388,Assembly,5
125,125,"genovo  novo assembly  metagenomes
nextgeneration sequence technologies produce  large number  noisy read   dna   sample metagenomics  population sequence aim  recover  genomic sequence   species   sample  could   high diversity methods gear towards single sequence reconstruction   sensitive enough  apply   set  introduce  generative probabilistic model  read generation  environmental sample  present genovo  novel  novo sequence assembler  discover likely sequence reconstructions   model  nonparametric prior account   unknown number  genomes   sample inference  perform  apply  series  hillclimbing step iteratively  convergence  compare  performance  genovo  three  short read assembly program   series  synthetic experiment  across nine metagenomic datasets create use   platform  largest     read genovo' reconstructions cover  base  recover  genes    methods even  lowabundance sequence  yield  higher assembly score 
 assist  reader table  summarize  notation use   follow section  assembly consist   list  contigs   map   read   contiguous area   contig  contigs  genovo  represent    list  dna letter {bso}  bso   letter  position   contig    read     contig number    start location  within  contig  denote    alignment orientation insertions  deletions require  match  baseforbase   contig boldface letter      represent  set  variables   type  subscript  exclude  variable index    set one way  assign  probability  every possible assembly   describe  full process  generate  read   creation   originate sequence    sequence noise copy  read   sequence  model  call  generative model   model  observe variables   read    hide variables   sequence bso   location    read  copy   plus  alignment   assembly  hence  assignment   hide variables   model      full assignment   plug    model  get  probability   generative process  first construct  potentially unbounded number  contigs   potentially unbounded length  assign place holders   begin  read   coordinate system  contigs  offset  finally copy  read letter   noise   place     map   contig  deal   challenge  unbounded quantities  assume    infinitely many   since  number  read  finite   finite number  infinitely many contigs    read assign       contigs  report hence instead  first decide  many contigs     assign  read      opposite—first partition  read  cluster   assign  cluster  read   contig hence  number  report contigs   determine   number  cluster   partition generate   read  order  randomly partition  read  need  prior  partition  chinese restaurant process crp aldous     prior crpa   generate  partition   items  assign  items  cluster incrementally   first    items  assign  cluster s1si    item  join  exist cluster   probability proportional   number  items already assign   cluster   join  new cluster   probability proportional    assignment probability   last item give  partition   previous items  hence give  psn                   exist cluster   represent  new cluster   count  number  items  include item     cluster  one property   crp    likelihood   partition   construction  invariant   order   items  thus  last conditional probability  true   item     assume     last one  conditional probability illustrate another desire property   crp   items   likely  join cluster  already   lot  items  parameter  control  expect number  cluster    case represent contigs  supplementary material additional file   show   set  correctly   idea  use  deal   unbounded length   contigs  treat  contigs  infinite  length stretch  minus infinity  infinity   draw  start point   read   distribution   integers  length   contig   simply determine   distance  table  notation table variables  vector  letter  read  observe  alignment insertionsdeletions  read   contig index  read   start offset  read  within contig bso dna letter  offset   contig   control contig  length  parameters  control  number  contigs pin pdel pmis probability  base insertion deletion mismatch  number  read  number  read  contig    dna letter alphabet typically {   }  laserson    two  extreme read since  cannot put  uniform prior   countably infinite set  since  want  read  overlap     choose  use  symmetric geometric distribution    integers  push  read towards  arbitrary zero  center   mean except  mark  region   integer line  read   likely  cluster formally   define  follow       jotj          parameter  control  length   region   read  generate  full generative model  describe   infinitely many letter  infinitely many contigs  sample uniformly bso~uniformb              alphabet   base typically b¼fac     empty read  randomly partition   contigs ~crpa    read  assign  start point  within  contig ~beta   ~gqs     distribution beta        mean     set      assume   lengths    read  already give  read letter   copy   mismatch   contig  start  position   accord   alignment  encode orientation insertions  deletions  ~alisi   pin pdel pmis     distribution  represent  noise model know   sequence technology  illumina etc  particular   read letter   pmis probability   copy incorrectly   probabilities  insertions  deletions  pin  pdel respectively   logprobability log pxi yijoi     generate  read   specific orientation  nhit match nmis mismatch nins insertions  ndel deletions  log   nhit log   pmis  nmis log pmis jbj     nins log pin  ndel log pdel assume  equal chance   appear   orientation   independent noise model give  assembly  denote   quantity  scorei read     read index  model include  infinite number  bso variables  clearly cannot   represent   algorithm  trick   treat    variables  unobserved effectively integrate    likelihood computations   observe bso letter     support  read    least one read letter align  location   hence   algorithm detail    contig letter lose  read support  immediately become unobserved  algorithm  algorithm start   initial assembly  take step   space   assemblies recall   assembly   assignment   hide variables   model namely  map  every read   set  contigs            contig letter bso   locations   support   least one read  step  take  design  lead   high probability regions   space  assemblies  step either maximize  sample  local conditional probability distribution   genovo  hide variables give  current value     hide variables  list   move use  explore  space  consensus sequence  type  move fig  update  sequence letter bso  maximize pbsojx     sequentially   letter let     number  read   current assembly  align  letter     location   since  assume  uniform prior   contig letter   easy  see    conditional probability  maximize  set bso  arg maxb2b   tie break randomly    word  set  sequence    consensus sequence   read   current map  read map  move fig  update  read variables    sequentially     sample   probability psi        yjx      first  remove read  completely   assembly   conditional probability decompose  psi            psi      ipoi       qspxi             order  make  sample tractable  reduce  space  consider  every location     best alignment     possible value      arg max  pxi             compute   use  band smithwaterman algorithm apply   read orientations  include locations   read  partially overlap   contig   case align  read letter   unobserved contig letter entail  probabilistic price  jbj per letter give  vector *    sample   simpler distribution   possible locations   psi            psi      ipoi       qspxi                 pxi            weight {}  count  number  read   sequence encourage  read  join large contigs  dictate   crp  also include  case   represent  empty contig   case  simply replace      formula    case  pxi     term also simplify  jbjli      length   read  set    sioi   bad alignments render    combinations extremely unlikely  significantly speed    computation  filter  combinations  implausible alignments   fast computation  detect locations    least one mer  common   read  weak requirement  enough  filter      locations make  optimization process efficient  scalable   speedup  achieve  cache common alignments  merge   run   algorithm  contigs grow  accumulate  read   common  find two contigs   overlap end even though  assembly  merge two  contigs  one would   higher probability  could take many iterations  reach  assembly   rely    read map step read  likely  move back  forth   two contigs especially   contain  similar number  read although eventually chance  make one contig  many  read       crp  push  rest   read   smaller contig   larger one  speed   process  design  global move fig    detect  case specifically  commit  merge   increase  likelihood specifically       kmers  common   end  one contig   begin  another  include  possible orientations  align  end realign  read   overlap interval  continue   merge assembly   overall likelihood  increase  fix indels   first read  map   previously unsupported area   contig   insertion error   error  go  propagate   contig representation hence  read map step  make    read  map    location align   unnecessary insertion   locations  step  propose  delete  correspond letter   contig  realign  read  accept  proposal   improve  likelihood fig     similar move  deletions  laserson    geometric variables   hide variables    represent specifically   assembly    parameters  control  length   contigs  set    value  maximize  probability prsj   see supplementary material additional file   detail also  shift   constant   start locations    read   particular contig   change  assembly hence  simply use  shift  maximize  overall probability    update  local optimization move    effect  current assembly  chimeric read chimeric read lasken  stockwell   read   prefix   suffix match distant locations   genome   algorithm  rare corrupt read often find  way   edge   assemble contig thus interfere   assembly process  deal   problem  occasionally every  iterations disassemble  read sit   edge   contig thus allow  correct read  contigs  merge    increase  likelihood beyond    original state    disassemble read   chimeric   reassemble correctly   next iteration thus keep  likelihood      computation  scoredenovo  adopt  view   metagenomic sequence assembly problem   two compete constraints  trade  first  wish  compact summary   read dataset  reconstruct sequence   reasonably cover  small  number second  read    reasonable point  origin   assembly scoredenovo coherently trade   constraints give  assembly denote    number  contigs     total length    contigs  measure  quality   assembly use  expression   scorei read  log jbjl  log jbjv0s  first term    score penalize  read errors   second  contig length embody  trade  require   good assembly  example  first term   optimize   naive assembly  lay  read    contig      exact copy     large number  total base  incur  severe penalty   second term  two term interact well since  represent probabilities— first term   log probability  generate  noisy read   contig base  align    second term   log probability  generate uniformly  contig letter   word   put  read   region  already   support   read  pay    disagreements   read   contig    put  read   unsupported region    read   first one  cover  contig region   pay log  generate  new letter   read   align well   support region   current assembly     beneficial  use  read  extend exist contigs  create new contigs   pay  high disagreement cost due  bad alignment  third term   score ensure  minimal overlap   base  two consecutive read  understand  assume two read   overlap   base   split  contig  two   position  third term give   bonus  log jbjv0   second term penalize   log jbjv  add  new base   assembly hence   prefer  merge  sequence      set      able  compare   score across different datasets  normalize   first subtract    score   naive assembly  put  read    contig   divide  difference   total length    read   dataset  define scoredenovo    normalize score see supplementary material additional file   another derivation  scoredenovo base   model",-0.1971485289333035,0.20732306737451012,0.1409781373275373,0.14750851588527114,-0.0349768924636794,0.018199784457810148,-0.12500197048425385,0.08393771640612782,-0.003947996028930946,0.08982846968665331,0.0077081467622205566,-0.0036157684878456546,0.14501393785183636,-0.08764311093443201,0.12185803718740927,-0.08666802459391229,0.025461306711087574,0.25098442913705593,-0.06279990314480029,0.04411304907308074,0.0906778249596099,-0.17595636146922067,0.04889796741980173,0.0008513966372295466,-0.0011875338042691545,-0.16346335728638928,0.046528516638700314,-0.17165094494237998,-0.006342575591125484,-0.0966680599173157,-0.011953459611616087,0.26930478012859416,-0.1784239159866135,-0.1048670398053232,0.1626994992833222,0.1021801398851308,0.05794433206704975,-0.024132094508492245,-0.10086284456054027,-0.13863513620738974,-0.07191567997284559,-0.14320170766191767,-0.05283490188956888,-0.12774574576221842,-0.16047630543146735,-0.023286063668532742,0.12396837421909293,-0.08570315476358076,-0.2199912969511804,-0.3813965735737612,0.134806410325769,0.01702338985042508,0.038511543000440664,0.6057740752200066,0.01883205223699156,-1.1973377079798124,0.0833113229667792,-0.16090763908084724,0.9944661759475392,0.2129742203182253,-0.18334264206626671,0.2814027860974477,-0.13123254551851712,0.060208887744220625,0.6234785750020684,0.039748841142928884,0.04568831353936497,0.05988937418712701,0.1527462423779936,-0.21791552797686498,-0.05622467545840309,-0.08675435585518139,0.04731282597608071,-0.15388696354625184,0.2086355644858141,-0.04055230191897525,-0.14226274814268014,-0.13812425150016674,-0.3663615842710407,-0.0547257533762604,0.20544302101856896,-0.07015224671903149,-0.3953933882047544,-0.060400011158352675,-0.8309855983429415,0.05540292375166225,0.20298759304558284,-0.12951936940342312,-0.11061288410521608,-0.07940853926955574,-0.2308364825826969,0.0855816831265024,-0.1442099316494912,-0.13808771633737496,-0.16979356920632244,-0.10879045331372003,-0.0691484488838103,-0.2496170691767583,0.2880482427817189,0.07077337943967847,Assembly,5
126,126,"metaspades  new versatile metagenomic assembler
 metagenomics  emerge   technology  choice  analyze bacterial populations  assembly  metagenomic data remain challenge thus stifle biological discoveries moreover recent study reveal  complex bacterial populations may  compose  dozens  relate strain thus  amplify  challenge  metagenomic assembly metaspades address various challenge  metagenomic assembly  capitalize  computational ideas  prove   useful  assemblies  single cells  highly polymorphic diploid genomes  benchmark metaspades   stateoftheart metagenome assemblers  demonstrate   result  highquality assemblies across diverse data sets
detecting  mask strain variation genomic differences  relate strain often result  “bulges”  “tips”    bruijn graph    unlike artifacts cause  sequence errors  genome assembly pevzner    zerbino  birney   example  sequence error often result   bulge form  two short alternative paths    vertices    bruijn graph  “correct” path  high coverage   “erroneous” path  low coverage similarly  substitution   small indel   rare strain compare   abundant strain often result   bulge form   highcoverage path correspond   abundant strain   alternative lowcoverage path correspond   rare strain aim   consensus assembly   strain mixture metaspades mask  majority  strain differences use  modification   spade procedures  mask sequence errors  algorithms  removal  tip “simple” bulge bankevich     “complex” bulge nurk    metaspades use  aggressive settings   ones use  assemblies  isolate  example  collapse larger bulge  remove longer tip  spade  note   bulge projection approach  spade improve   originally propose bulge removal approach pevzner    zerbino  birney  use   exist assemblers since  store valuable information   process bulge see “bulge projection approach”   supplemental material  feature  important   repeat resolution approach  metaspades describe  analyze filigree edge   assembly graph  addition  singlenucleotide variants  small indels strain variation  often manifest  highly diverge regions insertions  mobile elements rearrangements large deletions parallel gene transfer etc  green edge   assembly graph show  figure  result   additional copy   mobile element   rare strain2 compare   abundant strain1   blue edge correspond   horizontally transfer gene   highly diverge genomic region   rare strain3 compare   abundant strain1  edge fragment contigs correspond   abundant strain1  example  green edge  figure  bottom right break  edge   three shorter edge  note   edge   assembly graph  condense    represent nonbranching paths form  kmers  external file  hold  picture illustration etc object name  824f03jpg figure    bruijn graph  three strain   strain mixture  figure show   small subgraph    bruijn graph  abundant strain strain1  show  thick line   rare strain strain2  strain3  show  thin line  genomic repeat   show  red top leave   bruijn graph   abundant strain1 top right  rare strain2 differ   abundant strain1   insertion   additional copy  repeat   two breakpoint edge result   insertion  show  green  filigree edge   remove   graph simplification procedures   standard assembly tool aim  isolate bottom leave  rare strain3 differ   abundant strain1   insertion   horizontally transfer gene   highly diverge genomic region bottom right   bruijn graph   mixture  three strain  refer  edge originate  rare strain variants within  assembly graph   strain mixture  filigree edge traditional genome assemblers use  global threshold  read coverage  remove  lowcoverage edge  typically result  sequence errors   assembly graph   graph simplification step however  approach   work well  metagenomic assemblies since    global threshold   remove edge correspond  rare strain   preserve edge correspond  rare species similarly  idbaud  megahit metaspades analyze  coverage ratios  adjacent edge   assembly graph classify edge  lowcoverage ratios  potential filigree edge  denote  coverage   edge    assembly graph  cove  define  coverage covv   vertex    maximum  cove   edge  incident   give  edge  incident   vertex    threshold ratio  default value    vertex  predominate  edge    coverage  significantly higher   coverage   edge     ratio  cove  covv  edge   weak    predominate  either    note  filigree edge  often classify  weak since  coverage  much lower   coverage  adjacent edge result  abundant strain metaspades disconnect  weak edge   predominate vertices   assembly graph disconnection   weak edge    assembly graph   start vertex  end vertex   simply  removal   first last kmer rather  removal   entire condense edge  emphasize   contrast  idbaud  megahit  disconnect rather  remove weak edge   assembly graph since  goal   preserve  information  rare strain whenever possible       lead   deterioration   consensus backbone repeat resolution  exspander exspander prjibelski    vasilinetc    antipov      module  spade  combine various source  information  pair read  long errorprone read  resolve repeat  scaffold   assembly graph start   path consist   single condense edge   assembly graph exspander iteratively attempt  extend    longer path  represent  contiguous segment   genome genomic path  extend  path exspander select one   extension edge edge  start   terminal vertex   path choice   extension edge  control   decision rule  evaluate whether  particular extension edge  sufficiently support   data   extension edge   give  exist path exspander  remove overlap  generate genomic paths overlap reduction step  output  string spell   result paths   set  contigs metaspades modify  decision rule  exspander  account   local read coverage denote localcov   specific genomic region    reconstruct   path extension process  detail see “modifying  decision rule  exspander  metagenomic data”   supplemental material  value localcov  estimate   minimum across  average coverages   edge   path    extend take minimum rather   average coverage exclude  repetitive edge   path  consideration  typically underestimate  real coverage   region make  decision rule  conservative  new metagenomic decision rule  metaspades  intergenomic repeat  species  different abundances   resolve base   differences   depth  read coverage haider    namiki    metaspades introduce  additional metagenomicsspecific decision rule  filter  unlikely path extensions use  coverage estimate   region    reconstruct fig   often allow metaspades  pass  long interspecies repeat  reconstruction  abundant species metaspades apply  new decision rule describe     pair read fail  provide sufficient evidence  discriminate  extension edge  external file  hold  picture illustration etc object name  824f04jpg figure  apply  metagenomicsspecific decision rule  repeat resolution  figure show   small subgraph   assembly graph   path   currently  extend form  green edge along   blue extension edge   ′   shortedge traversal   end   extension edge   dot curve show  boundary frontiere   traversal  edge   set nexte  show  red  lowcoverage edge represent  dash arrows  edge  nexte  represent  solid arrows since  edge  nexte  low coverage  edge   rule    unlikely extension candidate   shortedge traversal   end   extension edge ′  since ′   single extension edge    rule     solid edge  nexte′   add   grow path   extension process continue  edge   assembly graph  call long   length exceed  certain threshold    default  short otherwise  say   long edge  follow  long edge    genomic path   edge   end     start     path  short  consider  extension edge  metaspades perform  direct traversal   graph fig  start   end    walk along  short edge  define  set   vertices   reach   traversal  frontiere  consider  set nexte   long edge start  frontiere  procedure  aim  find nonrepetitive long edge   follow    unknown genomic path  classify  edge   set nexte   lowcoverage edge   coverage estimate   region    reconstruct localcov exceed  coverage  least   factor   default value      edge  nexte  lowcoverage edge    consider  unlikely candidate   extension   current path     single edge ′ represent unlikely extensions  path  extend  ′ fig  utilize strain differences  repeat resolution  metaspades safonova    show  differences  haplomes   use  improve  quality  consensus assembly   highly polymorphic diploid genome metaspades capitalize   similar observation   differences  strain   somewhat counterintuitively use  improve  quality  consensus assembly   strain mixture  particular contigs generate prior  mask strain differences  assembly graph  thus represent genomic fragment  individual strain straincontigs often provide additional longrange information  reconstruction   strainmixture backbone inspire  dipspades safonova    metaspades use  follow pipeline  include two launch  exspander fig  generate straincontigs  construct  assembly graph  encode  abundant  rare strain  launch exspander  generate  set  straincontigs represent  rare  abundant strain fig  straincontigs   subject   default overlap reduction step  exspander transform assembly graph  consensus assembly graph metaspades identify  mask rare strain variants result   consensus assembly graph fig  generate strainpaths   consensus assembly graph capitalize   bulge projection approach see “bulge projection approach”   supplemental material metaspades reconstruct paths   consensus assembly graph correspond  straincontigs refer   strainpaths fig  repeat resolution use strainpaths  step utilize  hybrid mode  exspander originally develop  incorporate long errorprone pacific biosciences  oxford nanopore read   repeat resolution process ashton    labonté    antipov    instead  work  long errorprone read  modify exspander  work  virtual read spell   strainpaths  facilitate resolution  repeat   consensus assembly graph fig   external file  hold  picture illustration etc object name  824f05jpg figure  repeat resolution  metagenomic assembly  one  two identical copy   long longer   insert size repeat  red   abundant strain  mutate   unique genomic “green” region ′   rare strain   assembly graph result   mixture  read   abundant  rare strain two alternative paths   start   end   green edge one form   single green edge  another form  two black  one red edge form  bulge   straincontig span ′ show  green dash line construct  exspander   “generating straincontigs” step  mask   strain variation   “transforming assembly graph  consensus assembly graph” step lead   projection   bulge form  red  green edge  result   consensus assembly graph show    blue arrows emphasize  spade project rather  delete bulge facilitate  subsequent reconstruction  strainpaths   consensus assembly graph  reconstruction   strainpath green dot line correspond   straincontig green dash line   “generating strainpaths   consensus assembly graph” step    “repeat resolution use strainpaths” step metaspades utilize  strainpaths  pair read  resolve repeat   consensus graph  green dot strainpath    use  additional information  reconstruct  consensus contig crd span  long repeat note    example  figure   long red repeat  multiplicity    abundant strain  resolve    variants diverge green copy   repeat   rare strain scale metaspades since  metagenomic data set contain billions  read metagenomic assemblers    optimize  respect   speed  memory footprint nagarajan  pop  “reducing run time  memory footprint  metaspades”   supplemental material describe efforts  scale metaspades  assemble large metagenomic data set",-0.19662685274686215,0.2030650043790584,0.10657438475418986,0.12355139382865304,0.029531749762028606,-0.017177206417444225,-0.1234774689268968,0.016412447427142277,-0.0010458229567190077,0.10809563746683963,-0.04581943174752088,0.0006569652635023843,0.1498878307885684,-0.05831061461118652,0.1301125114325085,-0.025949939469601918,0.027713675243036383,0.15861198124764914,-0.021485089174837532,0.02651469301673825,0.02902754375808476,-0.1853341429594758,0.052613841356686265,-0.02081699641487381,0.02309267314288903,-0.13877590939205764,0.04079302778896928,-0.14128025027381536,-0.029497179107941907,-0.05472862563937525,-0.0036919288289548593,0.22922419907914754,-0.14944383533399355,-0.1045892857401155,0.15467304455863073,0.07023036221084378,0.07064168822210005,-0.028207627753701774,-0.09267707773806903,-0.06359241209282035,-0.08598005126051865,-0.16640772061327486,-0.07729457866058463,-0.08790607292566263,-0.11130750637647567,-0.0067479896072165394,0.16413926697449766,-0.058329517264909536,-0.1715496056949038,-0.31023364647108737,0.1277192359473678,0.054955743992493714,0.031627028823418286,0.5609288941338366,0.046816369665995616,-1.1305715445898803,0.058519682112963524,-0.2130966621931959,0.9371522305815324,0.2023955540560263,-0.15739907885447382,0.3664103053015107,-0.012993516237627154,0.07409452766518379,0.5686575421984338,0.04412923002801227,0.06419582857698616,0.02717588396797724,0.16369307879396575,-0.22268285073503785,-0.026548053562404764,-0.04628930664225634,0.06417972932579574,-0.13470956162257375,0.1798599677739669,-0.06391529998060291,-0.10855499868664673,-0.1005474357923578,-0.291849634964118,-0.045980339614960536,0.1890839202342705,-0.04117423452526709,-0.3295605140772112,-0.048425476865570034,-0.7826549148246391,0.050037619311231636,0.21071769768034346,-0.08102917790916099,-0.07800513533428961,-0.03154904972567844,-0.14200253752699374,0.05175672466678987,-0.14347252886527276,-0.11265097164461685,-0.15798444067539388,-0.09174139248912297,-0.1116717264278384,-0.30151949923136523,0.3005556090389204,0.05675276651169926,Assembly,5
127,127,"virustap viral genometargeted assembly pipeline
although nextgeneration sequence ngs technology provide  comprehensive mean    identify potential pathogens  clinical specimens simple  userfriendly bioinformatics pipelines  expect  obtain  entire viral genome sequence subsequently provide traceability base  extensive molecular phylogenetic analyse   develop  webbased integrate ngs analysis tool   viral genome virus genometargeted assembly pipeline virustap  include extensive sequence subtraction  host  bacteriarelated ngs read prior   novo assembly lead   prompt  accurate assembly  viral genome sequence  metagenomic ngs read 
clinical specimens  ngs short read  viral genome assembly sample ngs short read  prepare use stool specimens   patient  rotavirus gastroenteritis  analyze  describe previously mizukoshi     brief total rna  prepare  patient feces follow  rnaseq library preparation use  scriptseq  rnaseq library preparation kit epicentre madison  usa deep sequence  perform  obtain mer pairedend  short read   miseq reagent kit  illumina san diego  usa  sample shortread sequence   deposit   dna data bank  japan ddbj accession number dra004165  study protocol  approve   institutional medical ethics committee   national institute  infectious diseases  japan approval      conduct accord   declaration  helsinki principles ngs read process virustap accept single   read #  figure  read quality trim  perform use  skewer jiang     fastqmcf program   eautils package1   additional trim filter  unreliable sequence   user specify quality score #  figure  host read subtraction  readmapping  perform   bwasw program version 9ar786   durbin   ribosomal rnas       internal transcribe spacers rrna  retrieve   follow ftp site2 bacterial genome sequences3   latest host organism genome sequences4 #  figure  figure  wwwfrontiersinorg figure  schematic representation   virustap procedures   remove residual nonvirus sequence read   subtract  read  assemble  idbaud peng    follow   filter  nonvirus  read  megablast   altschul     rapsearch2   zhao    search   customize viral nucleotideprotein sequence   ncbi ntnr database base  virus taxonomy exclude bacteriophages5 #  figure   significant evalue less  either     megablast      rapsearch2  determine  nonvirus contigs  residual  read   subtract   follow process  nonvirus filter step   repeat    time   nonvirus contigs disappear  remove  nonvirus sequence read break  read  also remove   follow  novo assembly   novo assembly pipeline   select   follow four pipelines #  figure  a5miseq coil    platanus version  kajitani     priceti ruby     idbaud peng     priceti ruby    priceti   ruby    perform  iterative contig extension  preassembly contigs  platanus  idbaud a5miseq  one    recommend  novo assemblers  general ngs  read  assemble accuracy   resultant scaffold   check use  result “xxxscaffoldsfastq” file base   readmapping score  contigs  divide   nucleotide position   phred score  less     result sequence shorter     remove  final scaffold  subject  bwasw read map   megablast homology search   ncbi  database  alignment result  visualize   web page result  discussion basic virustap procedure briefly  schematic representation  virustap  show  figure   virustap process start   quality trim follow  host  bacteriarelated read subtraction  read subtraction  perform   follow two step first readmapping   bwasw program  rrna sequence bacterial genome sequence  select virushost genomes   human mouse  monkey  perform second nonvirus filter   virus nucleotideprotein database exclude bacteriophages   select   subtraction  extract possible virusrelated ngs read  abovedescribed highly extensive nonvirus read subtraction facilitate effective  novo assembly  prompt analysis achieve  time save  accuracy virustap performance comparison  direct metagenomic assembly methods use metagenomic rnaseq short read obtain  stool specimens   patient  rotavirus gastroenteritis mizukoshi     performance  virustap  compare      novo assembly methods without subtraction treatment  instance direct metagenomic assembly without subtraction use  clc genome workbench  qiagen aarhus denmark  a5miseq produce    scaffold respectively virustap significantly reduce  result   scaffold figure  step  figure  wwwfrontiersinorg figure  performance comparison  virustap  nonsubtraction methods  sample metagenomic rnaseq read obtain   rotavirus gastroenteritis patient  analyze  virustap  nonsubtraction methods  pairwise alignment view    similar hit   scaffold eleven scaffold show similarity  eleven segment  rotavirus genome sequence ncbi web blast search blastn  blastx   directly perform   scaffold  click  button  reconfirm  similarity  visualization   readmapping result   scaffold  viral quasispecies  read coverage   scaffold   confirm   readmapping viewer use  bam file   download result package  direct metagenomic assembly methods generate unexpectedly abundant scaffold relate  multiple organisms  step   figure   particular    scaffold  compose  bacterial sequence    scaffold  clc genome  a5miseq respectively figure  suggest  subsequent homology search  taxonomy classifications   laborious  timeconsuming procedures  identify  final viral genome sequence indeed  entire virustap process   sample read require  min  obtain  segment   rotavirus genome sequence whereas   two methods require        timeconsuming  novo assembly  homology search   abundant scaffold figure   addition   stool sample human serum specimen  dengue fever patient  investigate  rnaseq follow  virustap analysis since bacterial contamination   common  serum plasma spinal fluid  urine specimens virustap efficiently remove      hostrelated sequence  total read  obtain possible virus sequence read data  show  human genome subtraction could  sufficient   serum specimen  fecal  pharyngeal specimens contain unfavorable bacterial read  virus genome assembly  study demonstrate  rather laborious sample   bacteria rich stool sample   acceptable  determine  virus genome  virustap  include nonvirus filter see step #  figure   facilitate  virus genome assembly  result   homology search  pairwise alignment   scaffold   visualize   web figure    download  fullresults package although virustap provide  result   latest ncbi  database thus users  reconfirm  obtain scaffold  ncbi blastn  blastx web search   direct web link figure   download result package include  bwamapping “sortedbam” file    import   readsmapping viewer  visualize nucleotide polymorphisms insertiondeletion  read coverage depth   sample study   heterogeneous mixture  identify     position  scaffold  figure  indicate  possible quasispecies   valine  alanine residue     position   vp4 protein vp4   spike protein   outer capsid   receptor bind activities  function  membrane penetration trask    suggest   quasispecies could emerge  rotavirus gastroenteritis contribute   antigenic drift  rotavirus infection",-0.18103654617212772,0.1482602754144701,0.09820007219187114,0.08454871535257592,0.009854751456587912,-0.04947452840989215,-0.036927930973521525,0.056137585083084286,0.01189879369703904,0.07977244074420475,0.016978954161920124,-0.032250922602042036,0.14847508019006994,-0.049487287546161655,0.15318329671857053,0.10139392791431366,0.04791878971987027,0.11106044879425624,0.014655680349802204,0.011355935585667115,-0.07968116641947717,-0.21071388722222925,0.04842443248133891,0.05009879546205336,-0.04296002819423484,-0.07987604857250515,0.08835439178035928,-0.06908108497400238,0.0034529116420336987,-0.023597871593184275,-0.018238339829386902,0.26335222218390913,-0.12790125311216335,-0.022659211199520253,0.17678396548466827,0.038135332291427564,0.036998207582104384,-0.029739988462187443,-0.12079167081756367,-0.05263864219374057,-0.10097760743251168,-0.09510157921226578,-0.1373423766559657,-0.1478360192760435,-0.05816144477601674,0.04815825240361984,0.055305408292704014,-0.13793940269824415,-0.20275301307461613,-0.263711684637449,0.19095090181616808,0.02515810014508131,0.018663285972971275,0.4187241859462102,-0.04447877106141971,-0.8865159454238511,-0.017010905638307632,-0.2371337685917476,0.7984607925891272,0.1931598872761242,-0.16741555909083874,0.3187915859752973,0.033929442750166884,0.06790577887157209,0.5210164286203929,0.110795094535722,0.025189936178960558,0.022313319614218657,0.1988265174073834,-0.1762318601094176,-0.05821194875684605,-0.004547480756199479,0.14237203718834626,-0.08860203884760066,0.11371709396594433,7.796173237941481e-05,-0.1380635536200118,-0.1525630136062173,-0.3581666550676008,-0.08000800481223894,0.17716706533160714,0.017380615492263482,-0.3124401968847396,0.009246234972056865,-0.7403333279520358,0.10904735708852957,0.2702639881545837,-0.05290736268573061,-0.17021986829054725,0.006171139488548307,-0.06860776647788115,0.04831993354714704,-0.0964436015266843,-0.02255011248638335,0.0017957203481448996,-0.0533527034471458,-0.04312117759634795,-0.3449319510460259,0.2540118818039193,0.03420841397676545,Assembly,5
128,128,"searchsmallrna  graphical interface tool   assemblage  viral genomes use small rna libraries data
nextgeneration parallel sequence ngs allow  identification  viral pathogens  sequence  small rnas  infect host thus viral genomes may  assemble  host immune response products without prior virus enrichment amplification  purification however map   vast information obtain present  bioinformatics challenge  order   pass  need  line command  basic bioinformatics knowledge  develop  map software   graphical interface   assemblage  viral genomes  small rna dataset obtain  ngs searchsmallrna  develop  java language version  use netbeans ide  software  program also allow  analysis   viral small interfere rnas vsrnas profile provide  overview   size distribution   feature   vsrnas produce  infect cells   program perform comparisons   read sequence present   library   choose reference genome read show ham distance smaller  equal   allow mismatch   select  positives  use   assemblage   long nucleotide genome sequence  order  validate  software distinct analysis use ngs dataset obtain  hiv  two plant viruses  use  reconstruct viral whole genomes searchsmallrna program  able  reconstruct viral genomes use ngs  small rna dataset  high degree  reliability      valuable tool  viruses sequence  discovery   accessible  free   research communities    advantage    easytouse graphical interface
software searchsmallrna  develop  java language version  use netbeans ide  software biojava3corejar  biojava3alignmentjar package  use  additional tool   search engine doesnt use traditional alignment  find similar string  search read small dna string  24nt length   reference genome compare   ham distance   read present ham value equal  smaller   allow mismatch value  select  assemblage  read map generate  list  index value base   reference genome   first character   read  nucleotides   position   map genome  choose take  count  amount  read match    abundant nucleotide  use   assemblage   new genome  software  freely available      necessary  install java virtual machine  free available    higher sequence  clrdv genome  deepsequencing leave  cotton gossypium hirsutum plant cultivar fibermax966 infect  green house condition  cotton leafroll dwarf virus clrdv  viruliferous aphids inoculation  use  total rna extraction  clrdv virus correspond   pv1 isolate  suffer    years  passages  green house condition   ufrj rio  janeiro  brazil leave  mockinfected plant  use  negative control total rnas  extract use  invisorb spin plant rna mini kit invisorb®  quantity  quality  rna sample obtain  determine  spectrophotometry nanodrop  thermo fisher scientific  agarose gel electrophoresis systemic infections  confirm use nest rtpcr assay  detect  viral capsid proteinencoding gene  previously describe   procedures  obtain  viral small srna library  already describe   brief rna sample  precipitate  ethanol  sequence  fasteris  geneve switzerland   illumina genome analyzer illumina san diego usa small rnas     purify  acrylamide gel  ′ idt mirna clone linker integrate dna technologies san diego usa    ′ illumina adapters  singlestranded ligate   rna ligase   purify small rnas  construct  purify    acrylamide gel  remove empty adapters   reversetranscribed  pcramplified  primers use  cdna synthesis  pcr  design  insert  index   ′ adapter  libraries  quality control  clone  aliquot   topo plasmid  capillary sequence  clone highthroughput sequence  perform   genome analyzer gaiix   cycles plus  cycles  read  index  demultiplexing  adapter removal  million pass filter read  obtain   library  deep sequence libraries  deposit  geo gene expression omnibus   number gse311062  datasets  accession number human immunodeficiency virus  hiv read  download  sra database  use aspera software  accession number  hiv dataset  srp007924 spfmv read  download    accession number   complete genome virus use   paper  hiv  nc_001802 human herpesvirus  hhv  nc_001806 sweet potato feathery mottle virus spfmv  nc_001841 sweet potato feathery mottle virus isolate piu3 spfmv  piu3  fj155666 clrdvarg isolate  gu167940 clrdvpv1  hq827780  alignments  perform use multialign",-0.14372536817282666,0.1808400044111224,0.0601243165058621,0.004418816922849152,0.004578637778075609,-0.03928633179966958,0.014547730773391757,0.043818440700725436,0.011736704195522205,0.10631936707743682,-0.0066307499383356895,-0.0531452926163444,0.06948050313332013,-0.03909415853767634,0.17331864522236046,0.07628691954611333,0.15378781776845854,0.1716128593039939,0.061105090269636925,0.025656463145659825,-0.11747423458507494,-0.19319163712731693,0.08399692949848472,0.05667725603021491,0.024991187144232967,-0.06558178796881091,0.12740612236408233,-0.04048068441828846,-0.07141151215162751,-0.006690779977212675,0.018219594068113243,0.2651161184516949,-0.1771891602962544,-0.030222401355072193,0.26898973197376264,0.02072900104330084,0.034381064807649686,-0.006143607164029057,-0.07859892502793432,-0.07595925092338163,-0.052054013028850536,-0.1268697606411873,-0.16188001303250962,-0.14493029968536525,-0.0684238650282581,0.010944651278473258,0.05893689816111997,-0.10005584825386543,-0.1853486634433308,-0.16549665115951678,0.1014868873763518,0.1220262299344236,0.07857082732186299,0.39907373112162303,-0.019481108342527826,-0.8958224838121982,-0.07547679689709644,-0.1978327416303908,0.8344253579046539,0.11501875799497553,-0.09242335755809897,0.2957717835066408,0.019431105842289385,0.0655509316276619,0.4775789890250782,0.06857089212966079,0.03864226262633444,-0.027618946951428268,0.23184076777687965,-0.15524001193944836,-0.033401530496760715,-0.011173923863729769,0.14625400869190094,-0.11180330802203367,0.14280351480777428,0.002683695307185829,-0.07942854961656104,-0.06931381566774214,-0.3654031596518417,0.02636885430239484,0.18044482699899145,-0.041993360856783166,-0.33788774837660307,0.04245421340062884,-0.6947356980622177,0.16077171998740564,0.2959914291595385,-0.07371434033530487,-0.10036447902095627,0.029259711229631762,-0.09179501552865824,0.04977360797279956,-0.051820424922150735,-0.06469709460970027,-0.05547672259715089,-0.10309522738481584,-0.06180223946657457,-0.3507184702330889,0.2773040019992084,0.07321228092908222,Assembly,5
129,129,"drvm  new tool  efficient genome assembly  know eukaryotic viruses  metagenomes
virus discovery use highthroughput nextgeneration sequence  become  commonplace however although analysis  deep nextgeneration sequence data allow   identity potential pathogens  entire analytical procedure require competency   bioinformatics domain  include implement proper software package  prepare prerequisite databases simple  userfriendly bioinformatics pipelines  urgently require  obtain complete viral genome sequence  metagenomic data  manuscript present  pipeline drvm detect  reconstruct know viral genomes  metagenomes  rapid viral read identification genuslevel read partition read normalization  novo assembly sequence annotation  coverage profile  first two procedures  sequence annotation rely  know viral genomes   reference database drvm  validate via  analysis    sequence run generate  illumina  ion torrent platforms  provide complete viral genome assemblies   variety  virus type include dna viruses rna viruses  retroviruses drvm  compare   viral detection tool  demonstrate  merit  term  viral genome completeness  reduce computation time  substantiate  platform' potential  produce prompt  accurate viral genome sequence  clinical samples
reference databases viral nucleotide sequence  obtain   nucleotide database   national center  biotechnology information ncbi use  query term “completetitle  viridaeorganism”  query result    hit    march   increase    hit    october  base   sequence identifier accession number   viral sequence  taxonomic  scientific name  genuslevel annotation  separately obtain   ncbi taxonomy database viral sequence  taxonomy   include   virus division division      taxonomic information absent   lack genuslevel annotation  label “nonviral “notax”  “nogenus” respectively  nogenus sequence   use  add “ ” option   creation  databases   exception  nogenus sequence  sequence   nonviral  notax label  exclude  database construction  remain viral sequence  utilize  rawdb three hundred  seventyseven viral genomes  obtain  filter  host “human”   ncbi viral genome resource  retrieve  sequence  march    viral sequence  segment   correspond genus level  refdb  correspond refdb  upload  sourceforge  later use   increase read alignments  reduce memory requirements rawdb  split  eight subdatabases   contain sequence  total length  mbp snap version   possess  default seed size    use  generate index table snap_index_virus   viral subdatabases  addition  blast database blast_index_virus  create  makeblastdb blast    rawdb  enable contig annotation implementation  drvm  drvm pipeline  implement  python  incorporate several opensource tool include blast snap  spade   package comprise two modules createdbpy  drvmpy  schematic flowchart  drvm  show  fig   createdbpy viral sequence provide   user  process  produce rawdb  snap  blast database construction  refdb  download   sourceforge link drvmpy take single  pairedend read  input  align read  snap   accordingly identify viral read use  follow parameters snap single          base  taxonomic information genuslevel annotation   align sequence  viral read  partition  genuslevel group  group  label accord   correspond genus  examine  align sequence  read sequence coverage  read depth  calculate maximum coverage  average depth   genus  estimate  take  align sequence correspond   genus  consideration viral read   genus  average depth    equal  min depth default   undergo  novo assembly via spade  prior  assembly digital normalization   khmer   employ  remove read  highabundance default   kmers use blast  genuslevel assembly  annotate   closest reference  refdb use blastn identity ≧  reference  examine  confirm   contain  least   alignment rate   procedure return  hit  assembly  annotate  blast  rawdb note  although  viral sequence  refdb  restrict  human viruses    filter  host option  rawdb read  align  contigs  mean  soap2    readcovered contigs  place   coverage plot  referenceguide coordinate  increase contig continuity read align  contigs correspond   reference  extract  pair   pair read  reassemble  reassembly process   perform  pairedend read figure   schematic flowchart  drvm createdbpy process viral sequence  produce snap  blast databases drvmpy analyze ngs read  produce viral genomes open  new tabdownload slide  schematic flowchart  drvm createdbpy process viral sequence  produce snap  blast databases drvmpy analyze ngs read  produce viral genomes simulation datasets  reference genome   hepatitis  virus hcv nc_004102  use  simulate metagenomes         viral read use virtualnextgensequencer   simulate read  concatenate  gbp sequence read  million pairedend  read  liver cancer cells srr3031107  sra  mbp read   human microbiome sample srr062412  pairedend read contain    remove  read  liver cancer cells   read   human microbiome project hmp  take  host  bacterial metagenomes three reference genomes  respiratory viruses include human enterovirus nc_001612  ca16 human rhinovirus nc_001617  hrv  human respiratory syncytial virus nc_001781  hrsv  use separately  simulate         viral sequence use virtualnextgensequencer  simulate read      randomly select read  gbp  million pairedend  read   background   influenzanegative sample err690488   use  assess  ability  drvm  assemble viral genomes within   genus human enterovirus  rhinovirus metagenomic datasets  total   sequence run   sra  download see table   metagenome datasets base  prior study     summarize  table   run  analyze  drvm drvmpy  read1fastq  read2fastq   type iontorrent  ion torrent datasets   server intel xeon  00ghz     ram",-0.16882281508282265,0.18211895291062985,0.0930690638889466,0.08714245667034667,0.033678961623663566,-0.030716296288780275,-0.03771191063446935,0.0212932316650006,0.005087529599770719,0.12783485233511846,0.07026438643759614,-0.0028533383897326376,0.17397641795484914,-0.08402082650008992,0.11225756798199847,0.05107291928139625,0.11064234772199616,0.16849602721293488,-0.020226493745359668,0.05613693273705806,-0.12291922094445006,-0.2451249448165315,0.0885198871527006,0.058883475086229466,-0.029660731704069757,-0.15058553166490812,0.12863401153633916,-0.06309881279106189,-0.01625593090921594,-0.006098628884885657,-0.012955296228231966,0.2501385673122793,-0.15654775312586874,-0.00850690513023505,0.19244833678552686,0.04049247207099453,0.02955906785177125,-0.013354879088471326,-0.09268537582540363,-0.08718175320616367,-0.07353715847122702,-0.10751690094378924,-0.10044326527428854,-0.10351709250262388,-0.07363444830270004,0.01896238790332007,0.08094375547302407,-0.14649359095966016,-0.20323764440774925,-0.23462078612267406,0.14663846190076651,0.056336006773303124,0.041602700125311816,0.4611838813668684,-0.033582116292806934,-0.9073978549618598,-0.010906070696590584,-0.22917572426629945,0.8991791933098149,0.18604925075587125,-0.16951054057910075,0.32085237427367336,-0.013061740993151893,0.06645745962861092,0.5177723936416984,0.08039690559565073,-0.03338738396960478,0.023679990776936,0.2284321504000065,-0.15999858872440748,-0.05943519628739782,0.011089272387213687,0.07929088919866767,-0.1305159733121671,0.13506021329797574,-0.002181477996922729,-0.13220731611725128,-0.09766955447263194,-0.36163563296916135,-0.09165153709082627,0.21968452060821655,0.0006019883652279871,-0.3033964404191313,0.011245366980926198,-0.7394585445431431,0.1543731423324807,0.30905940989755465,-0.0941444139816272,-0.09929336793106107,0.055721835581884385,-0.08654912177007645,0.10826432044792816,-0.09657817499123524,-0.06275379286951717,-0.025391721142085717,-0.08147731423377991,-0.02844557164581088,-0.3070807026392601,0.2983077513943397,0.03423288554786155,Assembly,5
130,130,"intemap integrate metagenomic assembly pipeline  ngs short reads
nextgeneration sequence ngs  greatly facilitate metagenomic analysis  also raise new challenge  metagenomic dna sequence assembly owe   highthroughput nature  extremely short read generate  sequencers   illumina  date   generate  highquality draft assembly  metagenomic sequence project    fully address  conduct  comprehensive assessment  stateoftheart  novo assemblers  reveal   performance   assembler depend critically   sequence depth  address  problem  develop  pipeline name intemap  integrate three assemblers aby idbaud  cabog   find  complement    assemble metagenomic sequence make  decision   assemble approach  use accord   sequence coverage estimation algorithm   short read  pipeline present  automatic platform suitable  assemble real metagenomic ngs data  uneven coverage distribution  sequence depth  compare  performance  intemap  current assemblers   synthetic  real ngs metagenomic data  demonstrate  intemap achieve better performance   longer total contig length  higher contiguity  contain  genes  others  develop   novo pipeline name intemap  integrate exist tool  metagenomics assembly  pipeline outperform previous assembly methods  metagenomic assembly  provide  longer total contig length  higher contiguity  cover  genes intemap therefore could potentially   useful tool   research community  metagenomics
simulated dataset  construct  simulate metagenome dataset  use  metasim simulator   generate  collection  synthetic metagenomic read  reflect  specify abundance distribution   species   current study  mainly target  illumina read although  pipeline  also able   apply   short read  imitate illumina sequence  read length  set     average   standard deviation  pairedend insert size        model  specific pattern  sequence error  illumina technology  use ngsfy   generate sequence errors  read  use  fourthdegree polynomial model  describe  frequency  errors  illumina read  use  default settings  ngsfy   average error rate      previous study    construct  sim113sp dataset  mix  synthetic read   complete microbial genomes download  ncbi refseq database  collection    species  exactly    use  mavromatis     generate simulate metagenomic datasets except    unfinished genomes   choose close relatives usually  different strain instead see additional file  file    abundance set  use  logarithmic distribution    use  mende     model  microbial abundance distribution  highest sequence coverage  species   dataset   follow     coverage drop      top  species see additional file  figure   totally generate  million read  totally  mbp   able   download    order  calculate  number  genes contain   assembly   evaluation  simulate metagenomic dataset sim113sp  download  gene annotation file   reference genome  record  start  end position   gene   genome sequence   ncbi database accord   mappings   contigs   reference genomes  one gene  completely contain   align region   reference  gene  deem completely contain   contigs run  assemblers  preprocessing  correct  sequence errors  raw read   report  substantially enlarge  contig size   assemblers   single genome assembly    current study error correction also improve  metagenomeassembly quality especially   highdepth species  intemap pipeline employ  module  error correction  preprocess  read  assemble   fair comparison   experiment read  preprocessed   error correction process   assemble   assemblers see additional file  supplemental methods   detail process  error correction   assembler  run multiple time  different parameter settings  select  ones  appear optimal  near optimal result  parameters select  detail describe   run    assembler   additional file  supplemental methods  contigs  aby idbaud metavelvet  soapdenovo  extract   scaffold sequence  split  scaffold sequence  gap soapdenovo   additional module name gapcloser   postprocessor  test demonstrate   gapcloser' postprocessing actually increase  assemble errors dramatically therefore  select  assemblies without  postprocessing  gapcloser  soapdenovo evaluate  assemblies  extremely short contigs  many case  small   kmer size use  build  kmer graph  hardly support information   analysis    assemblies contigs  length    exclude  evaluation    previous study  follow  way use   previous study   use mummer package    evaluate  contigs   nucmer   use  align  contigs   reference   options “maxmatch   band  ”  deltafilter   option “   ”  dnadiff   use  obtain  globally optimal mappings  contigs  reference    could directly get  structural assembly errors segmental indels    misjoins  two nonadjacent segment   output  dnadiff  also get  identity   align contigs   evaluation   assemblies  simulate dataset  use correct contigs  evaluate  contiguity   contigs  compute  correct n50 size correct nlen size  correct esize  extract  align contig fragment   correct contigs   mappings  contigs  reference generate  dnadiff align fragment end   end  contigs  assembly errors  nlen size  compute  define   result section herein     note  n50 size correspond    lenx       denote  reference genome length  computation   evalue follow  formula ∑𝐶𝐿𝐶2𝐺      length  contig      total reference genome length  real ngs dataset mh0012   total length  reference genomes   available     esize formula  assign  maximal total contigs length among   assemblies run   dataset  use   algorithm   intemap pipeline   describe  procedures   intemap pipeline step  step  follow see fig  fig  figure6  flowchart   main procedures   intemap pipeline full size image step  correct errors   input read  default input read  first preprocessed   quake tool   aim  correct  sequence errors  highcoverage sequence see additional file  supplemental methods  detail two set  read   generate one name “correct read set” consist  read correct  validate  quake    consist   remain ones see additional file  figure    ratio   correct read  total read   coverage  species two set  mix together   mix read set  term “total read set” step  run idbaud  estimate read coverage   assembly  idbaud read  map   contigs use  read alignment tool bowtie   accord   mappings  read  contigs  coverage   read   estimate   time   total length  read   length   assemble contig furthermore  contigs  separate along   map read  different coverage  pipeline  pick    read map  contigs   coverage      designate  users   default   unmapped read  assemble  use cabog step  check  total length  high coverage contigs  pipeline first check  total length   contigs   coverage    length  shorter   designate value   mbp  default  pipeline go  step    condition   lowcoverage read assembly otherwise go   next step step  assemble read   “correct read set” use aby  idbaud respectively  “correct read set”   generate  step   use  set  largely increase  quality  assembly   highdepth species   aby  idbaud  assemblies  generate  aby  idbaud  pipeline map  read   contigs  pick   highdepth contigs   assemblies  minimal coverage  highdepth contigs  aby  idbaud  set   default step  merge  assemblies  high  low coverage level iteratively first  pipeline merge  highdepth contigs   idbaud  aby assemblies generate  step  use  algorithm describe   filter   highcoverage contigs ≥  idbaud  step   merge  remain contigs  cabog  step  since  pipeline  merge contigs    high  low coverage sequence finally  pipeline merge  together   final contigs note   range   high  low coverage overlap    ensure   pipeline cover   sequence   default cutoff  highdepth  lowdepth  set  make  range broader   use   assembly evaluation  pipeline end   step step  merge  assemblies  idbaud  cabog  step     skip  mean     high coverage species within  metagenomes merge  contigs generate   idbaud  cabog  step    final contigs  pipeline end   step  algorithm  merge two set  contigs  step  merge contigs   intemap pipeline  describe  follow step  compare  two set  contigs  begin  compare  two set  contigs use nucmer deltafilter  dnadiff  mummer package  get  mappings   two set  contigs   mappings   segment share  two set  contigs  mark   breakpoints  mark inside  contigs   bifurcations appear type  breakpoint   segment end   contigs   different assembly type  breakpoint  illustrate  fig   breakpoints may indicate assembly errors fig  figure7 illustration  merge two assemblies  two type  breakpoints cause  differences  two assemblies  illustrate suppose two assemblies asm1  asm2    assemble sequence segment seg1  first type  difference    asm1 seg1  extend  seg2   right   asm1 seg1 end   right  second type  difference    ass1 seg1  extend  seg2   right   asm2 seg1  extend  seg3   right  split  contigs   breakpoint within  suspicious region   example  merge  segment   breakpoints    break full size image step  validate  contigs  contigs  validate  map  pairedend read   contigs    use  previous work   basic idea    one contig  correctly assemble  pair  pairedend read  locate  mat correctly   region  ≥ mismate read locate  region   mark  suspicious  indicate potential misassembly within  region thus  one breakpoint  locate within  suspicious region    likely    assembly error therefore  algorithm break   breakpoints   locate within  suspicious regions fig  step  break  contradictory breakpoints  remain breakpoints  treat differently accord   type  type  breakpoints  mat   different assemblies respectively   mat breakpoints   break  step       break   step  contrast   one type  breakpoint  break  step    breakpoint  automatically transform   type  breakpoint  survive type  breakpoints  reserve step  connect  segment  reserve breakpoints fig      conflict breakpoints remain  step     segment    one segment link   reserve breakpoint  either  leave   right direction  begin   segment  end  one side  pipeline extend  segment  connect  adjacent one   extend segment end   extend direction  final contigs  generate  read  base   merge segment   segment  share  two assemblies randomly select one strand  sequence  read  base",-0.17223260606346136,0.2318444876841973,0.13318292338492901,0.14555113757233587,-0.01789401197874866,-0.04724076708755237,-0.08276997029725594,0.06956474728113862,-0.004572360316715575,0.1270924398600137,0.027858638757197057,0.00037676152844799617,0.17450279899120785,-0.0938911839071858,0.13636837110900218,-0.03831972899855477,0.045694513077464534,0.17591407813064586,-0.0631363918010622,0.04400193413332577,0.0019581033755312434,-0.2080765135669337,0.06054846879024881,0.007357591222053472,-0.027086873131065232,-0.1922721192328163,0.04549250921185025,-0.1637829002834629,-0.04839371900986104,-0.042448105591681606,-0.001706260092777283,0.2621271806575594,-0.15950410371657764,-0.0600738120460697,0.19169669034034112,0.09678799793410592,0.04504517547976435,0.011786293075802548,-0.0975091336394754,-0.1076943690631978,-0.06972501714461912,-0.1382932665811397,-0.06357043071545031,-0.08305249738637052,-0.14099439880220402,-0.02272938670566745,0.09937628920730028,-0.1343355504991301,-0.22151290362251555,-0.3828755804398229,0.15212187007509015,0.011037079322995169,0.06178940141255456,0.5963384452515867,0.01825939769858818,-1.1844129578468383,0.05312251137034473,-0.22170542690224126,0.9984931666701881,0.19345439828895666,-0.16476208636308462,0.33245427599925537,-0.08230771308823844,0.046292709236682564,0.5683486418330719,0.04926147565088222,0.032789280723907195,0.020361722268802528,0.16953157562108825,-0.19184073698507434,-0.05228382395819527,-0.019109146302156564,0.08050342550944753,-0.13735886809564776,0.21574337997346976,-0.02978906965543442,-0.09134565975775008,-0.07764651719699374,-0.3428403148624364,-0.09108275387839504,0.18713069539883356,-0.01280054882493421,-0.3755714198630582,-0.07506222383309366,-0.8303424610317457,0.0341614072393908,0.20858406098305352,-0.1417660215241559,-0.09809383569600087,-0.022946349325198505,-0.17777859479704866,0.07779417901699967,-0.12100018439962015,-0.11094196566037326,-0.13694016378528812,-0.04768001275085691,-0.06429652253574661,-0.2730493418847215,0.2985364291513614,0.06113598311308744,Assembly,5
131,131,"dbg2olc efficient assembly  large genomes use long erroneous read   third generation sequence technologies
 highly anticipate transition  next generation sequence ngs  third generation sequence 3gs   difficult primarily due  high error rat  excessive sequence cost  high error rat make  assembly  long erroneous read  large genomes challenge  exist software solutions  often overwhelm  error correction task   report  hybrid assembly approach  simultaneously utilize ngs  3gs data  address  issue  gain advantage  three general  basic design principles  compact representation   long read lead  efficient alignments  baselevel errors   skip structural errors need   detect  correct iii structurally correct 3gs read  assemble  polish   implementation preassemble ngs contigs  use  derive  compact representation   long read motivate  algorithmic conversion    bruijn graph   overlap graph  two major assembly paradigms moreover since ngs  3gs data  compensate     hybrid assembly approach reduce    sequence requirements experiment show   software  able  assemble mammaliansized genomes order  magnitude  quickly  exist methods without consume  lot  memory  save  half   sequence cost
 algorithm start  linear unambiguous regions    bruijn graph dbg  end   linear unambiguous regions   overlap graph use   overlaplayoutconsensus framework due   property  dub  software dbg2olc  whole algorithm consist   follow five procedures   implement    pipeline  dbg2olc  piece   pipeline   carry  efficiently  construct   bruijn graph dbg  output contigs  highly accurate ngs short read  map  contigs   long read  anchor  long read  long read  compress   list  contig identifiers  reduce  cost  process  long read fig  figure  figure1  map  bruijn graph contigs   long read  long read   red   bruijn graph contigs    color  long read  convert   order list  contigs term compress read  calculate overlap   compress read  alignment  calculate use  anchor contain read  remove   read  chain together   bestoverlap fashion  layout construct  assembly backbone   best overlap  consensus align  relate read   backbone  calculate   likely sequence   consensus output full size image  use multiple sequence alignment  clean  compress read  remove read  structural errors  socalled chimeras fig  figure  figure2 read correction  multiple sequence alignment  leave portion show remove  false positive anchor contig brown  appear     multiple alignment  right portion show detection   chimeric read  align   multiple read  breakpoint  detect    read   align   leave portion   target read   consistent    read    align   right portion   target read full size image  construct  best overlap graph use  clean compress long read fig   uncompress  chain together  long read fig   resort   consensus algorithm  convert   dna sequence fig  detail  procedure   explain   explanation  procedure    find   previous sparseassembler  ngs technology5   omit ",-0.21648142382543048,0.20040734277395328,0.15290719130944522,0.09723634394100847,-0.00802881215666117,-0.08164020252550709,-0.0906746241804364,0.043912457484428,-0.030436681536704542,0.15752891369376573,0.044793114441942984,-0.02374920220767229,0.14962132056446178,-0.07140679331559628,0.1344532633691257,-0.02274205879201991,0.032019623512219965,0.21000513787910915,-0.04374454001046378,0.028529612967521763,0.01862200706154513,-0.2450639128788759,0.057186700436590326,0.012881469797677077,0.007018028900189243,-0.1918078048468527,0.002871524243939506,-0.14409785024548435,-0.05411683506099507,-0.029480408289996183,-0.014184156812363019,0.2837460665614344,-0.2071723708662751,-0.13447406504533516,0.15664614491486092,0.07866255510421268,0.01822039682883769,-0.02956379218401549,-0.05736791858393901,-0.09465903443987886,-0.10061339401853847,-0.1443871069700633,-0.052104331795936036,-0.1181655689250202,-0.20892411858474827,-0.01194184999052516,0.14749885110580616,-0.15301413733623515,-0.2338410493975971,-0.378195872343697,0.13381711821800665,0.00560534832260126,0.01947160828706768,0.6483208935495223,0.04272153799082962,-1.2876923889637946,0.04696792863187906,-0.13159176339420653,1.0939577210937506,0.18202122266856072,-0.1848214750044344,0.3327543722293542,-0.1037452033791772,0.09156925462403982,0.6340814881854306,-0.017207393255059444,0.029368172107396,0.024244908866935668,0.14502437785742348,-0.2686429431319677,-0.01871863350417065,-0.02486432085440712,0.03800741142233322,-0.1533855340777613,0.22462933301753568,-0.03292243111291495,-0.17885359807785234,-0.0365304073974308,-0.3953472980394271,-0.047814292827514815,0.2499493305873804,-0.0041076838286877,-0.3944884529342032,0.029310667989826157,-0.9314011533886356,0.08118629770393929,0.2296046330460661,-0.12048750871136965,-0.17905631231184566,-0.07136633918929401,-0.14613603240476272,0.030528101221020537,-0.1338191557873,-0.10759435330375867,-0.1505452739486076,-0.10761101039521316,-0.11722442179376705,-0.35060583681131346,0.33814781980396696,0.09158515292232472,Assembly,5
132,132," masurca genome assembler
secondgeneration sequence technologies produce high coverage   genome  short read   low cost   prompt development  new assembly methods  particular multiple algorithms base   bruijn graph   show   effective   assembly problem   article  describe  new hybrid approach    computational efficiency   bruijn graph methods   flexibility  overlapbased assembly strategies   allow variable read lengths  tolerate  significant level  sequence error  method transform large number  pairedend read   much smaller number  longer superreads  use  superreads allow   assemble combinations  illumina read  differ lengths together  longer read    sanger sequence technologies make  one    assemblers capable  handle  mixtures  call  system  maryland superread celera assembler abbreviate masurca  pronounce mazurka  evaluate  performance  masurca  two    widely use assemblers  illumina data allpathslg  soapdenovo2  two datasets  organisms   highquality assemblies  available  bacterium rhodobacter sphaeroides  chromosome    mouse genome  show  masurca perform  par  better  allpathslg  significantly better  soapdenovo   data  evaluate   finish sequence   show  masurca  significantly improve  assemblies   original data  augment  long reads
 key idea drive  development   masurca assembler   reduce  complexity   data  transform  high coverage typically   deeper   pairedend read   coverage  fairly long maximal superreads  reduce data could   efficiently assemble   modify celera assembler   want  describe    modules  masurca   section  simply say superread  maximal superreads  nonmaximal superreads   use  assembly quorum error correction  use  quorum error corrector due   stability  high performance marçais    one may substitute another error corrector   quake kelley     long   output  process    way  read name  preserve   mat  report together creation  kunitigs extend  read base  base  computationally inefficient therefore  use errorcorrected read  construct kunitigs  follow  create  kmer count lookup table use  hash construct   jellyfish program marçais  kingsford   allow   determine quickly  many time  kmer occur   read give  kmer   four possible kmers  may follow  one   possible extension  acg    look   often    occur    find  one   four extensions  say   original kmer   unique follow kmer  similarly check whether    unique precede kmer analogously define  call  kmer simple     unique precede kmer   unique follow kmer  kunitig   string  maximal length   every kmer    simple except   first   last   alternative name  quite similar concepts   unipaths  allpathslg gnerre     construction  kmer  belong    one kunitig  note   kunitig   occur  multiple sit   genome   happen  exact repeat hence   kmer   kunitig   encounter   genome   whole sequence   kunitig  must appear   location   genome   use  property  kunitigs  create superreads superreads  pairedend read   kmer  belong    one kunitig   read   kmer  occur   kunitig  read   kunitig   align  one another   simplest case   read   substring   kunitig   kunitig   read superread   case  use individual read  merge  kunitigs  overlap    single longer superread figure  show  example   process    read   extend   superread  consist  two kunitigs  overlap   base kmers    belong    also  kunitigs     may extend beyond  end   two read  differ even   one base  map   extend  different set  kunitigs  kunitigs  construction   connect   exact  end sequence overlap  call  kunitig overlap  external file  hold  picture illustration etc object name  btt476f2pjpg open   separate window fig   example   read whose superread  two kunitigs read  contain kmers      end     belong  kunitigs    respectively kunitigs     show  blue   match kmers     show  red  green    overlap   base  extend read    end produce  superread also depict  blue  superread  consist  one kunitig   contain many kunitigs   read  pair  examine  pair  read  also call  mat read  mate pair  map  read   kunitigs   look   unique path  kunitigs connect  kunitig overlap  connect  two read   find   path   extend  pairedend read   new superread create  merge  kunitigs   unique path often  process  create  superread   pair fail      repeat sequence   gap  coverage   mat   case  form  superread     mat separately   mate pair  submit   assembler  link mate pair along   correspond superreads jump library filter although  require  masurca long jump libraries     pair  read  several kilobases apart  often part  genome sequence project   provide valuable longrange connectivity data   scaffold however  libraries sometimes contain read   chimeric   derive  two distant part   genome   may  misoriented   problems  library construction  particular  jump libraries use  circularization protocol    dna fragment  circularize  bring together  end  result read pair face outward mean   opposite end   original dna fragment occur   ′ end   two read misoriented mat   libraries  innies  originate  one side   original circle    contain  junction site  innies   treat  regular short insert   pairedend read   kinds  errors create many problems   scaffold phase   imperative      remove  give  data   assembly program  use quorum error correction   superreads procedures  perform library clean first  error correction  create  kmer database   pairedend read  exclude  jump libraries note  circularize read include  linker sequence   concatenation   linker   source dna represent sequence    appear   genome  one   read   jump library mate pair contain  junction site identify   linker  kmers  span  junction site   read    find   kmer database  error corrector  trim  read   junction site   create superreads   jump library read   introduce  modification   algorithm  accept  path  overlap kunitigs  build  superread   aggressive join   able  identify    nonjunction innie pair   end     superread next  look  redundant jump library pair    dna fragment  amplify  circularization produce two   pair  read  represent   fragment   assembly process assume   mate pair   independent sample   genome  redundant pair  lead  assembly errors later  examine  position  read   result superreads  look  redundant pair   set  forward  reverse read end     one  two superreads    offset  reduce  pair   single copy contiging  scaffold   cabog assembler  keep track   number  read  generate  maximal superread   position   read   maximal superread thus allow   precisely report position   read   assembly  create  superreads  assemble  data   modify version   cabog assembler miller     update  allow long superreads  well  short read    assembly  supply  follow four type  data  cabog superreads link mat clean  deduplicated jump library mate pair  available  available   note   modify version  cabog  use  masurca   capable  support  long higherrorrate read generate   pacbio technology cabog use read coverage statistics myers     distinguish  unique  repetitive regions   assembly  superread typically represent multiple read   keep track   many read belong   superread   position   read  modify cabog  incorporate  data use count    original read   computation  coverage statistics  major modification allow   use cabog  assemble superread data together  illumina   sanger read gap fill  final major step   masurca assembler  gap fill  step  aim  fill gap  scaffold   relatively short    contain complicate repetitive structure  gap may occur   assembler software overtrimmed  read   error correction step    misestimate  coverage statistics   contigs     reason  gapfilling technique   center   superreads algorithm   gap   scaffold  create faux  pairedend read   end   contigs surround  gap  call  contigend read   pair  contigend read   use  21mers whose count  globally   threshold    avoid highly repetitive sequence  pull   original uncorrected read  either  read   mate contain one   kmers   set  create  local bin  read correspond   gap  question   create kunitigs   read   bin   range      see    create  unique superread  contain  contigend read    able  achieve    value     result superread  use   local patch  sequence  fill  gap  find  depend   genome    gap   scaffold   fill use  approach",-0.24184563364821984,0.22454489169935835,0.11865048034118368,0.0950113141942918,0.035628995982676916,-0.026746486946522367,-0.12274534399957952,0.07273362514950762,-0.0050233321454831205,0.07897038029813372,0.01808681786386209,-0.015919668241427223,0.16742058288877332,-0.053564420017817915,0.11070791184442046,-0.04806944828113527,0.055656581123050615,0.1958524482389314,-0.06963849937645754,0.031131768309130357,0.016108976053468827,-0.19657001806505225,0.06494327791820761,-0.01785104879104948,0.009201215892482056,-0.16266282552044994,0.005050797331724036,-0.20209071602764656,-0.031697101457967086,-0.04497188548345532,-0.0252908314435982,0.2943373968507723,-0.15098893448184686,-0.10973761164051413,0.19885543664922284,0.12295899105007455,0.023178063701731415,-0.03692121701715677,-0.05591112419967528,-0.10265448634475564,-0.08337644086755867,-0.16683281219326754,-0.07422835837531153,-0.13583300523128955,-0.15288063428745585,0.006769257451888369,0.13851550507299404,-0.0955379711190573,-0.19087827325847345,-0.36633998326239575,0.12220757634598445,0.020401915196826367,0.05729509736446111,0.6318471295215616,0.019704621765086718,-1.317958032901624,0.03957195499051999,-0.16725897498050254,1.0390020638995774,0.2294717767890461,-0.17672281307169754,0.3735299872030083,-0.050824223033691336,0.0785710624369219,0.6066551193237267,0.03007105608241972,0.08416706162638106,0.07675958476467708,0.14842063011229967,-0.21832565832090567,-0.05795873381939237,-0.04762606212069185,0.049627153341007535,-0.1792228387888205,0.2329954119666858,-0.06521909176563598,-0.10036853035973464,-0.08001684681907241,-0.3529298047232035,-0.062140086355986085,0.2400226443960968,-0.047392906662830935,-0.3828943605729823,-0.05158897531869127,-0.9104154836313864,0.06718354608310256,0.21147148747884312,-0.10891215073146818,-0.11942674716855595,-0.029937075014604124,-0.1544786501592234,0.04224019701548497,-0.13001757082748552,-0.08304402541933567,-0.1535688951895154,-0.07694966268918461,-0.10810506016078714,-0.3131799642594666,0.3647673638297148,0.08388432659333027,Assembly,5
133,133,"tiger tile iterative genome assembler
  cost reduction   nextgeneration sequence ngs technologies genomics  provide    unprecedented opportunity  understand fundamental question  biology  elucidate human diseases  novo genome assembly  one    important step  reconstruct  sequence genome however   novo assemblers require enormous amount  computational resource    accessible   research group  medical personnel   develop  novel  novo assembly framework call tiger  adapt  available compute resources  iteratively decompose  assembly problem  subproblems  method  also flexible  embed different assemblers  various type  target genomes use  sequence data   human chromosome  result show  tiger  achieve much better ng50s better genome coverage  slightly higher errors  compare  velvet  soapdenovo use modest amount  memory   available  commodity computers today  stateoftheart assemblers   achieve relatively high assembly quality need excessive amount  compute resource  particular memory    available   researchers  achieve high quality result tiger provide   know viable path  utilize ngs  novo assemblers  require  memory    present  available computers evaluation result demonstrate  feasibility  get better quality result  low memory footprint   scalability  use distribute commodity computers
 assemblers  deal  small genomes    coli  well use  small amount  computation resource  time   large genomes   mammaliansize genomes  assemblers either cannot produce good result  require tremendous amount  resources andor time besides assemblers usually    design characteristics target  specific type  genomes   approach aim  substantially reduce  computational complexity  resources need  large genome assembly  key innovation    effectively divide  genome assembly problem  smaller subproblems  assemble  individually without internode communication   flexibility  use various offtheshelf assemblers  use  iterative refinement approach  gradually improve  quality  problem partition   overall solution key ideas tile genome assembly  rationale   method follow  belief   genome assembly could   partbypart instead    whole namely  input read   divide  multiple tile  cluster   assembly result   tile   merge   final assembly  call  approach tile genome assembly  observe       relate information  read    short fragment   target genome  assemblers would get excellent result  require much less memory include  read  correspond  larger regions increase memory requirement  potentially make assembly result worse  main reason    novo assemblers cannot tell  part   genome  read belong  however    partition  read   effective way assemblers  produce better result  require much less memory take  dbgbased assemblers   example ideally  contig   specific region   target genome  suppose   build use   kmers extract   read contribute   region however  assemblers extract  kmers    input read  mix  together  construct  dbg  specifically  kmers whose source read   contribute   specific region   target genome may still  use   dbg construction process   kmers  call  ambiguous kmers  genomes   less repetitive  ambiguous kmers could     genomes   highly repetitive    significant enough  confuse  assembly process therefore  design  new approach  partition  input read  multiple tile  goal     tile contain   read contribute   specific region   target genome  read   read tile  call wellclustered read thus  effect  ambiguous kmers   dramatically reduce since  read tile    necessary information  communication would  need among  assemblies  different read tile since regions   target genome   assemble independently    result  assembly  need less memory  complete read cluster base  cluster contigs  wellclustered read tile  contribute   continuous region   target genome  region   compose  one long contig   set  contigs cover  whole region without gap inbetween  set   contigs  call wellclustered    obtain  sort  cluster closely relate contigs together therefore  align  input read   wellclustered contig set  read  high similarity  subsections   contigs   collect   wellclustered read tile  process  call read cluster  collect read    assemble  produce  similar set   contigs   improve contig lengths  quality intermediate reference genome  target genome   consider   combination  multiple continuous regions  minimum number   number  chromosomes   target genome   region   contribute completely  one  many contigs therefore ultimately  would  multiple wellclustered contig set correspond  multiple regions   target genome   approach  treat  contigs  assembly   intermediate reference genome  arrange  contigs  multiple cluster contig set   novo assembly  start  random partition   read  tile assemble  read   tile  merge  contig set  one   intermediate reference   case  read   initial randomly partition tile  correspond  random regions   target genome   result  initial contig set  serve   intermediate reference  likely  fragment    errors  approach iteratively improve  cluster  thus  quality   intermediate reference genome   end  intermediate reference genome converge   final target genome iterative assembly  transformation  read  contigs   contigs  read form  cycle thus  whole assembly flow   iterative   transformation iterations  perform contigs become longer  higher quality since read cluster improve   tile contain less irrelevant information  may confuse  assembly process  tiger algorithm base  aforementioned ideas  develop ""tiled iterative genome assembler""  tiger  ""tile""   synonym  ""set""  ""cluster"" represent  tile computation nature   assembly process  conceptual flow  illustrate  figure  figure  figure1 schematic view   iterative framework  genome assembly full size image step  read partition  first partition  input read  multiple read tile   current implementation  input read  randomly partition evenly   subsets    determine  users base   available resources   total size   input read step  read assembly read tile  assemble individually use  offtheshelf assembler   velvet embed  tiger depend   available system memory  assembly  read tile    independently  serial   parallel   share  distribute memory computer cluster    communication   assemblies  different read tile   embed assembler require specify  kmer size kmer size  decide either manually  users  automatically   autokmer scheme  tiger   manual kmer designation  kmer size  use   read tile assemblies   tiger iterations otherwise  autokmer scheme randomly pick kmer size within  give range  record  best kmer size   assembly result  best kmer size   randomly pick ones   consider   subsequent assemblies userspecified kmer size   introduce   kmer history database  may   use    first attempt   good  number  use read   assembly  total length   contigs   resultant n50s  use  evaluate whether  kmer size  help produce  best result without know  target genome  avoid  problem  pick  contig set  high n50  low coverage  enable tiger  find  good direction   iterative process   converge  high quality result since step    first time  assemble  initial read tile  contigs   short  may cause long run time   later iterations  address  issue  merge  contig set  fee  merge contig set  velvet   longsequence flag enable velvet may  elongate  contigs  treat  input contigs  long read  new contig set  use    better   merge contig set  output contig set  scaffold  sspace   scaffold contig set   input  step   purpose   scaffold process   leverage pairedend information  bridge contigs  may   different assemblies   beneficial  better cluster contigs  step   scaffold process also help resolve duplicate contigs  different assemblies step  contig cluster  overall contig cluster algorithm  depict  figure   graph  model  contig connectivity intensity  build   merge contig set  graph  call  contig connectivity graph graph vertices   contigs vertex weight  contig lengths edge weight  define base   contig overlap degree    note   contig connectivity graph  much smaller   dbg   use much smaller amount  memory   apply  graphpartitioning tool metis   partition  graph  contig cluster metis  know   fast  memoryefficient  process millions  graph vertexes figure  figure2 contig cluster algorithm word  extract  contigs  number  common word  two contigs  use   edge weight   graph contig lengths  model  vertex weight  contig connectivity graph  thus build follow   metis partition process  partition subgraphs  cluster contig set full size image  contig lengths vertex weight  give less importance   contig overlap degrees edge weight   graph partition process     want  partition contig connectivity subgraphs    edgeoriented instead   vertexoriented   still need  consider  vertex weight   situations   exist many short contigs  little connectivity inbetween    common   assembly result   first  iterations  assemble randomly partition read tile  short contigs ought   distribute   cluster evenly    preserve  existence   follow tiger iterations  also reduce  influence   rest   cluster contigs  focus graph partition  edge intensity overlap contigs   group together  would  rebuild  one long complete contig later  step   contigs  use  produce wellclustered read   read cluster process  step     contig cluster step make crucial contribution   quality  result   later step build   contig connectivity graph   timeconsuming   traditional sequence alignment method  use like  smithwaterman algorithm  since  degree  overlap  contigs need   determine exactly   purpose  apply  heuristic algorithm base   image recognition algorithm use vocabulary tree    inverse document frequency score drop  begin  extract consecutive sequence  equal length call word     contigs   set  extract word  use  build  map  invert file   word   contigs contain   contig connectivity graph   build   map   edge weight  set   number  word  common   vertices contigs connect   edge since  connectivity graph store   contig connectivity information  memory usage   step  much lower     read assembly step regard runtime build  connectivity graph dominate  whole step build  word map     parallel   leave   future work overall  runtime  still much shorter  step    step  read cluster  entire input read set  align   contig set  step   read  high similarity   contig set  collect  one read cluster  read  collect    cluster  mean  read  appear  multiple read cluster  similar contigs   cluster together  process guarantee  read potentially contribute   contig set   collect  readtocontig alignment    bowtie   pairedend read  one   read pair align   give contig cluster  read  collect  step provide  opportunity  extend andor bridge  contigs  cluster process     parallel   serial   share  distribute memory computer cluster  communication  need  read tile  require memory  also proportional   size   read tile step  read assembly  assemble  read tile       step    assembly   merge contigs   read tile assemblies may   perform   assembly   merge contigs   improve   skip  later iterations  save time base   experience  find   useful    additional assembly   first  iterations step  post process    reach  give number  iterations    exit otherwise   step  step     form  iterative process  sum   rationale behind  framework    improvement  contig quality   current iteration   carry    next iteration   accurate read cluster  optimal cluster solution   achieve   read contribute   contig  cluster  assemble  contig  approach differentiate  algorithm   previous work  provide  framework  capability  improve  exist contig set ",-0.1901827595363695,0.2514432845935833,0.11994172859602892,0.20198698163604487,0.030883927248372776,-0.05397243811315528,-0.1347944305254951,0.04275728700095383,0.0018898091630746973,0.12496010001252768,-0.010646768960008478,-0.02252418264625189,0.19018074801785154,-0.10498521784927857,0.09951346364914966,-0.09611319264285673,0.04393060553525372,0.2171213274951341,-0.10649851931204624,0.061623036546845235,0.01607876334835411,-0.1921115937065738,0.05830968946684152,-0.056752502687437374,-0.016751307750161253,-0.15623378729467968,0.04373252982863367,-0.2110204585291364,-0.04369357573482178,-0.09843728239939084,-0.04049774458082697,0.31205685863922394,-0.16892793182310212,-0.1311570185203733,0.16562221048016396,0.08701513423065595,0.059231669189023735,-0.005132309783695509,-0.10439195467472967,-0.1094155357664694,-0.11673168791002472,-0.14538836555216025,-0.057584491230512,-0.13464471906013584,-0.16573291185410674,0.00871011189326806,0.17483972756435046,-0.1136906963731314,-0.22188550675725666,-0.4210882464924235,0.12933861416784806,-0.0060528254526814075,0.04589288316922688,0.6961533899722702,0.044568635761970656,-1.3524614071751864,0.1055235559647174,-0.23166639827768845,1.121470925483964,0.1912290562463726,-0.17848558040878626,0.3726084140273641,-0.1202769774890444,0.05527750902718095,0.6506281251244692,0.047747005870737866,0.06712982351183082,0.046351557130182026,0.21116372775558487,-0.22035386150211864,-0.009736974301133315,-0.06194558597578535,0.09089227088799184,-0.15639161902641796,0.2374043366495639,-0.0424860368968676,-0.15492269426644986,-0.11836886016282495,-0.3942832063028143,-0.05596566598067748,0.23994644950463506,0.015402525018536202,-0.3969444323450064,-0.03961293169287155,-0.9857219412811504,0.08333112203260458,0.1888443412222525,-0.14819399512565248,-0.15237489987225475,-0.06527313365735134,-0.17344262181254833,0.05898597048261486,-0.11827201416473025,-0.12514314691677852,-0.1873716177929094,-0.09367508579010103,-0.08100017905817368,-0.3420073920730552,0.3856775860790588,0.12909852536724192,Assembly,5
134,134,"pandaseq pairedend assembler  illumina sequences
illumina pairedend read  use  analyse microbial communities  target amplicons    rrna gene publicly available tool  need  assemble overlap pairedend read  correct mismatch  uncalled base many errors could  correct  obtain higher sequence yield use quality information pandaseq assemble pairedend read rapidly    correction   errors uncertain error corrections come  read  many lowquality base identify  upstream process benchmarks   use real error mask  simulate data  pure source template   pool template  genomic dna  know organisms pandaseq assemble read  rapidly   reduce error incorporation compare  alternative methods pandaseq rapidly assemble sequence  scale  billions  pairedend read assembly  control libraries show   increase   number  assemble sequence  naïve assembly  negligible loss  ""good"" sequence
pandaseq align  set  pairedend sequence read   threestep process first  determine  locations   amplification primers    specify   sequence   identify  optimal overlap finally  reconstruct  complete sequence correct  errors  check  various constraints   length  quality  score alignments  calculate  probability   true nucleotides       give  observe nucleotides     estimate    include quality information find   illumina read   base casava provide  encode quality score    probability   base  miscall  probability   approximate  𝐴0𝐴1     ascii quality value   illumina analysis pipeline versions  casava       ascii value use  casava   assume  nucleotides  equally likely   prior probability   true base match     sequence errors  independent  result  equiprobable choices    three nucleotides  probability   true base match give   sequence base match  pr𝑋ˆŷ∣∣𝑋𝑌𝜀𝑋𝜀𝑌𝜀𝑋𝜀𝑌3   probability   true base match give  sequence base mismatch  pr𝑋ˆŷ∣∣≠𝑌𝜀𝑌𝜀𝑋29𝜀𝑋𝜀𝑌𝜀𝑋𝜀𝑌  one   base   uncalled base    probability   base match  pr𝑋ˆŷ∣∣ use  probabilities pandaseq begin  assembly process  determine  position  forward  reverse primers  supply  accomplish   program find  first offset    primer align   primer    sequence   program calculate ∏∣∣∣∣1prŝ𝑖𝑥𝑃𝑖  assume  𝜀𝑃𝑖    highest value score assign  illumina   intuitively assume      program  find  best overlap greater   specify threshold   forward  reverse sequence    respectively   suitable overlap  find   read pair  discard      entire read even    primers   remove    possible   overlap   sufficiently long     primer region  schematic  show  figure   value   ∈  minf   choose  maximise  formula pr𝐹𝑅𝑐⋅∏…𝑐pr𝐹ˆ𝑖𝑓𝑅ˆ𝑖⋅∏…𝑟pr𝑅𝑖𝑐∏…𝑓pr𝐹𝑖  pr𝐹𝑖  pr𝑅𝑖   remainder      fix   value determine empirically    average error rate  value    calculate  count  mismatch rate  know index tag   define community data set describe   parameter need   retuned      estimate   error   index read  short  sequence earlier   process  likely  fewer errors  therefore  error rate  underestimate  true error rate regardless  error rate specify   step   negatively affect  ability  pandaseq  identify  best overlap   forward  reverse read   overlap  select  output sequence  construct   overall quality score  calculate   process  primer regions  disregard  primers  specify  unpaired regions  copy   available strand   quality score   regions   product   probability   base  correct   overlap region  decisionmaking process   complex   base agree  base  include   quality   base  assume   pr𝑋ˆŷ∣∣   base disagree  base   higher quality score  choose   quality   base  assume   pr𝑋ˆŷ∣∣≠  either   base  uncalled   consider  always match note  unassigned base  always associate   lowest quality score  casava   certain case  casava pipeline mask  quality score   end   read replace  quality score   lowest quality score    case special quality score  use  pandaseq  one base  mask  probability    base  use   base match  uniformly random   use     match      mask region  quality  assume   uniformly random   construct sequence    validate  userspecified criteria  quality score assign   assemble sequence   geometric mean   quality score calculate   compensate   variable lengths   final sequence pandaseq enable users  reject sequence base  low quality score lengths    short   long   presence  uncalled base  module system  also available within pandaseq  allow  sophisticate validation  user sequence   verification  know secondary structure  conserve regions note     detail manual include   software  describe example usage scenarios",-0.19631143783405425,0.20458177137747408,0.18137276578322054,0.16388133861497045,-0.07797362866764887,-0.08233791516622295,-0.1405045514672529,0.07495719686150551,-0.034526207393035295,0.1722281456850469,0.0041583474911749355,0.010911866255570205,0.12169157937169076,-0.14080597666464745,0.13863727889023722,-0.035035007728263734,0.04682455363683403,0.21997169374919032,-0.046318170447018935,0.11904561926051975,-0.013098813552409409,-0.2453311844710261,0.0801898940782994,-0.0043116704327985644,-0.044002283729612825,-0.21943273515626788,0.08002443748828955,-0.1760050863735378,-0.0510678359150188,-0.08015478349477052,0.046739792199805376,0.2336742783989757,-0.250087926109205,-0.06954884314816445,0.20447856563341335,0.05877854897733777,0.012942103758454324,0.016972722951322794,-0.10538022541627287,-0.1619496301957406,-0.07288275212072767,-0.14952579196187435,-0.10710686755739153,-0.12196234581200405,-0.172686123033287,-0.03834143512754235,0.11777109900768848,-0.19172654730267824,-0.2924406818142161,-0.41897771456232297,0.16339134946558626,0.02438893622299656,0.05456472646654584,0.6341327823400498,0.02356482967548072,-1.1535663525313138,0.0787745039681904,-0.237839884408284,1.0437463856115938,0.2327418262800202,-0.19337704105128067,0.2815956616499461,-0.11934915750287473,0.08977503794804216,0.6302567991195247,0.023686042003217157,0.04184057144448161,0.045667566172778604,0.1958658729018644,-0.1930346446649637,-0.0734879988423927,-0.04341382467187941,0.10327792867971584,-0.1277073212247342,0.2460040210261941,-0.04860124542040285,-0.1502071461342275,-0.14645542593859134,-0.3825940450262279,-0.10219346063770354,0.19316084483917806,-0.016077357053756715,-0.4645121878851205,-0.08610214589978568,-0.9026373541806824,0.042706381507683536,0.2369852605909109,-0.13622187061328442,-0.16456491007842122,-0.07572318259440362,-0.2304057799363509,0.10426525265397504,-0.12146490283310413,-0.1484811534890905,-0.1715824339594692,-0.07802135709673166,-0.049475659264251584,-0.3302757380353287,0.3024368186136708,0.08043198331678286,Assembly,5
135,135,"arachne  wholegenome shotgun assembler
 describe  new computer system calledarachne  assemble genome sequence use pairedend wholegenome shotgun read arachnehas several key feature include  efficient  sensitive procedure  find read overlap  procedure  score overlap  achieve high accuracy  correct errors  assembly read merger base  forwardreverse link  detection  repeat contigs  forwardreverse link inconsistency  testarachne  create simulate read provide fold coverage   genomes   influenzae  cerevisiae   melanogaster  well  human chromosomes     assemblies   simulate read yield nearly complete coverage   respective genomes   small number  contigs join   smaller number  supercontigs  scaffold  example analysis    melanogaster genome yield  coverage   n50 contig length      n50 supercontig length     assembly accuracy  high although  perfect small errors occur   frequency  roughly  per   typically deletion     size    small number   misassemblies  assembly  rapid  drosophilaassembly require   hours   single  mhz processor  use    memory
input data arachne  design  analyze sequence read obtain   end  plasmid clones—  pair forward  reverse read although   also  use  unpaired read  mean  standard deviation   insert length   plasmid clone   specify individually  practice    convenient  describe  clone  belong  one  several libraries characterize   parameters  base   read   associate quality score    produce   phred computer program ewing     quality score   correspond   probability     base  incorrect  quality score   thus correspond   accuracy   initial step arachne trim read  eliminate terminal regions  extremely low quality   eliminate read contain  little highquality sequence see  later section  technical detail “details  assembly algorithm”  program also trim know vector sequence  eliminate know contaminants  sequence   bacterial host  clone vector overlap detection  alignment sort  extend arachne start  detect  align pair  apparently overlap read refer   simply  overlap     false overlap result  repeat sequence   genome    eliminate  subsequent step overlap detection  perform   efficient manner rather  compare  pair  read  require  comparisons     number  read  program use  sort  extend strategy  scale approximately linearly  strategy involve produce  sort table   kletter subword kmer together   source—   read    occur   position within  read  practice  use     table  sort   identical kmers appear consecutively batzoglou   program  exclude kmers  occur  extremely high frequency  typically correspond  highcopy highfidelity repeat sequence   genome  eliminate   increase  efficiency   overlap detection process rather   eliminate repeat sequence    cause  problem per   program  identify  instance  read pair  share one   overlap kmer    readily recognize   sort kmer table  use  threestep process  align  read   efficient manner  first step merge overlap share kmers  second step extend  share kmers  alignments   third step refine  alignments  dynamic program detail provide   section  entitle “ alignment module”  overall process bear  resemblance   fasta algorithm pearson  lipman   threestep process yield   valid alignments  read pair  valid alignments may  miss   overlap  short  low quality  consist solely  highcopy highfidelity repeat  invalid alignments may result  lowcopy repeat  produce apparently overlap sequence error correction arachne next detect  correct sequence errors  generate multiple alignments among overlap read  program  identify instance    base  overwhelmingly outvote  base align    correct  base fig ​fig  practice  occur     disagreement   isolate position involve  single base  occasionally two base  process take  account  quality score   base base   case examine  majority   instance appear   sequence errors rather  slightly different copy   repeat sequence   latter instance   due   fact    typically multiple occurrences   alternative sequence  thus     overwhelm vote  one alternative arachne similarly correct occasional insertions  deletions result   appear   sequence errors   read  correct correspond change  make   alignments  external file  hold  picture illustration etc object name  16f1_l1ttjpg open   separate window figure  correct errors  read  portion   multiple alignment  five read  show   highlight column   alignment  base   quality   align   base       quality greater    base   change   base   quality  evaluation  alignments arachne assign  penalty score   align pair  overlap read  program first assign  penalty score   discrepant base base   sequence quality score   base  flank base  either side discrepancies  highquality sequence  assign  high penalty whereas discrepancies  lowquality sequence  penalize less heavily  penalty score   individual discrepancies   combine  yield  overall penalty score   alignment overlap incur  high  penalty  discard see  “alignment module” section  detail  step  stringent  false overlap  remain  typically cause  highly conserve repeat   point arachne also detect  discard likely chimeric read see  section  entitle “detection  chimeric reads”  detail identification  pair pair arachne search  instance  two plasmids  similar insert size  sequence overlap occur   end fig ​fig2a2a  instance  refer   pair pair  instance   extend  iteratively build complexes   pair pair fig ​fig2b2b  external file  hold  picture illustration etc object name  16f2_l1ttjpg open   separate window figure  use pair pair  overlap  merge read   pair pair  overlap  top two read  end sequence  one insert   bottom two read  end sequence  another  two overlap must  imply  large  discrepancy   insert lengths  initially  top two pair  read  merge   third pair  read   top  merge  base    overlap  one   top two leave read  overlap  one   top two right read  consistent insert lengths  bottom pair  similarly merge empirically  find   initial assemblies  almost always correct   significant exception occur   pair pair come  within  large repeat larger   insert size   plasmid  program attempt  detect  eliminate  case  virtue     high  depth  coverage see   instance  discard  collections  pair pair fig ​fig2b2b  merge together  contigs  consensus sequence  form see   result contigs   treat  large read  practice  length vary  slightly    size   typical read  ~  contig assembly   absence  repeat produce  correct layout  read  straightforward  two read  substantial sequence overlap must truly overlap   genome  thus  correct assembly could  obtain simply  merge  overlap read however false overlap may arise  read derive  different copy   repeat  example read enter different copy   repeat may  overlap sequence  could give rise  misassemblies fig ​fig3a3a  external file  hold  picture illustration etc object name  16f3_l1ttjpg open   separate window figure  contig assembly   merge read across  boundary   repeat may result   misassembly regions       unique regions  region    repeat occur twice   genome read    overlap  region  thus regions     wrongly join  merge read      potential repeat boundary read  overlap  read     read      overlap    disagree   rightmost end   repeat  start inside read     include  full read   show  practice sequence errors rather  repeat often cause  pattern  overlap  contigs  create  merge read    potential boundaries  repeat  potential repeat boundary   place   read may  extend  two nonoverlapping read two regions   genome cover  read  show  one region ard  cover  solid line read   second region crb  dot line read  two regions meet   repeat  create five contigs    unique contigs correspond  unique sequence        repeat contig correspond   repeat   read   copy    overcollapsed  one contig accord   algorithm use  construct contigs  contig correspond   would  exactly  read   fully include   boundaries      read would  assign  contigs       sequence errors read  dominate read    neighbor     neighbor     cause   sequence error     mark   figure note    represent correct sequence  would likely  extend   right   read    overlap   thus  would  dominate  arachne identify potential repeat boundaries  avoid assemble contigs across  boundaries  program mark  potential repeat boundary whenever  read    extend   right  leave  read          overlap   fig ​fig3b3b read    merge   read   right     clear  read    merge   contrast   neighbor   right   overlap       safely merge   closest neighbor   myers   program thus merge   stage read pair    cross  mark repeat boundary fig ​fig33c  criterion  merge pair  read   conservative  base   case examine  rarely produce misassemblies  fact   overly conservative   potential repeat boundaries reflect instance   read    fig ​fig3d3d fail  overlap owe  several sequence errors arachne employ  technique  eliminate    spurious repeat boundaries drop dominate read  describe   “contig assembly” section   perform  second round  contig merger  addition  dominate read another category  read  introduce repeat boundaries    merge across safely  read fully include   read  subreads    procedure  construct contigs subreads  ignore    use  detect repeat boundaries     include   contig  create  contigs  read   fully include  read  …    belong  contig     insert   detail  describe   “contig assembly” section detection  repeat contigs   previous step arachne merge read  contigs   potential repeat boundaries     repeat contigs—defined  contigs   nearly identical sequence  distinct regions  collapse together  repeat contigs   identify  two ways first repeat contigs  typically   unusually high depth  coverage    assess  use  logodds ratio—  contig   give length  density  read represent unique sequence versus  compose  read derive  two copy   repeat myers    second   typically  conflict link   contigs repeat contigs  usually link  multiple distinct nonoverlapping contigs reflect  multiple regions  flank  repeat   genome fig ​fig  external file  hold  picture illustration etc object name  16f4_l1ttjpg open   separate window figure  detection  repeat contigs contig   link  contigs      right  distance estimate               cannot  position without substantial overlap       correspond detect overlap       read   overlap    probably  repeat link  two unique regions   right creation  supercontigs   repeat contigs   correctly mark  remain contigs  represent correctly assemble sequence  unmarked contigs  refer   unique contigs similar  unitigs myers      usually represent unique sequence   genome  genomic repeat sequence   diverge sufficiently  allow   assemble     unique arachne  use  forwardreverse link  plasmid read  order  orient  unique contigs  longer layouts call supercontigs  scaffold supercontigs  create incrementally   begin  unique contig  consider  supercontig pair  supercontigs   merge   large supercontig    join   least two forwardreverse link fig ​fig5a5a  program require  presence   least two link  avoid link due   single chimeric plasmid   unlikely     two independent link support   incorrect merger priority  give   mergers support    link  involve  shortest distance see  “supercontig assembly” section   detail  external file  hold  picture illustration etc object name  16f5_l1ttjpg open   separate window figure  supercontig creation  gap fill   supercontig  construct  successively link pair  contigs  share  least two forwardreverse link  three contigs  join  one supercontig  arachne attempt  fill gap  use paths  contigs  first gap   supercontig show   fill  one contig   second gap  fill   path consist  two contigs fill gap  supercontigs  layout  consist   number  supercontigs      order list  contigs  interleave gap    gap correspond  regions mark  repeat contigs   thus omit   supercontig construction  gap  also correspond  regions      insufficient number  shotgun read  allow assembly arachne attempt  fill gap  use  repeat contigs  every pair  consecutive contigs   interleave gap   supercontig   program try  find  path  pairwise overlap contigs  fill  gap forwardreverse link   guide  construction   path  identify contigs likely  fall   gap fig ​fig5b5b  detail  give   section  entitle “filling gap  supercontigs” consensus derivation  postconsensus merger  layout  overlap read  convert   consensus sequence  quality score     convert pairwise alignments  read compute   overlap detection phase  multiple alignments  multiple sequence alignment  traditionally  timeconsuming step  develop  efficient algorithm describe    head “consensus derivation”  form consensus sequence arachne merge overlap adjacent contigs  supercontigs   final stage  accept overlap   significant number  discrepancies thereby merge across spurious repeat boundaries    detect  layout comparison   assemblers arachne  develop   earlier version   program describe   phd thesis batzoglou   broad outline  program follow  overlaplayoutconsensus approach    use  nearly  assemblers many   algorithmic aspects  arachne  novel   aspects  similar  exist assemblers myers  colleagues produce  sophisticate assembly program call  celera assembler myers    base  various layout algorithms previously develop  myers  arachne share  significant similarities   celera assembler  notably   algorithms  merge read  contigs    boundaries  repeat myers  however  two assemblers also  many significant differences  celera assembler screen  predefined repeat arachne    instead use kmer frequencies  identify repeat arachne use sort  kmers  detect overlap  initial version   celera assembler employ  different approach although  program   subsequently revise  myers pers comm like phrap green   cap3 huang  madan  arachne create refine  evaluate read alignments use quality score  celera assembler   use quality score subsequent  trim  prior  consensus arachne use error correction   accurately evaluate read overlap  assemblers detect potential repeat boundaries merge read    boundaries   myers   use read density  detect repeat contigs arachne also detect repeat contigs via conflict link moreover  use pair pair   techniques  produce longer contigs  layout  arachne   celera assembler require  least two link  order  pair  contigs   supercontig  apart    use different algorithms  build supercontigs  fill  gap within supercontigs simulation  wgs data  test arachne  simulate wgs data  know genomes  data  generate  two step  selection  random read   target genome   assignment  quality score  introduction  errors   first step plasmids  randomly choose   genome  select  random location   start   insert   random length   give length distribution  correspond forward  reverse read   read   genome   second step  simulate read  assign realistic quality score  errors  pair    real read take   finish bac sequence project   whiteheadmit center  genome research   read  length quality score  correctness   base   read  know  comparison   finish sequence   simulate read  impose  pattern  quality score  errors see   correspond read  simulate read thus contain fairly realistic error pattern nonetheless  fall short   completely realistic  several respect  decrease order  significance first   plasmids  randomly position along  genome  simulation   reflect potential clone bias   word    nonuniform distribution  clone across  genome second   simulate read  assign quality score  randomly pair   actual read  simulation   reflect regions  systematically poor sequence quality  example sequence follow  long polyastretch may  poor quality whereas  arachne simulation  pair   simulate read   independent real read third   read  take  publish genomic sequence  necessarily omit regions absent   publish sequence  concatenate sequence flank small gap consequently regions   difficult  clone sequence  assemble   original publish sequence  likely also  miss   result  generate full coverage  half coverage   simulations full coverage correspond  ~fold coverage base  whitehead' definition  trim read length  ~fold coverage base   number  base   phred quality score ≥ half coverage  half   level  generate data  small plasmids mean insert size    large plasmids mean insert size     ratio     case  full coverage     case  half coverage   case  insert size  normally distribute around  mean   standard deviation       read  successfully pair     single read reflect  realistic sequence failure rate moreover    insert  chimeric—  correspond forwardreverse link read  come  unrelated random locations   genome  rate  choose   higher   observe rate  chimeric insert  whitehead",-0.18370257880933305,0.16738014648751245,0.118417098061707,0.11522022861552544,0.004249876626433091,0.020202624860663584,-0.09117193522403097,0.07989659683016134,-0.010742492014134013,0.0877706822644399,-0.003152066242069236,0.007069189782302967,0.19548220813783984,-0.05740745366649633,0.12281630512926348,-0.08399298177939815,0.009895082032016944,0.16815874893229618,-0.08345183631139333,0.06673658971203031,0.06569300321431214,-0.1804959153803368,0.05946154926868395,-0.02319414496297839,-1.6712824936484454e-05,-0.2099823376463194,0.02937390160561288,-0.17594277098103633,-0.016319365926179885,-0.06770041226150465,0.010945522990841236,0.2474492895328092,-0.16402193062453813,-0.10550347207546501,0.18425185262878893,0.1035428002774156,0.05635811558712196,-0.026680085427988044,-0.11397013373959465,-0.07413627755980902,-0.10987851650573352,-0.13309350246300392,-0.0711198324613899,-0.09753991757476456,-0.1227705146972424,-0.04817689911678,0.1720360946038726,-0.1044752701891884,-0.21456114779598406,-0.39002873854202896,0.18287836214472306,0.0009634028629315925,0.06163716905178841,0.584919190266912,0.022248764736400226,-1.21847957702786,0.059005116689976676,-0.17666831804984082,0.9514694561172268,0.19321092228148531,-0.17478671172667218,0.3535293628975323,-0.05708154347950484,0.06246933533149384,0.5733656800830549,0.00490393710377295,0.063912857242999,0.059652006495502084,0.12942779253617945,-0.1507117339891235,-0.07618072217094292,-0.02987324828644852,0.068168474203261,-0.12758851233276752,0.18383075926050715,-0.05570451557778378,-0.14370845875785196,-0.1100822784805628,-0.3513016700672342,-0.07809672412646226,0.2019728209960196,-0.015238017878777125,-0.3489590651502289,-0.05285105225894685,-0.8510250596270228,-0.016738002047614744,0.17572694683641002,-0.1066705834684824,-0.07560670680497612,-0.049126789470793984,-0.188784457822542,0.06813210137691138,-0.1360506314265333,-0.08167234651215961,-0.17522568419882226,-0.04589161179017112,-0.12697569268729916,-0.2524672200559909,0.29806284739408345,0.05664956624269661,Assembly,5
136,136,"minimus  fast lightweight genome assembler
genome assemblers  grow  large  complex  response   need  algorithms  handle  challenge  large wholegenome sequence project many    common use  assemblers however  best serve   simpler type  assembler  require fewer software components use less memory   far easier  install  run   develop  minimus assembler  address  issue  test    range  assembly problems  show  minimus perform well  several small assembly task include  assembly  viral genomes individual genes  bac clone  addition  evaluate minimus' performance  assemble bacterial genomes  order  assess  suitability   component   larger assembly pipeline  show  unlike  software currently use   task minimus produce significantly fewer assembly errors   cost  generate   fragment assembly
implementation detail  minimus  minimus assembler  build   modular fashion  software modules available within  amos assembly package    release  one   components   package amos   opensource software package  provide researchers   collection  modules  software libraries   useful   development  genome assembly  analysis software  full description   amos package  beyond  scope   paper    publish elsewhere mpop manuscript  preparation minimus consist   combination  three amos modules follow  traditional overlaplayoutconsensus paradigm   modules interact      central amos datastructure call  bank  show  figure   three modules  figure  figure1 overview  minimus pipeline several independent modules   amos package show  ovals interact   amos api   central datastructure call  bank  order  execution   individual modules  show   arrow note   input  output  minimus follow  amos file format amos message file  amos package provide converters   file format  virtually  commonly use format  represent sequence data  genome assemblies full size image  hashoverlap   sequence overlapper  use minimizers   increase speed  decrease memory usage  tigger   unitigger  tool  identify cluster  read    uniquely assemble base  algorithms develop  myers    graph theoretic term  unitigger identify maximal interval subgraphs   overlap graph  makeconsensus   progressive multiple alignment program  refine  read layout generate   unitigger  build  precise multiple alignment   read note  sequence quality value   use   generation   multiple alignment consensus step   assemblers   phrap use  quality value   integral component   assembly algorithm  find  due   high quality  data produce  modern sequence instrument  explicit consideration  quality value   overlap  unitigging step  unnecessary instead   use  quality data  trim  poor quality flank   read see   sequence trim   compute  consensus  associate quality value   multiple alignment  coassembled read  execution  minimus consist   follow stag describe  detail  input stage  shotgun read  load   amos bank  input  present   amos message file whose format  model   format use  celera assembler  virtually  exist format  represent shotgun data   easily convert   message format   help  conversion tool distribute   amos package overlap stage  hashoverlap program  use  compute  pairwise alignments   read provide   input unitigger stage  tigger module construct  graph representation   set  overlap determine   overlap stage  overlap graph contain  node   shotgun read   edge connect two nod   correspond read overlap  unitigger  use several reduction step  simplify  graph  generate  set  unitigs base  algorithms originally develop  myers   briefly  reduction step   removal  containment edge read completely contain within  read   input  remove   graph  transitive reduction   set  three read       overlap       infer   overlap  read         overlap   edge correspond   overlap  remove   graph  uniquejoin collapse every simple path   graph paths  contain  branch    nod    outdegrees equal    collapse   single vertex   vertex represent  individual unitig consensus stage  final stage  minimus construct  full multiple alignment   read align within  unitig use   guide  approximate placement   read infer   overlap information sequence trim  criteria use  trim  vector sequence   poor quality flank  shotgun read vary significantly depend   source   data    protocols employ  sequence  design minimus  thus opt  perform  trim   data  external software tool    customize   specific characteristics   data   examples describe   paper  follow two different approach  sequence trim   data    confidence   trace archive clip coordinate  correct   two bacterial genomes  simply use  coordinate provide       datasets zebrafish gene  mouse bacs  follow  protocol describe   specifically  use  program lucy   quality trim follow   kmer base vector trim protocol note   phrap perform  trim base  quality value  order  ensure consistent trim   data  provide phrap  sequence already trim accord   protocol describe  extraction  gpc3 homologues  zebrafish shotgun data  extract  set  zebrafish shotgun read  map   human gpc3 gene  build  ncbi blast database contain  highquality region   zebrafish read obtain  remove  sequence vector   poor quality regions   align  protein sequence   human gpc3 gene use tblastn   evalue cutoff    read match gpc3   extremely relax criteria   provide  minimus  assembly",-0.2361487631881309,0.2491957142795605,0.11567099307731335,0.1411488282505513,0.07316137424293688,-0.048113029321745764,-0.09043507853658088,0.05980511569312864,-0.01664231008579654,0.1839651377571206,0.03480167384710043,-0.0946239417930971,0.189116141610148,-0.0643451371849815,0.12636090724563767,0.018650309097551318,0.09993384171074496,0.21447029316933044,-0.027489246159882075,0.049310090784509215,-0.04376221770841268,-0.2472500241872284,0.058036189523174415,-0.030429384558867182,-0.0038353970263063186,-0.1731068080065832,0.08414794160484998,-0.12966987485546738,-0.09596619425837193,-0.016744144610551768,-0.0008749647802042383,0.31024016938322496,-0.18971940387836508,-0.09056656928845652,0.2414586739776085,0.10656569324970816,0.0564611931932309,-0.014690017917253556,-0.08522635923262926,-0.13515428110821953,-0.06841876831885818,-0.16602735606434327,-0.07002682427968641,-0.09466727923849716,-0.13388778331329024,0.008388610344545373,0.10481527339321592,-0.11627118841204193,-0.21807261918851686,-0.289808365775107,0.13416611853115742,0.040557133541780435,0.04835461656818347,0.6245820671259876,0.03593588050308397,-1.1941814822880852,-0.008782499502863614,-0.2001903632546835,1.0759883832464354,0.18811233373887054,-0.12933667272398805,0.35384831760386604,-0.023089169509588708,0.09451157013404994,0.6462332000753152,0.024238861006714643,0.02425098428014485,0.028677766876588125,0.22788288493325276,-0.20660263960561412,-0.03602191494007252,-0.01135396063684546,0.11985985171491086,-0.17203002856188124,0.2221894099737608,-0.061390002252113426,-0.09304904973795336,-0.08743126915933024,-0.3797045337357097,-0.0973904653235701,0.20770048504414115,-0.039884598336591866,-0.3956609201806714,-0.0371632412996053,-0.9287303626567366,0.1655574034878819,0.2568152365721612,-0.1634700354894683,-0.15035223287995905,-0.027194133339986774,-0.13756381025492784,0.0986007975782418,-0.10170567862899793,-0.08936340113380742,-0.1109323839288986,-0.09847279050717912,-0.10082128437634016,-0.4064451324317845,0.3988969012965343,0.10011806933156724,Assembly,5
137,137,"scaffold preassemble contigs use sspace
 novo assembly tool play  main role  reconstruct genomes  nextgeneration sequence ngs data  usually yield  number  contigs use pairedread sequence data   possible  assess  order distance  orientation  contigs  combine   socalled scaffold although  latter process   crucial step  finish genomes scaffold algorithms  often builtin function   novo assembly tool  cannot  independently control   present  new tool call sspace    standalone scaffolder  preassemble contigs use pairedread data main feature   short runtime multiple library input  pairedend andor mate pair datasets  possible contig extension  unmapped sequence read sspace show promise result   prokaryote  eukaryote genomic testsets   amount  initial contigs  reduce   least 
materials part   test data  take   ncbi short read archive sra  ecoli strain  mg1655  use two illumina pairedend libraries correspond   insert size    srr001665    srr001666 respectively  gclavigera strain kw1407 diguistini     use  combination  singleend  read srr023307  srr023517  srr023533  two illumina pairedend libraries correspond  insert size    srr018008  srr018011    srr018012   genomes  sequence read  assemble  singleends  aby  subsequently scaffold  supercontigs use  aby  sspace scaffolders  minimum number  link require  match unambiguous contig link  set     giant panda genome  retrieve sequence scaffold construct  soap        split   gap position larger     result  contigs    scaffold  sspace use  available pairedread libraries  highquality read  total  libraries  insert range       minimum number  link require  match unambiguous contigs  set    analyse  perform     linux machine  sspace algorithm  overview   sspace algorithm  give  supplementary figure  first shortpaired dna read  filter  remove sequence contain nonactg character  remain read pair  map   preassemble contigs use bowtie langmead     position  orientation   pair  could  map  store   hash hereafter  postfiltering step  apply  remove duplicate readpairs optionally  preassemble contigs   extend use sequence read  could   map  feature  especially design  incorporate  pairedread datasets    use   preassembly  next step   sspace protocol  scaffold   modify  extend   ssake shortread assembler warren     brief putative contig pair prescaffolding stage  compute base   position   pair read  different contigs contig pair   consider   calculate distance   satisfy  userdefined distance range  pair  contigs scaffold  form  iteratively combine contigs   minimum number  read pair  support  connection default    start   largest contig   introduce  novel step  deal  contigs   alternative connections see also supplementary figure   connections  also find   alternatives   algorithm seek  place  alternatives   correct order use  estimate insertion otherwise  ratio  calculate   two best alternatives   ratio    threshold default     connection   best score alternative  establish extension  scaffold  abort  either  contig   link   contigs   ratio  alternatives  exceed  scaffold process  repeat   contigs  incorporate  linear scaffold  program   design  allow  multiple library input set   scaffold   hierarchical manner start  small insert libraries sspace provide  follow output file  final scaffold fasta format   complementary file list  contigs  build   scaffold also  summary file contain useful statistics    total number  scaffold  average size  n50 statistics  provide optionally  connections within  scaffold   graphically view",-0.1857582448638376,0.19330271312491412,0.0878569526569247,0.1333970893840345,0.026557501116905646,-0.004289277180066427,-0.08447765057360936,0.10872182297624916,-0.007033470722104786,0.11261132184881716,0.04509881848688396,-0.017418498270039967,0.11405692735126526,-0.07557823501726596,0.1064355220839034,0.025988144373868486,0.14282023317231876,0.1958038728010606,-0.01616907392241755,0.04873430246824667,-0.014846585661378071,-0.2366742762390813,0.07936496957761661,0.01803081492169255,-0.0056141099855067,-0.20507797439199366,0.056618265369591324,-0.1057529212969604,-0.049253100193879115,-0.03783532025655573,-0.013959132010606513,0.26875100630515314,-0.1718343886846708,-0.08326797226643172,0.20880515605195965,0.09141387209548787,0.011820076453644152,-0.04313644646593938,-0.1046807145871522,-0.11526788150352996,-0.03935841745618037,-0.10624084594605,-0.0702393153170321,-0.09905669087607223,-0.1048841322101337,0.002388786635030125,0.06810760776259762,-0.15142264919971132,-0.1671207190614087,-0.2871001834036009,0.10421268053459384,0.04067125224599109,0.108674081428158,0.5374445402521199,0.025475011658026063,-1.143060846638992,-0.002295984965758951,-0.18544037512876488,0.9284417256619191,0.20139715921896376,-0.16543745886698716,0.2850176139884644,-0.05242890879507887,0.0807938085004719,0.5521793180812244,0.021216948200101074,-0.008504335713272883,0.08467872758490681,0.11927991822535584,-0.18756041686682987,-0.04916742176961418,-0.0072108333568055155,0.06635109780324717,-0.14907052225563516,0.15092042064830913,-0.014021139122324729,-0.14089925226881722,-0.10956167803694478,-0.34296961520182884,-0.07838472025863574,0.1695354179738095,-0.046110166834126685,-0.32658700399116564,-0.055656978612868266,-0.7829192306257398,0.10478227352575492,0.2605328834267881,-0.09400332296539446,-0.07634515128018518,0.006567173057346274,-0.14809112794553245,0.11410681883236234,-0.08654689677385219,-0.07530368761143695,-0.12795594511395794,-0.11480360234627833,-0.01979371127415985,-0.2678025999183913,0.32273000566845256,0.07193927876740079,Assembly,5
138,138,"sspacelongread scaffold bacterial draft genomes use long read sequence information
 recent introduction   pacific biosciences  single molecule sequence technology  open new doors  scaffold genome assemblies   costeffective manner  long read sequence information  promise  enhance  quality  incomplete  inaccurate draft assemblies construct  next generation sequence ngs data   propose  novel hybrid assembly methodology  aim  scaffold preassemble contigs   iterative manner use pacbio  long read information   backbone   test set comprise six bacterial draft genomes assemble use either  single illumina miseq  roche  library  show  even   coverage  uncorrected pacbio  long read  sufficient  drastically reduce  number  contigs comparisons   aha scaffolder indicate  strategy  better capable  produce nearly complete bacterial genomes  current work describe  sspacelongread software   design  upgrade incomplete draft genomes use single molecule sequence  conclude   recent advance   pacbio sequence technology  chemistry  combination   limit computational resources require  run  program allow  scaffold genomes   fast  reliable manner
 sspacelongread methodology   summarize    step   describe   summarize  figure   pseudocode  summarize  additional file  figure  figure  figure2 overview   sspacelongread scaffold algorithm   input consist   set  preassemble contigs  scaffold  fasta format   set  pacbio clr read  fasta  fastq format   pacbio clr read  align   contigs use blasr    best alignment match  keep  red  repeat element  indicate  contig pair  multicontig linkage information  store   information also repeat elements  detect  base   pair  linkage information contigs  order orient  connect  scaffold   postprocessing step perform  final linearization  circularization full size image software input  user need  create  draft assembly use   novo assembly method  choice  velvet  soapdenovo  ray  clcbio clc bio aarhus denmark  newbler roche optionally  user may also provide scaffold sequence generate  dedicate software  sspace   sopra   result contigs  scaffold  fasta format    provide  input  sspacelongread software together   set  long read  fastq  fasta format  pacbio clr read note    study  observe  sspacelongread obtain  best result   draft assembly  construct  clcbio  newbler   tend  better split contigs  repeat boundaries see  result  discussion section  additional explanations alignment  long read   preassemble contigs  scaffold  long read  align   preassemble contigs  blasr  result   local alignment  correspond similarity score  gapestimation purpose  local alignments  extend  generate  full contig match  order  remove falsepositive alignments contigs  display  partial overlap   contig   obtain  higher alignment score  iteratively remove   dataset figure  step   minimum overlap   require  remove  contig   alignment  define  parameter  default value   computation  contig linkage   alignment order  remain contigs  sort base   alignment position   long read subsequently  contig distance  orientation  compute  contigpairing  multicontig linkage  store   hash  prefer pair  retain  remove contiglinks   also find within  multicontig path  another contiglink  example    two paths               linkage      remove  ambiguous paths  mainly explain   fact   blasr alignment tool generally   resolve align lowquality alignment regions  pacbio read  multiple paths remain  ratio  calculate   two best alternatives ambiguous pair  solve use  multicontig linkage information  unsolved pair  flag  repeat elements scaffold contigs  scaffold  contigs   connect  linear stretch  repeat elements  place base   multicontig linkage information repeat elements   edge   linear stretch  remove   postprocessing step  nonrepeated edge   preliminary scaffold  reuse  find connections   preliminary scaffold finally  gapsize   contig  calculate   value  negative   overlap  find contigs  merge   value  positive  gap  insert  contigs  gap  represent  one   undefined  nucleotides depend   gapsize software output  final linear assembly  represent   easily interpretable fasta file  addition  agp accession golden path file  generate  describe  contig order within  scaffold  latter file   readily use  ncbi genome submissions also  summary file contain statistics   assembly process  final assembly structure  provide  text format datasets  total six bacterial datasets  use  test  performance   software  comprise illumina miseq roche  pacbio  read  escherichia coli k12 mg1655 escherichia coli o157h7 f8092b bibersteina trehalosi usdaarsusmarc mannheimia haemolytica usdaarsusmarc francisella tularensis   salmonella enterica newport sn31241 datasets  download     describe  koren    dataset statistics  display  table   assess  assembly correctness  use close reference genomes deposit   ncbi database  coli k12 mg1655  nc_000913  coli o157h7  nc_002127 nc_002128 nc_002695  tularensis  nc_008369  enterica  nc_011079 nc_011080 nc_009140   trehalosi   haemolytica  reference genome  currently available assembly procedure draft assemblies  illumina miseq data  construct use ray version     clcbio  novo assembler version  clc bio aarhus denmark use   program  kmer set   draft assemblies  roche data  construct use newbler version  roche  describe  koren    scaffold  perform use aha    part   smrt analysis package version   sspacelongread   latter software  require  minimal estimate overlap    option    contigs  order  avoid false positive alignments  ray  minimal estimate overlap  set    since ray tend  include repeat elements  contigs edge   result  larger overlap   contigs  observe",-0.17731510180765048,0.20185781497723207,0.12981489927328838,0.1275625324381802,0.03955561095024817,-0.03659240671218588,-0.08237846637001403,0.06832313498419422,-0.016304444093257188,0.10518318936300393,0.04625767573929177,-0.05117332840723415,0.1464584511049235,-0.0688356228147705,0.12240069190971553,0.005024613674300221,0.113481241587836,0.18853668330890985,-0.02131391507689841,0.042512830889497234,0.0034344713411365558,-0.1915264045141745,0.06434808177873493,0.01214494981803,-0.01998547858773516,-0.1848263342048113,0.07011628114690001,-0.1276165681704879,-0.05552531337875945,-0.06658715928976353,-0.041421649387249584,0.2734399954172281,-0.1838688059998318,-0.08874012980216113,0.1827870280737093,0.06000986978841516,0.03980197752754276,-0.02578561589265099,-0.12025506564648822,-0.12718460029134385,-0.06119453489798336,-0.1408818793158459,-0.0960035434952722,-0.10336819950240447,-0.12623350323231605,-0.021671231762291143,0.1077707726508379,-0.1397942753917036,-0.18560335607088813,-0.2914074031614627,0.1664666909455823,0.023308054459496186,0.052524946224517546,0.5322846220261775,0.00220220348224617,-1.1142918291458717,0.0403058033149976,-0.1732490604533814,0.9071570912877528,0.16967923825176862,-0.17702017198361528,0.2539162541238161,-0.0555772149670296,0.05694525261337941,0.5298335008624081,0.015384131893515587,0.003539504056366591,0.05883758049243345,0.15549142307243669,-0.18279181119215746,-0.04331484887883282,0.01541694404351382,0.08646777556671832,-0.12508367995588252,0.14384085253812373,-0.01484784208918707,-0.09221370573227222,-0.0936390913815166,-0.34797371809872296,-0.09539478130119207,0.16573623289927267,-0.027436988066272955,-0.3233287220133039,-0.04323455412997506,-0.7635895614637636,0.09315899257834714,0.22487448409038524,-0.11714907217770815,-0.10349472478157484,0.006594066682177631,-0.13591579616463814,0.09781605300350256,-0.12532996906863095,-0.06535205016342494,-0.0949611703861648,-0.09873397174936074,-0.051621758972939386,-0.2845048780461701,0.31157165995440805,0.10625047944808523,Assembly,5
139,139,"cctsa  coveragecentric thread sequence assembler
 novo sequence  process  find  whole genome   regions   species without reference require much higher computational power compare  map sequence  reference  advent  continuous evolution  nextgeneration sequence technologies  stress  demand  highthroughput process  myriads  short dna fragment recently announce sequence assemblers   velvet soapdenovo  aby  exploit parallelism  meet  computational demand since contemporary computer systems primarily rely  scale  number  compute core  improve performance however      tailor  exploit  full potential   systems lead  suboptimal performance   paper  present cctsa  parallel sequence assembler  utilize coverage  prune kmers find prefer edge  resolve conflict  prefer edge  kmers  minimize computation dependencies  thread  effectively parallelize kmer process  also judiciously allocate  reuse memory space  order  lower memory usage   improve sequence speed  result  cctsa  compel    run several time faster   assemblers  provide comparable quality value   n50
execution flow  cctsa cctsa read input file     compose   short fragment read   original dna sequence  generate  output file  contain  result  sequence assembly sequence machine  occasionally make mistake  read basepairs   call basecalling errors   kmers  map   multiple regions   original sequence   call repeat   result    always possible   sequence assembler  perfectly reconstruct  original sequence   output file  cctsa typically consist  multiple dna sequence call contigs  none   contigs might  map   regions   original sequence currently cctsa  read fasta  fastq file  write  generate contigs   fasta file figure  illustrate  overview   execution flow  cctsa  consist  multiple phase first  read  series  short read  extract kmers   read   kmer consist   nucleotides  read   fewer   nucleotides  discard cctsa also discard kmers   ambiguous  unidentified nucleotides  check  dictionary call  kmer coverage table    kmer   key   coverage   value  see   extract kmer exist   table    coverage value  incremented  one    kmer  add   table   coverage value  note  kmer coverage  different   sequence coverage   original dna sequence  former   number   kmer instance   sequence read   latter stand   many time  nucleotide   original sequence appear   read    read  process cctsa optionally prune kmers   low  high coverage value assume   original sequence consist   nucleotides  kmer coverage table would   entries   sequence   repeat   read   basecalling errors   kmer generate   sequence read contain one   basecalling errors  kmer typically   low coverage    unlikely   original dna sequence include  kmer   basecalling error rate   read  high  kmer coverage table  much    entries   coverage table   entries  memory space  require   take  time  access  update  table assume   coverage   original dna sequence  sufficiently high   low coverage kmers  due  basecalling errors    high coverage kmers    original sequence   result prune  low coverage kmers   useful  remove  basecalling errors save memory usage  improve sequence speed however   coverage   original sequence   uniform    nucleotides    low coverage kmers could    original sequence hence prune incorrectly  lower  average length   generate contigs   would  possible  restore   phase  assembly    scaffold phase     discuss later   section kmers   high coverage  typically  repeat    optionally mark   repeat  exclude  hereafter remain kmers become kmer nod among   nod  share  nucleotides  link together  edge build   bruijn graph     type adenine thymine guanine  cytosine  nucleotides  dna  kmer node     neighbor    leave side  share  first  nucleotides     right side  share  last  ones  node   multiple neighbor  either side  call  junction node  link  kmers   connect without  junction  merge form  contig node    side   node  weight   edge  compute   neighbor   highest weight  call  prefer neighbor  weight   edge represent  likelihood   neighbor   highly correlate   coverage   neighbor nod     weight   edge   side  compute  add  coverage   neighbor kmer connect   edge   maximum coverage value among  kmers connect   neighbor kmer    side figure   give  priority   neighbor node  higher kmer coverage    time prefer  longer path  enable cctsa   miss  strong   likely path   connect   low coverage kmer cctsa  design  easily implement  ways  calculate weight  find prefer neighbor  check  junction node jn1 whether  prefer neighbor jn2 also point jn1 back   prefer neighbor    call     conflict  jn1  jn2   resolve  follow   coverage  jn1  higher  enforce jn2  point jn1   prefer neighbor   coverage  jn2  higher  disconnect  edge  jn1  jn2 find  prefer neighbor among  remain edge  repeat   step    still  conflict  conflict resolution algorithm figure   simpler     assemblers   tip removal  tour bus algorithms   velvet aby  soapdenovo    future work  refine  conflict resolution algorithm   conflict  resolve finally contigs  generate  traverse  nod connect  prefer neighbor unlike  assemblers cctsa   exploit pairedend read  orient  align multiple contigs   single supercontig  scaffold cctsa  leverage  separate tool   sspace    part   assemblers  perform  scaffold  finish phase optimizations continuous improvement  semiconductor process technology enable  single chip  integrate billions  transistors   rack server   dozens  compute core  terabytes  share memory   assume   entire work set  cctsa fit   share memory space  simplify program  provide better performance   systems  distribute kmer entries across  cluster  computers connect   network   infiniband  ethernet   compute core  access  kmer entry  low latency tens  nanoseconds memory load  store   share memory system   kmer information must  encapsulate  request  reply packets  transfer   high latency   microseconds   network   size   kmer entry  rather small  overhead  pack  unpack  entry  relatively high  reduce program speed  apply several optimization techniques  cctsa  reduce execution time  parallelize  phase   construct  kmer coverage table populate  link kmer nod  merge consecutive kmers without junction  take    single thread execution  cctsa  average   illumina bp80x datasets   organism explain   result  discussion section   phase  start  first divide workload  many small chunk     size  spawn multiple worker thread  worker repeat  process  receive  chunk process   ask  another chunk    process yet    chunk  process  time   thread  access data heavily depend   address  internal status   complicate memory system within  processor  interaction  concurrent access   thread time  process  chunk     either    result statically divide  workload   worker thread suffer   load balance problem  dynamically assign chunk  idle thread lead  better performance    worker thread  use  performance advantage   dynamic load balance method become even higher   kmer coverage construction phase  workload   sequence  short read  compose  kmer coverage table  thousands  hash map  use two different hash function  identify  hash map   entry   hash map  hash map  protect   mutex  prevent  simultaneous access   hash map  multiple worker thread  destroy  data structure    much  hash map   worker thread  hashmap update   simple operation  worker thread rarely access   hash map    time   result  mutex operations   incur significant performance overheads still   possible   alleviate  overheads   mutex  design  protect  block  memory    single word   heavier   atomic cpu operation  read modify  write  word atomically   length   kmer  shorter   base pair    represent   single bite word jellyfish  exploit   replace  mutex operations  atomic memory operations   compareandswaps  build concurrent hash map  update kmer coverage value  achieve  higher kmer coverage construction performance  short kmers   kmer node populate link  merge phase  hash map become  chunk mutexes   need   phase   data  update concurrently   multiple thread  save memory usage cctsa compare  kmer   reverse complement   store  value   earlier   lexicographical order  utilize bite field extensively   different data structure   kmer nod   without junctions  include  custom memory allocator   provide multiple allocation class  class  implement   chain  memory block   custom allocator  use  allocate  object  object  categorize   class  store   last block   class   block    enough free space  default memory allocator    use  allocate  block   class  cannot deallocate  single object   quickly deallocate   object   certain class simply  free  block   class cctsa utilize  custom allocator  prune low coverage kmers   separate table  low coverage  high coverage kmers assign  low coverage kmer object   kmer coverage table      class  deallocating  class  remain kmer coverage table  fewer entries   table without prune   fast access time  prune also help reduce execution time   even prune low coverage kmers   middle  build  kmer coverage table     end  provide  interest tradeoff   memory footprint  assembly quality   evaluate   result  discussion section availability  future directions cctsa  write      run  unixlike systems source code  freely available   cctsa   extend  multiple directions first alternative data structure  algorithms   explore  search  better sequence speed  lower memory usage second cctsa   target current generalpurpose compute  graphics process units gpgpus      provide enough memory capacity however  would  interest  see  cctsa  take advantage   high computation power  memory bandwidth  future gpgpus  many integrate core systems address  memory capacity issue third cctsa   integrate   scaffold tool  extend  exploit pairedend read   orient  align  contigs",-0.2378422634376386,0.22445683174547348,0.10523888772943403,0.10178610982283068,0.0397878052628062,-0.034423317704912984,-0.18744104698068534,0.05265031650083615,0.021825433408008733,0.12968919588932787,0.04591308051084629,0.005754240867973468,0.15964763733706328,-0.07630102235605622,0.11136379598562872,-0.0963212550360283,0.059623730326167926,0.18960927427550486,-0.07633803521341305,0.04590485987080498,0.026847759919486472,-0.21250993962103973,0.08386999281066959,0.009091106670874434,0.05055530586271883,-0.18918707041566704,-0.004790558915780898,-0.1555999139123687,0.007794731445072449,-0.029412693439979813,-0.010574123460083363,0.32116936732507984,-0.19479717067231628,-0.10487658386299743,0.19630494302941529,0.11092109448936734,0.033066987224135924,-0.058323917136030766,-0.058585829868637126,-0.11735157235754355,-0.07555854089958412,-0.1988918053897849,-0.06304379975893781,-0.1309153465330339,-0.13923547538168346,0.032236607579341395,0.1653587654330788,-0.14680640947802362,-0.14689468469440065,-0.3906914550028078,0.11654792519107253,0.02381489088368596,0.05720871513758205,0.6632082267980178,0.05535365038271792,-1.2327818400648949,0.03044439026631805,-0.21573196646187165,1.122617659442877,0.21414071612921745,-0.159061639691961,0.3367906333456222,-0.08465488496805756,0.07057181307010063,0.5564877941709647,0.03284198075425298,0.09300960116259367,0.042463420703453984,0.1937847407705696,-0.19782698776781127,-0.025608537924706284,-0.07353783300743373,0.07847686987946044,-0.1662474361577194,0.2153277002795716,-0.01999241847041532,-0.12933561206417113,-0.09985376248985016,-0.3389786555705441,-0.016135202617672137,0.28277617582239684,-0.039609388947337516,-0.4305318992898737,-0.011725516409510606,-0.9312312684610756,0.09348404782280613,0.2401997972826411,-0.1109042729931978,-0.1376893361888325,-0.03674801590958797,-0.1751760941599224,0.1186643061884347,-0.12127686744771063,-0.1337565162279955,-0.17216969778274485,-0.13314388027453905,0.0005665269150292063,-0.2693276233245975,0.3708069062918489,0.08628812242740214,Assembly,5
140,140,"readjoiner  fast  memory efficient string graphbased sequence assembler
ongoing improvements  throughput   nextgeneration sequence technologies challenge  current generation   novo sequence assemblers  recent sequence assemblers  base   construction    bruijn graph  alternative framework  grow interest   assembly string graph  necessitate  division   read  kmers  require fast algorithms   computation  suffixprefix match among  pair  read   present efficient methods   construction   string graph   set  sequence read  approach employ suffix sort  scan methods  compute suffixprefix match transitive edge  recognize  eliminate early   process   graph  efficiently construct include irreducible edge   suffixprefix match determination  string graph construction algorithms   implement   software package readjoiner comparison  exist string graphbased assemblers show  readjoiner  faster   space efficient
basic definitions let    string  length   symbols   alphabet    denote  ith symbol    …  substring    position     ≤   ≤  …   prefix   end  position   …   suffix   start  position   substring    proper    different    substring    internal    neither  prefix   suffix    read    string   alphabet {   }   assume   sort   alphabetical order           leave triangle  denote  lexicographic order   substrings   read induce   alphabetical order   let    length    reverse complement   denote       sequence      …          indicate  watsoncrick complement  base  compute suffix  prefixfree read set  first step   approach  assemble  collection  read   eliminate read   prefix  suffix   read   describe  method  recognize  read consider  order set       …      read possibly  variable length    read may occur       indeed  multiset  assume      ≤  ≤   ith read     virtually pad   sentinel symbol    right end    alphabetical order   extend                     define  binary relation precede      precede           precede reflect  order   read   input   prefixfree    read       ′   ∖ {  }      prefix  ′   suffixfree          read ′   ∖ {  }      suffix  ′  obtain  prefix  suffixfree set  read  lexicographically sort  read use  modify radixsort  string  describe     algorithm  string   sort  first insert  bucket accord   first character  bucket   sort recursively accord   next character   read   bucket  bucket always consist  read    common prefix   bucket  smaller   constant  remain suffix   read   bucket  sort  insertion sort    sort process  length   longest common prefix lcp  two lexicographically consecutive read  calculate   byproduct  two lexicographically consecutive read   ′   lcp  length ell     conclude     prefix  ′  ell  ′     proper prefix  ′   mark   ell  ′    ′  identical   mark  read   larger accord   binary relation precede   handle reverse complement   mark read   suffix   read one simply apply  method   multiset        …          …            ¯¯¯       ≤  ≤     include  reverse complement   read  method also mark read   suffix   read   due   observation   read    suffix  read ′      prefix    ′    final step   algorithm one eliminate  read      mark  remain unmarked read    process   algorithm  compute  suffix  prefixfree set  read run      max   time  λmax   maximum length   read     machine word size   consider λmax    constant    imply   read      length  algorithm run   time compute suffixprefix match suppose     suffix  prefixfree set   read let ellmin     minimum length parameter  set        suffixprefix match spms  short   smallest set  triple leave angle bracketr ′ ellright angle bracket      ' ∈   string    exist      ′     ell ≥ ellmin ell   length   suffixprefix match leave angle bracketr ′ ellright angle bracket   suffixprefix match problem   find  suffixprefix match   read  length smaller  ellmin cannot  definition contribute  spm   ignore   thus  assume    contain read  length  least ellmin  method  solve  suffixprefix match problem present  consist  two main algorithms  first algorithm identify  lexicographically sort  spmrelevant suffix   subset   suffix   read   one  compute  suffixprefix match  second algorithm enumerate  match give  sort list   spmrelevant suffix consider  suffixprefix match leave angle bracketr ′ ellright angle bracket   definition  suffix  length ell   exactly match  prefix  length ell  ′ obviously  suffix   involve   match start   position   ≤  ≤      min      imply   must   least  length ellmin    suffix cannot start   first position    otherwise  would   prefix    read contradict  assumption    prefixfree  enumerate  set   suffixprefix match  length  least ellmin  preprocess  read  determine  proper suffix   read  may  involve   suffixprefix match  precisely   read   determine  match candidates   proper suffix       length     least ellmin     read ′     ′   common prefix  length  least      userdefined parameter satisfy  ≤    {  min    }    two reason  impose  constraint   first  want  represent  string  length    alphabet  size   one machine word thus  ≤    second  suffix   read    take  prefix  length   minimum length ellmin thus  choose  ≤ ellmin  set   match candidates   read form  set   ellmin kspmrelevant suffix  simplicity sake  use  notion spmrelevant suffix  ellmin    clear   context   spms   construct   spmrelevant suffix   spmrelevant suffix lead   spm  efficient algorithm  identify  sort  spmrelevant suffix  first two phase   algorithm follow  strategy   borrow   count sort algorithm  like   algorithm   count phase   insertion phase however   problem  elements  spmrelevant suffix   sort   determine   algorithm moreover  number  key  initial kmers whose occurrences  count    order   number  elements   sort therefore   space efficient solution    trivial  access  counter give  key   develop  time  space efficient method  access  counter   key exploit  fact  count  insert  spmrelevant suffix       immediately instead  items   countedinserted  first buffer   sort  linear scan  perform  count  insert step  contrast  count sort  algorithm use  extra sort step  obtain  final order  elements presorted   insertion phase   assumption   maximum read length   constant    imply   read      length  algorithm run   time  space     total length   read   best   knowledge  method employ  similar strategy   yet  develop   suffixprefix match problem  first give  description   algorithm use string notation   separate section  explain   efficiently implement  algorithm   follow   consider  read   forward direction however    difficult  extend  method  also incorporate  reverse complement   read   comment   issue   end   methods section  initial kmer   sequence    prefix    length   determine  match candidates efficiently  first enumerate  initial kmers   read  store    table  size        time  notion table size always refer   number  entries   table  next step lexicographically sort  kmers   table  ascend order  string sort problem   transform   integer sort problem see implementation    solve  radixsort    time   extra work space   next step  linear scan   sort kmers remove duplicate   table  count  many time  kmer occur   table  scan require  time let  ≤    number  different kmers    store   table   size   count   elements   require another table   size   addition   duplicate removal  count  linear scan   sort kmers construct two set     size   depend  two user define parameters ′ ≤    ″≤     set   initial ′mers   read    set   kmers      ' '   …      ∈    assume  elements   add      constant time   membership   set   decide  constant time thus  linear scan construct      time     subset   set  size   ′     store    ′ bits  require   ' ' bits      initial kmers   read  consider result   sort table    nonredundant key  initial kmers  read  table   size   count kmers  two set     construction  count     least    sum   count    next task   enumerate   read   suffix     position   ≤  ≤      min        ellmin  suffix    suffix    construction   length ≥ ellmin one extract two string   …′         ' '   …        occur        prefix   read    thus     match candidate    discard     occur      ≠      ' '   …     read  ∈   thus     match candidate    discard thus    serve  filter  efficiently detect suffix    discard  read   suffix   correspond string      enumerate    ellmin time check membership      require constant time therefore  read   process    ellmin time thus  enumeration  check require   ∑  ∈  ∣ ∣  ∣ ∣    min  time altogether  next task   process  suffix say    pass  pfilter   qfilter     …′ set membership          ' '   …   ∈  hold one    check    … occur    verify     match candidate   latter  true  appropriate counter need   incremented hence    count phase   algorithm  simplest way  check  occurrence       perform  binary search take    key however  would require olog2d time   kmer pass  filter    slow use  hash table turn     slow  well  would require  much extra space     want  afford  propose  efficient method  work  follow store  kmer  pass     qfilter   buffer   fix size       constant       full   kmers   add   sort  elements    ascend lexicographic order  perform  binary search       first element   say     sort    smallest element  binary search     find  smallest element   greater   equal   use olog2  time    element occur   say  index   simultaneously scan  begin   first index   begin  index    element     equal   element   say  index    increment  counter      index  simultaneous linear scan     part   take    time  find  kmers   occur     scan   associate increments    buffer  empty   next round suppose     total *kmers   pass  thus   ⌈  ∗  ⌉ round fill  buffer  round  associate   sort step  binary search   linear scan sort require  time use radixsort  give  run time     ∗                      ∗            ∗             ∗           ∗     ∗ ≤    ∑  ∈  ∣ ∣  ∣ ∣   run time  linear   total length   read   read   process   initial kmer    read  follow hold     ith initial kmer       number  spmrelevant suffix      prefix  prepare   insertion phase compute  partial sum     array   size                             ≤  ≤             number   spmrelevant suffix one create  table   size     hold pair  read number  read offset    count phase enumerate  suffix  read  length  least ellmin pass     qfilter suppose      suffix  read number    read offset  let    initial kmer     store      buffer ′  fix size     choose  buffer size   elements  ′ require twice  much space   elements      count phase sort  buffer  lexicographic order   kmers  store   process  buffer elements use  kmer say    key  determine   match  element   say  index   insert    index       decrement    * elements pass  buffer    process  hold  spmrelevant suffix represent  read number  read offset  lexicographic order   initial kmers let    ith kmer     spmrelevant suffix  common prefix   store    index            thus   uniquely  divide  bucket  spmrelevant suffix    initial kmer   bucket   sort independently    bucket moreover  spmrelevant suffix  occur   ith bucket   initial kmer different    thus cannot   common prefix  length ≥ ellmin   suffix   ith bucket   consequence  suffixprefix match  derivable  pair  spmrelevant suffix occur    bucket thus  suffixprefix match problem   divide   subproblems  consist   computation  suffixprefix match   bucket  spmrelevant suffix  problem  consider later  sort  ith bucket one extract  remain suffix relevant  sort  bucket  store    table  strategy minimize  number  slow random access   read consider  ith bucket  let    one   suffix   bucket refer   suffix  read   read offset   extract  suffix   start  position      maximum read length  consider   constant  total size   remain suffix   store                  remain suffix   sort use radixsort                time  additional linear time scan   sort suffix   bucket deliver  table   size                    length   longest common prefix   suffix             sπi       ≤  ≤               sort  remain suffix  compute  lcptable  thus require oβmax space    ∑                          time  βmax   maximum size   bucket     total number  spmrelevant suffix  bucket  sort spmrelevant suffix   correspond table   process  algorithm  describe   follow implementation section  algorithm  describe  additional file  section      algorithm run         time    ′  ′′  βmax     space   choose ′′ ≤ ′ set membership olog2      βmax   smaller    space requirement   thus  algorithm  identify  sort  ellmin kspmrelevant suffix  optimal implementation    describe   efficiently implement  algorithm describe   essential technique use   algorithm  integer cod  kmers   widely use  sequence process    three different mersizes  ′  ″  dependencies   correspond integer cod  shortly describe  technique    problem  kmer always refer   sequence      prefix therefore  introduce integer cod  string  length ≥    string   length  least  define  integer code        ∑              map  →   →   →   →  uniquely assign number       base   alphabetical order   base note    first  symbols   determine ϕks    integer   range …     string   ′  length  least   leave triangle  ′ imply ϕks ≤ ϕks′  leave triangle  denote  lexicographic order  string  ≤ denote  order  integers besides   use  encode ′      ' '   ′  ″≤  ′ encode  prefix    length ′   define  analogy   replace   ′     ' '    encode  suffix      ' '   …    …  length ″      ' '     ∑  ' '      ' '          ' '      ′     ' '      compute  ϕks accord   follow equations   ′              '     ' '          mod   ′′   implement kmers   integer cod  integer code   compute  constant time  extract  appropriate sequence  consecutive bite pair   2bit per base encode   read set   implementation  use  representation   appropriate access function   gtencseq software library    ≤     store  integer code   integer   machine word size  sort  integer cod   initial kmers use quicksort adapt  code    implementation work without recursion  use  extra stack  size olog2   sort  integers  small additional space requirement   main reason  choose quicksort instead  radixsort   usually   twice  fast  require  extra work space     want  afford  set     implement  bite vectors     ′  ′′ bits respectively bite vpq  set       ′    ∈   bite vqq  set          ′′      read  ∈    obtain  bite index one compute ′     ' '     ϕks use equations    equation    implement   bitwise right shift    ′ bits equation    implement   bitwise  operation   integer ′′   thus give  integer code    ′  ″   compute  constant time therefore  set      construct   time   access take constant time  determine  kmer cod   count phase    insertion phase  sweep  window  width    sequence read  compute  integer code   sequence   current window  constant time  implement  count   byte array  size   store count larger     additional hash table additional file  section  give  detail  partial sum  table   bound    number  spmrelevant suffix  large read set    larger     however   partial sum  strictly increase one  implement     bite integer table   size      psi   mod      ≤  ≤    additional integer table  size     {   ⌈      ⌉   } mark  boundaries  carry bits detail  give  additional file  section    insertion phase  need  representation   read set  bits table  2kd bits set    ′  ′′ bits respectively table     bits  table   size    hold pair  read number  read offset  entry    store compactly    ⌈      ⌉  ⌈       max  min  ⌉ bits  would give  integer array  size ⌈    ⌉   would store  completely       employ  partition strategy explain next although  data structure represent table        different size  access follow   scheme suppose     smallest index     ≤      roughly half   suffix   insert    place  bucket  lower order  index ≤     half  place  bucket  higher order  index    bucket  lower order  associate   kmers     index  hence   one need table       index  let    suffix  length ≤ ellmin   ϕks ≤   apply  pfilter   one check   index          ′ ≤         ′      first half  vector   strategy divide table          part  roughly   size   generalize     part  part  define   lower   upper integer code   correspond lower  upper boundaries refer  section   four mention table partition  mean   allocate  maximum space  hold  bucket belong   single part  four table    split   part require    ′′   2kd  ″        bits hence   insertion phase  method require      ''           ''     bits    ′′ bits    representation   read   set   cannot  split   dominate   term    ′′   much larger    ′′    space gain   partition strategy  obvious   space require   insertion phase   number  part   precalculated one  choose  memory limit  calculate  minimal number  part    limit   exceed  particular choose  space peak   count phase   memory limit   insertion phase allow  balance  space requirement   phase  detail   partition technique  give  additional file  section   obvious disadvantage   partition strategy  say  part   requirement   scan   read set however  sequential scan   read set   fast  practice   make    small part   run time   insertion phase  expect size   bucket   sort   insertion phase  smaller   average read length  maximum bucket size determine  space requirement   phase     order  magnitude smaller      store   base  one integer   bits  remain suffix  form  sort key   store   max   max       integers  βmax   maximum size   bucket  λmax   maximum length   read  additional constant     length   remain suffix   read number   read offset  sort key  thus sequence  integers  different length     compare    longest prefix   string  encode  use quicksort     base  compare use  single integer comparison   side effect   comparison   suffix  obtain  longest common prefix  two compare suffix  constant extra time  store    table    size   bucket  suffix   bucket   table   pass  algorithm  describe next   algorithm  additional file  section   efficient algorithm  compute suffixprefix match  bucket  sort spmrelevant suffix  input   algorithm describe next   bucket  sort spmrelevant suffix   correspond table   compute   algorithm   previous subsection consider  ith bucket    let   sπi     jth suffix   bucket     ≤  ≤              size   bucket  construction    leave triangle    ≥      length   longest common prefix        ≤  ≤    note   bucketwise computation   deliver  lcpvalues  pair  spmrelevant suffix   boundary   bucket         length   longest common prefix  sπi    sπi   compute  sπi     last suffix      bucket  sπi   first suffix   ith bucket however   suffix belong  two different bucket  longest common prefix  smaller    thus smaller  ellmin  therefore   interest   suffixprefix match problem  suffix occur   bucket   process  nest intervals call lcpintervals  notion introduce  enhance suffix array    generalize  notion  table     follow  interval   ≤    ≤      lcpinterval  lcpvalue ell   follow hold •           •   ≥         ≤  ≤    •       least one      ≤  ≤    •                 also use  notation ell     lcpinterval   lcpvalue ell  ell     lcpinterval     …ell   longest common prefix   suffix   …     call  winterval  lcpinterval ell′  ′′  say   embed   lcpinterval ell       proper subinterval  ell     ≤ ′  ′ ≤   ell′  ell  lcpinterval ell     say   enclose ′′   enclose ′′     interval embed    also enclose ′′  ′′  call  child interval       parent interval  ′′  distinguish lcpintervals  singleton intervals ′   ′  ≤ ′ ≤    ′ represent ′  parent interval  ′   smallest lcpinterval    ≤ ′ ≤   parentchild relationship  lcpintervals   lcpintervals  singleton intervals constitute  virtual tree   call  lcpinterval tree      root   tree   lcpinterval       implicit edge  lcpintervals  call branchedges  implicit edge  singletonintervals  call leafedges additional file  section  give  comprehensive example illustrate  notions abouelhoda    algorithm  present  linear time algorithm  compute  implicit branchedges   lcpinterval tree  bottomup order  apply   bucket  sort suffix  algorithm perform  linear scan  table      eth iteration  ≤  ≤     access  value      nontrivially extend  algorithm  additionally deliver leaf edge  pseudocode   additions   line mark  new  give  algorithm  figure ​figure1  use  follow notation  operations  external file  hold  picture illustration etc object name  jpg open   separate window figure  algorithm  bottomup traversal algorithm  array  spmrelevant suffix    extension   algorithm    additional line mark  new •  stack store triple ell   represent  lcpinterval ell    access  elements    triple say   use  notation svlcp   lcpvalue ell svlb   leave boundary   svrb   right boundary  • stackpushe push  element  onto  stack • stackpop pop  element   stack  return  • stacktop return  reference   topmost element   stack • perpendicular stand   undefined value • process_leafedgefirstedge itv   process  edge   lcpinterval itv   singleton interval represent  suffix rpq… firstedge  true      edge   first process edge outgo  itv • process_branchedgefirstedge itv itv process  edge   lcpinterval itv   lcpinterval itv  value itvrb  define  firstedge  true      edge   first edge outgo  itv • process_lcpintervalitv process  lcpinterval itv  value itvrb  define depend   application  use different function process_leafedge process_branchedge  process_lcpinterval additional file  section  explain  algorithm  also deliver  leaf edge   lcpinterval tree   correct bottomup order consider  path   lcpinterval tree   root   singleton interval ′ represent ′  rpq… let ell     lcpinterval   path  consider  edge   path outgo  ell     edge go   lcpinterval  say lcpvalue ell′   edge  implicitly label   nonempty sequence       …    '     suppose  edge go   singleton interval   edge  implicitly label   nonempty sequence rpq  ell…      ell    rpq  ell…     empty string  imply   edge   singleton interval  label   sentinel    edge   terminal edge     read offset     call ′  wholeread interval     path   lcpinterval tree   root  ′  wholeread path   consider  suffixprefix match leave angle bracket   ell right angle bracket     suffix     length ell   prefix   length  recall     common prefix   suffix   ith bucket due   implicit pad  read   end  symbol follow    suffix      definition   also prefix     symbol   follow  occurrence    different   thus    winterval    lcpinterval tree         path   rootinterval   wholeread leaf interval   moreover    terminal edge   outgo   vice versa  lcpinterval  lcpvalue ell   path   wholeread leaf interval      terminal edge   identify  suffixprefix match leave angle bracket   ell right angle bracket   observation  suffixprefix match  exploit  algorithm  figure ​figure2  perform  bottomup traversal   lcpinterval tree     collect wholeread leave  terminal edge  lcpintervals  lcpvalue  least ellmin  precisely whenever  wholeread leaf    ≤  ≤   find line    append   list    lcpinterval itv   stack use   bottomup traversal  integer itvfirstinw  associate  elements  witvfirstinw…  exactly  read number  wholeread leave collect  itv  value  itvfirstinw  set whenever  first edge outgo  itv  detect   first edge outgo  itv   leafedge  previous wholeread leaf  itv   process thus      first index  list    whole read leaf information    itv   store see line    first edge   branchedge  lcpinterval itv′   correspond subset    itv′ must  inherit  itv technically   achieve  inherit  firstinwattribute  itv′  itv see line   algorithm   external file  hold  picture illustration etc object name  jpg open   separate window figure  algorithm  bottomup traversal  lcpinterval tree enumerate suffixprefix match whenever  terminal edge  read  outgo   interval itv  process line    add   list  suppose   terminal edge  outgo   lcpinterval itv  first symbol   label   terminal edge   suppose    branchedge outgo  itv   lcpinterval itv′   first symbol say    implicit label   edge must occur    thus  cannot   sentinel    consider different   lexicographic order   suffix hence  first symbol   either        symbols   respect   lexicographic order smaller   sentinels  branchedge  itv  itv appear   terminal edge  itv hence  terminal edge outgo  itv′   process  line      need  single list    entire algorithm  soon   edge outgo  itv   process   collect  terminal edge     wholeread leave    itvlcp exceed  minimum length algorithm  compute  cartesian product     appropriate subset    process  correspond suffixprefix match  length itvlcp  line    point suffixprefix match may  output  postprocessed  check  additional constraints   transitivity   cartesian product   compute  elements     longer need    empty line  note   algorithm empty    lcpinterval  lcpvalue smaller  ellmin  process   event     terminal edge  vintervals    longest common prefix     read    smaller  ellmin therefore     suffixprefix match   form leave angle bracket_  ellright angle bracket   ell ≥ ellmin     read represent     list  safely  empty  lcpinterval tree     contain  leafedges   lcpintervals   least two children        branchedges   lcpintervals     three function specify  algorithm   call   every correspond item  number  function call       recall  algorithm   apply   bucket   total size   bucket   hence        call   three function process_leafedge  process_branchedge run  constant time  run time  process_lcpinterval  determine   number  spms process assume   process take constant time  overall run time  algorithm    bucket         number  process spms handle reverse complement  read read may originate   strand   dna molecule   reason suffixprefix match shall also  compute  read  reverse complement   read handle  reverse complement   read  conceptually easy  integrate   approach one    process   instead     three step  involve scan  read  extend  process  strand   read    require double  size   read set representation   information   reverse complement read  efficiently  extract   forward read additional file  section  show   compute  integer cod   reverse read   integer cod   forward read  constant time  scan   reverse complement read   negligible impact   runtime  course  size   table     roughly double  additionally consider reverse complement  compute suffixprefix match  minor modifications  necessary apply algorithm     find  spms include  redundant ones   want  omit   formalize  follow  spm ⟨      ⟩ ∈         nonredundant     one   follow condition  true •  ∈    ∈   •  ∈    ∈     ≺   •  ∈     ∈    ≺      spm  condition  easily  check  constant time see algorithm   additional file  section  recognition  transitive  irreducible suffixprefix match   construction   string graph    need transitive spms  spm ⟨      ' ' ⟩  transitive       two spms leave angle bracketr  ellright angle bracket  leave angle bracket  ell′right angle bracket   ell  ell′   ell″ figure ​figure33 show  concrete example   transitive spm  spm    transitive  irreducible  external file  hold  picture illustration etc object name  jpg open   separate window figure  example   transitive suffixprefix match  example   transitive spm  set  three read   transitive spm leave angle bracketr  right angle bracket derive  leave angle bracket  right angle bracket  follow theorem characterize  spm   read   single irreducible spm satisfy  length constraint   match constraint see figure ​figure44   illustration  external file  hold  picture illustration etc object name  jpg open   separate window figure  illustration  transitivity   suffixprefix match schematic illustration  transitivity ⟨      ' ' ⟩   transitive spm derive   spm leave angle bracket  ellright angle bracket hence  prefix      suffix    …      ' '   theorem  let leave angle bracketr  ell″right angle bracket   spm  leave angle bracketr  ell″right angle bracket  transitive         ∈    irreducible spm leave angle bracket  ell′right angle bracket   ell′  ell″   ell″ ≥   ell′  …  ell′    ell″    ell′  …  ell″  proof  theorem    find  additional file  section    spm leave angle bracketr  ell″right angle bracket  transitive  leave angle bracket  ell′right angle bracket   spm satisfy  condition  theorem    say  leave angle bracketr  ell″right angle bracket  derive  leave angle bracket  ell′right angle bracket theorem  suggest  way  decide  transitivity   spm leave angle bracketr  ellright angle bracket check     irreducible spm leave angle bracket  ell′right angle bracket     derive  check involve comparison      ell′ symbols  verify  …  ell′   suffix     …      ' '     may  several irreducible spms   leave angle bracketr  ell″right angle bracket may  derive   necessary  store  correspond leave contexts   sequence    ell′  ≤ ell′    leave context lcs ell′     nonempty string …  ell′ due   bottomup nature   traversal  algorithm   spms involve  different prefix   give read  enumerate  order  match length   longest   shortest one thus algorithm  first deliver  irreducible spm leave angle bracket  ell′right angle bracket   ⟨      ' ' ⟩  possibly derive   '   ' '   theorem  one  conclude   first spm say leave angle bracket  ell′right angle bracket find   wholeread path    always irreducible hence one store lcs ell′  spm leave angle bracketr  ell″right angle bracket detect later  traverse   wholeread path    classify  transitive     lcs ell′   suffix  lcr ell″ see figure ​figure55   illustration  leave angle bracketr  ell″right angle bracket  transitive   discard otherwise lcr ell″ must  store  well  check  transitivity   spms find later    wholeread path   spm  either classify  transitive  irreducible   case  leave context  store  implement  method  use  dictionary   leave contexts   operation lcsearchd   return true      set membership       suffix   otherwise  add     return false   dictionary   example  implement   trie  store  leave contexts  reverse order   implementation  use  blindtrie   additional file  section   present  modification  algorithm   output nonredundant irreducible spms   external file  hold  picture illustration etc object name  jpg open   separate window figure  transitivity  leave contexts transitivity  leave contexts let  spm leave angle brackett  zright angle bracket  derive  leave angle bracket  zzright angle bracket hence  leave context lcs      suffix   leave context lct   wxy let leave angle bracketu  zright angle bracket   irreducible spm  lcu      non empty string   lcs     suffix   recognition  internally contain read   begin   methods section   show   detect read   prefix  suffix   read  construct  string graph  also   discard internally contain read   contain   read without   suffix   prefix  precisely  ∈   internally contain   read  ' ∈  exist   ′  urw   nonempty string     additional file  section   show   efficiently detect internally contain read construction   assembly string graph consider  read set    suffix  prefixfree  assembly string graph    graph   relationships   read construct            set   nonredundant irreducible spms         restrict  read    internally contain    ∈   graph contain two vertices denote     represent  two extremities   read  stand  begin  stand  end   nonredundant irreducible spm ⟨      ⟩ ∈         satisfy ell ≥ ellmin  graph contain two direct edge define  follow   ⟨      ⟩ ∈           two edge •  →   edge label sell  … •  →   edge label ¯      …       ⟨   ¯    ⟩ ∈      ¯¯¯¯     two edge •  →   edge label ¯      …     •  →   edge label ¯      …       ⟨       ⟩ ∈      ¯¯¯¯     two edge •  →   edge label sell  … •  →   edge label rell  …   implementation   string graph vertices  represent  integers        construct  graph   list  nonredundant irreducible spms  first calculate  outdegree   vertex   count  calculate partial sum   second scan   list  spms  insert  edge   array  size     ∣ ∣      ¯¯¯¯   ∣ ∣   strategy allow  allocate exactly  necessary space   edge   access  first edge outgo   vertex  constant time  array  edge  store compactly use    ⌈         ⌉  ⌈       max   min  ⌉  bits  λmax   maximum length   read ⌈         ⌉ bits  use   destination   edge  source   edge  clear   array index   edge  store ⌈       max   min  ⌉ bits  use   length   edge label  output  contigs  first write reference   read number  edge lengths   temporary file    complete  memory   string graph  deallocated   read sequence  map  memory finally  sequence   contigs  derive   reference   contigs  output  verify  correctness   string graph implementation   allow comparison   tool   implement  graph clean algorithms describe     experimental feature  sophisticate techniques    network flow approach describe    leave  future work   main focus   paper lie   efficient computation   irreducible spms   construction   string graph",-0.1964082986725351,0.18105602750121752,0.11238341684519887,0.15878507776901654,-0.004277379621488514,0.04326547335841648,-0.12239661156309495,0.06565741422976458,0.024514047855718816,0.09573912628202524,0.03158400504076631,-0.017963263646369697,0.15456051721138167,-0.033404116308043616,0.09985886265271912,-0.059982510967259185,0.02534100430144,0.21381806103801831,-0.052087566435808905,0.026206472682314543,0.05575918060229024,-0.1737601380461434,0.017575828543807372,-0.03783870976477236,0.030551296737865205,-0.14407882637794986,0.05308346150980105,-0.17267274429783255,-0.02562067200034018,-0.12665918034253412,-0.0014735861342963553,0.23257316707524814,-0.126684093317633,-0.11851412066877932,0.13617346564494476,0.11344519307539212,0.055686045054876517,-0.03147324776034234,-0.050251774592399205,-0.142322727223668,-0.057148527022144985,-0.11434367999439066,-0.00259456585943563,-0.0866998396427877,-0.13582750508261893,0.008845388679463127,0.11666740552646995,-0.07701775890037625,-0.18655853989563104,-0.313793109200922,0.160824860746766,0.025325581270044008,0.09415961466408496,0.5662591477142108,0.008793216279278008,-1.0595309747499104,0.0827968181847392,-0.16360778304416593,0.9086756782872734,0.1983587182283961,-0.1540986864205122,0.2399905459207745,-0.12470796116194205,0.05523244747594036,0.5822342462366477,0.02485128964232009,0.059284442537299385,0.05134136792466913,0.11319512660418753,-0.1996565417425808,-0.08563681102841704,-0.04611770978626061,0.07776981435283994,-0.13012102033232095,0.21843487011121748,-0.042040534799520815,-0.1238458933285098,-0.1246475839347576,-0.32516219524788803,-0.08254741948093003,0.14310443888414748,-0.07423170016692836,-0.33923858118031064,-0.06733394125973638,-0.7551660104685609,0.06891456887154378,0.16946538451571755,-0.1267206224264572,-0.03872551612483762,-0.059321947456286564,-0.2029087458138443,0.1154834183816664,-0.1002077771554854,-0.08810726773294568,-0.10798378757628274,-0.11617280505594504,-0.04961593547451189,-0.25056318085904994,0.2594848758924261,0.08310617673793183,Assembly,5
141,141,"bracken estimate species abundance  metagenomics data
metagenomic experiment attempt  characterize microbial communities use highthroughput dna sequence identification   microorganisms   sample provide information   genetic profile population structure  role  microorganisms within  environment  recently  metagenomics study focus  highlevel characterization   level  phyla  alternatively sequence   ribosomal rna gene   present  bacterial species   cost  sequence  fall though metagenomics experiment  increasingly use unbiased shotgun sequence  capture   organisms   sample  approach require  method  estimate abundance directly   raw read data   describe  fast accurate new method  compute  abundance   species level use  read collect   metagenomics experiment bracken bayesian reestimation  abundance  classification  kraken use  taxonomic assignments make  kraken   fast readlevel classifier along  information   genomes   estimate abundance   species level  genus level    demonstrate  bracken  produce accurate species  genuslevel abundance estimate even   sample contain multiple nearidentical species
 new method bracken bayesian reestimation  abundance  classification  kraken estimate species abundances  metagenomics sample  probabilistically redistribute read   taxonomic tree read assign  nod   species level  distribute    species nod  read assign   strain level  redistribute upward   parent species  example  fig   would distribute read assign   mycobacteriaceae family   mycobacterium genus    marinum   avium  read assign    marinum strain would  reassign    marinum species   show  bracken  easily reestimate abundances   taxonomic level  genus  phylum use   algorithm  order  reassign read classify  higherlevel nod   taxonomy  need  compute  probabilistic estimate   number  read    distribute   species   node  illustrate use  nod  fig   need  allocate  read assign  mycobacterium    marinum    avium     read assign   mycobacteriaceae would    allocate   marinum   avium  andhoyosella altamirensis  schematic show  partial taxonomic tree   mycobacteriaceae family figure  schematic show  partial taxonomic tree   mycobacteriaceae family download fullsize imagedoi peerjcsfig reallocate read   genuslevel node   taxonomy   genome     accomplish use bay theorem   appropriate probabilities   compute let psi   probability   read   sample belong  genome  pgj   probability   read  classify  kraken   genus level   pgjsi   probability   read  genome   classify  kraken   parent genus    probability   read classify  genus  belong   genome    express    psi∣∣gjpgj∣∣sipsipgj note    begin  assume   read  classify  node  pgj   next  consider   compute pgjsi  probability   read  genome    classify  kraken   parent genus   estimate  probability  read  length   classify  sequence genomes   use  build  database use   database  follow   kmer   sequence kraken assign   taxonomy    fast lookup   database  assign  taxonomy    read  length  kraken examine  kmer classifications   read  example          read  contain  kmers  procedure examine   genome   database  slide window  length  across  entire genome  find  taxonomy  kraken would assign   window  simply find  deepest taxonomy node   set  kmers   window since  kmer   database sequence  assign   taxonomy  somewhere along  path   genomes taxonomy    root  highestweighted roottoleaf path  thus  kraken classification correspond   deepest node   genome   length   thus generate      mappings  taxonomical ids  node    count  number  read     assign   ngjsi pgjsi    proportion  read     assign   genus node   pgjsi  ngjsi∕      also calculate  proportion  read     assign  every node  genome    root node   taxonomy tree  final term   must calculate     psi  probability   read   sample belong  genome    compute  relation   genomes    genus  example   sample contain three genomes    genus      read   three genomes belong    psi    estimate  probability use  read   uniquely assign  kraken  genome   follow   let usi   proportion  genome    unique  usinsilir  nsi   number  kmers  length    uniquely assign  genome   kraken     genome length  example     mbp    kmers  unique  genome   usi    use  number  read ksi   sample  kraken actually assign     estimate  number  read  likely derive    kˆsiksiusi  example  kraken classify  read  genome      read    unique   would estimate   read     contain   sample  genus  contain  genomes  estimate  number  read kˆs      genomes   calculate psi  psikˆsi∑a1nkˆsa use  result     allow   compute psigj   genome   probability psigj   use  estimate  proportion   read assign  genus   belong     genomes    calculations  repeat   taxonomic level   genus level family class etc  read distribution   level go   genomes classify within  taxonomic subtree  compute species abundance  genomelevel strainlevel read  simply add together   species level  case   one genome   give species  detect  kraken   dataset  simply add  read distribute downward   genus level     read already assign  kraken   species level  case  multiple genomes exist   give species  read distribute   genome  combine  add   krakenassigned species level read  add read give  final specieslevel abundance estimate  method  also estimate abundance   taxonomic level   case  higher nod within  taxonomy tree undergo read distribution  distribute read downward  estimate abundance   node   level specify  combine  distribute read across  genomes within  nod subtree",-0.18717900291703374,0.23497167340453004,0.10620358013120414,0.09096540887716466,-0.03890064759159345,0.02533909641268078,-0.11649927723018527,0.04459580054982623,-0.009651858072142751,0.11004105590456947,-0.014033706691342743,0.05853965822854532,0.17077039158078886,-0.07278054739262052,0.1333661596228954,0.007920719233992617,0.07030957554718398,0.21564555974888144,-0.019423302136303902,0.11130357494338754,-0.04914056555681194,-0.2094188560309317,0.06268621208707686,-0.009701843192673129,-0.07773077995227896,-0.1317425889387496,0.10111813257093978,-0.12218152596285585,-0.02718562319198936,-0.06144780153666201,0.022320425683896233,0.2215556603747181,-0.13875751319316634,-0.06533885493578875,0.21044531653481185,0.10352150265506543,0.020257648871799486,-0.007212011067328595,-0.04072410694814897,-0.11517896001645472,-0.12806031508144586,-0.07896835507292649,-0.14031508834635947,-0.11550234553179566,-0.13857220773651074,0.028929998936436538,0.1150828868550438,-0.09345127978831927,-0.22512790504420604,-0.2738650544032463,0.185303720923767,-0.02315607680774302,0.09160257151465764,0.5390529380575547,0.01261334685790064,-0.9425772670594628,0.047837579336977534,-0.20705145992523066,0.8634847112461529,0.2076848313798077,-0.1496551240163606,0.34708952677188404,0.005440815583703858,0.0156591229763529,0.6217226546579164,0.08550332167156997,-0.04109504707033985,0.015091731191140937,0.2279337094241621,-0.19049469536465008,-0.09601629355268664,-0.04357562920689558,0.06055461393967498,-0.1299044436319789,0.16794053991263386,-0.039739880365200035,-0.16959899825258262,-0.1886217419667977,-0.35691199554089226,-0.026573551910933503,0.10557617480759468,-0.023749039977669417,-0.431672769833554,-0.04651457251181447,-0.6782344734889612,0.032775369562946285,0.23688296253784696,-0.15178350377848487,-0.12192133041428385,0.007972571001062582,-0.17236367733407335,0.05941041651031464,-0.08784139795389552,-0.14783589763822347,-0.008376749028169459,-0.13418212869056229,-0.06620846591082162,-0.3555759578393113,0.22025779009625665,0.06107269619814064,AbundanceEstimation,6
142,142,"microbial abundance activity  population genomic profile  motus2
metagenomic sequence  greatly improve  ability  profile  composition  environmental  hostassociated microbial communities however  dependency   methods  reference genomes   currently unavailable   substantial fraction  microbial species introduce estimation bias  present  update  functionally extend tool base  universal  referenceindependent phylogenetic marker gene mgbased operational taxonomic units motus enable  profile   microbial species       could  previously  quantify   taxonomic resolution relative abundance estimate base  motus   accurate compare   methods   new feature  show  motus   base  essential housekeep genes  demonstrably wellsuited  quantification  basal transcriptional activity  community members furthermore single nucleotide variation profile estimate use motus reflect   whole genomes  allow  compare microbial strain populations  across different human body sites
 motus2 profiler  motu profiler version  motus2   standalone open source computational tool  estimate  relative abundance  know  well  genomically uncharacterized microbial community members   species level use metagenomic shotgun sequence data  taxonomic profile method  base  ten universally occur protein cod singlecopy phylogenetic marker genes mgs   extract     reference genomes13     metagenomic sample supplementary data   total   nonredundant  sequence  mgs  group   mgbased operational taxonomic units motus  represent microbial species many     still lack sequence reference genomes  addition   taxonomic profile  tool allow   basal transcriptional activity profile  community members use metatranscriptomic data  well  iii determine proxies  strain population genomic distance base  singlenucleotide variations snvs within  phylogenetic marker genes  comprise motus generation  annotation   motus2 database  motus2 profiler rely   custombuilt database   sequence extract  reference genomes refmgs   metagenomic sample metamgs  reference genomes  group  specieslevel cluster speci cluster   sequence   reference genomes  group base   speci affiliation  reference marker gene cluster refmgcs  refmgcs  augment  metamgs   remain metamgs  cluster  metamgcs mgcs  different mgs  subsequently group base   speci affiliation  bin base  coabundance analysis  reference genomebased motus refmotus  metagenomic motus metamotus respectively  result motus  qualitycontrolled compile   sequence database  shortread map  taxonomically annotate regular update     motu database   make available   collection  mgs  reference genomes  metagenomes   reference genomes use   motu database  download   progenomes database13 metagenomic data  download   genbank sequence read archive    european nucleotide archive  accession number  list  supplementary data   sample  obtain  human microbiome study include  sample  different major human body sit oral skin gut  vaginal14     sample  various human gut microbiome studies16  addition  use  metagenomic sample   ocean microbiome study22  sample  process  marker gene identification9 briefly qualitycontrolled raw sequence read  subject  metagenomic assembly  genes predict  contiguous sequence longer   base pair  mgs  subsequently extract use  fetchmgs tool available    short fetchmgs identify mgs use hmm model build  hmmer3  apply  set  optimize cutoffs4   extract correspond nucleotide sequence   seqtk tool   workflow  extract  set   mgs cog0012 cog0016 cog0018 cog0048 cog0049 cog0052 cog0080 cog0081 cog0085 cog0087 cog0088 cog0090 cog0091 cog0092 cog0093 cog0094 cog0096 cog0097 cog0098 cog0099 cog0100 cog0102 cog0103 cog0124 cog0172 cog0184 cog0185 cog0186 cog0197 cog0200 cog0201 cog0202 cog0215 cog0256 cog0495 cog0522 cog0525 cog0533 cog0541 cog0552     reference genomes     genes  currently suitable  metagenomic applications due  high rat  ambiguous map  short read owe  highly conserve regions within  sequence  well  lower assembly rat observe   mgs4  hence  select subset  ten mgs cog0012 cog0016 cog0018 cog0172 cog0215 cog0495 cog0525 cog0533 cog0541 cog0552  extract  genes   predict  metagenomes  describe  group  mgs  refmgcs  metamgcs reference genomes  process  cluster  speci cluster  build refmgcs4   end  calculate pairwise global nucleotide identities   genome      mgs use vsearch version  genometogenome distance  calculate   gene lengthweighted arithmetic mean   individual  sequence distance  result distance matrix  use  input  average linkage cluster use  optimize cutoff   nucleotide identity4 result   speci cluster  assess  quality  group genomes  speci cluster  test whether  taxonomic annotations   individual genomes provide   ncbi  congruent supplementary figure   specifically  speci cluster  annotate taxonomically  accordance   member genomes speci cluster  either homogeneous  members    specieslevel annotation heterogeneous different species annotations find    cluster  undetermined cluster  contain genomes  nonbinomial species name   synechocystis  pcc    evaluate  many ncbi species name occur multiple time  different cluster subsequently  ten mgs suit  metagenomics  extract   speci cluster result    refmgcs  enable  profile  species    yet represent  reference genomes  extract  sequence  metagenomic assemblies use  fetchmgs tool  cluster  first calculate  pairwise distance  mgs  refmgs  metamgs use vsearch version   retain alignments   least  align base   use openreference cluster employ  average linkage hierarchical cluster algorithm  augment  preexist refmgcs  metamgs  remain metamgs sequence  cluster  metamgcs contain  metamgs bin  mgcs  motus   cluster  metamgs  metamgcs  perform independently     ten mgs  result  unbinned metamgcs  oppose   refmgcs   group  motus base   speci cluster affiliation  order  bin mgcs  motus   link mgcs originate    species  utilize  property  genes  therefore mgcs    species  expect  covary  abundance across metagenomic samples41 accordingly  calculate  correlation  pairwise mgc abundances across  sample   biome  optimize  correlation measure  prevalence filter   mean   spurious correlation  lowprevalence mgcs see9   biome separately base   auroc determine  crossvalidating  group  refmgcs   membership    speci cluster serve   grind truth   result  define  follow biomespecific parameters human gut  prevalence filter five sample pearson correlation  logtransformed relative abundance ocean  prevalence filter five sample pearson correlation  relative abundance human oral cavity  prevalence filter  sample pearson correlation  relative abundance human vagina  prevalence filter five sample pearson correlation  log transform relative abundance human skin  prevalence filter ten sample spearman correlation  logtransformed relative abundance  order  combine  biomespecific correlations  transform      fdrcalibrated association measure    way    give fdr value   association value  assign  obtain  single measure  association   pair  mgcs  compute  maximum   fdrcalibrated association value across biomes   actual bin  use  slightly modify version   greedy algorithm describe  ref    initialization step  refmgcs  group accord   speci cluster affiliations  metamgcs  progressively bin start   highest fdrcalibrated association value  decrease   cutoff value    reach   procedure  mgc  add bin   exist group  another mgc  form  bin  size two    among  ten possible ones   already present  group   least  mgcs  retain  define  motus  result   metamotus consist   metamgcs   refmotus contain  least one refmgc  possibly additional metamgcs mgcs  remain unbinned  group   single unbinned group note  although speci cluster  refmotus  conceptually similar   two major differences first refmotus  compose  mgcs   least six    ten different mgs use  metagenomics  speci cluster represent genomes   group base  distance calculate     mgs second refmotus   describe  contain mgs  mgcs   assemble  metagenomic sample  assess  expect taxonomic consistency   bin strategy  metamgcs  fraction   refmgcs  treat    ways  metamgcs   taxonomic affiliation know  refmotu membership   use afterwards  ascertain  error rate   bin algorithm supplementary figure  across  metagenomic sample use  construct  motus  refmotus  detect  could  use  fold resampled fold crossvalidation  also assess  agreement   mgcs   motu  term  relative abundance  prevalence across metagenomic sample supplementary figure 2bc relative abundance  prevalence show higher agreement  metamotus   refmotus   expect since  bin algorithm  directly influence   two parameters  additionally evaluate  homogeneity   content among   sequence within  motu supplementary figure  metamgcs show  homogeneous  content  expect  genes  originate    genome    erroneously bin  sequence construction   motus2 map database  compile  sequence database   short metagenomic read   align  quantify  abundance  mgcs  motus  construct  nonredundant motus map database  remove identical  sequence  sequence   database  extend   start  end   gene      base   genome  metagenomic assembly  origin  reduce know map artifacts  gene boundaries  result nonredundant database consist   sequence file  fasta format along  mgc  motu annotations  well   coordinate   cod segment    sequence  sequence file   index  search  bwa42  snv call  construct  additional database   consist   centroid medoid sequence  every mgc   snvs   identify  respect  one reference sequence per mgc taxonomic annotation  metamotus  assign taxonomic affiliations  metamotus  first annotate   use uniprots uniref90  release 2017_08   reference protein sequence database43   supplement   set  additional marine protein sequence  describe in44 similarities  translate  sequence  reference database entries  compute use mmseqs245   follow parameters search  true   maxseqs  taxonomic affiliation  assign use  weight lowest common ancestor lca approach  follow     protein match   reference database   value ≥   highest bitscore  keep  outlier taxa  exclude  use  bitscoreweighted lca annotation  cover  least    sum   bitscores    next  transfer  annotation   bestscoring  member   mgc  use  mgc annotations  assign  taxonomy  metamotus  follow   metamotu    taxonomy rank  require  least three mgcs   annotate  consider  metamotus  annotate   rank annotate metamotus  consider consistent   least half   mgc taxonomy annotations   agreement phylogenetic analysis  motus  explore  phylogeny  motus refmotus  metamotus  reference tree  reconstruct  combine  phylogenetic signal   ten set  marker genes select supplementary figure     marker genes  translate  amino acid sequence  analyze use ete toolkit    particular  program etebuild  use  run  follow phylogenetic workflow first  set  marker proteins  independently align use clustalomega47 next alignment columns  less  three align residues  remove finally  ten individual  alignments  concatenate  use  infer  maximum likelihood phylogenetic tree use iqtree48    model  motus2 profile workflow  motus2 workflow  taxonomic profile consist  three step alignment  metagenomic sequence read  mgs estimation  read abundances  every marker gene cluster mgc  calculation  motu abundances  input motus2 expect  user  provide quality control sequence read   align   mgs   motu database use bwa mem algorithm default parameters  result alignments  filter      least  nucleotide identity  retain  alignments  filter accord   lengths default   minimum alignment length   adjust use   option next  compute  best alignments  every insert read pair   mgcs use bwa alignment score insert   single highest score alignment  flag  “unique alignments” whereas insert  multiple highest score alignments  flag  “multiple alignments” subsequently abundances   mgc  calculate  sum   number   insert flag  unique alignments result   unique alignment profile insert flag  multiple alignments  distribute among  bestscoring mgcs  accord   respective abundances estimate base   unique alignment profile thus  final abundances  calculate   sum   unique abundance profile   distribute contributions   insert flag  multiple alignments  addition   mgc insert count mgc base coverages  calculate  first sum   total number  base align   mgc   divide   respective gene lengths finally  abundances   motus  calculate   median   respective mgc abundances insert count  base coverages  order  reduce false positive result  require  certain number  mgcs   detect     metagenomic read map   default  mgs  option  motus2 although motus2  able  profile many organisms  yet represent  reference genomes   still around    mgcs  could   bin  motus see section  read map   mgcs  assign   group label  “unbinned” show  “”  motu abundance profile  abundance   group  calculate   median  unbinned mgcs sum  cog description  taxonomic profile output  motus2 profiler return multiple taxonomic profile since abundances base  read mappings   calculate  different ways one major distinction   unit  count either fragment   insert  read  singlepair sequence  map basepairs   count count  map basepairs   advantage   mean base coverage  easily  compute  divide  number  base align   certain gene   correspond length motus2 output  option “basecoverage” count base statistics  powerful  differential abundance test output  option “insertraw_counts”   count could  principle  noninteger number due  insert map  multiple genes see section   count  round  integers  relative abundancebased estimate genelength normalizations  require  account  vary lengths   sequence  vary number  mgcs present   motu   end  previously introduce “scaled counts”  retain    characteristics  insert count   approach coverages  calculate  describe     normalize  sum    number  insert  align  mgcs output  option “insertscaled_counts” singlenucleotide variant analysis  mgs  motus2 profiler  new functionality  compute metagenomic snv profile use  mgs comprise motus  reference sequence  result snv profile  highly correlate   obtain  whole genome snv profile see main text fig  supplementary figure    overall snv call pipeline start  align metagenomic sequence  centroid sequence  mgcs see    result bam file  postprocessed use metasnv functions34  motus2 command map_snv map  read use bwa42  perform read filter   similar fashion  describe  taxonomic profile   snv analyse  insert flag  unique alignments  keep   result sam file  sort  convert   bam file use  snv_call command  tool  compute base coverages  call snvs iii generate filter allele frequency table   calculate distance  strain populations  four step  directly build upon metasnv capabilities34 although  procedure  adapt  motus2  facilitate  use  genes rather  genomes firstly  bam file  process  compute per sample coverages  every reference sequencemotu  vertical average number  read per position  horizontal percentage   sequence cover  least  snvs  subsequently call use samtools mpileup49 follow  two postprocessing step  include  filter step   modify  include parallelize compute capabilities  well   removal  pad regions   allele frequency table  filter parameters remain identical  update default value  account   universal character   genes consider  minimal percentage   sequence horizontally cover per sample  per motu default    minimal average vertical coverage per sample  per motu default    minimum number  sample meet  list criteria per motu default    minimum vertical coverage per snv position default    minimum proportion  sample meet  previous criterion  say position default   finally  filter allele frequency table  use  compute genetic distance  sample   motu manhattan distance  well  major allele distance  use   population genomic distance measure   latter  allele frequency change     two sample  take  account  motu profiler use parallelize compute capabilities   step  output directory  include three file two   coverage information   motu  horizontal *covtab file  vertical *perctab file   log file additionally   two directories  per motu filter allele frequencies  identify snvs across sample filtered* directory   per motu genetic distance  sample distances* directory  manhattan manndist file  major allele alleledist file benchmarking motus2   tool  evaluate  accuracy  robustness  benchmarked motus2  two establish tool  taxonomic profile  metagenomic sample metaphlan27   base  cladespecific marker genes  kraken50   base  exact alignments  genomic kmers metaphlan2 version   execute  default parameters  krakenlabelled analyse  execute kraken  read classification  calculate relative abundances  bracken6 kraken  bracken  instal  version  use conda  minikraken database version minikraken_20171101_8gb_dustmasked  download    minibracken database  download     february   execute kraken use pairedend  singleend data use default parameters abundance estimation  bracken  perform   follow parameters  minikraken_8gb_75mers_distribtxt    resultabundancebracken comparison  motus  metagenomeassembled genomes   validate  motus use metagenomeassembled genomes mags reconstruct  different environments   purpose  first extract  metagenomic sequence run  human gut sample available   european nucleotide archive accession number  list  supplementary data  raw read   run  assemble use metaspades   subsequently bin  metabat2    minimum contig length threshold    sequence coverage require  bin  infer  map  raw read back   assemblies use bwa    retrieve  percentage  map read base  samtools    jgi_summarize_bam_contig_depths function  metabat2 quality score    metagenomeassembled genome mag  estimate  checkm  calculate   level  completeness    contamination  previously described23 goodquality mags     keep  subsequent downstream analyse mags  marine sample ocean mags  obtain   subset    mags   describe   recent publication23  order  identify oceanassociated mags  first search   keywords ocean marine baltic sea  north sea  extract entries  supplementary table  of23  find  sample match  keywords   sample  select  mags  supplementary data    reconstruct   metagenomes correspondence  mags  motus  establish use  follow procedure first  extract  ten mgs   mags use fetchmgs see  obtain  set  mgmags second  align  mgmags    database   motus use vsearch usearch_global parameters   minqt  finally  evaluate  congruency   mgmags  motu match    first check   least three mgmags could  assign   motu  map   mgc   part   motu      case  mag  annotate  “unassigned” next  remove  alignments  mgcs  assign  motus  assign  mag   motu     mgmags  consistently match    motu otherwise   majority motu  find  mag  annotate  “inconsistent” benchmarking motus2 use simulate metagenomes   able  assess taxonomic quantification accuracy ten human gut metagenomic sample  simulate use  human gut mags  subset    mags describe  exclude  mags create  sample use  construct  motu database supplementary figure  mags   ani    dereplicated   one representative mag per species cutoff accord  ref   ani  calculate   fastani tool   correspond fastq file  well   simulate abundance data  available   metagenomic read data  simulate use bear54 first  generate   insert     pairedend read    length    insert distance standard deviation  use generate_readspy second trim_readspl  default parameters  use  add  quality score introduce errors  shorten  read every sample  simulate base  motus2 profile relative abundances  ten real sample   simulate sample  randomly select  mags   representative reference genome sequence   superset   kraken metaphlan2  refmotu databases   additional mags sample    lack  reference database representation    preclude  mags  map  metamotus  benchmark  perform  evaluate precisionrecall plot   simulate metagenomes base   number  true positives  false positives  represent species   predict   present   real sample  false negative  represent species   miss   profiler precision  calculate  tptp    recall  tptp   next  evaluate  mean absolute error mae define   average absolute difference  estimate relative abundances  relative abundances simulate  grind truth finally  evaluate  accuracy  alpha diversity estimate use  difference  predict  actual shannon index abbreviate   benchmarking motus2 use  cami framework   evaluate motus2   cami framework25  include eight simulate sample one low complexity two medium complexity  five high complexity    grind truth  available within  first cami community challenge ten metagenomic profile tool include metaphlan2  motus1  already benchmarked   data set  comparatively assess  performance  motus2   context  convert  output  camibioboxes format  option   motus2 profiler  use opal  develop    author  cami  consistency  performance assessments use precisionrecall plot  evaluate motus2 employ five different parameter set high precision      precision default      precision recall      recall high recall      recall  maximum recall      recall hence motus2  represent  five red dot   precisionrecall plot demonstrate     tune  obtain  range  precisionrecall tradeoffs  evaluation   mean absolute error mae    call  norm   cami paper  also obtain  opal  default opal renormalise  relative abundances   gold standard   profile result   sum    calculate  mae  apparently substantially deteriorate  quantification accuracy  motus2 see supplementary figure    reason  include  renormalise  relative abundances without  postprocessing   evaluation  motus2  aim  maximum transparency   comparison    tool  could   evaluate   renormalise version  could theoretically also benefit   evaluation  nonnormalised relative abundances determine environmental specificity  motus  determine  environmental specificity   motus  use  set   metagenomes supplementary data   assess  environmental specificity   metamotus   subset  refmotus   present   sample supplementary figure    end  generate motus2 profile   sample  default settings  remove sample  less   scale insert count base   result profile   classify  motu   present   specific environment    detect    three sample   environment analysis  community structure  assess correlations   shannon index calculate base   rrna genebased analyse  three metagenomic profile tool motus2 metaphlan2  kraken    use data  two different biomes metagenomes generate  stool sample   colorectal cancer crc study21  metagenomes  seawater sample   tara oceans expedition22   crc study amplicon sequence data    region    rrna  download   european nucleotide archive ena database  accession number erp005534   ocean water sample  rrna gene contain fragment  extract  metagenomic sequence read mitags55  ensure comparability   data set  extract  first     mitag sequence start    primer sequence ribosomal rna data  initially process use usearch56 version   follow pairedend read  merge  qualityfiltered use  fastq_mergepairs command  default settings merge read  filter use  fastq_filter command fastq_maxee  sequence  dereplicated use  fastx_uniques command singletons  exclude   remain unique sequence  cluster  operational taxonomic units otus    chimera removal use  cluster_otus command finally otu abundances   sample  determine use  usearch_global command strand     otu abundance table  downsampled   minimum number  read per sample crc  read tara  read  normalize  uneven sequence depths use   function rarefy within  vegan package57  shannon index  diversity  compute   sample   methods  rrna genebased  metagenomic methodbased use   function diversity   vegan package  order  obtain   confidence interval  use bootstrapping     resampling pair  shannon index value  confidence intervals reflect     percentile   bootstrapped sample  sample distance  determine use human body site sample     one time point  available    individual  specifically   body site  compare community compositional distance  sample    individual intraindividual  distance     individuals interindividual canberra  braycurtis distance  compute   vegdist  function   vegan package   logeuclidean distance  compute   euclidean distance   logtransformed relative abundances   addition   pseudocount smaller   smallest nonzero value     three distance   sample  identify   similar sample   one   minimum distance value  determine  proportion  case    sample belong    individual analysis  metatranscriptomes  demonstrate  use  motus2  assess basal transcriptional activity  microbial community members  use  dataset   sample   metagenomic  metatranscriptomic sequence data  available31  sample  metagenomes   metatranscriptomes  subject  profile use motus2 krakenbracken  metaphlan2  result profile  transform  relative abundances  logtransformed  add  small pseudocount   spearman correlations  correspond metagenomic  metatranscriptomic profile generate    sample  calculate  compare  profile methods fig   supplementary figure   moreover evaluate  well species abundance estimate correlate  metagenomic  metatranscriptomic profile   twelve  abundant taxa   class level class level information  motus  metaphlan2  available  part   profiler output class level annotations  kraken  obtain use ncbi taxonomy identifiers comparison  snv profile  mgs  whole genomes  assess  comparability  snv profile generate  motus2  whole genomes  use sample   human microbiome samples14    prokaryoteenriched metagenomes   tara oceans project22 metagenomic read  map   motus centroid database use  motus2 command map_snv   addition   set   reference genomes13 genomic distance  strain populations  sample  estimate base  snv profile compute   motus   whole genomes use  motus snv_call command  filter parameters use within  snv_call command  adapt   specificity  datasets  reference  allele frequency table  filter use  horizontal coverage  equal    whole genomemapped read    motumapped read  vertical coverage     per position coverage      position prevalence     minimum number  sample per reference      human sample     ocean sample wholegenomebased distance  compare    motus use pearsons correlation fig   select  refmotusgenomes  pass  filter thresholds   methods  correlate  sample distance   two methods     species   vaginal supersite pass  filter requirements   methods individuality  microbial populations across body sit  test   individuality  microbial strain populations   subset   human microbiome sample describe      least two time point data  available   body site  compare snv profile distance  sample    individual intraindividual intrabodysite distance  distance     individuals interindividual intrabodysite distance  determine whether intraindividual distance  smaller  interindividual distance see supplementary figure —indicating individuality  strain populations— use roc analysis roc curve see supplementary figure  ascertain  accurately small distance predict whether  pair  sample originate    individual  similarly small interindividual distance  consider false positives  systematically vary  distance cutoff roc curve   summarize   area   curve auroc  higher value correspond  clearer separation  intra  interindividual distance fig   supplementary figure  confidence intervals   auroc fig   obtain  bootstrapping use  proc package",-0.15333163585661294,0.16161597205960182,0.09978009712661573,0.11335978681515055,-0.028341611059838817,-0.010774409196952058,-0.08265637439101843,0.0265264300798738,-0.018742377189107786,0.11849267332365306,0.005532014481975686,-0.036748285949638984,0.15570047144775692,-0.07886791341308619,0.12149161249794453,-0.026036956848816174,0.045701828019262467,0.12041238578622895,-0.019330643225925426,0.06160230744000639,-0.020636595502806537,-0.16599545531585644,0.053434881572520083,0.0037870581600049024,-0.023393373345059525,-0.16133713329014915,0.07397121874949332,-0.11773177518987607,-0.053096813573163024,-0.04935889825836397,0.02333254787658824,0.1759595519860409,-0.1345017341689113,-0.04577721531307929,0.16636379795200554,0.06390423810263644,0.06050263592840606,0.02985570187883068,-0.09306905410388844,-0.0883201247284176,-0.07858339632122988,-0.10724780263740648,-0.0670850354598268,-0.060609266660982826,-0.0899102270622232,-0.002274877727072069,0.0919860110604264,-0.08377047027159368,-0.1937175654274472,-0.2564064313994828,0.11824092880229385,0.032067170488441765,0.051772366053517316,0.453374176958178,0.001096407562448751,-0.8218876670859953,0.0603524987807539,-0.1956778243937511,0.72043717352329,0.17391419604677494,-0.12008855536256074,0.24688821533342525,-0.04837357971889504,0.043852471545159,0.4638536356859143,0.03807240539845515,-0.0013215468964350432,0.0011281779474037485,0.20726721287224004,-0.15011268380667378,-0.04671263407145971,-0.029972560438572445,0.12446958044715267,-0.08711860394951522,0.14239121068048308,-0.03966516314181286,-0.11074677540516872,-0.14948969602713008,-0.2669693285722571,-0.06632176797263477,0.10450402989059072,-0.02535895908994434,-0.2719684790735263,-0.019887399198518948,-0.6008839743840891,0.046250051874274,0.16877812655730715,-0.12483122186660052,-0.06635441834514805,0.006632095805231253,-0.17545489534450145,0.06724359030446496,-0.1017298715904138,-0.0673536460181357,-0.06614169781584951,-0.060234831280261074,-0.08781996712162317,-0.25863270644492803,0.21073495110758655,0.05776487285230214,AbundanceEstimation,6
143,143,"abundance estimation  differential test  strain level  metagenomics data
current metagenomics approach allow analyze  composition  microbial communities  high resolution important change   composition  know  even occur  strain level    hand  hand  change  disease  ecological state however specific challenge arise  strain level analysis due  highly similar genome sequence present   limit number  tool approach taxa abundance estimation beyond species level     strong need  dedicate tool  strain resolution  differential abundance test  present ditasic differential taxa abundance include similarity correction   novel approach  quantification  differential assessment  individual taxa  metagenomics sample  introduce  generalize linear model   resolution  share read count  cause  significant bias  strain level   capture abundance estimation uncertainties  play  crucial role  differential abundance analysis  novel statistical framework  build  integrate  abundance variance  infer abundance distributions  differential test sensitive  strain level   result  obtain highly accurate abundance estimate   substrain level  enable finegrained resolution  strain cluster  demonstrate  relevance  read ambiguity resolution  integration  abundance uncertainties  differential analysis accurate detections  even small change  achieve  falsepositives  significantly reduce superior performance  show  latest benchmark set  various complexities   comparison  exist methods
ditasic  design   comprehensive approach  abundance estimation  differential abundance assessment  individual taxa thereby  main focus   distinguish   strain level  highly similar sequence   correspond challenge  step   ditasic workflow  illustrate  figure   consist  three main part map abundance estimation  differential abundance assessment  external file  hold  picture illustration etc object name  btx237f1jpg open   separate window fig  workflow  ditasic  consist  three main part  map  taxa abundance estimation  iii differential abundance assessment   rely  prior prefiltering  species  external profile tool   kraken  mash read  map   give reference genome sequence   number  match read per reference  count map abundance  similarity matrix reflect  genome similarities  construct  subsequently  glm  build  resolution  read count ambiguities result  correct abundance estimate along  standard errors iii   comparison  metagenomes abundances  formulate  distributions   divergence reflect differential events  final list  test taxa  fold change  adjust pvalues  report   first two part  build     core ideas   previously publish tool gasic lindner  renard   strongly improve  abundance quantification  introduce new methodology  address  critical aspects  variance  abundance estimate  differential abundance   metagenomics sample measure  ngs technologies  face millions  billions  read   derive  diverse taxa ditasic rely   prefiltering  species  fast profile tool   kraken wood  salzberg  clark ounit    kaiju menzel      use mash ondov     genome distance calculator  reduce  number  potential reference genomes  keep  main focus  species expect   data   specifically aim  reveal  picture   highest available strain level   first map step  read  assign   give reference   first attempt  decipher  potential origin  number  hit per reference genome  count  refer    map abundance   taxon   next step  abundance estimation  new generalize linear model glm  introduce   resolution  share read count   crucial  strain level   result  accurate abundance estimate  obtain   different strain along  standard errors  abundance uncertainty   last section  focus    comparison  whole metagenomics sample   assessment  differential abundance  taxa thereby  concentrate   method  integrate  variance  abundance estimate abundances  transform  distributions divergence  distributions  use  infer differential events  correspond pvalues  calculate  detail   three ditasic part  explain   follow section  follow notation  apply different metagenomics sample  denote    {   … }  contain   {  … } total input read  set  taxa   {  … }  know reference sequence  consider thereby   synonymously use    taxa   well   exact reference genome map  abundance estimation  address   data set separately   last step  differential abundance estimation  define   pair  sample    map  identify  origin  assignment  read  conduct   competitive map approach  mean  select reference genome sequence   simultaneously offer   read   sample     map particularly  strain level reference sequence exhibit high sequence similarities thus  read  expect  match  different genome sequence equally well  read  define  share read   account    multiple hit however  exact match position   reference genome     importance  several position hit  one read    reference   count  one   map   pseudoalignment approach provide  part   kallisto implementation bray     apply   exact alignments  require   purpose  pseudoaligner  sufficient  prove   much faster  accurate use  fast kmerbased approach   gain significant improvements   previously publish tool gasic  rely  individual reference alignments  bowtie  langmead  salzberg  altogether  extract  count  number  read hit  reference genome receive  refer    map abundance   taxon   case  data set  consist  mainly dissimilar reference   dominate  clearly unique mappings  observe map abundances  may already closely reflect  underlie true abundances   taxa however  many similar reference  present    common scenario  strain level  large bias  present due  multiple hit  share read  sum   map abundances   taxa  drastically exceed  number  input read  abundance estimation follow  idea introduce  gasic  rely   simulationbased representation  reference genome similarities  resolve  effect  share read  similarity matrix  construct  encode  proportion  read   expect   share among  pairwise combinations  reference sequence consider read  simulate use mason holtgrewe  base   reference sequence   subsequently map   reference follow   competitive map setup  apply   read     step   key element   imitate sequence read  map characteristics  good  possible  reproduce  source  ambiguities parameters   read length  mismatch probability  crucial   simulation  read   infer   raw read    square matrix   aij   …  compute columnwise   reference  aij refer   count  read simulate  reference   map  reference  next  matrix  normalize columnwise   read count ajj  number  simulate read   assign back   reference  origin thus  matrix    aijajj   … hold value  zero  one replace  classic linear model  gasic  formulate  new glm   vector  absolute map abundances   similarity matrix   correct   share read bias aim  recover  true  unknown abundances    taxa           aij  …     … cmt     … rmt  nonnegativity constraint  ≥   error term epsilon  observe map count   taxon  correspond   sum mixture   underlie true abundance   taxon    proportion  share read count  due    reference        ∑  ≠     ⋅        taxon   taxa   ⎧ ⎨ ⎩  …  ⎫ ⎬ ⎭ ≠   glm  define   identity link function   linear relation  components hold  explain  observe map count however   set  discrete count  error epsilon  define  follow  poisson distribution  expect  observe  overdispersion   abundance estimate within  sample  ambiguity correction   model supplementary material    contrast  measurements  replicate sample  may display overdispersion  motivate  negativebinomial assumption anders  huber   glm  internally solve   iteratively reweighted least square  find  maximum likelihood estimate refer   true abundance estimate    taxon  along   abundance estimate standard errors  compute  report  range  accuracy  reliability   abundance estimate  pvalues  give   taxa estimate   measure  significance  case  high uncertainty   presence   crucial amount  taxa within  select set  reference  application   implement filter  possible thereby pvalues   set threshold commonly  value    estimate   minimum number  assign read  use  indicators  falsepositive estimate  filter step help  numerically stabilize  equation system  case  many absent taxa   reoptimization step  subsequently conduct  differential abundance   section  focus   compare metagenomics sample  objective   identify  taxa significantly change  abundance  one metagenome sample  another  well   hold  constant abundance   differential abundance assessment  similar strain  integration   variance   abundance estimate  crucial hence  place  directly compare abundance point estimate  taxa  sample  make use   estimate  well   standard errors first  comparison  different sample require account  potentially different number  total input read   number  input read   significant impact   compute abundances   standard error estimate  linear dependence  clearly noticeable see supplementary fig     agreement  theoretical derivations   glm framework  abundance count estimate  scale linear   number  read whereas  standard error scale quadratic  mean  accuracy  abundance estimate improve  increase number  input read  expect altogether  normalization factor  require   factor  nxny  correspondingly apply  sample     achieve  comparable base  sample   next step  integrate abundance estimate  correspond standard errors  infer  abundance distribution   taxon   sample    assume   unknown true abundance count   taxon underlie  poisson distribution  potential bias due  falsely assign read  taxa  correction  read ambiguities   glm model   expect  exceed  variance   poisson distribution   analytical approach   feasible    exact distribution  describe  practice   mixture  poisson distributions however  empirical approach   pursue   realize   twostep sample process   first step  define intervals  abundance estimate  ±  standard errors  boundaries   list taxon  use  scale unit  one standard error   reflect  uncertainty interval   expect  contain  abundance estimate subsequently potential abundance point estimate  uniformly sample   interval concurrently    sample value refer    value   poisson distribution   second step   taxon   potential     value   default setup  draw   correspond define poisson distribution  parameter   create one empirical distribution base   specific    taxon pool  empirical distributions create    different    assign   taxon result   overall empirical distribution comprise   poisson draw  default setup  refer    empirical abundance distribution   taxon  order  assess whether taxa show differential abundance  two sample  abundance distributions need   compare   rely  empirical distributions   analytical form  standard differential test  applicable yet   transfer  assessment  differential abundance   question   extent  correspond abundance distributions overlap clearly separate distributions refer   significant abundance change   increase overlap point  smaller   significant difference measure  separation   distributions  implement  randomly draw pair  value  either distribution  difference within  pair  compute  yield  overall distribution  differences   result thereby  location   zero value relate   distribution  differences  meaningful  zero value move towards  center   distribution reflect  higher previous overlap  correspond   less significant abundance change  empirical pvalue  correspondingly infer  determine  quantile   zero value within  distribution  case  taxon   detect within one sample  absent     single abundance distribution   taxon  test   userdefined threshold correspond   minimum read count  latter test yield  significance  taxa presence   one sample generally pvalues  calculate individually   taxa consider   sample  comparison either  assess differential abundance  taxa present   sample   infer new appearance  taxa   one sample thus pvalues need   adjust  multiplicity   perform   method  benjaminihochberg benjamini  hochberg   final report  provide list  taxa test  differential abundance along  normalize abundance estimate   sample log2 fold change  adjust pvalues  implementation ditasic  implement  python3   version ≥    available     link webpage  user manual provide easy guidance   three main command ditasic  base   flexible design  allow  integration  map algorithms  read simulators  choice  implementation use  current state   art pseudoalignment algorithm provide within  kallisto framework bray       individually call   command kallisto pseudo   prerequisite  overall index  build  select reference sequence use  generate tsv   file format  extract  map count   contigs  merge  accord  genomes  allow circumvent  use  large sam file  read simulators need   optimally adapt  capture  read characteristics   mason simulator holtgrewe  serve  default",-0.21771211810410024,0.20666910852991466,0.12877075234118318,0.24148557502477336,-0.0462870194519007,-0.05619989049248718,-0.1048490612743072,-0.006007746445311986,-0.02352844362719617,0.1225983887325562,-0.01907098971546517,-0.06397013689536568,0.15428239922583906,-0.09849255042120712,0.1380923906858122,-0.04222147486860428,0.04316119827851311,0.22197814564388288,-0.0547004106691654,0.06469223182328011,0.014047015534389185,-0.2634597867816994,0.05550545300154118,-0.007866865045758425,-0.03802154392747362,-0.2118123943276635,0.11211185614837957,-0.16808949342817753,-0.07408750493494888,-0.05820799019276336,-0.01538393788804394,0.2281791834280839,-0.20522024020421267,-0.0916091527750314,0.17083642943810304,0.07826758556627593,0.10010820921647166,0.022812691286906876,-0.1165107520446694,-0.14475953652066342,-0.1269346075961281,-0.13322656008405845,-0.05192432844564917,-0.09139353484427984,-0.184949999607762,-0.006280871431573952,0.16701891505877153,-0.11805224560955198,-0.2624332841566909,-0.384835272241937,0.202961972321452,-0.005504534853496289,0.08580996229798199,0.6403713715869352,0.04152421149843877,-1.1772993597975256,0.11656838517834715,-0.2369984801476309,0.9623032204892248,0.17474804351783418,-0.1674461750536324,0.3225294884475837,-0.13179115471622369,0.0420874402933079,0.6109589833633786,0.01880394568492727,0.020982053163333226,0.025116174456817224,0.20981865930403024,-0.16202335266402812,-0.05065264805699213,-0.03864086137223698,0.08983332631984563,-0.1251396718699861,0.2368466235522113,-0.06490025427085648,-0.12823238197282605,-0.181765753415268,-0.3805798068070152,-0.06216700587062798,0.18988850382647965,-0.011587913352205768,-0.3865736303641674,-0.0673533352672917,-0.8701631116061344,0.06647638608936494,0.17460837485823422,-0.13592007154697092,-0.12367959933912427,-0.08996820009213129,-0.24082457750310504,0.08580372621232661,-0.1334453961781254,-0.08443197231385173,-0.0807702800113742,-0.07148198385342716,-0.1162686291966724,-0.3279560442157346,0.31474394494723185,0.13066976700563393,AbundanceEstimation,6
144,144,"fastviromeexplorer  pipeline  virus  phage identification  abundance profile  metagenomics data
  increase   availability  metagenomic data generate  next generation sequence    urgent need  fast  accurate tool  identify viruses  hostassociated  environmental sample   paper  develop  standalone pipeline call fastviromeexplorer   detection  abundance quantification  viruses  phages  large metagenomic datasets  perform rapid search  virus  phage sequence databases  simulate  real data  human microbiome  ocean environmental sample  use  validate fastviromeexplorer   reliable tool  quickly  accurately identify viruses   abundances  large datasets
fastviromeexplorer write  java  two main step   read map step   read  map   reference database    filter step   map result  subject  three major filter detail later  output   final result  virus type  abundances  input   read alignment step  raw read singleend  pairedend  fastq format fastviromeexplorer use  reference database download  ncbi contain  refseq viral genomes  default   also use  update  customize databases  reference fastviromeexplorer incorporate  reference database   input parameter   user  use  database   choice  input  precomputed kallisto index file generate    genomes  distribute   first fastviromeexplorer call kallisto bray      subprocess  map  input read   reference database kallisto  develop  map rnaseq data   reference transcriptome   transcripts   genome leverage  pseudoalignment process  estimate  abundance   transcripts use  expectationmaximization  algorithm dempster laird  rubin      actual sequence alignment   entire read   reference sequence  pseudoalignment process enable read map    lightweight  superfast essentially kallisto search  exact match   short kmer default size     metagenomic read   sequence   virusphage database  example kallisto  able  map  quantify  million pairedend rnaseq read   human transcriptome sample  less   min   small laptop computer   ghz processor bray     addition   ultrafast speed kallisto also give accurate estimation  abundance   transcript  reference sequence schaeffer    soneson    consequently kallisto could provide  ideal tool  detection  quantification  viruses  metagenomic sample  commonly  tens  millions  read map   use commonly use program   blast   timeconsuming  often infeasible without computer cluster therefore fastviromeexplorer deploy kallisto   purpose  read map  abundance estimation   viruses since kallisto search  exact match   short kmer default size     metagenomic read   sequence   virusphage database     match  find   virus  detect  multiple hit occur  kallisto use   algorithm  help resolve  redundancy  quantify  abundances   detect viruses  kmer size  kallisto   alter depend  users need  example   sample  expect  contain viral sequence   divergent     reference database  kmer size   reduce  improve detection sensitivity   first alignment step fastviromeexplorer take  output  kallisto  include information   align read together  estimate abundances  estimate read count    identify viruses   process   second step  second step filter  output   first step use three criteria introduce  ensure  quality  virus detection  especially  reduce  number  false positive viruses   result  detail  first criterion hereafter refer   “”  base   ratio   observe extent  genome coverage   expect extent  genome coverage compute  equation             observe extent  genome coverage   map read compute  equation              actual length   genome   support  cover   map read     length   genome    expect extent  genome coverage assume  poisson distribution   map read along  genome  therefore equation              number  map read   genome    read length     length   genome   virus     fastviromeexplorer discard  virus  criterion  motivate   observation   viruses detect   tool   read map   repeat regions   genomes  example  analyze  fecal sample  lee     find    bean  virus nc_032111   read  map  one particular region   genome       see fig  analyze  region use repeatmasker smite hubley  green  reveal     simple repeat region  fall   class  alu elements   virus  truly present   sample  expect read   map     repeat region  also  regions   genome therefore find  virus  likely  artifact cause   prevalence  repeat regions instead  real biological signal   read   map   repeat region  observe coverage   virus genome   expect   much lower     result   low   impose  cutoff   determine base   empirical analyse viruses   read map   repeat regions get filter   second criterion require  ≥     virus       discard  criterion require   map read  cover  least    viral genome manual inspection   result   tool reveal   large viruses may  several repeat regions   genomes    result though   read  map   repeat regions   map  different repeat regions   case  difference     may  small  therefore    high enough  pass  first filter however    likely   result  simply  artifact  repetitive sequence  example  analyze  fecal sample lee     find  pandoravirus dulcis nc_021858   large virus     several repeat regions    read  map    repeat regions see fig  hence  alleviate  artifact  ≥   use   second filter  repeat regions   virus usually cover less     genome philippe      virus  cover       read   reasonable  assume   read   merely  repeat regions  thus  virus   consider   result  third criterion  base   number  map read  extensive empirical analysis  inspection   result   tool show    small viruses    read  enough  cover  good portion   viral genome result  high     pass criteria     example   fecal sample lee      analyze four read  map  rise rosette virus rna3 nc_015300   viral sequence     four read  length    enough  pass criteria        handful  read  map   likely   virus  false positive    stringent fastviromeexplorer apply  third filter require  number  map read   greater    therefore discard  ones      apply   filter fastviromeexplorer output  final result  contain  list  identify viruses   give sample along   estimate read count  abundance  taxonomy   viruses  output list  sort   abundance    abundant viruses   top   list   worth note   three criteria  introduce  improve  virus detection specificity  alleviate artifacts cause  factor   repeat sequence  low genome coverage  actual cutoff value       base   empirical experience  literature observation however depend   specific study   need  users  cutoff value use  might   suitable  allow flexibility  customization fastviromeexplorer incorporate  three filter  parameters   users  easily adjust  value  adapt    study  example users  deploy  stringent criteria  set higher value        default  get  “high confidence” set  viruses   lower  value  increase sensitivity  detect divergent viruses  viral read  metagenomic data  coverage may  expect    uniform solonenko    fastviromeexplorer  run   simulate  real data  examine  run time  accuracy fastviromeexplorer use kallisto version   default settings  generate pseudoalignment result  sam format  filter abundance result   tabdelimited file  abundance result contain identify virus name ncbi accession number ncbi taxonomic path  estimate read count fastviromeexplorer  run  two different reference databases  default database distribute together  fastviromeexplorer    ncbi refseq database contain  genomes  eukaryotic viruses  phages   set  sequence collect   jgi “earth virome” study paezespino    contain  metagenomic viral contigs mvcs  taxonomic annotation  host information   mvcs  collect   imgvr database paezespino     addition   challenge  map     millions  metagenomic read tool   accurate identification  quantification  viral genomes must also  capable  handle evergrowing reference databases  viral sequence  order  measure   index step  kallisto scale  reference databases  different size kallisto  apply  index five different databases three databases  generate  ncbi refseq viral database one contain  phages  phage genomes one contain  eukaryotic viruses  eukaryotic virus genomes  one contain  phages  eukaryotic viruses  viral genomes   two databases  create  sequence collect  paezespino    one contain    mvcs    contain half   mvcs  time analysis  kallistos index step  produce   linux base cluster   cpus    ram  index step  run use default kmer size   default number  thread   precomputed kallisto index file   full  mvcs  jgi  available    evaluate  performance  fastviromeexplorer  compare speed  accuracy  viromescan  recently develop virus annotation pipeline  call bowtie2   subprocess  read map   show    time faster  previous tool rampelli    viromescan  run  default settings    eukaryotic dnarna virus database contain  genome sequence  largest reference database provide  viromescan    custom database consist    mvcs  jgi viromescan generate alignment result  abundances  viruses  family genus  species level  also run blastn version ncbiblast  use   ncbi refseq viral database   large jgi database blastn  generate  alignment result  text format   time analyse  calculate use elapse real time  unixs time command  examine  virus detection  quantification accuracy  fastviromeexplorer simulate metagenomic data  use  randomly select collection  genomes contain  virus genomes   bacteria genomes  obtain  ncbi refseq database four pairedend read datasets  contain one million read  length    generate   genomes use  read simulator wgsim     datasets  read   viruses    bacteria  four datasets  generate use  sequence error rate       mutation frequencies respectively viromescan  blastn  also apply   four datasets  viromescan use eukaryotic viruses   reference database  comparison  fastviromeexplorer  blastn  run   reference database contain  ncbi refseq eukaryotic viruses viromescan  run   eukaryotic virus database provide  viromescan   default set viromescan remove   map read   quality filter  trim step trimbwastylepl script    produce  result therefore   run without viromescans quality filter  trim step   grind truth   alignment   read recall precision   score  calculate use  follow formula equation          equation          equation           examine  run time  performance  fastviromeexplorer  detect viruses  real data  fecal metagenomics datasets describe  lee     download  ncbi   accession number srp093449  annotate   fastviromeexplorer  viromescan  study track bacteria colonization   fecal microbiota transplantation fmt experiment   analysis  metagenomic data  examine   virusesbacteriophages  affect   transplantation  reanalyzed  four fecal metagenomic sample collect   healthy donor  three sample   recipient patient suffer mildmoderate ulcerative colitis  three sample   recipient  collect prior  fmt four weeks  fmt  eight weeks  fmt respectively   read  illumina pairedend read    read length seven data set  different size         million read  also generate   sample  annotate  fastviromeexplorer  viromescan  compare  run time  large datasets  examine  effect   reference database  result fastviromeexplorer  apply   sample use two different reference databases fastviromeexplorers default reference database   set   mvcs collect   study paezespino     use  ncbi refseq database  reference  linux base laptop  intel core i53230m cpu @  ghz *  processors    ram  use  produce  result   use   mvcs  reference  linux base cluster   cpus    ram  use  produce  result  use  cluster  one thread  use  run  tool  examine  applicability  fastviromeexplorer  environmental sample  ocean water metagenome file describe  aylward     download  ncbi sra   accession number srx2912986  analyze  fastviromeexplorer  metagenome sequence file  around  million pairedend read    mvcs collect   study paezespino     use  reference database   original study focus  ocean virome  viral contig set collect  global ocean virome gov study roux     also use  reference database  gov contig set contain  epipelagic  mesopelagic viral contigs   precomputed kallisto index file   viral contig set  available  ",-0.18871819410920326,0.22346048846272992,0.1229685545053654,0.0665203065427451,-0.0340525164015639,-0.02600560284855853,-0.09241393976171784,0.032224934185245344,-0.014058273440432322,0.09738451208943218,0.021174008226208088,-0.002666648205846341,0.1445573140155101,-0.11017097992402734,0.13497741486271694,-0.03343135578811121,0.07219693555765361,0.169380311460316,-0.02277549702077865,0.0958062881849132,-0.0449913611398248,-0.2351667316412609,0.05783859326013581,0.02028968133659519,-0.0088224263843827,-0.11240930203846963,0.04355723363680394,-0.1261437057659062,-0.028808741362135244,-0.02699590975364343,-0.000625736140935209,0.2516221790031053,-0.1737884617565405,-0.03177532119832522,0.1988981542281824,0.08981455195290326,0.03990226389233988,-0.011137928610903907,-0.08041735380669612,-0.09998733719934988,-0.11568128161487068,-0.14855239801378686,-0.10696987336792144,-0.1205872122524406,-0.1194029568998159,-0.002988808194877843,0.1021074050499228,-0.184848877504105,-0.1716145450655397,-0.3571232200487531,0.17412550544141386,0.008853515898332706,0.03878140228721203,0.5335106131046357,0.022458858121928358,-1.0977806021166243,0.02547161342432559,-0.19162508180564414,0.9557540147137537,0.17718445283285494,-0.1329419469110976,0.3450724233554605,-0.061296263363659065,0.05612823872565745,0.5607104610374528,0.03366534535950588,0.018255283191054263,0.005163960892715086,0.2320132462942985,-0.16107621735756586,-0.04297593698334837,-0.015149786873676713,0.0910521762064664,-0.0955868259858045,0.19083205818727603,0.03127754070074148,-0.14664424426940406,-0.13155147182103047,-0.33482316281891783,-0.057633343669216935,0.2694887687714882,-0.026345365162057863,-0.41741610383335703,-0.053677124531173834,-0.8393633366889984,0.06883415004487271,0.23013800387001526,-0.14920516832974964,-0.122889143456675,-0.010690093327017513,-0.12593007378720894,0.102533556809609,-0.07417815696095102,-0.10170850423240074,-0.10626420765822032,-0.08669157397940283,-0.0925995917914523,-0.3099760282989113,0.3165696379903113,0.0493516462697494,AbundanceEstimation,6
145,145,"nearoptimal probabilistic rnaseq quantification
 present kallisto  rnaseq quantification program   two order  magnitude faster  previous approach  achieve similar accuracy kallisto pseudoaligns read   reference produce  list  transcripts   compatible   read  avoid alignment  individual base  use kallisto  analyze  million unaligned pairedend rnaseq read   min   standard laptop computer  remove  major computational bottleneck  rnaseq analysis
index construction  construction   index start   formation   color  bruijn graph15   transcriptome   color correspond  transcripts   color transcriptome  bruijn graph  node correspond   kmer  every kmer receive  color   transcript  occur  contigs  define   linear stretch    bruijn graph   identical color  ensure   kmers   contig  associate    equivalence class  converse   true two different contigs   associate    equivalence class   graph  contigs   construct kallisto store  hash table map  kmer   contig   contain  along   position within  contig  structure  call  kallisto index  errorfree read     difference   equivalence class   read   intersection   kcompatibility class    read  length     happen    two transcripts          kmers occur  different order   unlikely  happen  large    would imply   tdbg   direct cycle shorter        fact also provide  criterion    test pseudoalignment read  pseudoaligned  look   kcompatibility class   kmer   read   kallisto index   intersect  identify kcompatibility class   case  pairedend read  kcompatibility class lookup     end   fragment    result class  intersect since  tdbg identify  kmer   reverse complement  kmer hash  kallisto  strandagnostic however  implementation could also  adapt  require specific strandedness  read  strandspecific protocols   speed   process kallisto use  structural information store   index   kmers   contig   tdbg    kcompatibility class  would  redundant  include   one kmer   contig   intersection  kcompatibility class  observation  leverage  kallisto  find  distance   junctions   end   contig  time  kmer  look  use  hash   read  arise   transcript   tdbg  kmers    distance   skip without affect  result   intersection result  fewer hash lookups  help ensure   read  consistent   tdbg kallisto check  last kmer   skip  ensure  kcompatibility class  equal  expect  rare case     mismatch kallisto default  examine  kmer   read   majority  read kallisto end  perform  hash lookup   two kmers supplementary fig   pseudoalignment   require  make use   locations  kmers  transcripts   possible  extract  data   tdbg   “pseudobam output” option  kallisto take advantage    produce  alignment file contain position  read within transcripts  pseudobam   possible  examine  location  read within transcripts  genes  interest  quality control  analysis purpose quantification  order  rapidly quantify transcript abundances  pseudoalignments kallisto make use   follow form   likelihood function  rnaseq  equation     set  fragment    set  transcripts    effective length3  transcript   yft   compatibility matrix define    fragment   compatible     otherwise  parameters     probabilities  select fragment  transcripts  likelihood   rewrite   product  equivalence class   similar summation term   factor together   factorization  number    number  count observe  equivalence class   equation   write  term   equivalence class  equivalence class count  sufficient statistics  thus   computations  base   much smaller set  data usually hundreds  thousands  equivalence class instead  tens  millions  read  likelihood function  iteratively optimize    algorithm  iterations terminate   every transcript  αtn      total number  fragment change less    iteration  iteration  transcript abundances  output  kallisto  transcripts per million9 tpm units bias correction   many source  bias  rnaseq  previous work  identify sequencespecific bias12  particularly problematic sequencespecific bias arise   result  nonrandom prim  fragment   nucleotide sequence   ′  ′ end affect  probability  sample  kallisto correction  similar    roberts   however  use mers   transcript sequence overlap  ′ fragment start   upstream   fragment first kallisto measure  empirical frequency  mers  estimate   first  million pseudoalignable read  apply  bias correction  use  initial estimate   abundance use  round    algorithm  bias  mers  use  adjust  effective length   transcript  add  bias   mer   strand  account  edge effect kallisto  add  mers   start    length   transcript minus  average fragment length  process  repeat     update expression estimate   round    algorithm bootstrap  bootstrap  highly efficient  kallisto     algorithm   fast    sufficient statistics   model   equivalence class count  latter fact mean  bootstrap sample    rapidly generate  pseudoalignment   fragment  complete    original fragment   categorize  equivalence class generate  new bootstrap sample consist  sample  count   multinomial distribution   equivalence class   probability   class  proportional   count   original data  transcript abundances   new sample   recomputed use   algorithm  kallisto  number  bootstrap   perform   option pass   program    large amount  data   produce  output  compress  hdf5  hdf5 file   read  another program  process  example     convert  plain text use kallisto",-0.20421411734772849,0.20818933028106887,0.13229999006104967,0.1623038341042896,-0.04139870756189338,-0.01822411556864002,-0.09142045493451102,0.08638860777175675,-0.034484860069739325,0.11797144842644533,0.04050659322179854,0.001471842802129686,0.16181950997570918,-0.09208505541241416,0.17631240476844445,-0.04787299436701384,0.033919740354176615,0.20897597410609406,0.030912295223679394,0.05548129303439055,0.027655129208384702,-0.22876921683346155,0.0614788593739892,0.016478538444110503,-0.00231029662458847,-0.2276702892081812,0.08216506412087862,-0.17312461948332689,-0.044897889668063726,-0.09661933010812694,0.00929947743192315,0.2577252809967225,-0.18101147556381567,-0.11817260821718567,0.15627421853569104,0.09512969638570212,0.06945471457283323,0.011768797716746729,-0.07013372694607824,-0.11802607439768813,-0.08466937747318297,-0.1685345775303237,-0.07495433678404273,-0.1076589382342839,-0.14971549719009394,-0.021471640036130942,0.12342262088010708,-0.20322088181817285,-0.23669878788214802,-0.38089205356896855,0.20002741972915827,-0.009954718907829374,0.07640231822462132,0.6277555934588115,0.02459037278662436,-1.2020198768253127,0.03493351756905516,-0.21095169027335944,1.045885427792867,0.1998899886526245,-0.1987729761521526,0.288426375669272,-0.0789705887887006,0.06941168576944619,0.6175605281023309,0.054973676062266656,0.034506705135572704,0.004703082957615455,0.2290422509222602,-0.18810430072247986,-0.11395409999327967,-0.03833179558472087,0.12032462719701775,-0.13327382773646002,0.2714777284736435,-0.05156326116838803,-0.11644845587123805,-0.1687881904781049,-0.3546191515858906,-0.09125011268576297,0.23982751449361486,-0.052684194422521015,-0.4265157848032929,-0.06918812364106998,-0.887285128692165,0.117665287667575,0.2512762203610813,-0.19635336125424752,-0.08809058367274701,-0.06079213394414789,-0.2070482275572916,0.13014172550523653,-0.1563014673977159,-0.09899414552375674,-0.12547314937692136,-0.11818513386611205,-0.04055941070429981,-0.29550622461674114,0.32460668004117904,0.1060554038368476,AbundanceEstimation,6
146,146,"metagenomic abundance estimation  diagnostic test  species level
one goal  sequencingbased metagenomic community analysis   quantitative taxonomic assessment  microbial community compositions  particular relative quantification  taxons   high relevance  metagenomic diagnostics  microbial community comparison however  majority  exist approach quantify  low resolution   phylum level rely   existence  special genes     severe problems discern species  highly similar genome sequence yet problems  metagenomic diagnostics require accurate quantification  species level  develop genome abundance similarity correction gasic  method  estimate true genome abundances via read alignment  consider reference genome similarities   nonnegative lasso approach  demonstrate gasics superior performance  exist methods  simulate benchmark data  well   real data  addition  present applications  datasets   bacterial dna  viral rna source   discuss  approach   alternative  pcrbased dna quantification
 gasic workflow  depict  figure     referencebased methods  read  first align  every genome   set  reference   number  read match   genome  count  call  count  observe abundances  oppose   abundance estimate   want  obtain   end   next step gasic construct  similarity matrix encode  alignment similarities   reference sequence  similarity matrix   observe abundances   use together   linear system  equations  gasic solve   correct abundances use  constrain optimization routine  obtain  estimate  whole procedure   iterate use bootstrap  sample   original dataset  yield  stable abundance estimate  provide  intuitive nonparametric statistical test   presence   species figure  gasic workflow metagenomic read  first align   reference genomes  match read  count   genome observe abundances gasic  use  reference genomes  construct  similarity matrix encode  genome similarities  consider influence   apply sequence technology  similarity matrix   observe abundances  use   linear system  equations  model  influence  reference genome similarities  read alignment gasic solve  system  equations use  constrain optimization routine  calculate  estimate true abundances   reference genomes   dataset bootstrapping   read deliver stable abundance estimate  allow gasic  test   presence   species   dataset open  new tabdownload slide gasic workflow metagenomic read  first align   reference genomes  match read  count   genome observe abundances gasic  use  reference genomes  construct  similarity matrix encode  genome similarities  consider influence   apply sequence technology  similarity matrix   observe abundances  use   linear system  equations  model  influence  reference genome similarities  read alignment gasic solve  system  equations use  constrain optimization routine  calculate  estimate true abundances   reference genomes   dataset bootstrapping   read deliver stable abundance estimate  allow gasic  test   presence   species   dataset  first introduce  notation    use   follow start   experiment side  sequence dataset  denote   contain  read  total  read may originate   set   species forumla  know reference sequence  possibly   source noise contaminants   relation   species   forumla  synonymously use    species   well   reference sequence  quantification  species  use  term abundance    number  read belong   species divide   total number  read  due  amplification bias  abundance may  represent  true absolute abundance   species   data  may  valuable  compare abundances  multiple  particular similar species alignment  read    align   species    alignment method suitable   characteristics     count  number  read forumla     successfully align  forumla irrespective   number  match position  forumla  match   species  particular  neither restrict   unique match   assume  phylogenetic structure within  forumla     example  megan   dataset  contain  dissimilar species  read count forumla may already  suitable estimate   true abundances otherwise  forumla   general highly disturb  dominate  share match    forumla cannot directly  use  abundance estimate similarity estimation  proper similarity estimation   reference sequence  require  achieve accurate similarity correction   forumla  similarities  sequence  encode   similarity matrix forumla  forumla denote  probability   read draw  forumla   align  forumla  practice  simulate  set  read  every reference forumla   read simulator   able  imitate  sequence technology  error characteristics    example mason   grinder  simulate illumina   sanger read  dwgsim sourceforgenetprojectsdnaa simulate illumina abi solid  iontorrent read   align  simulate read  forumla  forumla use    settings   align  read  dataset   count  number  match read forumla  matrix entries   estimate  forumla  key element  similarity estimation   proper read simulation since  use  simulate read  estimate  reference genome similarities  source  ambiguous alignments thus  simulate read    read characteristics   error characteristics   instrument read length pairedsingle end etc   cover  reference genome  least    complex metagenomic communities   high number  species   calculation   complete similarity matrix may become infeasible    computational complexity forumla  recommend  first estimate similarities use  example fast kmerbased methods   refine  estimate via  simulation approach   genomes  sufficiently high  forumla similarity similarity correction  introduce  linear model  correct  forumla   genome similarity use  similarity matrix  let forumla denote  true  unknown abundance  species forumla   assume   observe abundance forumla   mixture   true abundances forumla   species forumla weight   estimate probability forumla   read     align   formula  simplify notation  use  matrix representation   true   observe abundances  forumla  forumla  matrix notation    write  formula since direct inversion   matrix  may result  instable abundance estimate  formulate  solution     nonnegative lasso  problem formula formula  constraints enforce  result   meaningful   estimate relative abundance forumla must  equal   greater  zero   sum   relative abundances must  less   equal  one  first condition also ensure   correction produce abundances lower   equal   measure abundances  last condition allow  presence  read   totally unrelated species since  abundances  allow  sum   less   equal  one  also enforce  sparsity  result    meaningful contributions  abundances larger    solve  constraint optimization problem   cobyla method implement  scipy wwwscipyorg error estimation  test  apply  bootstrapping procedure   step describe  first  estimate  errors   input data propagate   correction algorithm  second  calculate pvalues  test   presence   species   sample   end  generate  bootstrap sample   dataset   perform similarity correction   sample separately yield  distribution forumla  abundances   species   calculate  average abundance forumla  estimate  standard error forumla  test whether  species  present   sample  count  many bootstrap sample yield  higher abundance    priori define detection threshold  formula quality check   composition   reference genome set  critical   complete method gasic offer  additional quality check   alignment  reference genomes  quality check step analyse  output sam file   read alignment tool  provide helpful statistics   user  judge  appropriateness   result besides report statistical measure    number  map read   average genome coverage gasic generate  coverage histogram  often allow  user  exclude certain genomes   reference set   detect possibly important miss reference genomes  example  high number  uncover base  combination   typical poisson distribution  higher coverage may indicate   consider species   contain   dataset   closely relate species  addition   statistics   histogram gasic produce warn message  critical setups    dataset may   small  abundance estimation  large part   genome   cover although   evidence   genome   dataset technical detail  implement gasic   python program language wwwpythonorg make extensive use   high performance scientific compute libraries scipy  numpy wwwscipyorg since gasic  independent   choice   alignment algorithm  read simulator  already integrate interfaces   set  tool  user  add custom interfaces easily  brief manual  provide within  code  set value  comprehensible  welldocumented code   gasic  easily  adapt   users need without deeper knowledge  python gasic require  widespread sam alignment format   output   alignment tool  analyse  result since  alignment tool either directly support sam output  alignment result   readily convert  sam file",-0.22018885939605728,0.2075758352328588,0.15164365391727225,0.193065919170482,-0.0692551468678947,-0.0241958209838613,-0.1450486235697778,0.012127581814880904,-0.0037828148652704592,0.17260416048304142,-0.049854182762242176,-0.07635270614619549,0.15872003576925264,-0.12154416607248453,0.15690116252806086,-0.014909074512886629,0.06278940377904069,0.22448243242185428,-0.03036572905372848,0.09898142067243786,-0.036593114848653456,-0.2513511788063377,0.0827929188557244,-0.050049796494395116,-0.0762659079497364,-0.21771046674905184,0.11072373517517514,-0.18119811621757814,-0.07677234094244959,-0.050048976286483735,-0.022962513866690883,0.26651235923350985,-0.2505827026300201,-0.08033122102181031,0.2293340156582645,0.09804907646249036,0.06384038436044172,0.011392519714471257,-0.0935484401356762,-0.1605746754701675,-0.15079139569268488,-0.11177328711808124,-0.09279975558217134,-0.12048426475655533,-0.21383855831456752,-0.03028564828342525,0.17121053253502316,-0.14309892653504036,-0.27637808708906875,-0.3839007054784459,0.21530137746454267,0.03437510060873515,0.07614891410789479,0.6182082150962481,0.05060146812774489,-1.211109784212299,0.09583541360597417,-0.2529524934364729,1.0438176760007445,0.1674159331061493,-0.1636790722519963,0.2878750847563191,-0.10271936896325187,0.04013138846372675,0.667573729528761,0.020040165977117875,0.048478755495369966,-0.01941798467860209,0.21083420325292807,-0.19436458140665144,-0.08766096013234308,-0.01427076642461396,0.1396184335189948,-0.12584291214266835,0.21535489244013292,-0.059610588716795324,-0.16807961023130574,-0.17500172761802665,-0.4210055786841019,-0.07685870852159682,0.20626420673310747,-0.015533747583416148,-0.4246266403710579,-0.07342073210185593,-0.967010260172682,0.11607460379260096,0.2475398441061728,-0.13508336551634256,-0.1859404235593756,-0.08515381255463997,-0.18486692996661594,0.06861116043073137,-0.13463129610791025,-0.07811800504587202,-0.05142232541618905,-0.08117780518716848,-0.1414521466502944,-0.3912539588993867,0.29775335288767074,0.11715463469961206,AbundanceEstimation,6
147,147,"salmon accurate versatile  ultrafast quantification  rnaseq data use lightweightalignment
transcript quantification   central task   analysis  rnaseq data accurate computational methods   quantification  transcript abundances  essential  downstream analysis however  exist approach  much slower   necessary   degree  accuracy  introduce salmon  novel method  software tool  transcript quantification  exhibit stateoftheart accuracy   significantly faster    tool salmon achieve    combine application   twophase inference procedure  reduce data representation   novel lightweight read alignment algorithm
salmon consist  three components  lightweightalignment model  online phase  estimate initial expression level  model parameters  construct equivalence class   input fragment   offline phase  refine  expression estimate  online  offline phase together optimize  estimate   latent parameters    method  compute  directly   parameters  online phase use  variant  stochastic collapse variational bayesian inference   offline phase apply  variational bayesian  algorithm    reduce representation   data represent   equivalence class   datadependent convergence criterion  satisfy  overview   method  give  figure    describe  component   detail  figure  download figureopen  new tab figure  overview  salmons method  components salmon except either raw  align read  input perform  online inference  process fragment  alignments build equivalence class   fragment  subsequently refine abundance estimate use  offline inference algorithm   reduce representation   data  lightweightalignment  key computational challenge  infer relative transcript abundances   determine  potential locioforigin   sequence fragment  make  optimization tractable  position cannot  consider however   sequence   fragment  substantially different   sequence   give transcript   particular position    unlikely   fragment originate   transcript  position —  position    probability truncate      omit   optimization determine  set  potential locioforigin   sequence fragment  typically   align  read   genome  transcriptome use tool like bowtie2  star   hisat   salmon  process  alignments generate   tool    give  respect   transcriptome  provide another method  determine  potential locioforigin   fragment directly use  procedure   call lightweightalignment  main motivation behind lightweightalignment   achieve accurate quantification  transcript abundance  rnaseq data   require know  optimal alignment   sequence fragment   transcript  every potential locus  origin rather simply know  transcripts  position within  transcripts match  fragment reasonably well  sufficient formally  define lightweightalignment   procedure  give  transcripts    fragment  return  set  tuples     {ti1 pi1 si1 …}  tuple consist   elements  transcript ′  position ′ within  transcript   score ′  summarize  quality   match    ′  position ′  describe   lightweightalignment approach   single read  extend naturally  pairedend read  look  lightweightalignments  read pair   appropriately position    transcript salmon attempt  find  chain  supermaximal exact match smems  maximal exact match mems  cover  read recall  maximal exact match   substring   share   query read  reference transcript  cannot  extend  either direction without introduce  mismatch  supermaximal exact match    mem    contain within   mem   query salmon attempt  cover  read use smems differences — whether due  read errors  true variation   sample  sequence   reference —  often prevent smems  span  entire read however one  often  able  find approximatelyconsistent colinear chain  smems   share   read  target transcripts  chain  smems   collection  tuples   {   … }      position   query read    position   reference transcript     length   smem  ∑            say   chain  consistent —  space   location  smems   query   reference     instead  require  ∑            say   chain  approximately consistent  δconsistent consistent chain  deal   substitution errors  mutations  δconsistent chain  also account  indels figure  show  example figure  download figureopen  new tab figure   δconsistent chain  match cover  read   coverage score   chain  embed image  embed image   discussion    term  smems  chain construct  salmon typically consist   mix  smems  mems    like bwamem  salmon break smems    large  default greater   time  minimum require mem length  prevent   mask potentially highscoring mem chain  order  salmon  consider  read  match  transcript locus sufficiently well  must   δconsistent chain   read   transcript sequence begin   locus  cover  userspecified fraction   read   default use  procedure salmon implement lightweightalignment  find   fragment   transcript position pair ′ ′  share  δconsistent chain   cover  least fraction    fragment  score ′   lightweightalignment  simply  fraction   fragment cover   chain salmon search  smems use  fmdindex  specifically salmon use  slightlymodified version   bwa  index replace  default sparse sample   dense sample  improve speed  salmon  run  lightweightalignment mode one must  first prepare  index   target transcriptome   lightweightalignment    perform  salmon index  build use  index command  salmon unlike kmerbased indices   use  sailfish   kallisto   parameters  lightweightalignment   fraction   read require   cover   minimum length mems consider  chain   modify without rebuild  index  allow one  easily modify  sensitivity  specificity   lightweightalignment procedure without  need  recreate  index  often take longer  quantification  online phase  online phase  salmon attempt  solve  variational bayesian inference problem describe  section   optimize  collapse variational objective function  use  variant  stochastic collapse variational bayesian inference   inference procedure   stream algorithm  update estimate read count   every small group   call  minibatch  observations  pseudocode   algorithm  give  algorithm  algorithm  laissezfaire scvb0      popworkqueue   embed image   read  ∈         alignment         transcript involve  alignment          {  } ▹ add  contribution   local weight  transcript   end  ▹ normalize  contributions   alignments     alignment         transcript involve  alignment   embed image  end   sample  ∈   update auxiliary model use   end   embed image ▹ update  global weight  local observations    end   observation weight  minibatch    line   algorithm    increase sequence sequence     set     adhere   robbinsmonroe condition    represent  weight estimate count  fragment originate   transcript use  method  expect value     compute directly   use equation   employ  weak dirichlet conjugateprior  embed image    ∈   outline    scvb0 inference algorithm  similar  variants   onlineem  algorithm   modify prior  procedure  algorithm   run independently   many worker thread   user  specify  thread share  single workqueue upon   parse thread place minibatches  alignment group  alignment group  simply  collection   alignments   multimapping locations   particular read  minibatch  consist   collection   small fix number  alignment group    default  worker thread process one alignment group   time use  current weight   transcript   current auxiliary parameters  estimate  probability   read come   potential transcript  origin  process  minibatches occur  parallel    little synchronization  require   atomic compareandswap loop  update  global transcript weight   end  process   minibatch — hence  moniker laissezfaire  lack  synchronization mean   estimate      certain    uptodate value     use however due   stochastic  additive nature   update   little   detrimental effect   inference procedure   generic   type  alignments  process  may  either regular alignments  come   bam file  lightweightalignments generate  describe  section     entire minibatch   process  global weight   transcript   update  update  sparse   transcripts  appear   alignment  minibatch     global weight update      process  ensure     update   parameters    perform efficiently  stream determination  equivalence class   online phase   online phase  addition  perform stream inference  transcript abundances salmon also construct  highlyreduced representation   sequence experiment specifically salmon construct “rich” equivalence class     sequence fragment  define  equivalence relation   fragment let    {     ∈   }   set  transcripts    map   also  analogously compute use traditional alignments  say             relate  distinct notions  alignmentbased equivlance class   introduce previously    show  greatly reduce  time require  perform iterative optimization    describe  section  fragment   equivalent   group together   purpose  inference salmon build   set  fragmentlevel equivalence class  maintain  efficient concurrent cuckoo hash map   construct  map  associate  fragment           call  label   fragment   query  hash map      key     map  create  new equivalence class   label  set  count   otherwise  increment  count   equivalence class   label   find   map  efficient concurrent nature   data structure mean  many thread  simultaneously query  write   map  encounter  little contention  key   hash map  associate   value   call  “rich” equivalence class   equivalence class   retain  count      total number  fragment contain within  class  also maintain   class  weight vector    entries   vector   onetoone correspondence  transcripts    label   equivalence class   embed image   embed image   average conditional probability  observe  fragment   give    fragment   equivalence class since  fragment     exchangeable  pair   conditional probability   particular fragment   particular transcript need   maintain   follow series  equalities hold embed image thus  aggregate weight store   “rich” equivalence class give   power  consider  conditional probabilities specify   full model without   continuously reconsider    fragment    offline phase   offline phase salmon use  “rich” equivalence class learn   online phase  refine  inference give  set   rich equivalence class  fragment   use  expectation maximization  algorithm  optimize  likelihood   parameters give  data  abundances    compute directly     compute maximum likelihood estimate   parameters  represent  estimate count  number  fragment derive   transcript  embed image  embed image   write   likelihood  term   equivalence class    embed image  update rule  likelihood  hence  represent       optimize  apply  follow update equation iteratively embed image  apply  update equation   maximum relative difference    parameters satisfy embed image   embed image let ′   estimate   achieve convergence    approximate   embed image  embed image  variational bay optimization instead   standard  update      optionally perform variational bayesian optimization  apply vbem update     adapt    respect   equivalence class embed image  embed image      digamma function  upon convergence   parameters   obtain  estimate   expect value   posterior nucleotide fraction  embed image  embed image variational bayesian optimization   offlinephase  salmon  select  pass  usevbopt flag   salmon quant command  sample   posterior   convergence   parameter estimate   achieve   offline phase   possible  draw sample   posterior distribution use collapse blockwise gibbs sample   equivalence class sample   draw  iterate   equivalence class  resampling assignments   fraction  fragment   class accord   multinomial distribution define  hold  assignments    fragment fix many sample   draw quickly since many gibbs chain   run  parallel  due   accuracy   precede inference  chain begin sample   good position   latent variable space almost immediately  posterior sample   use  obtain estimate  quantities  interest   posterior distribution    variance   produce confidence intervals  salmon  pass  usegsopt parameter   draw  number  posterior sample    specify   numgibbssamples parameter",-0.20250459279208435,0.18435523274085264,0.12038435286507562,0.1860812852608615,-0.022768664137833586,-0.0007909357859093622,-0.11242312792646232,0.04091062814645766,-0.027879286663138245,0.1072738976363028,-0.0027779999952325268,-0.025467765640614055,0.18212240440237712,-0.10661696526936136,0.11760070444514892,-0.06318032212797285,0.031530078946648964,0.22188396077528824,-0.02676268396846729,0.06270704123073452,0.015489643097308547,-0.2462882041814023,0.04701332326936545,-0.038708239243840065,-0.01852659206929786,-0.16338017000572744,0.059477138589779086,-0.16577130071114146,-0.044933731619012485,-0.07755643287818814,-0.02587769454695544,0.2545961811753482,-0.2065489138131947,-0.09868356142065,0.17360699806294064,0.10277944280583114,0.07871292649072181,0.012010881963427844,-0.06315076068578886,-0.14436234170209106,-0.060393942361647565,-0.14941161312485754,-0.04638073814379701,-0.09198562751175618,-0.1350744951712558,-0.012103761243290215,0.11545926887612952,-0.13981564145533806,-0.19547892031166988,-0.3627814898764475,0.1714268369523519,0.043068287659394563,0.08220811695710838,0.620863790006771,0.05859534446436222,-1.1499301834933742,0.06623704556698562,-0.19848082382527155,0.9467967681640068,0.18683791855867832,-0.163281885849501,0.2662125307138617,-0.14247730107842765,0.034696134097268516,0.6321889148831771,0.025298923725626053,0.02439310175132441,-0.00782752230576723,0.17763661101957068,-0.18293426841093186,-0.07331532463204747,-0.0487721738598837,0.12569207861010845,-0.1229802316726292,0.23328416642793864,-0.04422557392588041,-0.14395165075319447,-0.178551116079551,-0.3606943450096789,-0.07859127165236393,0.18009051199072065,-0.046763403724106735,-0.3944772170807017,-0.060120702317534004,-0.8156224309327748,0.1013275175544639,0.20612626009028406,-0.13165937030901234,-0.11892031899385312,-0.07511153689655617,-0.23678730197578424,0.10105919054302756,-0.1252107495228188,-0.08952505765425647,-0.07412823014759319,-0.1142541003236852,-0.0720677063232602,-0.3073874603988363,0.2939493420375759,0.12118810507424126,AbundanceEstimation,6
148,148,"sailfish enable alignmentfree isoform quantification  rnaseq read use lightweight algorithms
 introduce sailfish  computational method  quantify  abundance  previously annotate rna isoforms  rnaseq data  sailfish entirely avoid map read  timeconsuming step   current methods  provide quantification estimate much faster   exist approach typically  time faster without loss  accuracy  facilitate frequent reanalysis  data  reduce  need  optimize parameters sailfish exemplify  potential  lightweight algorithms  efficiently process sequence reads
indexing  first step   sailfish pipeline  build  index   set  reference transcripts  give  kmer length   compute  index ikt contain four components  first component   minimum perfect hash function    set  kmers kmerst contain    minimum perfect hash function   bijection  kmerst   set  integers { kmerst  } sailfish use  bdz minimum perfect hash function9  second component   index   array  contain  count csi  every ∈ kmerst finally  index contain  lookup table map  transcript   multiset  kmers   contain   reverse lookup table map  kmer   set  transcripts    appear  index   product    reference transcripts   choice    thus need    recomputed  either   change quantification  second step   sailfish pipeline   quantification  relative transcript abundance  require  sailfish index ikt   reference transcripts   well   set  rnaseq read  first  count  number  occurrences    ∈ kmerst ∩ kmers   know exactly  set  kmers  need   count  already   perfect hash function    set   perform  count   particularly efficient manner even faster  efficient hashbased approach  example perform concurrent mer lookups use  thread jellyfish10 require  average   μskey   minimal perfect hash require  average   μskey  maintain  array    appropriate size kmerst   contain  number  time   thus far observe      unstranded protocol sequence read  hence  kmers  contain may originate  transcripts  either  forward  reverse direction  account   possibilities  check   forward  reversecomplement kmers   read  use  majorityrule heuristic  determine    kmers  increment   final array  count    number  kmers appear     forward direction   read  greater   number  reversecomplement kmers    increment  count  kmers appear   read   forward direction otherwise  count  kmers appear   reversecomplement   read  incremented   array  count tie  break  favor   forwarddirected read   strand rnaseq protocol  read   know orientation read provide  sailfish   specify  originate  unstranded forwardstrand  reversestrand read   appropriate kmers  count   case  take advantage  atomic integers   compareandswap cas operation provide  modern processors  allow many hardware thread  efficiently update  value   memory location without  need  explicit lock   stream   update  count    parallel  sustain  little resource contention   apply  expectationmaximization  algorithm  obtain estimate   relative abundance   transcript  define  kmer equivalence class   set   kmers  appear    set  transcripts    frequency   word let    vector   entry    give  many time kmer  appear  transcript ∈    equivalence class   kmer   give    {∈ kmerst    }  perform   procedure   allocate count  transcripts accord   set  equivalence class rather   full set  kmers   let denote  total count  kmers    originate  equivalence class   say  transcript  contain equivalence class      subset   multiset  kmers    denote    ⊆  estimate abundances via   algorithm   algorithm algo  alternate  estimate  fraction  count   observe kmer  originate   transcript estep  estimate  relative abundances   transcripts give  allocation mstep  initially allocate kmers  transcripts proportional   occurrences   transcript    transcript    potential origin   particular kmer   observations   kmer  attribute   transcript whereas   kmer  appear      different transcripts  occur  time   set  read  observations  attribute   potential transcript  origin  estep    algorithm compute  fraction   kmer equivalence class' total count   allocate   transcript  equivalence class   transcript   value  compute   ′   currently estimate relative abundance  transcript   allocations   use   mstep   algorithm  compute  relative abundance   transcript  relative abundance  transcript   estimate      variable ′ denote  adjust length  transcript    simply ′           length  transcript   nucleotides however rather  perform  standard  update step  perform update accord   squarem procedure11 describe  algo   ′  ′ ′   vector  relative abundance maximumlikelihood estimate  •   standard iteration   expectationmaximization procedure  outline  algo    detail explanation   squarem procedure   proof  convergence see ref  intuitively  squarem procedure build  approximation   jacobian  ′  three successive step along   solution path  use  magnitude   differences   solutions  determine  step size    update  estimate accord   update rule line   procedure   capable  make relatively large update   ′ parameters  substantially improve  speed  convergence  sailfish  iterative squarem procedure  repeat   specify convergence criterion  meet  default  procedure terminate   transcript   relative abundance greater     relative change greater  half   percent  consecutive iterations additionally  user may specify either  fix number  iterations  perform   require minimum relative change   transcript abundance estimate  squarem iterations   relative change  transcript abundance exceed    procedure  consider   converge   estimation procedure terminate bias correction  bias correction procedure implement  sailfish  base   model introduce  zheng   briefly  perform  regression analysis   set  potential bias factor   response variables   estimate transcript abundances kpkms sailfish automatically consider transcript length  content  dinucleotide frequencies  potential bias factor   specific set  feature  suggest  zheng     transcript  prediction   regression model represent  contribution   bias factor   transcript' estimate abundance hence  regression estimate  may  positive  negative  subtract   original estimate  obtain biascorrected kpkms   detail   bias correction procedure see ref   original method use  generalize additive model  regression sailfish implement  approach use random forest regression  leverage highperformance implementations   technique  key idea      bias correction  abundance estimation rather  earlier   pipeline  bias correction  sailfish   disable   nobiascorrection command line option finally  note    possible  include  potential feature like normalize coverage plot   encode positional bias   bias correction phase however   current version  sailfish    implement  test bias correction   feature compute kpkm rpkm  tpm sailfish output kmers per kilobase per million map kmers kpkm read per kilobase per million map read rpkm  transcripts per million tpm  quantities predict  relative abundance  different isoforms  rpkm estimate    commonly use   ideally  time  rate   read  observe   give position   tpm estimate  also become somewhat common6  sailfish  kpkm measure   natural  rpkm   kmer   basic unit  transcript coverage however  two measure  proportional give  relative transcript abundances estimate    procedure describe   tpm  transcript   give  let    number  kmers map  transcript    kpkm  give      total count  map  hashable kmers   final equality  approximate    replace   ′  kpkm  proportional   rpkm    estimate  replace    estimate number  read map  transcript      estimate number  map read    calculate   map kmer count   average read length  fragment per kilobase per million map fragment fpkm measure  also proportional   krpkm   mean  denote  fragment rather  read  mapped— single end data  read  fragment coincide  pairedend data  concordant read pair  consider  single fragment accuracy metrics   experiment  pearson correlation metric  compute  estimate  abundance   log transform   previous work6     prevent   abundant transcripts  dominate  correlations   necessitate discard sample   either  true  estimate abundance   spearman correlations  compute  estimate    log transform   synthetic data  additionally compute  root mean square error rmse  median percentage error give  vectors        groundtruth abundances         estimate abundances  rmse  define   percentage error    true abundance    correspond estimate   define  unlike  definition present   work12    define division    compute  percentage error   define  medpe   median   percentage error   transcripts    true abundance greater     median   value pexi     ≤  ≤    ≠   compare   qpcrbased abundances  use  kpkm estimate produce  sailfish  fpkm estimate produce  rsem cufflinks  express directly  fluxsimulator record  number  read   actually generate   transcript   simulate sequence experiment  read count   transcript lengths  use  compute  grind truth fpkms directly use equation  however  find   fpkm estimate compute  rsem express  cufflinks appear   number  transcripts   systematically inflate  respect   grind truth fpkms  inflation persist even  estimate  compare directly  grind truth relative transcript fraction  appear   due   effectivelength normalization procedures employ   methods indeed  cufflinks  run  noeffectivelengthcorrection  rmse  medpe decrease significantly   correlations  grind truth fpkms increase marginally  well thus   synthetic test  cufflinks result  compute   noeffectivelengthcorrection flag enable though rsem  express   expose   flag directly  compute fpkm estimate without effectivelength corrections   methods  use  estimate read count output directly   methods   true transcript lengths use equation  use fpkms compute   manner reduce  rmse      medpe      express  reduce  rmse       medpe      rsem sailfish compute  estimate kmer count  kpkms   consistent manner directly   underlie transcript abundances     difference   kpkms provide  sailfish    would  compute use  estimate kmer count directly simulate data  simulate homo sapiens rnaseq data  generate   flux simulator17    parameters list  supplementary note   result   dataset        pairedend read  read produce   flux simulator  group   origin  read originate    genomic locus appear together   read file however  synthetic artifact violate  assumption make  express  read  produce   random order thus  postprocess  read generate   flux simulator  shuffle   keep mat appropriately pair   random order  also randomize  orientation   read  simulate  unstranded protocol  shuffle matepair read   split  separate file  ensure  sufficient map rate   parameters use  produce alignments  express  cufflinks    bowtie     tophat22  synthetic read  quality trim use sickle    default parameters untrimmed read   appropriate  rsem' default parameters   rsem  provide  untrimmed read  map rat increase significantly   trim read  overall accuracy   methods depend little  whether trim  untrimmed read  use rsem express  cufflinks   give pairedend alignments since  make special use   data tophat22  provide   option mateinnerdist   adjust  expect matepair innerdistance   simulate average  bowtie  give  option    ensure  pairedend read originate   valid fragment would  consider  untrimmed synthetic read file  provide directly  sailfish without  extra information since   quantification procedure  use whether single  pairedend read  provide software comparisons  express  read  align  bowtie3  use  parameters      suggest   express manuscript  allow   three mismatch per read  report  alignments  alignments  rsem  compute  default parameters use  rsemcalculateexpression command  use bowtie    underlie aligner  prepare alignments  cufflinks tophat  run use bowtie  bowtie1   options   readeditdist   allow   three mismatch per read  rsem express  cufflinks  report time   sum   time require  alignment   time require  quantification  time require   method   decompose   time   alignment  quantification step  figure  choice  software options  effect  runtime  expression estimation software include rsem express  cufflinks provide  myriad  program options   user  allow  tradeoffs  various desiderata  example  total time require  tophat  cufflinks  lower  cufflinks  run without bias correction     oppose     bias correction   srx016366 data however without bias correction cufflinks yield slightly lower accuracy pearson    spearman       methods  still take  time longer  run  sailfish similarly although align read   stream directly  express via bowtie  empirically observe lower overall runtimes  align read  quantify expressions separately   sequence   time  report finally   provide rsem   alignments use  express     previous work7  observe substantially increase runtime   qpcr datasets     alignments generate  srx016366      alignments generate  srx016367 since rsem   appear  efficiently handle  large number  multiple alignments    generate  short read  allow many mismatch instead  report time  rsem   alignment  perform use   default parameters  general  attempt  run  piece  software  options  would  common   standard usage scenario however despite  inherent difficulty  compare  set  tool parameterized   array  potential options  core thesis  sailfish  provide accurate expression estimate much faster   exist tool remain true   fastest perform alternatives even  sacrifice accuracy  speed    order  magnitude slower  sailfish sailfish version   use   experiment   analyse     kmer size      use  concurrent thread     experiment involve  real   simulate data sailfish  run   polya option  discard kmers consist   consecutive     bias correction  enable  kpkm value report  sailfish  use  transcript abundance estimate rsem6 version   run   nobamoutput flag       experiment involve  real data rsempreparereference  use  prepare  reference index  append polya tail   transcripts   quantification  perform   estimaterspd flag   synthetic data rsem  give  pairedend option  produce pairedend alignments   read apart   options rsem  run   default parameters   experiment express7 version   use   experiment   run  default parameters   macq data  without bias correction nobiascorrect   synthetic data   synthetic test bowtie  give  appropriate    options  compute pairedend alignments cufflinks5 version   use  experiment   run  bias correction   multiread recovery    macq data   multiread recovery    effectivelength correction noeffectivelengthcorrection   synthetic data   test  cufflinks  tophat  run     option  take advantage     concurrent thread  execution  experiment  run   computer   amd opteron  processors four core      ram   experiment  wall time  measure use  builtin bash time command implementation  sailfish sailfish  two basic subcommands index  quant  index command initially build  hash   kmers   set  reference transcripts use  jellyfish10 software  hash   use  build  minimum perfect hash count array  lookup table describe   index command take  input  kmer size via   option   set  reference transcripts  fasta format via   parameter  produce  sailfish index describe     optionally take advantage  multiple thread   target number  thread  provide via   option  quant subcommand estimate  relative abundance  transcripts give  set  read  quant command take  input  sailfish index compute via  index command describe   provide via   parameter additionally  require  set  read provide   list  fasta  fastq file finally     index command  quant command  take advantage  multiple processors  target number    provide via    option sailfish  implement    take advantage  several  language  library feature  particular sailfish make heavy use  builtin atomic data type parallelization across multiple thread  sailfish  accomplish via  combination   standard library' thread facilities   intel thread build block tbb library23 sailfish  available   opensource program   gplv3 license    develop  test  linux  macintosh   algorithm    iteration one iteration   expectationmaximization procedure  update  estimate kmer allocations   compute new estimate  relative transcript abundance ′′ base   current estimate  relative transcript abundance ′ algorithm   squarem iteration one iteration update  relative abundance estimate accord   accelerate  procedure whose update direction  magnitude  dynamically computed11",-0.18003886655161652,0.2068058141885558,0.12640559275153268,0.13604875594011925,-0.026271882771272684,-0.04914427651935592,-0.09529782827201967,0.04622155447425859,-0.01758574567848663,0.10655772360041738,0.01481660367085457,-0.003052214078591913,0.14857363491260406,-0.09554809976083263,0.15673626258036694,-0.04934860634119427,-0.006815246753416708,0.19575462388314044,-0.0028389523644295014,0.05016992009510846,0.02605881038986889,-0.2308396781469427,0.0369364964912787,0.02675866486675613,-0.005871877214418948,-0.15593875783474975,0.060901027334624866,-0.13769149296486727,-0.07624818679491592,-0.07322083670626428,0.014383802544826619,0.23394836190649745,-0.20979077640805385,-0.08046223876935753,0.19018924383055516,0.10986400357004744,0.05711991729121212,-0.002521330036007051,-0.05090148738061175,-0.14291515529093654,-0.05693043247111181,-0.14290337240715958,-0.04885215080266098,-0.06662725310870653,-0.14509957629757714,-0.03465200047959357,0.1435723409257823,-0.14719337497164034,-0.20965148540028766,-0.3396758258553101,0.1613636566814156,0.017543807741541184,0.0887185870409137,0.5768019147055177,0.026259534672964397,-1.030645880750911,0.05965653637164756,-0.16931434739708953,0.8890202375559159,0.1615946555019819,-0.16299234819271538,0.2123002271987446,-0.12275688097789395,0.060829885457966575,0.5370308814145355,0.0306116397077858,0.022432341340183626,-0.015394922360244409,0.18533224808064155,-0.1624839601562472,-0.06586313817711073,-0.024580848725995967,0.10872246077463077,-0.09881140669018304,0.19710014820801788,-0.04057704934242378,-0.10859098214519068,-0.14177393189314713,-0.3176954117378137,-0.07217734379797618,0.17278411937813065,-0.07231429317959473,-0.38582129939606624,-0.05767569649073773,-0.7805889111883125,0.08939310439285393,0.1987123065700871,-0.15996586024036186,-0.0979507708312506,-0.0635530161547465,-0.2109075848116684,0.11631340904218805,-0.14348407590335266,-0.10387801650478327,-0.07848261101117956,-0.12712499289847085,-0.06014821923940584,-0.26799237850511554,0.297891298491328,0.08479704243479859,AbundanceEstimation,6
149,149,"rocker accurate detection  quantification  target genes  shortread metagenomic data set  model slidingwindow bitscores
functional annotation  metagenomic  metatranscriptomic data set rely  similarity search base  evalue thresholds result   unknown number  false positive  negative match  overcome  limitations  introduce rocker aim  identify positionspecific mostdiscriminant thresholds  slide windows along  sequence   target protein account  nondiscriminative domains share  unrelated proteins rocker employ  receiver operate characteristic roc curve  minimize false discovery rate fdr  calculate  best thresholds base   simulate shotgun metagenomic read  know composition map onto wellcurated reference protein sequence  thus differ  hmm profile  relate methods  showcase rocker use ammonia monooxygenase amoa  nitrous oxide reductase nosz genes mediate oxidation  ammonia   reduction   potent greenhouse gas n2o  inert  respectively rocker typically show fold lower fdr  compare   common practice  use fix evalues previously uncounted atypical nosz genes  find   two time  abundant  average   typical counterparts   soil metagenomes   abundance  bacterial amoa  quantify   highlyrelated particulate methane monooxygenase pmoa therefore rocker  reliably detect  quantify target genes  shortread metagenomes
implementation rocker  implement   ruby program language   workflow consist  five task  build read  userprovided list  uniprot universal protein resource protein identifiers  download  correspond whole genome sequence encode  proteins  generate data set  simulate shotgun shortread illumina metagenomes use grinder   second list  know negative reference  closely relate proteins     consider  true match  also  give   step  order  increase  performance  rocker see amoa example   train reference sequence  download  annotate use  european bioinformatics institute rest api   align use clustalω  subsequently rocker query  reference protein sequence provide   simulate shotgun data set use blastx   diamond  iicompile translate search result  alignment columns  identify   discriminant bitscore per alignment    amino acid window  another userdefined length   set  sequence use proc   latter algorithm calculate sensitivity  specificity use  number  true  false positive match   window  bitscore thresholds  calculate   value   roc curve  maximize  distance   identity line   nondiscriminatory diagonal line   roc curve accord   youden method windows  iteratively refine  reduce lowaccuracy regions  estimate accuracy   windows  sufficient data ≥ amino acid position  ≥ true positives available thresholds  regions  insufficient data  infer  linear interpolation  surround windows iiifilter use  calculate set  bitscore thresholds  estimate   compile task  filter  result   preexist search ivsearch execute  search  metagenomic sequence  target protein sequence  single protein function use blastx  diamond  filter  output accord   mostdiscriminating bitscores calculate   compile step vplot generate  graphical representation   alignment  thresholds   match obtain together  summary statistics see supplementary data target gene sequence protein sequence  nitrogen cycle reference genes  obtain   national center  biotechnology information ncbi download  march   uniprot download  june   order  avoid misannotated reference  protein sequence  align  visually inspect   presence  characteristic amino acids  protein motifs   phylogenetic relationships   list  wellcurated reference sequence  key  accurate rocker result  reference protein sequence use   analysis  nirk    nosz    pmoa    archaeal amoa    bacterial amoa     rpob     available   simulate data set  benchmark analyse generation  simulate shotgun data set simulate data set  construct use  build function  rocker base   input list  uniprot identifiers   protein sequence  option grinder' parameters differ   default options  follow sequence depth    nosz  nirk   bacterial  archaea amoa simulate data set remove *nnkkmmrryysswwbbvvhhddxx character sequence error uniform  mutation ratio    read length distribution  uniform      average read length   simulate data set simulate data set range     million read  size supplementary data  cpu time cput  hours require  generate simulate data set   approximate  use  power law regression  follow cput  *        number  protein reference sequence use calculate rocker profile   reuse  follow similarity search  process   similarity search output  rockerbased filter typically take    second   couple  minutes   personal computer depend   number  match sequence similarity search analysis  simulate shotgun data set  use  query sequence  blastx blast  diamond  search   reference protein sequence  correspond   input uniprot ids default settings  use  blastx except  evalue  set    diamond  settings use  min score    sensitive  settings  use  make diamond comparable  blastx  term  sensitivity albeit   expense  speed users  want faster diamond search  opt   default settings instead   case  best match  consider  use  script blasttabbest_hit_sortedpl   enveomics collection   blastx search  use  generate rocker profile  nosz nirk  rpob protein reference profile available   hide markov model   set  proteins  build use fulllength alignments  hmmer   hide markov model hmmbased search  read sequence  first translate  amino acids use fraggenescan   subsequently use  query sequence   hmmsearch algorithm implement  hmmer  supplementary data tenfold crossvalidation calculations  nosz  nirk rocker profile   evaluate  perform  tenfold crossvalidation test  ensure  multicopy reference encode    genome  group together  crossvalidation set  randomly separate  genomes  ten subsets rather  use protein uniprot identifiers   subset  simulate data set  generate   query test  challenge  rocker profile build   remain nine subsets model similarity search  perform use blastx   parameters describe  fnr  fdr  calculate   subset          read length simulate data set  generate data set  available   shotgun metagenomes publicly available shotgun metagenomes  download   sequence read archive metagenomics rast   web resources see supplementary data  detail  data set include two representative midwest usa agricultural sit havana  urbana illinois usa  two prairie soil  undergo infrared heat   years warm  control oklahoma usa  tropical misiones argentina  boreal forest alaska usa  alaskan permafrost active layer alaska usa  two beach sand    deep marine sediment  relate   deepwater horizon oil spill florida usa human stool    waste water enrichment sample  sequence process  shotgun metagenomes solexaqa   use  quality trim  raw illumina metagenomic read  extract  longest continuous segment   phred score ≥   pairedend  single read   one read  available longer     use   analysis fraction  genomes encode nitrogen cycle genes rpob rna polymerase beta subunit sequence  obtain  review proteins  uniprotswissprot  total   sequence  visually inspect  conservation  functional domains  complete alignment   use  construct  simulate data set  rocker profile similar options    nitrogen cycle genes  use  pergenus option   build step  order  reduce redundancy cause  sample individual species  many representative sequence shortreads  soil metagenomes  use  query sequence  independent blastx search  settings     nosz nirk amoa  rpob protein reference  rockerfiltered  evaluefiltered count  normalize   median length   sequence   protein reference  fraction  microbial genomes encode either nosz nirk  amoa  genome equivalent  calculate   ratio  nirk nosz  amoa read count  rpob read count use rocker profile  evalues phylogenetic placement  amoa  nosz read protein reference sequence  nosz  amoapmoa  align use clustalω   default parameters  alignment  use  build  phylogenetic tree  raxml    model nosz  amoareads  extract  soil metagenomes use rocker blastx option   proteincoding sequence  predict use fraggenescan  latter sequence  add   nosz  amoapmoa protein alignment use mafft addfragments    place   correspond phylogenetic tree use raxml epa    option   house script jplaceto_itolrb available    use  prepare  visualization   generate jplace file   itol  availability  dependencies  rocker  rocker package documentation  precomputed profile  available   rocker  distribute    package ruby gem   source code    term   artistic license  complete rocker execution require  restclient  json ruby gems  well   include  proc package ncbiblast  diamond grinder  clustalω  muscle   addition rocker model   build online    ",-0.1821985494194304,0.21203261373543392,0.14705185396365406,0.06965374976481402,0.013362536129954332,-0.04875774561088531,-0.08355483039080765,0.08440854508448084,-0.06312716201957176,0.1488244888453704,0.03956941315445347,-0.05417789191327696,0.11890919087743908,-0.08541911727446083,0.13557318938335916,0.011801585019517913,0.09165143310603363,0.15553545517479134,0.00853702853728803,0.06801250667719068,-0.027171822575231392,-0.17021983214305747,0.06252389867630002,0.05569296230212062,-0.02953056158598196,-0.11378728511683475,0.06758769320800811,-0.08496645204221548,-0.051312366314907217,-0.046784013389719666,0.0052465785542545424,0.2474531491844304,-0.19369039793477605,-0.050352935556695434,0.1742844822256528,0.03340496388531538,0.052656365239628314,0.021739904958331537,-0.04391752841340582,-0.10250612587400344,-0.06988970199614324,-0.1795343626684335,-0.10749700321084636,-0.07693327078041398,-0.08450003194296829,0.018134020883532137,0.03912847115818265,-0.13951878136182475,-0.20757139156036,-0.3089306765794778,0.130691609737525,0.005250817718836103,0.02271843443065014,0.528411690732387,-0.02564802148375047,-0.9981405137754652,-0.003652323359637049,-0.2450355037472714,0.919662153964388,0.19452572975336144,-0.15269526586643475,0.3174638797928662,-0.03845125689956034,0.043601486225483266,0.5657026173699239,0.04873405743798137,0.07431160278910459,-0.06326225933190993,0.2327070657175187,-0.1700304040022958,-0.06694673320902059,-0.004165389777525612,0.1964013442335897,-0.07726847100749855,0.15393909830918176,-0.02974050786099387,-0.07570426564424551,-0.1555591693999319,-0.3326779749701436,-0.0663980093640497,0.2135467968377116,0.0010063429024732358,-0.3538962528222833,0.0032105450722095838,-0.7055199935467813,0.11718010673502854,0.27911889227010755,-0.12102145861675692,-0.10682233618562713,-0.014582119808594,-0.1273894413663836,0.05350231796003662,-0.12715486308374668,-0.07374636958089058,-0.09849748154547774,-0.05945768070023499,-0.09202357687805172,-0.3303149065540768,0.2825037027491299,0.021068731859226583,AbundanceEstimation,6
150,150," gaas metagenomic tool   estimations  viral  microbial average genome size  four major biomes
metagenomic study characterize   composition  diversity  uncultured viral  microbial communities blastbased comparisons  typically  use   analyse however sample bias high percentages  unknown sequence   use  arbitrary thresholds  find significant similarities  decrease  accuracy  validity  estimate   present genome relative abundance  average size gaas  complete software package  provide improve estimate  community composition  average genome length  metagenomes   textual  graphical format gaas implement  novel methodology  control  sample bias via length normalization  adjust  multiple blast similarities  similarity weight   select significant similarities use relative alignment lengths  benchmark test  gaas method  robust   high percentages  unknown sequence   variations  metagenomic sequence read lengths reanalysis   sargasso sea virome use gaas indicate  standard methodologies  metagenomic analysis may dramatically underestimate  abundance  importance  organisms  small genomes  environmental systems use gaas  conduct  metaanalysis  microbial  viral average genome lengths    metagenomes  four biomes  determine whether genome lengths vary consistently   within biomes   microbial  viral communities    environment significant differences  biomes  within aquatic subbiomes oceans hypersaline systems freshwater  microbialites suggest  average genome length   fundamental property  environments drive  factor   subbiome level  behavior  pair viral  microbial metagenomes    environment indicate  microbial  viral average genome size  independent     indicative  community responses  stressors  environmental conditions
gaas genome relative abundance  average size  random shotgun libraries gaas software package gaas  implement   standalone software package  perl   freely available    accept  produce file  standard format fasta sequence newick tree tabular blast result svg graphics  gaas methodology  describe  detail    outline  figure  thumbnail        download pptpowerpoint slide pnglarger image tifforiginal image figure  flowchart  gaas  calculate relative abundance  average genome size gaas run blast  use various corrections  obtain accurate estimations  similarity filter blast analyse ncbi blast   conduct  gaas  order  determine significant similarities  metagenomic sequence  completely sequence genomes similarities  filter base   combination  maximum evalue minimum similarity percentage  minimum relative alignment length evalue filter remove nonsignificant similarities   alignment similarity percentage  relative length  use  select  strong similarities likely  reflect  taxonomy   metagenomic sequence evalues depend   size   database   absolute length  alignments  query  target sequence  thus may   comparable  analyse  relative alignment length also call alignment coverage    ratio   length   alignment   length   query sequence figure    independent   database size  sequence length  provide  intuitive  consistent threshold  select significant similarities since  end  sequence read    lower quality similarities  keep    length   alignment represent  majority   length   query sequence sequence   similarity satisfy  filter criteria  ignore   rest   analysis similarity weight  order  avoid  loss  relevant similarities  reliance upon smallest evalues alone   significant similarities   query sequence  define   criteria   keep  assign weight  follow base   karlinaltschul equation  expect value eij   metagenomic query sequence    target genome sequence   give    '   effective query sequence length '   effective database size  number  residues  '   highscoring pair hsp bitscore  use  effective length correct   “edge effect”  local alignment   significant  sequence smaller      sequence produce   high throughput roche gs20 platform assume   query sequence   likely   local similarities  longer target genomes    evalues   reformulate   expect value fij   similarity   give target genome    '   effective length    target genome  use  length   target genome   fvalue produce  expect value relative   target genome    totality   genome database    case   evalue  fij  weight wij   calculate       constant     give metagenomic query sequence    weight carry  statistical mean   expect value   similarity relative   give genome    way   larger  expect value  lower  weight therefore   give query sequence   weight  calculate   genome relative abundance use genome length normalization  relative abundance  sequence   random shotgun library  proportional     relative abundance   genomes   library  also   length similarly   normalization use  proteomics  normalization  genome length  need  obtain correct relative abundance   species   metagenome   target genome   weight wij   genome  add  obtain   weight similarities    genome   normalize   actual length    genome include chromosomes organelles plasmids   replicons  obtain accurate relative abundance estimate      constant    average genome length calculation gaas rely   relatively stable genome size find within taxa   calculate average genome length  average genome length  calculate   weight average  individual genome lengths  length   genome   individual organism identify   metagenome  weight   relative abundance   organism  calculate  gaas thus  mean genome length   calculate       relative abundance  organism     individual genome length confidence intervals  relative abundance  average genome length estimate  bootstrap procedure  implement  gaas  provide empirical confidence intervals  relative abundance  average genome length estimate  estimation  community composition  average genome length  repeat many time use  random subsample   sequence   repetition confidence intervals  determine base   percentiles   observe estimate  5th  95th percentiles    confidence interval reference databases  viral microbial  eukaryotic metagenomes ncbi refseq ftpftpncbinihgovrefseqrelease release  august    use   target database   estimation  taxonomic composition  average genome size three databases contain exclusively complete genomic sequence  create   viral microbial  eukaryotic refseq file  incomplete sequence  identify   descriptions contain word   “shotgun” “contig” “partial” “end”  “part”   remove   database  taxonomy file contain   taxonomic    sequence   three databases  produce use  ncbi taxonomy classification sequence   description match  follow word  exclude   file unless  chromosomal sequence  also available    organism “plasmid” “transposon” “chloroplast” “plastid” “mitochondrion” “apicoplast” “macronuclear” “cyanelle”  “kinetoplast”  complete viral microbial  eukaryal sequence file  accompany taxonomic ids  available   map  phylogenetic tree similarly   interactive tree  life itol   metamapper  gaas  able  graph  relative abundance  viral microbial  eukaryotic species  phylogenetic tree    viral proteomic tree vpt  tree  life   viral proteomic tree  construct use  approach introduce   phage proteomic tree  extend     viral sequence present   ncbi refseq viral collection edwards   unpublished data  benchmark use simulate viral metagenomes simulate metagenomes  create  test  validity  accuracy   gaas approach use  free software program grinder    develop  conjunction  gaas grinder create metagenomes  genomes present   usersupplied fasta file users  simulate realistic metagenomes  set grinder options   community structure read length  sequence error rate   simulate metagenomes base   ncbi refseq virus collection  generate use grinder  viral database  choose since  large amount  mosaicism  horizontal gene transfer represent  worstcase scenario therefore benchmark result use  viral database  expect   valid  higherorder organisms   bacteria archaea  eukaryotes  parameters use   coverage   fold   sequence error rate    substitutions  indels half   simulate metagenomes   uniform rankabundance distribution    half follow  power law  model parameter  sequence length   artificial metagenomes  vary        analysis  read length effect  gaas estimate   simulate viral metagenome gaas  run repeatedly  different parameter set relative alignment length  percentage  identity  maximum evalue  fix    order  remove similarities due  chance alone  set  variable parameters  test   minimum   different grindergenerated metagenomes  computations  run   node intel dualcore linux cluster due   limit number  whole genome sequence available  great majority   sample organisms   metagenome cannot  assign   taxonomy  evaluate  effect  sequence  novel organisms  gaas estimate  taxonomy   randomly choose organisms   database  make inaccessible  gaas render  “unknown”  control simulation   know organisms  run  comparison figure   accuracy  gaas estimate  evaluate  compare gaas result  actual community composition  average genome size   simulate metagenomes  relative error  average genome size  calculate         true  estimate value respectively   composition  cumulative error  calculate       relative error   relative abundance   target genome      total number  sequence   database   benchmark result   normal nonparametric statistical test  use   pairwise mannwhitney  test  multifactor comparisons friedman test  average errors nonparametric correlations  calculate use kendall' tau benchmark use simulate microbial metagenomes gaas  also test   three simulate metagenomes available  imgm  parameter set  data process  conduct   viral benchmark experiment point   imgm microbial benchmark graph represent  average   repetitions microbial strain typically   largely identical genome   fraction cod  additional genes  account  differences  genome length  additional simulation  perform  investigate   presence  closely relate genomes influence  accuracy   gaas estimate   escherichia coli strain present   ncbi refseq database range       genome size  use  produce  shotgun libraries  grinder  parameters use       simulate viral metagenomes    coverage   fold  sequence half   simulate metagenomes  treat    viral benchmark use  gaas approach  assume  unknown species   half  treat similarly  take   top similarity point   graph   microbial strain benchmark represent  average   repetitions metaanalysis   metagenomes  composition  average genome size   metagenomes  calculate use gaas    metagenomes  publicly available   camera  ncbi   mgrast  table     dozens  viromes  microbiomes newly collect  solar saltern ponds chicken gut different soil   oceanic oxygen minimum zone protocol   metagenomes use  therefore represent viral bacterial archaeal  protist communities sample   diverse array  biomes   categorize  one   follow “aquatic” “terrestrial” “sediment” “hostassociated”  “manipulated  perturbed”  large number  aquatic metagenomes   subdivide  “ocean” “hypersaline” “freshwater” “hot spring”  “microbialites” sample filter process  sequence methods differ among compile metagenomes table  provide  summary   number  metagenomes   biome  list   complete dataset  present  detail  table  thumbnail        download pptpowerpoint slide pnglarger image tifforiginal image table  summary  metagenomes  type use   metaanalysis    metagenomes gaas  run use  threshold evalue     alignment relative length    addition  bacterial archaeal  eukaryotic metagenomes similarities  calculate use blastn   alignment similarity   due   low number  similarities  viral metagenomes use blastn tblastx  use  viruses   threshold alignment similarity    average genome length estimate produce  less   similarities  discard  keep result  accurate  possible manipulate metagenomes  ultimately  use   metaanalysis     accurately represent environmental condition statistical pairwise differences  average genome lengths across biomes  assess use mannwhitney  ranksum test  average genome length  relative abundance result obtain   metagenomes   gaas method  compare   “standard” analytical approach     top similarity   metagenomic sequence  keep     filter  alignment similarity  relative length    normalization  genome length  carry   virome   sargasso sea  choose  illustrate  detail  difference   result obtain   two methods figure  correlation  viral  microbial average genome length average genome lengths  calculate   pair  microbial  viral metagenomes sample    location    time  statistical relationship  viral  microbial average genome length  pair metagenomes  evaluate use kendall' tau since lengths   normally distribute regression analysis  perform  generalize linear model glm interactions  genome lengths  biome classifications   significant    include  final model statistical analyse  statistical analyse   gaas benchmark result environmental genome length  genome length correlations describe   perform use  free statistical software package ",-0.2089779832082369,0.20942610156811156,0.1327790933110538,0.15425968520663774,-0.07826291334659811,0.012458615666514176,-0.06845588403648878,0.018293027197295628,-0.04964850092084823,0.1222236945099891,-0.02481692852662076,-0.02514118609807321,0.17885633887230346,-0.1256989681489126,0.17639616605962016,0.04315263308160091,0.01600768995614579,0.1861112857351908,0.00318438786856907,0.08638644832420979,-0.0469790165903183,-0.21485122499701795,0.0774108805330243,0.021162098373013843,-0.04256680768199866,-0.1843591303097527,0.09927635102615363,-0.1252799208668466,-0.0987357902140195,-0.035819646835001266,0.05651544670069391,0.20385273349625155,-0.18160844196243944,-0.07170172049246787,0.20790673501132795,0.0757090157429962,0.062105035813836335,0.008793982250815149,-0.096844190771287,-0.13072679195158607,-0.10015799489064932,-0.12724797385745842,-0.13158390181120327,-0.0653135300909674,-0.14379100686021756,-0.0038941346701255545,0.11234390849595292,-0.12129405176631344,-0.2517793730091772,-0.28713993786106423,0.2187970985276677,0.0031414638718111373,0.062485177363015676,0.489254454287087,0.04739455852306345,-0.961273763570358,0.09156190781914376,-0.2334769062773677,0.8670834775814895,0.1962925454202601,-0.1797802596851309,0.29565929616434505,-0.05344287446991839,0.04930904677301981,0.5898285221114518,0.08477732515631778,-0.005384974969557739,-0.06012703140316913,0.2419050330647589,-0.17675302249318736,-0.07317185576682139,-0.003686817109106042,0.15251711653696207,-0.07210173239707808,0.1661086320697101,-0.03839529857369695,-0.13493557192960065,-0.18545927450420796,-0.32138447087182964,-0.02900365771141295,0.16961123229167818,-0.006849773144297036,-0.3651471696667352,-0.031194073740413893,-0.7463838943006933,0.05939561527955834,0.2343454787159936,-0.1414691789475869,-0.13675015219817058,-0.011515970572453136,-0.17988984342868697,0.08284807075155763,-0.0896114931314289,-0.1102322657850816,-0.06856386481745406,-0.05700372757611177,-0.126229461894928,-0.3409246879002502,0.2749977478314992,0.06704778537074149,AbundanceEstimation,6
151,151,"accurate genome relative abundance estimation base  shotgun metagenomic reads
accurate estimation  microbial community composition base  metagenomic sequence data  fundamental  subsequent metagenomics analysis prevalent estimation methods  mainly base  directly summarize alignment result   variants often result  bias andor unstable estimate   develop  unify probabilistic framework name grammy  explicitly model read assignment ambiguities genome size bias  read distributions along  genomes maximum likelihood method  employ  compute genome relative abundance  microbial communities use  mixture model theory grammy grammy   demonstrate  give estimate   accurate  robust across  simulate  real read benchmark datasets  apply grammy   collection   metagenomic read set  four metagenomics project  identify  frequent species minimally  abundant   least    data set   human gut sample  result show substantial improvements  previous study   adjust  overestimate abundance  bacteroides species  human gut sample  provide  new referencebased strategy  metagenomic sample comparisons grammy   use flexibly  many read assignment tool map alignment  compositionbased even  lowsensitivity map result  huge shortread datasets    increasingly useful   accurate  robust tool  abundance estimation   grow size  read set   expand database  reference genomes
 finite mixture model  develop  finite mixture model   grammy framework follow angly    use genome relative abundance gra   relative abundance measure  mostly unicellular microbial organisms   describe  sample  sequence procedure  follow first randomly choose  genome   probability  proportional       abundance     genome length second randomly generate  read    without loss  generality   assume    give genome    reasonably approximate  generation  shotgun read   component distribution     probability  generate  read        reasonable assumption  independence   two sample step  whole procedure  probabilistically equivalent  sample   mixture distribution    mix parameters denote      component distributions denote       number  genomes subsequently  read set denote     regard   realize independent identically distribute iid sample  size    mixture   relative abundance  know genomes  exactly  transformation   mix parameters     estimate base   read set   schematic view   finite mixture model  show  figure    component distributions properly set    find  maximum likelihood estimate mle   mix parameters  many study  knowledge   genomes present   community  limit   circumstances   define  mixture   first  components  know genomes   last  component   collective  unknown genomes note     know components  suppose   genome sequence   genome size   know therefore  gra  know genomes    normalize abundance   relative abundance    know genome       biological set  want  estimate vector     measure  organism relative abundance   transform mixture problem   relate   mix parameters      inverse     number  sample read   proportional   genome relative abundance   length   two factor  confound  miss knowledge   genome length  prohibit  estimation     data since  effective genome length    unknown genomes   available  cannot estimate  relative abundance   unknown component however  relative abundance  know genomes  still  estimate use  procedures estimation  gra use expectation maximization  algorithm  estimate  mix parameters  adopt   algorithm  calculate  maximum likelihood estimate mle    framework  assume  miss data matrix     entry    random variable indicate whether          solve   parameters  iteratively estimate    use algorithm  see support methods note   variable  superscript  stand   value    iteration     estimate      step      iteration  estep assume  know    update   correspond posterior probabilities  mstep assume  know  new mix parameters   update     mle    find use equation   mle     calculate thereby solve  original problem  space complexity    algorithm     time complexity    algorithm      average number  associate genomes  one read     time cost relate   convergence criteria   since      constants  relate    algorithm  linear  space  time complexity   read number    concavity   loglikelihood function   show    algorithm  guarantee  converge  global maximum see text  read probability approximations  probability   assess base   ideally    probability    generate  read  uniformly sample  genome  let    number  copy  read      probability  approximate   however due  sequence errors  natural genetic variations  '   readily observable   map  alignment result  blast blat   map tool  available  number  high quality hit      effectively  use  '  keep   reliable  statistically significant hit raw hit  filter  evalue alignment length  identity rate  refer   finite mixture model   read probability  map  alignment result  map   remainder   paper  alternative way  assess  read probabilities   use kmer composition   jth genome  calculate  fraction   kword     normalize frequency   word   genome    read   define pseudolikelihood         set  word form  slide windows  size  along   probabilistic assignment capture  overall similarity  read  genomes  idea adopt   compositionbased study    sandberg      especially useful   large number  read    reliable hit  reference genomes   refer   finite mixture model   read probability   multinomial kmer composition  kmer   remainder   paper standard errors  gra estimate  also derive  asymptotic covariance matrix   mix parameters  use  asymptotic theory  mle estimate     independent parameters     choose     denote    let      mle estimate     correspond gra respectively   asymptotic standard error    approximately        observe information matrix    small number  compare  number  parameters  read  map  condition   asymptotic  hold cannot  satisfy   alternatively use  bootstrap covariance estimator   standard error  mle        bootstrap mean estimator numerical error measure  use  follow measure  evaluate  accuracy   gra estimate let  true gra     estimate   first measure   commonly use root mean square version  relative error    also include three  error measure   average relative error   maximum relative error    total variation distance     commonly use  evaluate  accuracy   estimate real read set  reference genome set  prepare  real read set  download  fames data  jgi    data  tracedb ftpftpncbinihgovpubtracedb ncbi project    uhg data  sequence read archive  ncbi project    jhg data  bgi     amd data  tracedb ncbi project    prepare  reference genome set  download currently available complete  draft bacteria genomes   ncbi refseq  metahit  hmcj  wustl gordon lab   jgi   manually curated genomes  remove redundancy  organize    ncbi taxonomy  database  use  genome information available  imgm  imghmp   gold   group   habitats   finally  obtain  human gastrointestinal tract genomes   human gut reference genome set hgs read filter  assignment procedures   map read probability backend  use blat  map read  reference genomes  prefer blat  blast  blat  tens  time faster  handle lowsensitivity similarity search  massive number  sequence  blast since   keep alignment result  identity rate greater    blat result   differ much    blast  use   human gut  simulate data  use similar filter methods   turnbaugh     evalue ≤ align length        identity ≥   kmer readprobability backend  use kmer length     gaas  megan  use   map result  blat   common start point  use gaas' default filter options evalue≤ align length        identity ≥  well  megan' default options minscore     equal     minscore     equal    top percent   min support    comparisons  evaluate  ribotype  protein marker base method  use  ecoli  rrna rrse  ribosome protein rpob genes  retrieve homolog sequence   simulate read    filter  options evalue0 align length        identity  accord    validations  show  variations   parameters within  reasonable range  little effect   result higher level taxonomic statistics many downstream analyse   carry  base  grammy' estimate  example  average genome length   readily obtainable  subsequently   test  statistical significance   median average genome length difference  two sample group  wilcoxon test wilcoxtest   since genome size bias  already  correct   use grammy estimate  calculate  relative abundance   higherlevel taxon  simple addition   purpose  use  ncbi taxonomy    taxonomic assignments   reference genomes  use   illustrate   specific taxonomic level   relative abundance    specific taxon           one   seven hierarchical level   taxonomy  species  kingdom hierarchical biclustering   possible  use grammy estimate  cluster analysis  statistical hypothesis test  cluster  sample base   pairwise similarities correlations   relative abundance distribution    longtailed shape   distribution  signaltonoise ratio  low   less abundant genomes therefore use  thresholds    minimum abundance     minimum occurrence   select  estimate    abundant genomes    reliable  cluster  use rank transformation  normalize gras  take  rank  apply score transformation   function heatmap  hierarchical cluster",-0.2090811839381762,0.2181076273900899,0.1300614857279752,0.19367750115094629,-0.05406328583279637,0.011622096757752238,-0.09406567337291938,0.008973560632302965,-0.021540523333971967,0.11915632164097692,-0.0326201347341264,-0.039780461572821765,0.19338257689283525,-0.12468317762717256,0.17350362003109174,-0.021501471943559364,0.02961835503141818,0.2369670678083085,0.0029821377522827267,0.08182584187758322,0.007389612315089286,-0.2096004609789153,0.052709101395249175,-0.0019168254359748515,-0.032359837179391386,-0.1896861953059956,0.11895133500250556,-0.15405740931432152,-0.07851672932067978,-0.08502289823747852,0.023062264485513986,0.22296009602332226,-0.1733087255603557,-0.062066818408566024,0.21306805614814608,0.058366329823327685,0.08666286639739919,0.05244622847159775,-0.07062316939957973,-0.16084000465602544,-0.09303077875544093,-0.12474874681642267,-0.0863221887844552,-0.08711876245639782,-0.125203686737412,-0.016337163707278286,0.13989740093646486,-0.119935733594966,-0.2849579881912061,-0.3192167813193211,0.20745534226422546,-0.011755650048522954,0.07873575173196162,0.5804182808283603,0.004692245084249946,-1.0816816778812122,0.08773683561461648,-0.21174662863144272,0.8969691504578867,0.17472580404868013,-0.14640030534812976,0.2773930807585309,-0.10644892555532204,0.0514093770038482,0.6162751912338348,0.055320693656990064,0.005666767691975205,-0.05036913109157909,0.2481454360146538,-0.16748267921786794,-0.08128715006504794,0.0006696345774990197,0.1166075592211078,-0.07929713494819135,0.21973697412476234,-0.05232757075519024,-0.11849702990143166,-0.19490460327593104,-0.385653979295497,-0.07221350705501668,0.1761539477889595,-0.01882686501465093,-0.4267514555778409,-0.06800064786161558,-0.7944587603243727,0.06035134177632255,0.2236705234850284,-0.2018182462269699,-0.1279053790626114,-0.0589084909457881,-0.2111640335847912,0.08542229888739505,-0.1095823272005877,-0.1042786583947341,-0.0948489778366108,-0.09572913826452346,-0.1160294368303504,-0.32395906761387633,0.2658021716391385,0.09932610496965494,AbundanceEstimation,6
152,152,"metaid  novel method  identification  quantification  metagenomic samples
advances  nextgeneration sequence ngs technology  provide    opportunity  analyze  evaluate  rich microbial communities present   natural environments  shorter read obtain   shortgun technology  pave  way  determine  taxonomic profile   community  simply align  read   available reference genomes  several computational methods  available  taxonomic profile   genus  specieslevel none   methods  effective   strainlevel identification due   increase difficulty  detect variation   level   present metaid  alignmentfree ngram base approach   accurately identify microorganisms   strain level  estimate  abundance   organism   sample give  metagenomic sequence dataset metaid   ngram base method  calculate  profile  unique  common ngrams   dataset   prokaryotic genomes  assign weight   ngram use  score function  score function assign higher weightage   ngrams  appear  fewer genomes  vice versa thus allow  effective use   unique  common ngrams  species identification  fold crossvalidation result   simulate dataset show  remarkable accuracy     strainlevel identification   organisms  gut microbiome  also demonstrate   model show impressive performance even  use       genome sequence  model  addition  identification   species  method  also estimate  relative abundance   species   simulate metagenomic sample  generic approach employ   method   apply  accurate identification   wide variety  microbial species viruses prokaryotes  eukaryotes present   environmental sample  propose score function  approach  able  accurately identify  estimate  entire taxa   metagenomic community  weight assign   common ngrams   score function  precisely calibrate  match  read    strain level  multipronged validation test demonstrate  metaid  sufficiently robust  accurately identify  estimate  abundance   taxon   natural environment even  use incomplete  partially sequence genomes
datasets  input genome dataset consist   catalogue   completely sequence genomes retrieve  ncbi ftpftpncbinihgovgenomesbacteria  july   nucleotide sequence    bacterial genomes span across  genera  species   strain  download  entire dataset   bacterial genomes   plasmid sequence   respective bacterial genomes  remove     genomes  tag use  first three letter   genus  species name  addition  entire strain name  retain  clarity purpose  example  genome chlamydia trachomatis duwcx  tag  chl_tra_ duwcx table s10  additional file  list  entire set   genomes   associate statistics    length   genome  number  ngrams      genome  number  unique  common ngrams   genome   repeat ratio  ngram model  nucleotide representation  ngram   subsequence   nucleotide sequence  fix length   literature  nucleotide subsequences   call alternatively  nmers oligonucleotide oligopeptide etc   purpose  obtain common  unique ngrams across    bacterial genomes  possible ngrams  extract     genomes   dataset give  dataset  genome sequence  let     complete nucleotide sequence   organism      𝑑𝑖𝑠1𝑠2…  ∈   represent  set  four nucleotide        set  𝑘𝑛ngrams   obtain    𝑔1𝑠1… 𝑔2𝑠2…𝑠𝑛𝑔𝑘𝑛𝑠𝑘𝑛… use  ngram model  follow property  ngrams   observe   countable number  ngrams across   genomes   highly abundant  phenomenon  relate  zipf' law     important  note     bacterial genomes contain additional letter namely          account  two ambiguous base   give position  example  letter    give position indicate unknown base  letter    give position indicate either     letter    give position indicate either        addition   letter      represent base ambiguities therefore ∑  {              } unique  common ngram profile   entire  genomes  possible nonrepeating ngrams     obtain  ngrams   genome  compare   ngrams    genomes  finally arrive   set  unique present   single genome  common present  multiple genomes ngrams  unique ngram set include two columns   ngram   genome     present    hand  common ngram set include four columns   ngram frequency   occurrence   entire dataset  weight assign   score function   genomes     present score function  score function obtain  set  common  unique ngrams base   ngram model discuss   score function  parameterized   length   ngram   target dataset  begin   score function read   nucleotide sequence   genome  generate  possible ngrams without  repeat   nucleotide sequence   length    total number  ngrams  give      ngrams  generate  score function compare   ngrams   genome       genomes   dataset  successful comparison  score function determine  profile    common  unique ngrams   dataset   unique ngrams  assign  weight  unity     common ngrams  assign weight use  dampen factor  account   popular  ngram   respect   genomes present   dataset   ngram   dampen factor  give   expression 𝗅𝗈𝗀𝑒∣∣∣∣∣∣∈∣∣𝗅𝗈𝗀𝑒∣∣∣∣  ∣∣∣∣ denote  total number  genomes   dataset  ∣∣{∈}∣∣ denote  total number  genomes    ngram   present  factor  similar   term 'weighting'  discuss   previous study   damp factor adjust  weight   ngrams    way  popular ngrams receive  low weightage  viceversa table   additional file  show  weight assign   hypothetical ngrams base upon  frequency  occurrence   dataset   ngram  present    single genome   weight  unity       present    genomes   weight  zero   model build  modelbuilding step involve index  entire set  common  unique ngrams  assign appropriate weight   ngram base   frequency profile across  reference genome set  model build  tool consider either  entire set    partial     set  nonrepeatable ngrams   genome  model build use  partial genome set nonrepeating ngrams  randomly select   genome  number  ngrams select   genome  proportionate   size model build    crucial step  metaid    also  time consume process  case  add new genomes   dataset  add  completely different community include viral fungus archaeal etc  modelbuilding step    carry   therefore  update process   schedule  periodic intervals moreover modelbuilding step   tool   offline process repeat ratio  harvest  ngrams      reference genomes  observe     large number  ngrams    tendency  reappear therefore  come    parameter ""repeat ratio""  account   abundances  repeat ngrams   genome repeat ratio  determine  compute  fraction   repeat ngrams   total number  ngrams   genome  repeat ratios  represent  percentages  table s11  figure   additional file  present  histogram   repeat ratio distribution across   bacterial genomes across  bacterial genomes  repeat ratio distribution range widely      small fraction   genome    repeat ratios within  almost     genomes   repeat ratio      total nearly    genomes   repeat ratios range      mean   standard deviation   repeat ratios across  bacterial genomes  observe      respectively test  identification classification though  objectives behind  test  identification classification step       subtle difference    test  consider        nonrepeated ngrams randomly choose   genome  try  identify  origin  contrast  identification  consider  entire set  metagenomic read  harvest  possible ngrams     try  determine  constituent organisms   give community let  consider {𝑔1𝑔2𝑔3…}   set  ngrams obtain   read  randomly select   genome  {𝐺1𝐺2𝐺3…}   set  genomes present   database  define  map      →    elements  domain  map   single element  codomain   𝑔1𝑔2𝑔3…→      single range  codomain   ∈  obtain  map      construct  * matrix   form ⎛⎝⎜⎜⎜⋮⋯⋱⋯𝑦0𝑚⋮𝑦𝑛𝑚⎞⎠⎟⎟⎟   define {𝑐1𝑐2𝑐3…}  {𝑦0𝑦1𝑦2…} {𝑦0𝑦1𝑦2…} {𝑦0𝑚𝑦1𝑚𝑦2𝑚…𝑦𝑛𝑚}   columns   * matrix  𝑦𝑒𝑓 represent  weight assign   ngram    present  genome      ngram    present   genome    abovementioned * matrix  define ∑∑𝑦0𝑧𝑦1𝑧𝑦2𝑧…𝑦𝑛𝑧   sum    elements   column   compute  sum   column   * matrix  arrange   column sum   descend order   associate 𝑔1𝑔2𝑔3…→ provide  ∑∑∑…∑  ∑∑∑…∑  summary  obtain  ngrams   read    genomes  construct  matrix   row represent  ngrams   columns represent  entire set  genomes   dataset   replace  matrix entry   weight   ngram correspond   particular genome   ngram   part   genome   replace  entry   zero    fill  matrix entries  determine  column sum   genome identify  highest column sum  associate map  entire set  ngrams   particular genome   important  note    identification step  try  map  set  read   genome instead  map  single read   genome      hard  classify  single read   genome due   intense computation involvement  lack  discriminatory signal     order  ensure  successful classification  compare  classification result   classifications perform  metasim metasim read metagenomic read   mockstaggered communities  obtain use  metasim simulation tool  parameterizing metasim   genomes  abundance profile  empirical error model table s12  additional file    total number  read   generate metasim generate  set  read   genome   mockstaggered community metasim generate   million   pairend read table s13  additional file  show  parameter settings use  metasim  construct  mock stagger community   detail   simulation output mock communities two different mock communities  use   study  first one   mockeven community   construct  two datasets namely hc1  hc2 obtain  metaphlan website   original datasets consist   genomes    equal abundance     datasets  construct  mockeven community   microbial genomes   hc1    hc2   also present    set  reference genomes  entire set  read pertain    genomes  include   community  ensure   abundances  equal    eliminate  rest  genomes either due   absence   dataset      appropriate map find   kegg '  hc1  hc2   ncbi name   database secondly  construct  mockstaggered community  randomly choose  microbial genomes     genomes   dataset  final mockstaggered community include genomes  genome size vary        repeat ratios range       community  randomly assign  abundance value   genome     total    table   additional file  abundance estimation consider  set  read   genome  harvest  possible nonrepeated ngrams     map    reference genome upon map  count  total number  ngrams    common intersection   read   reference genome  determine  relative ""observed abundance""   genome   ratio   number  nonrepeated ngram count   total sum   nonrepeating ngrams   genomes present   community multiply   total number  genomes   sample  determine  observe abundances  notice  genomes  extreme repeat ratios         tendency   estimate higher  lower respectively therefore  correct  observe abundances  either subtract  add  first standard deviation   repeat ratios   genomes   mean   repeat ratios   genomes    hand   repeat ratio   genome lie       mean   repeat ratios   genomes  use    correct abundance   genome  report base   repeat ratio use  follow expressions 𝐶𝑜𝑟𝑟𝑒𝑐𝑡𝑒𝑑𝐴𝑏𝑢𝑛𝑑𝑎𝑛𝑐𝑒𝑂𝑏𝑠𝑒𝑟𝑣𝑒𝑑𝐴𝑏𝑢𝑛𝑑𝑎𝑛𝑐𝑒𝗅𝗈𝗀10𝑅𝑒𝑝𝑒𝑎𝑡𝑅𝑎𝑡𝑖𝑜𝜇𝑅𝑒𝑝𝑒𝑎𝑡𝑟𝑎𝑡𝑖𝑜𝑜𝑓2031𝑔𝑒𝑛𝑜𝑚𝑒𝑠 𝑅𝑒𝑝𝑒𝑎𝑡𝑟𝑎𝑡𝑖𝑜 𝐶𝑜𝑟𝑟𝑒𝑐𝑡𝑒𝑑𝐴𝑏𝑢𝑛𝑑𝑎𝑛𝑐𝑒𝑂𝑏𝑠𝑒𝑟𝑣𝑒𝑑𝐴𝑏𝑢𝑛𝑑𝑎𝑛𝑐𝑒𝗅𝗈𝗀10𝑅𝑒𝑝𝑒𝑎𝑡𝑅𝑎𝑡𝑖𝑜𝜇𝑅𝑒𝑝𝑒𝑎𝑡𝑟𝑎𝑡𝑖𝑜𝑜𝑓2031𝑔𝑒𝑛𝑜𝑚𝑒𝑠±𝜎𝑅𝑒𝑝𝑒𝑎𝑡𝑟𝑎𝑡𝑖𝑜𝑜𝑓2031𝑔𝑒𝑛𝑜𝑚𝑒𝑠 𝑅𝑒𝑝𝑒𝑎𝑡𝑟𝑎𝑡𝑖𝑜50𝑎𝑛𝑑𝑅𝑒𝑝𝑒𝑎𝑡𝑟𝑎𝑡𝑖𝑜     mean     standard deviation   repeat ratios    genomes present   dataset table s10  additional file  note    mean  standard deviation   repeat ratios  change   addition  elimination  genomes   dataset  figure  additional file   notice     genomes   repeat ratio range     therefore  correct  abundances correct abundance  subtract one standard deviation   mean   genomes whose repeat ratio     add one standard deviation   mean   genomes whose repeat ratio      genomes  repeat ratios      mean   repeat ratio  consider     report  abundance estimate   give community  percentages     entire community  equal   number  microbial species   community therefore   correct abundance   add     equal   number  species  report  ""estimated abundance""   normalize  either   equal   number  species   community performance metrics  report standard performance measure  term  accuracy  percentages accuracy  define   ratio  number  entries genomes    correctly identify   number  entries  consideration   case   report balance accuracies wherever   information  specificity  sensitivity",-0.2053627787742044,0.22251153301539933,0.13627237445772844,0.16541216952336293,-0.048750585158986094,0.04914883363894488,-0.10453720938182023,0.027015286664227502,-0.06614768461797195,0.13628472575196013,-0.02120028644538835,-0.03366265582223578,0.17488255900343674,-0.10374557076852753,0.14128647016262572,-0.009654012594770285,0.01878279630916156,0.21838715894129346,-0.037618158637433986,0.07606257165897272,0.0068277835468440115,-0.22737754047826245,0.05403516401979089,0.008929277107250236,-0.02217807333744266,-0.1848578868798895,0.12162231685923525,-0.13209908523696384,-0.031343420038794687,-0.07383787167779189,0.035635650462319535,0.19134350607690467,-0.16214867164163055,-0.09011981088083698,0.1895266410663028,0.0993774826454314,0.04950585677725354,-0.002300662352937639,-0.13312293042313153,-0.09638476254883116,-0.09888208846775257,-0.1266039496681221,-0.07769447004457289,-0.07772014816582021,-0.09753088828747708,-0.006108894819738074,0.10538499212807216,-0.122276684182192,-0.2531812499826442,-0.35660879229758563,0.2187863601141408,0.0010341821935334822,0.08379241357503546,0.5661774755552523,0.006362111788120677,-1.0520657414102714,0.06375881730120438,-0.2297456806781235,0.9183501819787,0.19234349035083906,-0.19298722767376109,0.3271394284726753,-0.08189646066552783,0.024189170245532327,0.6439213881420515,0.04318481042746762,0.01933824021746726,-0.019083977076961328,0.2521547653569989,-0.20455311899143944,-0.08847984482567707,-0.02812642686556193,0.10968875217832,-0.07248632660558768,0.2053369349838423,-4.1088748169453085e-05,-0.15750854465392788,-0.2027217135676504,-0.34093800546676084,-0.0739969512878633,0.16717600165768434,-0.03746437131404412,-0.3613986001134267,-0.07881620540159978,-0.7898202681196294,0.02054460428889534,0.2080577517930161,-0.16866760969675096,-0.08794384376941361,-0.025464862278083915,-0.2064695209772938,0.0820255883241317,-0.07277947476897663,-0.0936869971936982,-0.08475044120065785,-0.06790318673285749,-0.13564374040732394,-0.3365916581518475,0.2743939374799618,0.07015936075526193,AbundanceEstimation,6
153,153,"stamp statistical analysis  taxonomic  functional profiles
stamp   graphical software package  provide statistical hypothesis test  exploratory plot  analyse taxonomic  functional profile  support test  compare pair  sample  sample organize  two   treatment group effect size  confidence intervals  provide  allow critical assessment   biological relevancy  test result  userfriendly graphical interface permit easy exploration  statistical result  generation  publicationquality plots
 original release  stamp  park  beiko    limit  compare  single pair  taxonomic  functional profile  release add statistical test  plot  assess differences  two   treatment group along  increase compatibility  popular bioinformatic software input data  stamp  process functional  taxonomic profile produce  qiime  caporaso      picrust  langille      mgrast  meyer      imgm  markowitz       rita  macdonald      custom profile  also  specify   tabseparated value file stamp  process input file contain hundreds  sample span thousands  feature   standard desktop computer statistical hypothesis test  welch  test  white nonparametric  test  white       provide  compare profile organize  two group stamp implement  anova  kruskalwallis  test  compare three   group  profile statistically significant feature    examine  post hoc test  tukeykramer  determine  group  profile differ    effect size  confidence intervals  widely use effect size measure  provide   statistical test  aid  determine feature  biologically relevant differences  group twogroup test use  difference  mean proportion effect size measure along  welch confidence intervals  etasquared effect size measure  use  consider multiple group filter  feature   feature   filter base    value effect size  prevalence within  group  profile  create plot focus  feature likely   biologically relevant specific subsets  feature  also  manually filter plot  numerous publicationquality plot   produce use stamp principal component analysis pca  fig   plot bar plot  supplementary fig   boxandwhisker plot  fig   scatter plot  heat map permit  initial exploratory analysis  profile extend error bar plot  fig   provide  single figure indicate statistically significant feature along    value effect size  confidence intervals fig  example output  stamp    pca plot compare classlevel taxonomic profile   cbm communities sample  shallow core cuttings   drill core deep core cuttings produce water niches within  coalbed environment    boxandwhisker plot illustrate rhodocyclaceae taxa   present  appreciable number within communities sample  shallow core cuttings    cog categories differ significantly  melainabacteria  oxyphotobacteria genomes   effect size ≥ open  new tabdownload slide example output  stamp    pca plot compare classlevel taxonomic profile   cbm communities sample  shallow core cuttings   drill core deep core cuttings produce water niches within  coalbed environment    boxandwhisker plot illustrate rhodocyclaceae taxa   present  appreciable number within communities sample  shallow core cuttings    cog categories differ significantly  melainabacteria  oxyphotobacteria genomes   effect size ≥",-0.2838666448534945,0.2756561081342092,0.0644848212832585,0.12409456755508555,0.037989142775182894,-0.1009429761838201,-0.07103052088913657,0.059507872374761385,-0.01057032953958804,0.13327164847139247,0.010150410656503142,-0.07935852749953763,0.13443730153231578,-0.12240800139158085,0.13310512444610606,0.048357930468373306,0.0500985565884645,0.116877099183614,-0.034815251276850395,0.0777018677447399,-0.026768407792668543,-0.2199344489841926,0.12011028807775595,0.03498541183642955,-0.05129836075085067,-0.2249706086961652,0.08580754680721607,-0.14521461909019648,-0.16375239333413408,-0.027998079556817487,0.05729986406131179,0.1871145342644745,-0.19151446278366813,-0.033916801030295714,0.14957260309540138,0.11046421646895492,0.06655460937753231,0.03416665063167994,-0.11107464482423646,-0.10038658626344517,-0.15705986463736202,-0.19368640444938576,-0.066809818243674,-0.06926288564907132,-0.09670154215801044,0.02893205953778468,0.030737173516505994,-0.13552505420741334,-0.19918911667132871,-0.29791021816633617,0.15833629020517306,0.0026299846937229646,0.03441238877178892,0.5394606112265552,0.03420679804148461,-1.1486577840808492,0.07941401220262932,-0.2508607930655332,1.0121061823870876,0.2180512933909188,-0.15027379054443898,0.339666859461711,0.0041151122292007744,0.10880905032962472,0.5951115188778505,0.025766062000545962,0.02560669024124984,-0.024702367182688777,0.2663502189008376,-0.1839202070941449,-0.012094698522603118,0.033785741762450985,0.08572246148333659,-0.12883458516323532,0.14478889043503526,0.009757598762857844,-0.050904487079207805,-0.1161301244813508,-0.3635573211544849,-0.036285436753536286,0.21507495925995967,-0.03825572017337797,-0.2867714608113623,-0.021539039802379333,-0.8238241186354464,0.052501141298948034,0.2701550443882685,-0.09335657367179688,-0.10449716653785056,-0.018224284822980944,-0.1702200526581008,0.09326530455958826,-0.15284265984902326,-0.10049823593050684,-0.08215558752500228,-0.05032879442869295,-0.1272718289869799,-0.3355823672106545,0.3617980415352824,0.09297810483327104,AbundanceEstimation,6
154,154,"imglad accurate detection  quantification  target organisms  metagenomes
accurate detection  target microbial species  metagenomic datasets  environmental sample remain limit   limit  detection  current methods  typically inaccessible   frequency  falsepositives result  inadequate identification  regions   genome   either  highly conserve   diagnostic  rrna genes  prone  frequent horizontal genetic exchange  mobile elements remain unknown  overcome  limitations  introduce imglad  aim  detect target genomic sequence  metagenomic datasets imglad achieve high accuracy   use  sequencediscrete population concept  discriminate  metagenomic read originate   target organism compare  read  cooccurring close relatives mask regions   genome    informative use  mytaxa engine  model   sequence breadth  depth  determine relative abundance  limit  detection  validate imglad  analyze metagenomic datasets derive  spinach leave inoculate   enteric pathogen escherichia coli o157h7  show   limit  detection   comparable    pcrbased approach   samples
overview   imglad pipeline imglad assume  read   metagenomic dataset originate  random   regions   genome thus  fraction   genome   recover   dataset sequence breadth  well   number  time  region  sequence sequence depth  depend   abundance   organism   community highly conserve regions  rrna  trna genes  well  regions result  recent horizontal gene transfer  transposase  integrase genes  recruit read   nontarget genomes  misleadingly increase  value  sequence depth  hence estimate relative abundance   datasets depend   gene composition   organisms present  address  problem  develop  framework  identify  fraction   target genome correspond  read  belong   target   fraction   result  spurious match  framework  two step initial train  subsequent prediction fig  train set selection   automatic  user define  automatic train generate read   randomly select number  genomes default   genomes  refseq pruitt tatusova  maglott   build insilicogenerated datasets    million read  simulate read   target genomes   generate   similar way  add   former datasets  order  create  positive datasets  decrease target abundances read   target genomes  omit   construction  negative datasets   genomes use  create  datasets  sample  equal proportion   relative abundances  user  also choose  genomes  use  generate  train set  genomes previously know  cooccur    environment   case  construction   train set   perform base   genomes rather   default genome collection  refseq simulate illuminalike read  generate use artmountrainier huang     default settings simulation  read  additional sequence platforms  provide   option use also artmountrainier read   positive  negative sample   recruit   target genome sequence reference use blat kent  alternatively blast   use  improve sensitivity   expense  computational time altschul     default read  identity higher     least    read length align  select  calculate sequence breadth  sequence depth  normalize   size   dataset  level  identity   show  capture well  genomeaggregate average nucleotide identity ani typically see   currently name bacterial species   ani within   ani  species konstantinidis  tiedje  rodriguez      sequencediscrete populations recover frequently  metagenomes  natural habitats caroquintero  konstantinidis  although different userdefined cutoffs   use  well members   sequencediscrete populations show high genecontent  nucleotide sequence similarity among  often   always  ani andor lower relatedness   ani  close relatives review  caroquintero  konstantinidis  sequence depth   calculate   number  read map   genome  multiply   read length  divide   total length   genome   sequence breadth   calculate   number  base cover  divide   total length   genome use eqs     respectively   genome consist    one contig  draft genomes  length  assume    sum   lengths   contigs sdl∗∕ sbb∕  logistic function  fit   result recruitment data     value   value alone see also   attempt  separate  positive   negative train datasets  term  sequence depth  sequence breadth  latter two   variables   function  particular  approach calculate  parameters   logistic function  compute  error   train set      value  observe    positive    negative train datasets  modify  parameters accordingly  reduce  error  convergence  reach error  assess   loglikelihood maximization via gradient approach  modify  parameter value   error  minimize regression coefficients   logistic equation  calculate      variables  well    intercept term  thus  model estimate three parameters     intercept final parameters   model  estimate  default  base   sequence breadth   variable  find     discriminate parameter  positive  negative sample see also  however  estimation include   also provide   option  order  produce  addition   probability  presenceabsence  accurate estimation   abundance   target genome estimation   probability  detection  limit  detection   parameters   logistic function   determine       use  reliably predict  probability  presence   target genome   number  query metagenomes   read   query   recruit   target genome  observe   estimate  describe   train datasets  probability  presence  estimate accord  ∓     linear function   form βtt  represent  regression parameters    either  vector compose            default  onedimensional variable correspond   base   model parameters     possible  establish  detection limit   target genome   metagenomic dataset analyze  limit  define   minimum fraction   need   sample  order  estimate  probability  presence    result  display   black solid line    plot      fig    value observe base   read recruitment  correspond   probability value equal  higher     use  estimate  relative abundance   organism   sample   correspond   probability  provide  limit  detection  term  relative abundance identification  target genomes  metagenomic datasets  imglad figure  identification  target genomes  metagenomic datasets  imglad positive datasets cross  separate  negative datasets dot   logistic function solid line base  insilico train datasets  datasets  read   coli  separate  negative datasets  datasets  read   anthracis  separate  negative datasets red asterisk denote  position   experimental metagenomes remain dot represent insilico generate datasets note  differences  scale   xaxes  positive  negative datasets download fullsize imagedoi peerjfig filter conserve regions  avoid spurious result  read map  regions   target genome  insufficient diversity high sequence conservation   rrna genes  frequently undergo horizontal gene transfer   mobile elements  user  create  filter   regions use mytaxa luo rodriguez  konstantinidis   filter  create  predict genes   target genome  determine  classification weight use mytaxa   mytaxa classification score    bottom    gene   score   hypothetical proteins  gene  remove   genome   analysis  filter version   genome  subsequently use   model train  probability estimation step bioinformatic tool comparisons  tool parameters use metaphlan  truong     run   default settings use bowtie version  langmead  salzberg   read map metamlst zolfo     use  default settings pathoscope  hong     run  default settings use   set  reference genomes   use  build  train datasets  imglad four test  perform  assess specificity  sensitivity   case sensitivity  calculate   proportion  properly classify positive datasets among  total number  positive datasets specificity  define instead   fraction  correctly identify negative datasets among  negative datasets examine   first test metagenomic datasets  create  similar parameters   train dataset   coli   datasets  refseq genomes  datasets  spike  seven different concentrations    coli genome  order  provide    coverage   genome  sequence breadth   second test human microbiome project hmp metagenomes  spike  read    coli genome  order  provide    sequence breadth    hmp datasets  use    coli concentration   third test  datasets construct  test   spike  read  close relatives   coli  klebsiella  ani salmonella  ani  escherichia fergusonii  ani  random concentrations   genome  addition    coli read finally  test use close relatives   ani represent strain    species  perform   hmp datasets   similar way  describe   test # leaf inoculation experiment  test imglad  sample sequence fifty grams  fieldgrown spinach leave  inoculate spike   cells  escherichia coli o157h7 strain rm6067  strain link    spinachassociated outbreak   usa carter    three serial dilutions  perform result  three inoculation concentrations       cells per pellet plus  control sample   inoculate cells cells  inoculation  obtain  single colonies   grow overnight  cell concentrations  determine  enumeration  colonyforming units cfus   agar plat leave  subsequently wash  leaf wash  filter  remove plant debris  leafassociated microorganisms  pelleted  centrifugation      min   ° dna extraction  perform use mobio ultraclean microbial dna isolation kit accord  manufacturers instruction mobio dna sequence libraries  prepare use  illumina nextera  dna library prep kit accord  manufacturers recommendations except   protocol  terminate  isolation  clean amplify double strand libraries library concentrations  determine  fluorescent quantification use  qubit  dna kit  qubit  fluorometer thermo fisher scientific formerly life technologies waltham  usa accord  manufacturers recommendations  libraries  run   highsensitivity dna chip use  bioanalyzer  instrument agilent santa clara  usa  determine average library insert size  equimolar mixture   libraries final load concentration     sequence use  miseq reagent  kit   cycle     pair end run   inhouse illumina miseq instrument georgia institute  technology run  miseq control software  mcs adapter trim  demultiplexing  sequence sample  carry    mcs additionally  use metagenomic datasets inoculate  bacillus anthracis dna   make available previously     mcfaddens pseudor2 metric  assess  robustness   logistic modelfunction  close relatives  ability   logistic model  distinguish  positive  negative train datasets  close relatives  increase relatedness   target genome  use   train step  assess use  mcfaddens pseudor2 metric specifically  model determine fit  imglad   certain train dataset  compare   standard null logistic model   contain  intercept variable effectively  null model represent  standard logistic curve center    point   fit imglad model  without  adjustment   shape   curve specifically  metric  define  r2mcfaddenloglcloglnull     maximize likelihood value   fit model  lnull   maximize likelihood value   null model intercept   covariates therefore   comparison show perfect congruence   two model pseudor2 close   value  mean   fit model   robust  similar   randomly draw model  contrast  pseudor2 approach   denote  robust fit model note  pseudor2 may  equal  even  robust model   null model may approximate  fit model estimate  imglad  chance alone   iterations since   draw use   intercept value   evaluation  genome  one close relative   time  add   negative  positive train datasets  similar relative abundance    ensure complete genome coverage   target genome  coli strain o157h7  add   positive datasets  genomes  relatives  sort   follow group correspond   ani value   target genome                  genome  find  ani value     ani  addition   relate genomes  uniform background dataset  include  genomes show  ani   coli strain o157h7  include  provide positive  negative train datasets  adequate complexity successive iterations  imglad   result train datasets   contain one close relative  vary ani value   target genome  perform  model  evaluate use      implement   scipy module  python",-0.1988258408992078,0.20098227830291024,0.08509061273358852,0.11702330566616476,-0.04087886261414,-0.030009639662572783,-0.04677610754336699,0.03448069731311065,-0.05129026803069709,0.16479066890426075,-0.02199408892895384,-0.038119744160001294,0.13331471980480095,-0.07371436480973415,0.16572158213344804,-0.020808480658649573,0.05943903887662156,0.1773450709677362,-0.016585373620548287,0.045702416988232505,-0.021987028149532968,-0.2333951770563457,0.06298742691281432,0.028585206887755756,-0.030271538017324413,-0.13447472765558344,0.08898543169343348,-0.12341532201722548,-0.07079444838880676,-0.05815525370578264,0.0041981701922523505,0.22840039532829395,-0.16010241666672448,-0.04174603957620732,0.20373758280755636,0.05426362586400375,0.06588278565080008,0.036478010079351864,-0.07450192800214676,-0.10024292918197647,-0.08280269433133652,-0.16024390369375974,-0.1243669697924005,-0.10386600287672564,-0.08465731822171024,0.02051152352170981,0.10182429341646064,-0.11976999970796955,-0.237312254305978,-0.2832718909981774,0.14809770404023986,0.00759523714230837,0.049289787438961785,0.5565696411585256,0.016325399418722353,-1.025877981074408,0.02750251508800029,-0.21928307803169386,0.8724528755401066,0.1898014317250797,-0.13676340099786047,0.2796726986235971,-0.0374265412526195,0.07779100733484225,0.5700198149117565,0.06954527302360343,0.02393526201831099,-0.031846893558203616,0.2322498137906097,-0.1547860000226537,-0.06934908011828714,-0.02619800624351428,0.10158024468238824,-0.08302453611199888,0.2006190638374808,-0.017622416593284836,-0.1009463601844544,-0.16238727989602492,-0.34033029671114434,-0.03772680782986868,0.1885797129100167,-0.0008516661616163952,-0.4060591435127092,-0.028647067006605555,-0.7567064421783419,0.08579511829050168,0.253822534027959,-0.11956161928661894,-0.11032758206750236,-0.005785394893456741,-0.1785252603876342,0.061958064173560375,-0.09238528598272353,-0.10702149236263447,-0.07775505906889578,-0.04849617648890881,-0.10850385776505436,-0.3147539637198785,0.247676144888584,0.004220931322229122,AbundanceEstimation,6
155,155,"metaphlan2  enhance metagenomic taxonomic profiling
metaphlan metagenomic phylogenetic analysis   method  characterize  taxonomic profile  wholemetagenome shotgun wms sample    use successfully  largescale microbial community studies2  work complement  original specieslevel profile method   system  eukaryotic  viral quantitation strainlevel identification  strain track    extensions make  metaphlan2 computational package   supplementary softwaremetaphlan metagenomic phylogenetic analysis   method  characterize  taxonomic profile  wholemetagenome shotgun wms sample    use successfully  largescale microbial community studies2  work complement  original specieslevel profile method   system  eukaryotic  viral quantitation strainlevel identification  strain track    extensions make  metaphlan2 computational package  efficient tool  mine wms samplesan efficient tool  mine wms sample  method infer  presence  read coverage  cladespecific markers  unequivocally detect  taxonomic clades present   microbiome sample  estimate  relative abundance1 metaphlan2 include  expand set   million markers  ±    bacterial species   species base   approximately tenfold increase   number  sequence genomes   past  years subspecies markers enable strainlevel analyse  quasimarkers improve accuracy  allow  detection  viruses  eukaryotic microbes
  editor metaphlan metagenomic phylogenetic analysis   method  characterize  taxonomic profile  wholemetagenome shotgun wms sample    use successfully  largescale microbial community studies2  work complement  original specieslevel profile method   system  eukaryotic  viral quantitation strainlevel identification  strain track    extensions make  metaphlan2 computational package  cibiounitnittoolsmetaphlan2  supplementary software  efficient tool  mine wms sample  method infer  presence  read coverage  cladespecific markers  unequivocally detect  taxonomic clades present   microbiome sample  estimate  relative abundance1 metaphlan2 include  expand set  ~ million markers  ±    bacterial species   species supplementary table  base   approximately tenfold increase   number  sequence genomes   past  years subspecies markers enable strainlevel analyse  quasimarkers improve accuracy  allow  detection  viruses  eukaryotic microbes  full list  additions  provide  supplementary note   supplementary fig   validate metaphlan2 use  synthetic metagenomes comprise  million read   species supplementary note   supplementary table  metaphlan2 prove  accurate average correlation  ±   motu4  kraken5  ±    ±  respectively fig  supplementary figs   supplementary table   fewer false positives  average   compare      motu  kraken respectively  false negative  average   compare      two methods even  include genomes   absent   reference database supplementary note    adoption   bowtie2 fast mapper  support  parallelism metaphlan2    ten time faster  metaphlan   speed  comparable     test approach supplementary fig   apply metaphlan2  four elbowskin sample   sequence  three subject fig  supplementary note   supplementary table   data show  propionibacterium acnes  staphylococcus epidermidis dominate  sit  agreement  expect genuslevel results6  provide specieslevel resolution together   core species  find malassezia globosa    sample  confirm   coverage analysis supplementary fig  although  globosa   know colonizer   skin  metagenomic characterization highlight  ability  metaphlan2  identify nonprokaryotic species phages   propionibacterium  doublestranded dna viruses   polyomavirus genus  also consistently detect  subsequently profile  whole set   sample   body sit   human microbiome project hmp include  sample sequence   initial publication supplementary note   supplementary fig  microbes   track across sample extensively  culturedependent approach  metaphlan2  offer  possibility   cultureindependent set  fingerprint  microbiome   strain level   illustrate   multipletimepoint    hmp data set    find  speciesspecific strain fingerprint  subject specific  conserve longitudinally supplementary note   supplementary figs   confirm  strong subjectspecific strain retention   gut microbiome   ability  metaphlan2  perform strain fingerprint  track   retention pattern  unlikely  occur  longitudinal sample  chance additionally strain identification  possible   sample contain  previously sequence genome supplementary note  supplementary table   supplementary fig  metaphlan2s enhance taxonomic profile include associate postanalysis conversion  visualization tool   characterization   hmp data set  serve  convenient tool  extend reference  future analysis   human microbiome",-0.15904253193630127,0.2339528674011999,0.06502007836008171,0.07093363791306871,-0.02313989990202864,-0.07384596834590161,-0.054977601774213535,-0.0002162549580626805,-0.05634982820702801,0.11107913013269972,-0.021536725623439144,-0.007918405678195862,0.1872468303948846,-0.06685005385645477,0.17693490521243235,0.047496472994947525,0.05308988133932404,0.14229983414006378,-0.051852194353117866,0.10882907612740547,-0.040268217197431413,-0.17306449683810318,0.025910298517315626,0.012378783530230985,-0.005919074108866856,-0.13483034857813644,0.1333776872387207,-0.13304053831614826,-0.05199957991642621,-0.004812256974561157,0.0072861913497636625,0.205500715044797,-0.16907107138177466,-0.01921970488016553,0.2367620560701845,0.10147536183288748,0.007721635606994324,-0.06558697702311868,-0.10157244029847924,-0.04555005688805543,-0.1683431030990697,-0.11391895252778975,-0.08946553939833828,-0.06857902799901731,-0.0993137883424007,0.024682037944589324,0.14089426660478765,-0.15783085777005607,-0.22131026833779566,-0.3191608007139646,0.17112983142478613,0.015765823120007787,0.004339203088161954,0.5195557271053485,0.027448447636134257,-0.9927082454909596,0.042726860402489436,-0.2366051916278677,0.8468365886445166,0.1554292813520195,-0.1641286264955752,0.3630387101656439,0.015567900411092562,0.04354282263068295,0.5439297218567802,0.08140703069191392,0.002769979334291105,0.035168766015510444,0.2625533672863481,-0.17635239777936218,-0.005626456687198055,0.03933736976073765,0.09571426293378538,-0.11777038942731985,0.1519430092014714,-0.009020623880750372,-0.10969361867178913,-0.11930154343755113,-0.35430866980299336,-0.031822229115561575,0.1847288683911256,0.0002275935818501022,-0.3001529333844392,0.007425540643786892,-0.7789842255259736,0.050446064506204584,0.2895773163389996,-0.10924651210918304,-0.14324725875598934,0.029486193141148108,-0.1393412641495778,0.031616605754189814,-0.0818990006874136,-0.1065096181161582,-0.009033976430329708,-0.06851169333682147,-0.15841152645869674,-0.306764243485688,0.2562305859424635,0.08312190442833059,AbundanceEstimation,6
156,156,"metaphyler taxonomic profile  metagenomic sequences
 major goal  metagenomics   characterize  microbial diversity   environment   popular approach rely   rrna sequence however  approach  generate bias estimate due  differences   copy number    rrna gene  even closely relate organisms  due  pcr artifacts  taxonomic composition  also  determine  wholemetagenome sequence data  match individual sequence   database  reference genes one major limitation  prior methods use   purpose   use   universal classification threshold   genes   taxonomic level  propose  better classification result   obtain  tune  taxonomic classifier   match length reference gene  taxonomic level  present  novel taxonomic profiler metaphyler  use marker genes   taxonomic reference result  simulate datasets demonstrate  metaphyler outperform  tool commonly use   context carma megan  phymmbl  also present interest result obtain  apply metaphyler   real metagenomic dataset
building  reliable phylogenetic marker genes database  use metagenomic sequence  taxonomic profile  analyze  protein cod marker genes previously show  provide sufficient information  phylogenetic analysis   phylogenetic marker genes  universal present     genomes   rarely subject  horizontal gene transfer hence  provide   accurate estimation   microbial composition  methods rely   rrna alone  order  create  accurate  comprehensive reference dataset  use  manually curated marker genes  amphora  seed  extend   include marker genes   complete genomes  ncbi  protein database   draft genomes  addition   also include phylogenetic marker genes  archaea whose information   available   seed dataset  amphora   result  final marker genes dataset cover  genera  families  order  class   phyla  build metaphyler classifiers many previous metagenomic study employ homologybased classification methods  apply  universal threshold   genes  taxonomic label   best similarity hit   transfer   query sequence  improve variant   approach involve combine  top hit instead   use  best one   propose  better classification result   obtain  tune  taxonomic classifier   blast hsp length reference gene  taxonomic rank  detail  learn parameters   reference database  build  taxonomic classifier   particular reference gene   follow figure   simulate 60bp metagenomic read   reference marker genes   curated  describe   previous section    negative set  genomic sequence    contain marker genes  map  simulate read  reference gene  use blastx   build  classifier  gene    specific taxonomic level say order  vector border  store blastx bite score  gene    simulate read      order  vector belse  store bite score  align   read     find  bite score cutoff bcut  minimize  follow error function  ∈border ibi  bcut   ∈belse ibj  bcut      indicator function  equal    condition  meet   otherwise note   taxonomic tree  download   ncbi taxonomy database  repeat  previous three step  find bite score cutoffs  simulate read  lengths 120bp 180bp     length  gene   60bp increments   find cutoffs  sequence  arbitrary match lengths base   sequence lengths   sample  build  linear regression  cut     see     choose linear regression     sequence length  cut   bite score cutoff  length       parameters  repeat step      build bite score cutoff regressions   taxonomic level genus family class  phylum  gene    repeat   procedures  build classifiers   reference marker genes   database  step   assume  bite score  close phylogenetic neighbor  higher  distant neighbor   generally true  marker genes    closely relate phylogenetically tend    similar sequence   phylogenetic relationships   marker genes   fully consistent   correspond taxonomic tree   download   ncbi taxonomy database ideally  would expect  see  cutoff bcut   lower    score  border  higher  score  belse  error metric equation   use   count   number  misclassified point   similar   norm distance use  svm classifiers next  show   step  linear regression   reasonable approximation  bite score base   match hsp length  describe    bite score sbit             raw score   blast alignment      parameters depend   database  addition  raw score  equal  sum   score  match amino acids    sij  logqijpipj      logodds ratio   observe  expect frequencies  gene   length    rewrite   lsijl  metagenomic read   length   ≤    simulate 60bp  metagenomic read  eads  map simulate read  reference gene  use blastx  minimize error function bcut  repeat      find cutoffs  longer simulate read  build linear regression   taxonomic level figure  build metaphyler classifier   contain  subsequence   fulllength gene   raw score    smnl     assume   evolutionary mutations  amino acid compositions  randomly distribute across gene   smnl ≈ sijl  sij   indicate     sij  hence   rewrite equation    gene fragment   bite   sij        sij   constant   particular gene    result  bite score  bite   subsequence  gene   linearly correlate   hsp length      estimate  relationship   linear regression   step   classify metagenomic sequence  query metagenomic sequence  initially map   reference marker genes use blastx metaphyler classify  sequence individually base   best reference hit  example assume   query sequence   gene    best hit  blast bite score     hsp length   first  try  classify    genus level  calculate  bite score cutoff bcut  gene  use  precomputed linear regression function   bite score  higher   cutoff  ≥ bcut   transfer  genus label  reference   query  otherwise  try  classify   higher taxonomic level family order class  phylum use levelspecific classifiers build  gene   either  classification  successful  one   taxonomic level   query    classify  sideeffect   algorithm specifically  stringent classification strategy   avoid assign  organism   lowerlevel taxonomic group   evidence   support  assignment   ability  identify novel organisms  taxa  presence  novel organisms lead   detectable discrepancy   number  sequence assign   lower taxonomic level   number  sequence assign   higher less specific taxonomic level  example   set  query sequence  classify   particular order  cannot  classify   exist families   order   indicate   read come  novel familylevel clades figure   sequence    analyze use   novo approach  use minimus    potentially recover  fulllength gene  thus characterize  novel bacterium see  result section   example figure  detect novel organisms  metaphyler   example  novel organism   classify   order level   family level indicate  presence  novel familylevel clades",-0.20667763573655976,0.2227456529129995,0.11926096487986795,0.1517927665863681,-0.06588411831908161,0.004984483681619167,-0.07864042737892303,-0.007580736260933919,-0.07127494537671737,0.12948396532883635,-0.004703029525262537,-0.0199199661044986,0.2167009774777398,-0.0981232288362662,0.16281734766962472,0.027723245963352385,0.049850295692886,0.1801258883864648,-0.021785579959032474,0.11108264093436446,0.013208103946817571,-0.22205385554771054,0.060413005034206435,0.005070703308592784,-0.04653763549722498,-0.19123870715266092,0.07667262719714926,-0.17238293461850845,-0.03450252635138895,-0.05577592961399205,0.020168616033879518,0.22930331963143544,-0.16311837467510487,-0.056483282984845576,0.2506167293145154,0.09847198623756412,0.07041904113766577,-0.002144329507791553,-0.08239534713738976,-0.11420063128098265,-0.08910988463067042,-0.10178800575836247,-0.1254542540997136,-0.08026829450136573,-0.14213922254839415,-0.007953398707195447,0.09148662857614907,-0.07884345651473268,-0.2965007003655046,-0.3409185140877525,0.24171897302003345,-0.019462172746898432,0.10108561561937676,0.5816131699073595,0.043025110156486336,-1.051125662765844,0.012334064504830166,-0.2397754344387067,0.8786694579030154,0.23401160237281146,-0.1612200296379342,0.34473603847982304,-0.048132866594824006,0.037655098909272065,0.6713599687311216,0.05256722520716721,-0.006242873905284796,0.01969574044123874,0.217288404692772,-0.16775542587420206,-0.10493345059250032,-0.02307778871199844,0.14381678601484965,-0.1201002508358215,0.20350796970524246,-0.07133680182269017,-0.14297070979155252,-0.2437831796829414,-0.3815260281364317,-0.060321156203644935,0.13775684278393782,-0.03083483568043448,-0.4188673648457552,-0.06653378674819806,-0.8279049567332549,0.05830025149989524,0.1940983409906039,-0.16190042314410674,-0.1590242004751417,-0.028045951896092446,-0.2532229377276963,0.04704188316090949,-0.11345057449070735,-0.12832797662376833,-0.06278879942256026,-0.055652262493094885,-0.14076764995406849,-0.378761944296275,0.22792380634637086,0.06063347205199534,AbundanceEstimation,6
157,157,"protein signaturebased estimation  metagenomic abundances include  domains  life  viruses
metagenome analysis require tool   estimate  taxonomic abundances  anonymous sequence data   whole range  biological entities    usually  prior knowledge   data composition    domains  life  also viruses    include  taxonomic profile   fullrange approach however  difficult  realize owe   limit coverage  available reference data  particular archaea  viruses  generally  well represent  current genome databases  introduce  novel approach  taxonomic profile  metagenomes   base  mixture model analysis  protein signatures  result  simulate  real data reveal  difficulties   exist methods  measure achaeal  viral abundances  show  overall good profile performance   proteinbased mixture model   application example  provide  largescale analysis  data   human microbiome project  demonstrate  utility   method   first instance profile tool   fast estimate   community structure
 novel taxonomic profile approach taxypro  base  mixture model   protein domain frequencies   metagenome  describe   follow  argue   use  functional reference profile  mixture model components provide  powerful framework  cope   inherent underrepresentation  certain biological entities  current genome databases  problem  especially evident   case  viruses   fact  seem  possible  accurately estimate  fraction  viral dna  metagenomes merely base  genomic reference data  overcome  limitation  explore  possibility  include metagenomic reference data  improve  profile accuracy   inclusion  taxypro  straightforward  classical blastbased pipeline suffer   computational burden    extension  therefore realize  speedoptimized combiblast method  provide  classical baseline approach  comparison  taxypro see supplementary material  proteinbased mixture model  new method  taxonomic profile combine  detection  protein domains   mixture model reconstruction   result domain frequencies  mean  taxonomically label protein reference signatures thus  taxypro approach comprise two step first  estimate  overall protein domain distribution   metagenome  relative frequencies  pfam hit use  comet domain detection engine  result profile comprise  relative frequencies    protein domain families accord  release    pfam database   approximate  pfam profile vector    metagenome  linear combination   precalculated protein reference signatures  external file  hold  picture illustration etc object name  btt077i1jpg  mix weight  accord  equation image          estimation   mixture weight  use  expectationmaximization  algorithm dempster    whereby  external file  hold  picture illustration etc object name  btt077i2jpg   external file  hold  picture illustration etc object name  btt077i3jpg sum   mixture weight   viral reference signatures  finally obtain  estimate   virus fraction   give metagenome  fraction  bacterial  archaeal dna  well   composition   specific phylogenetic level  estimate    way  sum   weight   correspond reference signatures  approximation error    mixture model   divergence   original pfam profile vector    approximation  external file  hold  picture illustration etc object name  btt077i4jpg  refer    fraction  domain hit unexplained fdu  fdu  calculate accord  equation image           half  manhattan distance   two profile vectors  therefore range      term   use protein signatures  fdu measure  fraction  pfam domain hit  could   reconstruct   model   fraction   miss   reconstruct profile vector  external file  hold  picture illustration etc object name  btt077i5jpg  predict domain frequencies owe  symmetry    equally size fraction  domain hit   overpredicted   model     present   actual metagenome profile  together  two fraction make   complete manhattan distance accord   overall  approximation error  error   important indicator   reliability   abundance estimate  better  model fit  actual distribution  pfam hit   lower  fdu value     trust  taxonomic profile  directly result   estimate mixture weight note  half  manhattan distance  also  use  measure  divergence  two taxonomic profile whereby  yvalues represent different relative abundances  phyla   context  distance measure correspond   braycurtis dissimilarity   widely use  ecology  comparison  two assemblages bray  curtis   reference signatures  viral metagenomes   reference signature vector profile  external file  hold  picture illustration etc object name  btt077i6jpg    use genomic pfam profile  several prokaryotes eukaryotes  viruses   also use  collection  metagenomes  computation  reference vectors   number  available phage genomes    sufficient length  estimation  pfam profile  rather small  variation  viral signatures  large  use additional reference signatures obtain   collection  viral metagenomes  total taxypro include  phage genomes   viral metagenomes  addition   bacterial  archaeal   eukaryotic genomes  obtain  functional reference signatures   estimation  pfam profile require  sufficient amount  dna sequence   use phage genomes   length  kbp  computation   reference signature depend   particular treatment  viral metagenome data  current databases contain  vary amount  microbial contamination  reason  accuracy  mixture approach    use  viral signatures  arise  sequence data    small virus fraction therefore  implement  selection criterion  require  reference signatures  viral metagenomes   well distinguishable  microbial metagenome signatures use  pfam profile   metagenomes   camera website    april   train linear classifiers  discriminate  viral  microbial metagenomes  stepwise elimination  apply  reduce  signatures regularize least square classifiers  pfam domain frequencies lingner     optimize   fold crossvalidation  minimize  classification error  optimization  perform  time  time   different random partition   crossvalidation therefore  signature  use  time   test example   one   highest misclassification rate    run  eliminate  whole procedure  repeat   reduce set  signatures   test error occur    crossvalidation run   way  original number   viral metagenomes  reduce   viral reference signatures   finally include   mixture model see supplementary table   contrast   oligonucleotide signatures   original taxy approach  pfam signatures  taxypro depend  sequence length  make genomic  metagenomic pfam profile compatible  fragment  genomic sequence  perform  comet domain detection   purpose  use half overlap fragment     length",-0.1602490768306639,0.2400046235509731,0.14352255269399572,0.19578837565137566,-0.031656926620475465,-0.017215523873206098,-0.09818575838257557,-0.01633825133428306,-0.026906300590149836,0.14360180539181838,-0.017782002697369726,-0.048799797819856834,0.1818277680713809,-0.10216698219613334,0.16569249715938086,0.020568491390844577,0.033997444638670986,0.2356092054176523,0.017034872455598805,0.08025774781368908,-0.026236645109093626,-0.2486449108210801,0.041945689155100274,-0.020170719812298045,-0.0026963596402635147,-0.16845452388688298,0.12999731026683886,-0.13843896067980382,-0.11273264879513567,-0.0852188787605593,0.01276840634309108,0.24489572580480706,-0.1878847181224132,-0.10629100836567397,0.206312362575916,0.07302131748127337,0.0922938445773951,0.03890153830716745,-0.09374198524688283,-0.14268900491282555,-0.09776153474200036,-0.1235248420234826,-0.10621764202057224,-0.07579673266835946,-0.13046076893035252,-0.023296912782917338,0.1767640231487162,-0.12763545167638274,-0.27523871523229704,-0.3131074164546027,0.22801222370302876,0.008261940341768933,0.08344009268605841,0.5995369721097542,0.046650544191601945,-1.1612485399064298,0.02895704059669166,-0.2492726093443696,0.9800219843957326,0.2273616729982121,-0.16196255754291636,0.3406602645256889,-0.05947088462753039,0.06796402265670289,0.701295666428935,0.07347287077527223,0.03151727486798416,-0.041098352128710325,0.2416461875518249,-0.2022123699471625,-0.0973469140945474,-0.007469902636207146,0.13933419940024774,-0.07537157515692597,0.2369906255172577,-0.07257048717967296,-0.13745687519455746,-0.19079648826399093,-0.4113348957991421,-0.03884377526501282,0.18430896471063565,0.005469936206907457,-0.3660316528717191,-0.07967460673571966,-0.9223931743634852,0.11101036554250912,0.20389419000548803,-0.1982502518908476,-0.16653702783542287,-0.07589557114198997,-0.18985944005222966,0.044166968965830215,-0.0897319542250687,-0.08856822162857779,-0.05522790389012087,-0.0832512158994513,-0.12315909208271547,-0.4028785564121056,0.33659944807220404,0.06654618346875632,AbundanceEstimation,6
158,158,"trimmomatic  flexible trimmer  illumina sequence data
although many nextgeneration sequence ngs read preprocessing tool already exist  could  find  tool  combination  tool  meet  requirements  term  flexibility correct handle  pairedend data  high performance   develop trimmomatic    flexible  efficient preprocessing tool  could correctly handle pairedend data  value  ngs read preprocessing  demonstrate   referencebased  referencefree task trimmomatic  show  produce output    least competitive    many case superior   produce   tool   scenarios tested
trimmomatic include  variety  process step  read trim  filter   main algorithmic innovations  relate  identification  adapter sequence  quality filter   describe  detail   list    process step  present   supplementary materials  removal  technical sequence trimmomatic use two approach  detect technical sequence within  read  first refer   simple mode work  find  approximate match   read   usersupplied technical sequence  mode   advantage  work   technical sequence include adapters  polymerase chain reaction pcr primers  fragment thereof  sequence   detect   location  orientation within  read  require  substantial minimum overlap   read  technical sequence  prevent falsepositive find however short partial adapter sequence  often occur   end  read  inherently unable  meet  minimum overlap requirement  therefore   detectable  second mode refer   palindrome mode  specifically aim  detect  common adapter readthrough scenario whereby  sequence dna fragment  shorter   read length  result  adapter contamination   end   read   especially  case  longer read length  support   miseq although  short fragment  normally  remove  library preparation  practice  process   perfectly efficient  thus many libraries suffer   problem   extent palindrome mode    use  pairedend data   considerable advantage  sensitivity  specificity  simple mode note   current technical sequence identification approach  trimmomatic   design  filter  categorize data   basis  barcodes  simple mode  simple mode  read  scan   ′ end   ′ end  determine     userprovided adapters  present  standard seed  extend approach   homer   use  find initial match   technical sequence   read  seed   require  match perfectly   userdefined number  mismatch  tolerate base   seed match  local alignment  perform   alignment score exceed  userdefined threshold  align region plus  remainder   alignment  remove figure  illustrate  alignments test   technical sequence  process begin   partial overlap   ′ end   technical sequence   ′ end   read  show   test proceed  move  putative contaminant toward  ′ end   read    partial overlap   complete overlap   ′ end  scenarios  entire read   clip   contaminant  find within  read   base   ′ end   read   begin   alignment  retain  test process continue    partial alignment   ′ end   read remain   external file  hold  picture illustration etc object name  btu170f1pjpg fig  putative sequence alignments  test  simple mode  alignment process begin   partial overlap   ′ end   read  increase   fulllength ′ overlap  follow  full overlap   position   finish   partial overlap   ′ end   read  note   upstream adapter sequence   illustration     part   read   align region simple mode   advantage    detect  technical sequence   location   read provide   alignment  sufficiently long   read  sufficiently accurate however    short partial match  possible    scenarios     contaminant may   reliably detectable  palindrome mode  note  palindrome mode  specifically optimize   detection  adapter readthrough  readthrough occur  read   pair  consist   equal number  valid base follow  contaminate sequence   opposite adapters furthermore  valid sequence within  two read   reverse complement  detect  three   symptoms   adapter readthrough   identify  high sensitivity  specificity  performance reason  actual algorithm combine  three test  adapter sequence  prepended   respective read    combine readwithadapter sequence   pair  align     highscoring alignment indicate   first part   read  reverse complement   remain part   read match  respective adapters  alignment  implement use  seed  extend approach similar    simple mode global alignment score  use  ensure  endtoend match across  entire overlap figure  illustrate  alignments test  palindrome mode  process begin   overlap   adapters   start   opposite read  show    alignment would detect  read pair contain  useful sequence information  could  cause   direct ligation   adapters detection   scenario would result   drop   read test  proceed  move  relative position   read backwards test  increasingly longer valid dna fragment illustrate    scenario would result   trim   read  illustrate even    small fragment   adapter  overlap  show    overall alignment  easily sufficient  ensure reliable detection  process  complete   overlap region  longer reach   adapters   external file  hold  picture illustration etc object name  btu170f2pjpg fig  putative sequence alignments  test  palindrome mode  alignment process begin   adapters completely overlap  read  test  immediate readthrough  proceed  check  later overlap  include partial adapter readthrough  finish   overlap indicate  readthrough   adapters   main advantage  palindrome mode   longer alignment length  ensure   adapters   reliably detect even   presence  read errors     small number  adapter base  present  require palindrome mode   use  remove even  single adapter base  retain  low falsepositive rate   aware  one  tool adapterremoval lindgreen   independently develop  similar approach note however  palindrome  limit   detection  adapter readthrough  comprehensive strategy require  combination   simple  palindrome modes  alignment detection  score  algorithmic approach use  technical sequence alignments  somewhat unusual avoid  precalculated index often use  ngs alignments   homer  initial sequence comparisons   use  base fragment   sequence   base  convert   bite integer know   seed use  bite code   base               seed   compare use  bitwisexor  determine  bits differ   two seed   result    code   match base   code  two     mismatch      mismatch  xor     within  result   count use  popcount operation   count   exactly twice  number  differ base   base fragment   seed  within  userspecified distance  full alignment score algorithm  use match base  score   external file  hold  picture illustration etc object name  btu170i1jpg     mismatch  penalize depend   quality score   external file  hold  picture illustration etc object name  btu170i2jpg   thus vary      result   higher penalty  base   believe   highly accurate simple mode align  read   technical sequence use local alignment   implement  find  highest score region within  alignment  thus may omit divergent regions   end palindrome mode align  forward  reverse read combine   adapter sequence  use global alignment    total alignment score   overlap region  quality filter trimmomatic offer two main quality filter alternatives  approach exploit  illumina quality score   base position  determine   read   cut result   retention   ′ portion   sequence   ′   cut point  discard  fit well  typical illumina data  generally  poorer quality toward  ′ end  two approach  describe   follow section  slide window quality filter  slide window use  relatively standard approach  work  scan   ′ end   read  remove  ′ end   read   average quality   group  base drop   specify threshold  prevent  single weak base cause  removal  subsequent highquality data  still ensure   consecutive series  poorquality base  trigger trim  maximum information quality filter  novel alternative approach  motivate   realization   many applications  incremental value  retain additional base   read  relate   read length intuitively   clear  short read  almost worthless   occur multiple time within  target sequence  thus  give  ambiguous information even   risk  introduce errors   worthwhile  retain additional lowquality base early   read    trim read  sufficiently long   informative however beyond  certain read length retain additional base  less beneficial  may even  detrimental read  moderate length  likely   already informative  depend   task  hand   almost  valuable  fulllength read therefore  smaller potential benefit  retain additional base must  balance   increase risk  retain errors  could cause  exist read value   lose     worthwhile   trim process  become increasingly strict   progress   read rather   apply  fix quality threshold   best   knowledge  approach    apply   exist tool  maximum information quality filter approach implement  adaptive approach  use  combination  three factor  determine  much   read   retain  first factor model  length threshold concept whereby  read must    least  minimal length   useful   downstream application  describe   short read  little value     ambiguous   informative    hand  long read   map   locations   target sequence   cannot  uniquely map    originate   repetitive region   unlikely   small number  additional base  resolve   read   extremes  marginal benefit   small number  additional base  considerable   extra base may make  difference   ambiguous   informative read  logistic curve  choose  implement  score behavior   give  relatively flat score  extreme value  provide  steep transition around  userspecified threshold point give  target length   putative trim  length  would give  length threshold score equation image  second factor model coverage  provide  linear score base  retain sequence length equation image  reflect  give reasonably highaccuracy base  longer read contain  information   useful   applications  final factor model  error rate  use  error probabilities   read quality score  determine  accumulate likelihood  errors   read  calculate  score  simply take  product   probabilities   base  correct give equation image  correctness probabilities pcorr   base  calculate   sequence quality score  error score typically begin   high score   start   read  depend   read quality typically drop rapidly   point   read  maximum information algorithm determine  combine score   three factor   possible trim position   best combine score determine  much   read  trim  userspecified strictness set     set     control  balance   coverage factor maximal       error rate factor maximal      give  follow overall formula equation image figure  illustrate   three factor  combine   single score  peak score   use  determine  point   read  trim  external file  hold  picture illustration etc object name  btu170f3pjpg fig   maximum information mode combine uniqueness coverage  error rate  determine  optimal trim point",-0.20549246275933436,0.1987754010445109,0.15064270205426467,0.160822218865648,-0.06576357459934883,-0.07132593352436553,-0.14482408179771322,0.055744547686764616,-0.03482632179769544,0.10701305714177524,-0.010876357051443884,-0.00021313652250357388,0.15935143607385224,-0.13210796638521088,0.16248659062194346,-0.09321551431299624,-0.01891207225179045,0.15950083840152424,-0.02975628635320256,0.07989341740640217,0.06627709848412483,-0.18701377378227668,0.04788750673642162,-0.020804557283627702,-0.03142775921151042,-0.15647796992737575,0.014964627099282812,-0.2329872745965343,-0.07060067422877606,-0.08942287816664504,-0.0014467224430801215,0.2819091604352706,-0.19328887708180675,-0.11387605779211535,0.21978704697147514,0.09991762260708466,0.06399834412267283,-0.022872659873886148,-0.13063491356347626,-0.10870514507145022,-0.09235564055092116,-0.13935926540391294,-0.03832648660384965,-0.14164998077488478,-0.1146203174019572,-0.05410692563735707,0.2254978876859908,-0.1522346898904008,-0.20724569400772447,-0.4817777507361837,0.20563666265087005,-0.007870293269116199,0.03209079884907327,0.6781413548035334,0.05950890755920485,-1.3140875453882594,0.10189898590030153,-0.2502282474492624,1.1071633578369795,0.19396024873395296,-0.1750662435866164,0.37029982103561976,-0.12707459963899798,0.0996451301414778,0.634604513463908,0.005991155004818451,0.05551792384807377,-0.01011267906915338,0.18126918525907465,-0.24074752854484904,-0.07660758445666296,-0.09261814135373404,0.11324607500106135,-0.10722932286268323,0.2760803918135446,-0.03823217563461346,-0.16243269072425753,-0.14450241233846192,-0.3633890693863516,-0.09548015534925698,0.2698934514710528,-0.012192865474562638,-0.429567230515332,-0.08952247108407298,-0.9835710870286958,0.002867316980835809,0.2024154385380703,-0.08924728705468578,-0.1334422510283972,-0.09657186637438524,-0.22922655563411914,0.08358688840576943,-0.12410506318162885,-0.10506143700018923,-0.1617851118433187,-0.05728454725744965,-0.08379708500438364,-0.3187543829435262,0.3540886430094806,0.11622362064512268,Trimming,7
159,159,"seqpurge highlysensitive adapter trim  pairedend ngs data
trimming  adapter sequence  short read data   common preprocessing step  ngs data analysis  perform pairedend sequence  overlap  forward  reverse read   use  identify excess adapter sequence   exploit  several previously publish adapter trim tool however  evaluation  ampliconbased data show     current tool   able  remove  adapter sequence   adapter contamination may even lead  spurious variant call   present seqpurge   highlysensitive adapter trimmer  use  probabilistic approach  detect  overlap  forward  reverse read  illumina sequence data seqpurge  detect  short adapter sequence even   one base long compare   adapter trimmers specifically design  pairedend data  find  seqpurge achieve  higher sensitivity  number  remain adapter base  trim  reduce      depend   compare tool  simulations  different error rat  find  seqpurge  also   errortolerant adapter trimmer   comparison seqpurge achieve   high sensitivity   high errortolerance combine   specificity  runtime   comparable   stateoftheart adapter trimmers   good adapter trim performance complement  additional feature   qualitybased trim  basic quality control make seqpurge  excellent choice   preprocessing  pairedend ngs data
 go   algorithm detail   briefly define  problem  formally give forwardreverse adapter sequence   forwardreverse read produce  one dna fragment remove  base   read  stem   readthrough   adapters  present  base  must   trim   stem   actual sequence  interest  call insert   follow text calculation  nonrandom match probability  mention   introduction  algorithm   base  sequence alignment  use  rather simple probabilistic approach give two dnarna sequence  length   count  number  match base    sequence give  probability    single base match  calculate  probability   observe    match base  sequence  length  use  binomial distribution ∑𝑖𝑘𝑛𝑛𝑖𝑛𝑖 𝑝𝑖𝑝𝑛𝑖  call two sequence  nonrandom match    less   give threshold  threshold   main parameter  balance sensitivityspecificity   algorithm use  simple approach  possible  model indels   necessary   insertiondeletion   insert  present   read directions  use  fix match probability      base   assume   four base occur    rate base   performance evaluations  simplification cause  major problems algorithm description  primary design goal  seqpurge   achieve   high sensitivity  maintain  stateoftheart specificity  general  insert match approach   sensitive  thus   best approach  pairedend read however certain sequence motives  unbalance base content  make sequence difficult  one read direction  even   read directions   difficult sequence  adapter match approach  perform better   insert match approach thus  combine  two approach  increase  sensitivity  seqpurge first  try  find  insert match  forward read   reversecomplement   reverse read  detect  insert match  possible offset   read  test   match see fig    find  match  adapters  trim   insert remain   find several match  select  best offset   one   lowest probability   random several match occur primarily  read  regions  simple repeat  prevent overtrimming   falsepositive match  simple repeat regions  also require  match   previously define adapter sequence   sequence flank  putative insert  additional adapter match  require   one    two read  make  algorithm  robust towards bad read quality  one read direction   insert match  find  check  adapter match   forward  reverse read separately   possible offset  test   adapter sequence match   adapter match  detect  read  trim start   offset position   one   two read   adapter match   read  trim   offset  well   read   always symmetrical  rationale    one read could  bad quality due  sequence problems theoretical runtime  runtime optimizations  theoretical runtime   algorithm        number  read     read length  implement several optimizations  reduce  runtime  practice   need  calculate  match probability   time   read pair  three faculty value  require   calculation  faculty value  precalculated  store   hash  fast lookup  avoid  large part   match probability calculations  add  minimum match base parameter default      maximum allow number  mismatch   comparison  exceed  rest   comparison   skip  reduce  overall runtime      read  data  file  process  data    thread  slow   analysis considerably  file   slow thus  prefetch read    thread  use  additional thread  data analysis     default  strategy  course increase  memory usage slightly   currently evaluate  possible speedup  use four bitarrays instead  character  store dna sequence  approach  also use  skewer   fastest tool   comparison",-0.2400852083071274,0.18029670139954,0.13513877725316914,0.12963007160156378,-0.06300981875017075,-0.05445958066880966,-0.141321926062031,0.04663705201023878,-0.07191127931582741,0.11353718123451295,0.00551511689076095,-0.0058867180451348,0.13814160272229328,-0.0835072404457136,0.1456544935222595,-0.03970212005397996,0.0200867010904814,0.17879963232811746,-0.014277001899303756,0.060836306056796366,0.0195374027600572,-0.2299543870425212,0.029758244450579605,0.01373956365991504,-0.016398002739034353,-0.165059226317211,-0.014525163141379674,-0.2334198587249698,-0.04727000274778543,-0.062289371806987376,-0.052953133130476115,0.2940721566706235,-0.18844016014237802,-0.09579107870494256,0.17797399961144098,0.14659184780189646,0.02561396093721757,-0.024976880413540188,-0.07734305280750813,-0.11026182755285258,-0.09091186407209943,-0.17633743160067458,-0.02006806230342444,-0.11630704817587448,-0.16154599743106612,-0.022772460358194826,0.15266853774195507,-0.2477467000041337,-0.23352849609058934,-0.479396272478381,0.19911542997485207,-0.01546270335752671,-0.008305239407608526,0.6985375072221242,0.043396537376411866,-1.3555452414007196,0.053419742226270175,-0.1898402598383273,1.0688574361035623,0.19918037934117053,-0.15319427915235265,0.34577385937765004,-0.0962114583122574,0.1126238246065294,0.6140961522028046,0.007448403229993288,0.032422563359667096,0.010628858451571344,0.20490480426838809,-0.2060670050960917,-0.10946931047264144,-0.052951603634879114,0.07884498998452816,-0.12950234926979792,0.2138990329037751,-0.02534775484321384,-0.16254385483484984,-0.11949030841295155,-0.3258712114475202,-0.07070256888654249,0.2569204090931077,-0.02352223887846189,-0.4185451212143826,-0.07673939788078461,-0.99766147371819,0.019256277764432,0.20419273643018376,-0.10695742593182536,-0.12369843437866825,-0.10257151182269164,-0.2339139357697399,0.08327948104218401,-0.13356932478106295,-0.10226031477636313,-0.1669084969227345,-0.08752860247923602,-0.05747075555301572,-0.3327507356401428,0.3748817637810604,0.10863735974154194,Trimming,7
160,160,"skewer  fast  accurate adapter trimmer  nextgeneration sequence pairedend reads
adapter trim   prerequisite step  analyze nextgeneration sequence ngs data   read  longer   target dnarna fragment although typically use  small rna sequence adapter trim  also use widely   applications   genome dna sequence  transcriptome rnacdna sequence  fragment shorter   read  sometimes obtain    limitations  ngs protocols   newly emerge nextera long matepair lmp protocol junction adapters  locate   middle   properly construct fragment hence adapter trim  essential  gain  correct pair read however  investigations  show   adapter trim tool meet  efficiency  accuracy requirements simultaneously  performances   tool   even worse  pairedend andor matepair sequence  improve  efficiency  adapter trim  devise  novel algorithm  bitmasked kdifference match algorithm     expect time   space     maximum number  differences allow    read length     adapter length  algorithm make  possible  fully enumerate  candidates  meet  specify threshold  error ratio within  short period  time  improve  accuracy   algorithm  design  simple  easytoexplain statistical score scheme  evaluate candidates   pattern match step  also devise score scheme  fully exploit  pairedendmatepair information    applicable   feature   implement   industrystandard tool name skewer  experiment  simulate data real data  small rna sequence pairedend rna sequence  nextera lmp sequence show  skewer outperform   similar tool     utility  skewer  considerably faster   tool   comparative accuracies namely one time faster  singleend sequence    time faster  pairedend sequence   faster  lmp sequence skewer achieve  yet unmatched accuracies  adapter trim  low time bound
kdifference problem give  sequence ss1s2…    query pattern pp1p2…     threshold ≤ search  substrings   note  {′}   ∥′∥    ≤ extend kdifference problem give  sequence ss1s2…    query pattern pp1p2…     threshold ≤⌊⌋ search  substrings   note  {′}   ∥′∥    ≤   suffix   note  {′}   ∃  prefix   note  ′  ∥′′∥    ≤′ algorithms   kdifference problem  classic approach  compute   dynamic program matrix cmn use  follow recurrence 𝐶𝑖𝑗𝑚𝑖𝑛⎧⎩⎨⎪⎪𝐶𝑖𝑗𝛿𝑖𝑗𝐶𝑖𝑗1𝐶𝑖𝑗  𝛿𝑖𝑗{if𝑝𝑖𝑠𝑗otherwise  initialization   upper boundary      leave boundary  cii  …  … finally  algorithm test  last row   matrix  cmj  report  elements    greater    algorithm    time    space complexity  space bind   easily reduce    matrix   compute  columns note     …  report  match  time   ≤  compute column   require   knowledge  previous column   careful design      share one column vector  propose  ukkonen  ukkonen also observe   columns    last element greater      boundary index     note                         …   easy  prove      ≤  ccj use  observation ukkonen reduce  time     expect     algorithm  develop  ukkonens algorithm however  use  queue instead   array  store  elements  current column   boundary index     new element  correspond   topmost element   new column  elements   queue shift automatically   next lower position   elements transfer   diagonals  matrix   process inherently keep  basic properties  ukkonens algorithm  facilitate subsequent improvements lemma    dynamic program matrix   tackle  kdifference problem  value  elements along  diagonal  monotonically nondecreasing  proof  provide  additional file  appendix  theorem    match elements   query pattern  sequence  equal   precursors   diagonal    need   update   dynamic program process proof  theorem   direct consequence  lemma    dynamic program recurrence        word  mismatch elements need   update   dynamic program process  bitvectors  denote mismatch position  comparison   adapter sequence     four nucleotide character  precomputed   bitvector  mark  position   queue elements  exceed  kdifference constraint  maintain  unnecessary computations  update  column vector   inhibit    key point  lead   main improvement   algorithm  ukkonens algorithm  list  algorithm   bitmasked kdifference match algorithmhas  follow characteristics use  queue instead   array  store  elements   current column  boundary index  preprocessing calculate    four nucleotide character  bitvector  denote  mismatch position compare   adapter mark  internal cells  exceed  kdifference constraint   bitvector  shift   queue push   process  column start   input nucleotide update   cells  mismatch     mark  algorithm use  queue  size   several bite vectors  size ⌈⌉     word length   computer  example  equal    bite machine  hence   space        character   target sequence  character enter  queue   exit   queue      random sequence  expect size   queue   hence generally  algorithm    expect time however    restrict   bitmask operations  element   queue usually update    time  bite operations  negligible compare  element update operations  algorithm achieve   worstcase time  practice   better     expect time  ukkonens algorithm algorithm    improve   avoid  unnecessary update  constant time bite operations within  iteration cycle   target nucleotide  basic principle     element   diagonal   original dynamic program matrix   value   derive   adjacent diagonal   indel occur   correspond path  score  associate index   element  remain unchanged   precursor remain unchanged although   improvement  reduce  theoretical time complexity  expect    worstcase   experiment  large volumes  real data show   reduce element update operations   compensate   additional bite operations   extend kdifference problem  additional step bound    perform  check   elements remain   queue   hit  find  previous step deal  basecall qualities  main advantage   bitmasked kdifference match algorithm  myers bitvector algorithm      extend  handle basecall quality value  handle basecall quality value  introduce  follow parameters       g10  minimum penalty   mismatch       g10  maximum penalty   mismatch           penalty   insertion  deletion  penalty   mismatch  quality value   calculate  ⎛⎝⎜⎜⎜⎞⎠⎟⎟⎟⎧⎩⎨⎪⎪𝑃𝑚𝑖𝑛𝑃𝑚𝑖𝑛𝑞𝑃𝑚𝑎𝑥𝑃𝑚𝑖𝑛𝑃𝑚𝑎𝑥𝑞≤𝑞40𝑞≥   trivial  prove  pql  g1010q    score   negative logarithm   probability   correspond base  actually  match   adapter sequence  sequence error note   score scheme herein  induce penalties  mismatch  insertionsdeletions  match   possibility  false match base  sequence homology reduce exponentially   match length increase  false match possibility   reduce  set  longer alignment length   information  available  false match possibility   reduce   minimum  extend version  algorithm    take quality value  consideration  outline  additional file  appendix  deal  pairedend information unlike  standard  sequence  sequence read   dna template twice  opposite directions  different end  underlie fact      read  need   trim must   preserve pair sequence reversecomplement     illustrate  figure   additional file  appendix  figure  figure5 layout  pairedend read   adapter contaminants full size image use  property  program first find  kdifference occurrences  adapters   pair read use  extend version  algorithm   quality value consider   reversecomplementary property   trim pair sequence  check next  candidates  evaluate   score scheme  take  account  fitness  adapter sequence  pair read   alignment  reversecomplementary counterparts finally  program output  optimal occurrence    score scheme  use   follow 𝑠𝑐𝑜𝑟𝑒𝑖𝑑𝑥𝑝𝑠𝑐𝑜𝑟𝑒𝑟𝑒𝑎𝑑2𝑖𝑑𝑥…𝑟𝑒𝑎𝑑𝐿𝑒𝑛𝑎𝑑𝑎𝑝𝑡𝑒𝑟2𝑝𝑠𝑐𝑜𝑟𝑒𝑟𝑒𝑎𝑑1…𝑖𝑑𝑥𝑟𝑒𝑣𝐶𝑜𝑚𝑝𝑟𝑒𝑎𝑑2…𝑖𝑑𝑥𝑝𝑠𝑐𝑜𝑟𝑒𝑟𝑒𝑎𝑑1𝑖𝑑𝑥…𝑟𝑒𝑎𝑑𝐿𝑒𝑛𝑎𝑑𝑎𝑝𝑡𝑒𝑟1  idx   start position  trim      exyxp          yxy       maximum penalty   difference       yxy   penalty  match     calculate   kdifference match algorithms         denote  reverse complementary sequence    goal   find  idx  meet  kdifference requirement  maximize  score function deal  nextera lmp information matepair library sequence allow  generation  longinsert  libraries   useful   scaffold process   novo genome assembly    detection  longrange genome structural variations   nextera lmp library construction process   additional reactions call “tagmentation”  “circularization”   normal  library construction  tagmentation reaction use  specially engineer transposome  fragment  dna sample  tag  dna fragment  attach  pair  biotinylated junction adapters simultaneously   end next  tagmented dna molecules  circularize  shear  ultrasonics   subfragments contain  original junction part  enrich via  biotin tag   junction adapter trim adapters  nextera lmp read  like  reverse process  nextera lmp library construction  process nextera matepair read  program first trim  adapters     deal   read   trim junction adapters   process pair read separately use  extend version  algorithm ",-0.20736282337200612,0.1452055090852509,0.12447713650741675,0.1467014696652501,-0.0062456364241971225,-0.058046780729029815,-0.14682023484369852,0.05454443621773854,-0.04746073214662979,0.10822556284576687,0.02591795448658116,-0.04941172289118435,0.10784005558836074,-0.055289638600923084,0.14099514468144753,-0.03002426306333408,0.006276968917718644,0.19237114951468964,-0.01304988322279965,0.0036550568870093603,0.02476444487019929,-0.234164131360466,0.0006131932941487554,-0.0035763755280507404,0.03057973026543634,-0.1739843554715754,0.054378873602927175,-0.17505666135263018,-0.06690193272148763,-0.0708531189298443,-0.010173503684366994,0.2493787412669183,-0.18592877238158484,-0.08977994436735648,0.1977614728705728,0.09610613053632523,0.05434024820548542,-0.035032281733797264,-0.07144198521016884,-0.10869186122313253,-0.06326442220370572,-0.14289585713964248,-0.05207178097267271,-0.08222010902261549,-0.1265604314243436,-0.004302529174177117,0.12582550232604128,-0.12268864228766638,-0.1977473726695555,-0.339551724229433,0.19347863123830145,0.02033501164507069,0.06274464929267046,0.6057406194794308,0.053260924323828285,-1.1040413965120774,0.05230359111671173,-0.20445026944785533,0.9675822582142856,0.1829917376313344,-0.17644777154068542,0.2814837653564242,-0.10303890518683922,0.08889901780880081,0.5589362912877557,0.041906994170191,0.030712794612037388,0.004348616597430627,0.1936142356369918,-0.1851762310747824,-0.08295699527348048,-0.029952420606830586,0.11317343246761802,-0.12009819487399215,0.21275818207271294,-0.05767504947976671,-0.0923938535646762,-0.15053428816310035,-0.3365136767241467,-0.08216403709610266,0.17809024542547286,-0.03307063894704414,-0.39240061474632665,-0.07017408978749241,-0.8567952831097401,0.1123953061086209,0.21697031631008426,-0.13936817341831506,-0.11695622639739114,-0.05782869022061628,-0.23016694634768325,0.09375254900639003,-0.11073961035896376,-0.07538689785410539,-0.10549354982197097,-0.09133257732193686,-0.031028665791248574,-0.3303949423721744,0.3026433194299397,0.10261555632641496,Trimming,7
161,161,"ktrim  extrafast  accurate adapter  qualitytrimmer  sequence data
nextgeneration sequence ngs data frequently suffer  poorquality cycle  adapter contaminations therefore need   preprocessed  downstream analyse   evergrowing throughput  read length  modern sequencers  preprocessing step turn    bottleneck  data analysis due  unmet performance  current tool extrafast  accurate adapter  qualitytrimming tool  sequence data preprocessing  therefore still  urgent demand ktrim  develop   work key feature  ktrim include builtin support  adapters  common library preparation kit support usersupplied customize adapter sequence support  pairedend  singleend data support parallelization  accelerate  analysis ktrim   time faster  current tool  also show high accuracy  apply   test datasets ktrim could thus serve   valuable  efficient tool  shortread ngs data preprocessing
ktrim provide  adapter  qualitytrimming   sequence data  schematic workflow  ktrim  show  supplementary fig    current implementation ktrim perform qualitytrimming first   read ktrim screen  quality   sequence cycle   tail  head  stop   position   quality   correspond cycle  higher   give threshold  ktrim  trim   cycle   one   remain sequence  shorter   minimum acceptable size  parameter could  set   users  read   discard otherwise ktrim  perform adaptertrimming   read ktrim employ  dualindex scheme  search  adapters   sequence data  pairedend read ktrim use  head     two adapters link  read   read  respectively  index  find  potential ligate position “seed”   adapters  singleend data however ktrim use  head      next     adapter link  read    index  dualindex approach could tolerate sequence errors   adapter sequence thus improve sensitivity  find  “seed” ktrim search  adapters   leftmost “seed” cycle  compare  sequence data versus  adapters basebybase   end   sequence read   adapters whichever occur first   manner ktrim could handle  scenarios  adapters  completely include  partially cover   sequence data   number  mismatch identify   comparison  sequence read  adapters  smaller   dynamic threshold  parameter could  set   users  “seed” position   call   adapter ligation site  ktrim trim   cycle   “seed” position  ignore   rest “seed” otherwise  next “seed” position   investigate    “seed” get exhaust  adaptertrimming ktrim check  size   read    report  longer   minimum acceptable size specify   user  performance evaluations  million pairedend dna read   silico generate  read length  set     dna insert size range      hence  dataset  consist  read  contain complete  partial adapters  well    contaminate  adapters meanwhile random mutations  also introduce   read  simulate sequence errors notably  adapter information  know    silico read therefore allow accuracy evaluation  comparison  adaptertrimming algorithms furthermore  read also serve   test dataset  singleend read three widely use tool trim galore  wrapper   cutadapt program martin  trimmomatic bolger     seqpurge sturm     collect  performance comparisons  addition  real dataset collect   literature zhang     also analyze detail information include cod  simulation data generation  performance evaluations could  find  supplementary method",-0.2447366394094055,0.2258083029593364,0.1188056721175998,0.060964904717601284,-0.002324548829346895,-0.05502363304946879,-0.12322839971336468,0.12318577334375645,-0.0037314923900384,0.09661697660822692,0.04846391555080872,-0.0401137816271086,0.11566214287858002,-0.08110486306647613,0.1502362548646222,-0.03886745895440804,0.07097490368320084,0.18363034671496192,-0.04056249275099395,0.10945454782454253,-0.04421210266399856,-0.25402295458721136,0.0427686087991588,0.013021897890877614,-0.010330944603717907,-0.188100096901379,0.0036114059161485696,-0.1597329134212398,-0.04619718857064116,-0.03914723016247835,-0.06227613131447536,0.2509260611358757,-0.2060176388133408,-0.04271808474086134,0.2008573697603069,0.12513549686977413,0.0047221887731788365,-0.020865521625411217,-0.08665936396758231,-0.13898920082691602,-0.11650046972535187,-0.16171221015044976,-0.10961048291689468,-0.10630802521709262,-0.1515649741884639,0.008048587870392266,0.10413733741563813,-0.19532592906219112,-0.16432548600317134,-0.3938884892756483,0.205393056862238,0.006646248702209714,0.015019521682818487,0.6252129065736038,0.05635588829769049,-1.1527462073397343,0.030181110547798713,-0.19296511714062767,1.0073826146380205,0.14434607492123802,-0.1410100697501415,0.33348380124832433,-0.07188741512960051,0.10971348373469238,0.5687396767322065,0.034459223273982535,0.04907556981417612,-0.015160388556286332,0.21853082369808566,-0.19592344443563645,-0.03870378719520665,-0.025139988715925096,0.11574350189880422,-0.12451512965987005,0.20779723140479225,-0.012177436321792079,-0.11259785826522405,-0.06301363754801725,-0.3553403370672973,-0.10187541684646886,0.3000362671446055,-0.02404841710472616,-0.3840354116247376,-0.06926146555328515,-0.975342504725587,0.07300866699675325,0.2352836619233485,-0.07374183724055113,-0.14919038973975834,-0.0364157727980566,-0.1419005678058034,0.09542256009015368,-0.07871649394254768,-0.13160257041454315,-0.10094542617046433,-0.04591811861638434,-0.08615267428160622,-0.3007343512073886,0.3536777180369671,0.10160138236994788,Trimming,7
162,162,"condetria content dependent read trimmer  illumina data
  last  years dna  rna sequence  start  play  increasingly important role  biological  medical applications especially due   greater amount  sequence data yield   new sequence machine   enormous decrease  sequence cost particularly illuminasolexa sequence    increase impact  gather data  model  nonmodel organisms however accurate  easy  use tool  quality filter   yet  establish  present condetri  method  content dependent read trim  next generation sequence data use quality score   individual base  main focus   method   remove sequence errors  read   sequence read   standardize another aspect   method   incorporate read trim  nextgeneration sequence data process  analysis pipelines   process singleend  pairedend sequence data  arbitrary length    independent  sequence coverage  user interaction condetri  able  trim  remove read  low quality score  save computational time  memory usage   novo assemblies low coverage  large genome sequence project  especially gain  trim read  method  easily  incorporate  preprocessing  analysis pipelines  illumina data
condetri  implement  perl require version     platform independent   additional hardware  library requirements   distribute  artistic licensegpl   design  run singlethreaded  desktop computers   cluster machine  default mode    run  give  one fastq file  singleend sequence  two fastq file  pairedend sequence  advance options allow  user  control  things   quality value use  trim trim size  fraction   read contain high quality base   quality format use either illuminasolexa fastq format  sanger fastq format  choose  different offset score  trim approach   correct  actual quality score call   illumina pipeline instead  remove base  quality value lower   threshold   ′end   read  check  remain read  internal low quality base condetri apply two filter step   read first  read  trim one base   time   iterative process start   ′end   read base  remove   correspond quality score  lower   threshold   reach  base   quality score higher    base  keep temporarily  follow base  evaluate  parse  certain number  consecutive high quality base   trim  terminate however even base  low quality score   record    reach  save temporarily    consecutive low quality base  accept    surround  high quality base    overrun  temporarily save base  remove   process start    trim continue  either  consecutive high quality base  find   read  trim   length    trim read   approve  must contain    certain fraction   base   quality score higher     base   quality score less   lower bind threshold    base   quality score lower    read  remove   read   trim  read   read pair  examine   single read pass  quality check   store   new fastq file  pair end read pair    read fulfill  quality demand  save  new pair fastq file   pair contain  one read pass  quality requirements  high quality read  save   extra fastq  read   use  single end read besides fastq file condetri report  number  scan  remove read   number  read   present  pairedend   singleend read figure  summarize  algorithm   flowchart  figure  give two examples per default  high quality score   set     similar   sequence error probability    value  choose  inspect quality score distributions  several data set  different insert size   collar flycatcher genomesequencing project   level   number  base keep   highest possible quality without   considerable loss  read   set inspect change  quality threshold   result   loss   majority  read  filter    hand lower      increase  number  read keep significantly   per base error probability   read     three time higher  however  default value    mean universal   threshold   set accord   data  low quality score   set    equal  probability   sequence error    fraction   base   quality score higher    set      minimum number  base  trim  set    prevent save read    short   novo assembly  parameters     set     respectively  mean    low qualitybase  must   least five high quality base       value    connection   number must  consider  tweak  parameters  keep         increase     result  remove  large proportion  read   second step however   settings   change  desire quality score distribution along read  read length distribution  trim   libraries use  choose  default value  show  figure        s10 s11 s12 s13 s14 s15 s16 s17  table  condetri  read  three different fastq quality score standards illumina  solexa early illumina quality score   offset    sanger standard   offset   conclusion  main focus   quality filter approach   provide  accurate standardize  easy  use method  trim illumina sequence data  comparison   program data filter  condetri give better result  respect   size   assemble data  also  accuracy    novo assembly  comparison  untrimmed data less memory  time  need   novo assemblies   crucial  larger eukaryotic genomes  affordable computational resources  still  limit factor  perform assemblies  larger genomes use several insert size  pairedend sequence use qualityfiltered data reduce   bruijn graph   assembly process   improve downstream analyse  ngs data  snp call",-0.16315349279969638,0.2065228226072636,0.14338917444325736,0.14147762537101036,0.013989286195139623,-0.045312087992907216,-0.15423844125573308,0.10086529179038914,-0.03189446602106815,0.12381127021629296,0.05695477714361522,-0.03925695820414465,0.11076365399577463,-0.12718932885312773,0.09403140943223698,-0.07508472340201497,0.02536320944018762,0.2060137469028156,-0.04901461678767397,0.09210754605469136,-0.0030773611402132393,-0.2139900564608301,0.10627608835750584,0.04524353040485746,0.01952611178236489,-0.23475319346226084,0.022380097008954502,-0.21443226601090612,-0.04937292093019164,-0.059244321817557226,0.009067794165780976,0.29779173961279776,-0.17217306709618016,-0.07452677716926663,0.21145391557709892,0.10046621128010454,0.050834733727438165,0.010263910190799813,-0.1056076686714165,-0.09436088040830756,-0.0962548131385224,-0.20155750786891669,-0.07130071640016318,-0.10728706176591768,-0.13755442147680616,-0.02328104679189008,0.133750906099789,-0.2283167970253281,-0.19376608411744767,-0.4372413238410556,0.16900131144055155,0.0015378103155048572,0.017807822373251708,0.6726433833540287,0.017569266328935292,-1.373651650453013,0.043947242327221414,-0.2328826943049408,1.2253712023271242,0.2049949326926732,-0.13705537188182731,0.2824664149476352,-0.09809727489023626,0.10879496934049257,0.616602001906169,0.04710144899240161,0.036649160130503566,0.02553035175460341,0.2470493234608883,-0.21392905838452916,-0.019321212871229662,-0.05946197955671775,0.08561446756701566,-0.13529243422872436,0.2010543608026559,-0.0010617091533257276,-0.17239212146025534,-0.1224704706071203,-0.3995579822376157,-0.08333235588358669,0.28593653337563696,-0.02970552087346706,-0.39483854283935865,-0.04034210721741841,-1.0024734170248693,0.08439971008617597,0.24574963464134614,-0.13268235065193185,-0.13950561906801914,-0.04892121847488627,-0.11683400815764215,0.08365901927280116,-0.1049453246805276,-0.11589906886587165,-0.23949279312434935,-0.0952160818649182,-0.04676674661897524,-0.284530649970596,0.4401677354058671,0.08472809226479128,Trimming,7
163,163,"infotrim  dna read quality trimmer use entropy
biological dna read  often trim  map genome assembly   task  improve  quality   result biological sequence complexity relate  alignment quality  low complexity regions  align poorly   many read trimmers  many   use sequence complexity  trim alignment  read generate  whole genome bisulfite sequence  especially challenge since bisulfite treat read tend  reduce sequence complexity infotrim  new read trimmer  create  explore  issue   evaluate  five  trimmers use four read mappers  real  simulate bisulfite treat dna data infotrim  reasonable results
infotrim   multiprocess python  program feature  maximum information score use  cut dna read    end   read   substring    read start  base position   end  base position  start   first base  score stotaldl  compute    start    end   total length   read   position   maximize  score  choose  every base    discard   read  infotrim maximum information model involve four term  first term slendl   logistic function  provide  length threshold   cause  trimmer  strongly prefer read larger    reason     read    small    little information   useful  default       equation   follow slendl     eml  second term scovdl cause  trimmer  prefer longer read  shorter read  order  increase  coverage   read represent   simply  length   read give  linear relationship   length   score   describe   follow scovdl    phred score sphreddl   third term   measure base call correctness  phred score  base position   read    probability   base  call correctly  determine   sequence platform  phred number  positive integer  base position   give     probability derive    give  pcorrecti       phred term  give   follow formula  rationale  use  product  give   trimmomatic paper  sphreddl     pcorrecti infotrim add  fourth term  entropy  probability plb   frequency  base   find  read    shannon entropy  multiply  one half  give   scale      formula  infotrim use  give   follow sentdl      ∈{act } plb logplb  last three term  combine use  geometric mean   proportional change   term  contribute equally   final score parameters   entropy    phred  use  weight  relative contributions   last three term  value         must  add   one  example        entropy term   use   coverage  phred score    use thus  final score   follow",-0.2646870695415043,0.2973411515986006,0.12750859097727846,0.1783541082802619,-0.06595179888630105,-0.021902093917672196,-0.0948318613636788,0.07180039528757334,-0.117519414241636,0.14179949381298596,-0.02135869928470422,-0.007268216448926156,0.11322595009048875,-0.10531083684519776,0.1279805473006901,-0.08706260731353635,-0.01332557074004604,0.23648522262097216,-0.01854231799952686,0.08856562095123434,0.06427382111789719,-0.2122523839405227,0.02627459334570073,-0.008740943158045411,-0.012132712693945056,-0.1322643848436494,0.04859082673773951,-0.20737721363473086,-0.05096591045223777,-0.1117166297450181,0.01038744977164653,0.3184661730523071,-0.19183771002196492,-0.12458753142535925,0.17238289803029938,0.0971127746607958,0.06350510558714309,0.09259638407327717,-0.11958852018823005,-0.08917414658109568,-0.08355299182266238,-0.2363271923825866,-0.049542199705366885,-0.1578019959273778,-0.17254908050095005,0.004212055693853706,0.1635879993633998,-0.18990013049014154,-0.27018269673064954,-0.4432574370282612,0.15446331915746053,-0.03258754220103935,0.04990083881233248,0.7499995897156037,0.04978594707715656,-1.4076443178444018,0.0823991683341803,-0.20152198784353756,1.1048925348046807,0.2374025209765551,-0.18200991033940694,0.27647213512400703,-0.17095132387663808,0.039313406353035284,0.690835414929015,0.06955870687961578,0.043094724744197815,0.03386044181102226,0.20428359984052216,-0.168078408953208,-0.06049608199825724,-0.026785376294320748,0.05445995407794873,-0.12329206598712313,0.2584577244706452,-0.02914591041363535,-0.14460120677587487,-0.18788339092486328,-0.4013707738189447,-0.08072371652064424,0.2407085719420725,-0.0386788709269416,-0.4379478472795698,-0.10047436422300376,-0.9660611414681038,0.032739894440202345,0.2228661549337689,-0.18806482495349505,-0.11315618916790213,-0.09000712662424531,-0.23582463727572994,0.12332690377239018,-0.13182685350578638,-0.15070219705962845,-0.20929386365497785,-0.1037461026301307,-0.08448593125288044,-0.3287506236679732,0.33361433096710713,0.08726521493386358,Trimming,7
164,164,"cutadapt remove adapter sequence  highthroughput sequence reads
 small rna  sequence  current sequence machine  result read  usually longer   rna  therefore contain part   ' adapter  adapter must  find  remove errortolerantly   read  read map previous solutions  either hard  use    offer require feature  particular support  color space data   easy  use alternative  develop  commandline tool cutadapt  support  illumina  solid color space data offer two adapter trim algorithms    useful features
cutadapt  mainly write  python   speed  alignment algorithm  implement     python extension module  program  develop  ubuntu linux  test also  windows  mac     also work   platforms   python  available feature  program  initially develop  trim  sequence data collect  zeschnigk     insertions  deletions within homopolymer run  common   data cutadapt support gap alignment  small rna data analysis  schulte     program  modify  support trim  colourspace read   also  test  work well  illumina data cutadapt  search  multiple adapters   single run   program   remove  best match one   optionally search  remove  adapter multiple time   useful  perhaps accidentally library preparation  lead   adapter  append multiple time   either trim  discard read    adapter occur read   outside  specify length range  trim  also  discard  decrease  number  random hit  minimum overlap   read  adapter   specify  addition  adapter trim lowquality end  read   trim use   algorithm  bwa cutadapt  thoroughly unittested  program  actively maintain  many feature   add  response  request  users performance  theory adapter trim  cutadapt  dominate   time need  compute alignments   onk     total number   character   read     sum   length   adapters  practice  operations   read  parse  input file take    half   time    colourspace read   adapter  length  cutadapt trim approximately  million read per minute   per read   single core    ghz intel core  processor colourspace read cutadapt correctly deal  read give  solid colour space   adapter  find  adapter   colour precede  must  remove   colour encode  transition   small rna   adapter sequence  could otherwise lead   spurious mismatch  read map cutadapt  produce output compatible  maq   bwa   tool need fastq file    colour   encode   digits     letter acgt socalled double encode     last primer base give  nucleotide space   first colour  remove usage example   simple example  adapter aaccgg  trim  read   compress file infastqgz  result  write  outfastq cutadapt  aaccgg infastqgz  outfastq  use case  document   readme file   cutadapt distribution    website full documentation  available  type “cutadapt help”   command line algorithm   follow  character   nucleotide   colour encode    first step  process  single read   compute optimal alignments   read   give adapters cutadapt compute either regular  slightly modify semiglobal alignments regular semiglobal alignments also call endspace free alignments  chapter    penalise initial  trail gap  allow  two sequence  shift freely relative      “” parameter  use  provide  sequence   adapter  adapter  assume   ligate    end   molecule   behaviour  cutadapt  therefore  remove  adapter   character    regular semiglobal alignments  short usually random match  overlap  begin   read would lead   removal   entire read  therefore require   adapter start   begin  within  read   achieve  penalise initial gap   read sequence     modification  regular overlap alignment see figure  right column sppng figure   illustration show  possible alignment configurations   read  adapter sequence   two different trim behaviours trigger  whether option “”  “”  use  provide  adapter sequence note   case “partial adapter   beginning”   possible  option “”   alignment algorithm prevent  regular semiglobal alignment  use   location   adapter  unknown assume   “” parameter  use    adapter  find  overlap  begin   read  character   first nonadapter character  remove see figure    illustration   possible case  align  adapters   read  alignment   greatest number  character  match  read  adapter  consider    best one next  error rate   compute     number  errors     length   match segment  read  adapter finally   error rate    allow maximum  read  trim",-0.2511475932126974,0.22144614804682194,0.11938668192482975,0.042370865705386535,0.04038252267694356,0.01431162513212721,-0.06573645080777579,0.10454880370046286,-0.006532159930679436,0.10439764913354142,0.0908955303148604,-0.03574213456755102,0.15435044249644111,-0.07087900274040579,0.17908194140695474,-0.045904304659651486,0.05079121340760121,0.15927439933167953,-0.054176624661640214,0.0950386334251722,0.0336000330317035,-0.23780204576129715,0.01194377119890323,0.042706382270062376,0.06760383036864155,-0.1651865518834515,0.02786772604963249,-0.1269154960517863,0.0013105890293623884,-0.03278636626314883,-0.003633681995173296,0.3802324819876173,-0.2092055015174636,-0.07232698563979391,0.20939515322303012,0.1511074617943343,0.0302463936149234,-0.028895090308551693,-0.027562449092739357,-0.12526454913712964,-0.05249470207205627,-0.1661480426252477,-0.02183567806073994,-0.09694264642848614,-0.12830715940251727,-0.04551624031143957,0.08116611561957089,-0.22219565113750744,-0.14710121286380126,-0.3824057154284388,0.1717289308373652,0.04129642326996534,0.034880700538519264,0.6258995924510208,-0.0001922654855412011,-1.3407892974860527,-0.008362411083105733,-0.21120026808816428,1.1417860470712184,0.2791576640637062,-0.1671452801232911,0.32672576588468955,-0.09419075535500752,0.07050479757690839,0.6352379470780565,-0.012927170936931291,0.07145282010383466,0.025143599246318142,0.1460128310538244,-0.18626182634684751,-0.07707573948439449,-0.010874089627873664,0.0709666114889414,-0.17331245479164828,0.20809273188568506,0.01717678249959706,-0.1193625388913514,-0.05917290900251827,-0.3601802519230428,-0.08545495596024956,0.22859993662511674,-0.07687594590071753,-0.4091278012342039,-0.06774917924685367,-0.9365185227496184,0.0902750942166712,0.27992622988006355,-0.15069710007850445,-0.06709480549336648,-0.04113342205619476,-0.20065004506385795,0.13001585056452886,-0.11752731032365953,-0.1090703001293792,-0.1577575622080807,-0.12161823643106676,-0.05653328409820211,-0.2968600348021616,0.4031352804371101,0.09529003868354302,Trimming,7
165,165,"alientrimmer  tool  quickly  accurately trim  multiple short contaminant sequence  highthroughput sequence reads
contaminant oligonucleotide sequence   primers  adapters  occur   end  highthroughput sequence hts read alientrimmer  develop  order  detect  remove  contaminants base   decomposition  specify alien nucleotide sequence  kmers alientrimmer  able  determine whether  alien kmers  occur  one    read end  use  simple polynomial algorithm therefore alientrimmer  process typical hts single  pairedend file  millions  read  several minutes   low computer resources base   analysis   simulate  realcase illumina® ™  ion torrent™ read data  show  alientrimmer perform  excellent accuracy  speed  comparison   trim tools
 alientrimmer algorithm decompose dna sequence  overlap kmers  sequence  length    standard task  bioinformatics give  nonzero positive integer value      kmers   store    bits  use  nbit binary code  provide    alientrimmer use  binary cod  define  b2a   b2c   b2g    b2t    order  deal  degenerate nucleotides   also use another binary cod  define  b4a   b4c   b4g    b4t   see   detail   cod  degenerate residues therefore  kmer  bijectively associate   unique binary number   bits usual computer word     bite long  binary cod allow kmers   ≤    easily compute  store give  alien  read sequence alientrimmer compute  binary representation   kmers  use three basic bite operations bitwise   bitwise    bite leave shift   formally     binary representation   kmer start  position   end  position        binary representation      next kmer  easily compute   formula         bnci    maskn       character state  position     maskn  constant binary representation      allow set  zero  bits shift beyond  nkth one follow  approach  list  every kmer   nucleotide sequence  length   compute  time  give  fix integer value     default alientrimmer first perform kmer decomposition   specify alien sequence   binary representation    extract alien kmer  compute follow  binary cod     order  deal   presence  degenerate nucleotides see   binary representation   kmer encode    equivalent   integer lie    polya  length       polyt  length   distinct alien kmer  store inside  bitset   size     alien kmer  b2coded    xth bite    set       integer value equivalent    alien kmer binary representation encode    store   sort list  note  alientrimmer also store  binary representations   reversecomplement   extract alien kmer  order   able  search   reversecomplement   specify alien sequence  read end  whole procedure allow compute  store   bitset   sort list      distinct kmers    extract   different specify alien sequence see algorithm detail  supplementary materials  denote    sum   different alien sequence lengths    ∈ ola even    much smaller    practice therefore  first precomputing step require ola log  time complexity give  read sequence  length  alientrimmer proceed  successive kmer survey follow   way   alien sequence however   read kmer alientrimmer search whether   present among   alien ones   read kmer  contain nondegenerate nucleotides        search  directly perform  consider   cod  look   precomputed alien kmer bitset  whether  correspond bite  set    contrast   read kmer contain  least one degenerate nucleotide alientrimmer consider   cod   able  deal   character state  set b4n    kmer contain degenerate nucleotides  compatible  another kmer   degenerate nucleotide   respective binary cod   ′ verify  simple property   ′  ′ indeed b4s  b4s′  b4s′     ′       read kmer  contain  least one degenerate nucleotide alientrimmer search whether  exist one compatible alien kmer ′ among   ones  lead   worst case  time complexity   read kmer   least one degenerate nucleotide however    b4coded alien kmers  sort   see   step  accelerate  search first  largest alien binary representation ′min   ′min   recall  b4n    binary search algorithm   allow find ′min among   alien kmers  time olog  reciprocally  update  second binary representation      cod  alientrimmer also search   lowest alien binary representation ′max      binary search algorithm thank   two cod        exist inside   least one alien binary representation ′ compatible   read one  contain  least one degenerate nucleotide  one  ′min ≤ ′ ≤ ′max  alientrimmer search  ′    two bound  two olog  binary search  ′min  ′max   modify  theoretical  computational complexity  allow observe faster run time  practice  crudely test compatibility        alien ′   use  previously describe method alientrimmer  able  determine every nucleotide index   read   exact alien kmer match occur  use  nucleotide index alientrimmer easily estimate  alien coverage within  read   number  time  read nucleotide  cover  alien kmers  alien kmer coverage   directly compute together   alien kmer match process without modify  overall time complexity see algorithm detail  supplementary materials  moreover  simple approach   easily extend  qualitybased trim  incrementing    coverage value  every nucleotide support   low phred score value finally alientrimmer perform trim  remove  prefix  suffix subsequences   read   alien kmer coverage  higher  zero fig  represent four examples  read contamination  graphical representations   alien coverage estimate   nucleotide       result trim alien residues though fast  efficient  complete alien oligonucleotide sequence  present   least one   end   read see figs     algorithm may  accurately perform  task  mismatch occur within  read end   trim  practice  situation correspond   single nucleotides  zero alien coverage occur  nucleotides  nonzero alien coverage see base   white background  fig  albeit infrequent  low quality nucleotides  trim  see section   fig   mismatch  easily accommodate  alientrimmer   follow manner  ′ end alientrimmer first search   index    first nucleotide  nonzero alien coverage second alientrimmer survey  follow alien cover nucleotides   nucleotide  index   zero alien coverage  reach give  specify number  mismatch   ⌈⌉  default alientrimmer verify whether  nucleotide  index     cover   alien kmer   alientrimmer reiterate  search   next index    nucleotides   index        cover   alien kmer see algorithm detail  supplementary materials   approach allow identify  subread define  index      mainly cover  alien kmers   subread  sufficiently close enough   ′ end   ≥   alientrimmer remove  read prefix   index   ′ end trim  perform follow   approach  start   last nucleotide index   nonzero alien coverage  perform backward search   index      nucleotides  index        cover   alien kmer give  collection  alien sequence  total length  decompose  store    distinct alien kmers require ola log  time complexity see    negligible  comparison   overall alien trim process give  read  length  alientrimmer  able  detect  remove alien sequence  ′  ′ end  time olr  olr  depend   absence  degenerate nucleotide within  read   respectively know   ∈ ola  overall time complexity require  alientrimmer  process  read  length   ola log      best case scenario   degenerate nucleotide  olalr  log    worst case scenario  presence  degenerate nucleotides within  read therefore  deal  standard hts data   read   degenerate nucleotide  ′ read  degenerate nucleotides  overall time complexity require  alientrimmer  ola log      ′  ",-0.2149721233574,0.2418861346913649,0.13197973732933047,0.12175610242679555,-0.04928261339053781,0.01706071208081994,-0.09380953073636383,0.058659785909663975,-0.026008921354093075,0.1172960545250374,0.050055460710274544,-0.045157001711854,0.15994908952322812,-0.04561067204983709,0.1152038090542766,-0.029848739825722174,0.04091547230047198,0.18924876965818266,-0.04491443513583554,0.0867037684786881,0.07586117006231738,-0.16756705491034632,0.0731608335368755,-0.006117036340200636,0.016295467037324624,-0.16149562469371104,0.03008985402304556,-0.16398848085219994,-0.02499497007882287,-0.06966729651876928,0.0042222963031810275,0.2094577511356635,-0.18037977436630934,-0.0998224984574144,0.1889598554573336,0.09830769689487122,0.0066988380969728745,-0.017011914382333328,-0.062451338972191725,-0.09743680220019182,-0.07058603987484514,-0.17249868513762953,-0.036731333745257486,-0.08686184183093965,-0.12652998751907849,0.015043613716108285,0.1260880433740232,-0.1347705127608558,-0.16383407966905475,-0.3853266009801269,0.1919334266743757,-0.03846587674572794,0.08056039207210568,0.6293062267236804,-0.0014410603140085614,-1.1935858130271204,-0.0062910944964785715,-0.16904015171435036,1.0206470832130627,0.24092006137901706,-0.1814229778167493,0.3320845385651888,-0.12886565397677355,0.07718871161035311,0.5934929534131171,0.02934985751122248,0.07310341183275389,0.048123330497841565,0.15811848979348342,-0.1664820594543064,-0.10174921559501184,-0.0057748085800037536,0.09320848170883483,-0.11914929381792287,0.25257963431067765,0.02117743870281916,-0.15642255539990546,-0.18493873961070725,-0.3551618379271148,-0.060387376847134674,0.22867294936507898,-0.04612896248028464,-0.3658105223929803,-0.06999091979244106,-0.8466998825974051,0.048287283384477055,0.20452815156711854,-0.10768907523934584,-0.107253126948643,-0.04776476641286296,-0.20225066949933532,0.09289278302917647,-0.12892538470968198,-0.08388001839538399,-0.139153380869079,-0.10151724395415697,-0.11589688592319268,-0.2753775389903335,0.25751084287644754,0.0908392158514624,Trimming,7
166,166," efficient trim algorithm base  multifeature fusion score model  ngs data
nextgeneration sequence ngs  enable  exponential growth rate  sequence data however several sequence artifacts include error read base call errors  small insertions  deletions  poor quality read   impose significant impact   downstream sequence process  analysis   present petrimmer  sensitive  special trim algorithm  ngs sequence first petrimmer remove technical sequence  pairedend read base   characteristics  low quality read  ngs data second petrimmer determine  range  read  need   trim accord   quality score statistics histogram  read   library  improve  accuracy   algorithm  design  lightweight  easytoexplain score model  evaluate candidates   pattern  trim step finally petrimmer select  appropriate trim strategy  process  low quality read base   location determine   score model petrimmer  able  locate  remove adapter residues   pairedend read   easily configurable  offer superior throughput   multithreaded mode  test petrimmer  five datasets  compare    current five latest methods  experimental result demonstrate  petrimmer produce  superior result compare   trimmers
 pipeline  petrimmer   divide  three major step  first one   remove  technical sequence   read library  technical sequence include adapters simple repeat ployat tail  nonatgc character  second one   determine  range  read  need   trim  last one   determine  two sit   lowest quality   read  need   prune  use  composite score model  select  appropriate trim strategy  trim  read base   distribution   two sit  illustration   pipeline  petrimmer  show  fig   detail step  illustrate   follow subsections  removal  technical sequence   many type  technical sequence  ngs data   base   nonatgc character polya  polyt tail simple repeat adapters      low quality sequence   remove correctly   lead  either miss alignments  wrong genotyping  snp call   downstream analyse  follow strategies  propose  remove  low quality sequence   study  removal  base   nonatgc character assume     quality function  represent  average quality score  string  let    length  read let ler   threshold   length  read  trimminglerl  default   read consist    character   read  discard directly   read end   series  character   nonat  character   length  read  trim  larger   equal   threshold ler  strange tail  cut  conversely   length   read  trim  less   threshold ler  read  discard   whole   character   nonat  character  scatter   read petrimmer cut  read  several normal segment accord   position   abnormal character    select  segment whose length  larger   equal   threshold ler finally  calculate  quality score   segment  function   select  segment   highest quality score   retention segment  principle  remove  character   nonat  character   read removal  polyat tail  polyat tail must  remove since  iprovide false sequence  mislead assemble alignment  downstream sequence process  analysis   read end   series  character    polya  polyt   strange tail  cut    read consist   polyat sequence   discard directly  principle  remove  polyat tail   read removal  simple repeat simple repeat  part   real sequence  may also mislead  analysis   read end   series  simple repeat  strange tail  cut    read consist   simple repeat   discard directly  principle  remove  simple repeat   read removal  adapter next generation sequence require dna   insert  bacterial vectors  biological amplification adapter  linker oligonucleotides may also  attach  target dna fragment  facilitate insertion   vector  vector  adapter sequence  sequence concomitantly   target  insert sequence  represent contamination  must  remove   dataset prior  analysis give  know adapter pattern   read sequence adapter trim  usually model   semiglobal sequence alignment also call endspace free alignment   space   end   begin   alignment   incur penalties  accuracy  adapter trim depend   adapter sequence scan   error prone  end   end  overcome  impact  sequence errors   adapter sequence scan  introduce  fuzzy match algorithm  string base   edit distance   study   similarity   first  base   last  base   read   know adapter sequence  larger   threshold  default  specific head  tail  cut   principle  remove  adapter sequence   read determine  range  trim quality score  usually give  phredscaled probability   ith base  wrong  average value   quality score  base   read   use  measure  reliability   read  quality score statistics histogram  read   library  show  fig let  represent  length  select region  represent  length  reserve region pmin represent  minimum quality score pmax represent  maximum quality score  pth represent   coordinate  trim threshold   quality score   read  less  pmin   ∗ pmaxpmin  mean   read need   trim   contrary  read   need   trim     influence factor  trim petrimmer control  trim degree accord   value    larger  value indicate   read need   trim  default value      value also   determine   user accord   actual situation  sequence trim  improve  accuracy    algorithm  design  lightweight  easytoexplain score model  evaluate candidates   pattern  trim step finally petrimmer select  appropriate trim strategy  process  low quality read base   location determine   score model  slide window  read quality detection  slide window use  standard approach  work  scan   end   end   read   process  window slide petrimmer use  score model  calculate  score   window afterwards petrimmer summarize  score   window  form  bar chart finally petrimmer determine  trim site   low quality read accord   bar chart fig   quality score statistics histogram  read  dataset  rhodobacter sphaeroidesthe dataset  rsphaeroides  obtain  gageb website  xaxis refer   quality score  read  yaxis refer   frequency  quality score ′′ represent  select region ′′ represent  reserve region ′ ′ represent  trim region ′pmin ′ represent  minimum quality score ′pmax ′ represent  maximum quality score ′pth ′ represent   coordinate  trim threshold  score model let    represent  read   length respectively let qxr represent  quality score   rth base  read     window appear   ith position  read    represent  length  wiwi     size   window  fix  default  correct probability     express  pwi  therefore  error probability     express  pwi  petrimmer use  error probability     first score point   string contain   window  treat   kmer  read    represent   list     kmers   experiment  find    kmer size   keep small  prevent  overuse  computer memory  still large enough    kmers  unique  genome    determine  maximum number  kmers  fix      practice  often require  space size  kmer    least  time larger   genome size     ∗    less   upper limit  system memory usage  addition   value   increase  time require   kmer frequency statistics also increase therefore  select  size     necessary  comprehensively consider  memory requirement  time requirement   accuracy requirement   study  set  value        fully consider   factor  deal  large genomes  value     increase appropriately  example   number  read exceed  million  value     set   odd number       well know   low frequency kmers  often cause  sequence errors  bias especially  highdepth readsreads   high sequence depth regions  low frequency kmer   likely  result  sequence errors petrimmer use  frequency  kmer   second score point   show  equation  lower  frequency     higher   scorewi   scorewi    requencywi   sequence errors occur  frequently  regions   extremely high    content   constant heterochromatin regions  include centromeres telomere  highly repetitive sequence   petrimmer consider  string contain   window   kmer use   content  kmer   third score point   show  equation  ngc represent  number   character   kmer  higher   content     higher   scorewi   scorewi  ngc    finally petrimmer combine three score formulas  form  comprehensive score model   show  equation scorewi  ngc    qwi   qxij     requencywi    petrimmer score  window   read  need   trim  select  two windows   highest score   next judgment  process  example  apply  score model  show  figure   figure   xaxis refer   position   read  yaxis refer   score  four different situations  subgraph  show  kmer frequency score   window   read  subgraph  show  quality score   window   read  subgraph  show   score   window   read   subgraph  show  comprehensive score   window   read  score  windows   read petrimmer screen   two highest score windows  record   appear   read next petrimmer select  appropriate strategy base   two record locations  trim  low quality read  select trim strategy base  score information petrimmer take three trim strategies accord   possible position   two windows   highest score   follow  introduce  three trim strategies  detail let    length  read let   denote  position   two highest score windows   read respectively let m1m2 represent  distance      thd represent  threshold   effective distancel  default let     indicate three candidate regions respectively case1   two windows   highest score  locate   end   read              distance    larger ",-0.19824387059965734,0.17645468735559694,0.1509966091542378,0.1142094822329864,-0.05146562798114503,-0.03095871455252325,-0.10812863219634224,0.09060913973843863,-0.06752551312214593,0.13039108279468345,0.0129078630323239,-0.037598085742387724,0.14125383742268233,-0.07271217667352632,0.1552885638864428,-0.03358806261953688,0.002198178483860772,0.16196314374319246,-0.024125176740027676,0.04940214430326986,0.01851278483070413,-0.2339041069595976,0.0284195371212606,-0.01169110519820044,0.010544119354005885,-0.17814606582838555,0.0626875813509501,-0.16778993375930953,-0.03934267042777672,-0.07031709020204613,0.008301402069445388,0.2830156530299302,-0.17056857295356415,-0.0664080681336595,0.18219172820140767,0.06512860686783996,0.022747857722877983,-0.01798575252040986,-0.08711606819723265,-0.08471080046287294,-0.09529471859404164,-0.17088650776877426,-0.05949410837398433,-0.1554933661053747,-0.10697727651821072,-0.002211361061809073,0.15926200939227791,-0.16994875129336656,-0.21621289771950453,-0.39358659579658745,0.18758282123050649,-0.0038658824610781095,0.02657387431553097,0.6254240206067319,0.023767553535302254,-1.2155633124191294,0.05255668564164445,-0.19430862961937945,1.0405518229601598,0.22010084648488007,-0.171959928069669,0.3463759485980208,-0.05957737354883505,0.10208323729804752,0.5930929969336729,0.05053159181962365,0.062270120377481676,0.0029135325591634572,0.2193598254322908,-0.17896591484271165,-0.07314858665777328,-0.04074930270189963,0.11813702498764075,-0.08607467095165255,0.19737796889647294,-0.04588049791806776,-0.1244035930700688,-0.10051294027752103,-0.34566870961199314,-0.06399376902434273,0.2343926700422158,-0.02218513038895929,-0.4022576239312626,-0.0708189766702205,-0.8874507465592405,0.026931162810054268,0.2135903285962593,-0.11221568487616283,-0.0956525993472482,-0.06624966386743121,-0.204851827782296,0.0971348432315689,-0.1233344288632464,-0.10111178529048973,-0.1345032932576894,-0.045008601536376994,-0.0926645408423815,-0.3327524338456368,0.3224109122319347,0.02666496480169038,Trimming,7
167,167,"cutprimers  new tool  accurate cut  primers  read  target next generation sequencing
cutting  primers  read   important step  process target ampliconbased next generation sequence data exist tool  adapt  cut  one  several primeradapter sequence  read  remove    occurrences also    exist tool use kmers  may cut  part  primers  primers  study sequence  gene    use   program lead  incorrect trim reduction  coverage  increase   number  falsepositive andor falsenegative result   develop  new tool name cutprimers  accurate cut   number  primers  read use sequence read   obtain  study  brca1 genes  compare   cutadapt alientrimmer  bbduk    trim read    way  coverage   least two amplicons decrease  unacceptable level  read compare  read trim  cutprimers    time trimmomatic  alientrimmer cut  occurrences  primer sequence   length   remain read  less  prospective
reads primer sequence  amplification  brca1 genes  kindly provide  author  hiplexprimer tool nguyendumont    primers  synthesize   institute  chemical biology  fundamental medicine novosibirsk russia  primers     nucleotides  length mean   minimum     construct    way  almost  amplicons without primer sequence  length   nucleotides  read  obtain  sequence  amplicons  miseq illumina use miseq reagent kit   cycle throughout  compare  tool  already exist tool use three pair  fastqfiles  different number  read     also  make  comparison  one whole run   dna sample  read pair   input  program cutprimers use four fastafiles  primer sequence locate    end   end     read respectively alternatively  may trim primers     end   amplicon length     read length       input  output  fastq  fastafiles  use biopython package seqio cock     search primer sequence   read cutprimers apply two python modules regex  search primer sequence  regular expressions  multiprocessing  last one  necessary  multithreading  process   read  program  save error statistics   primers   error occur  one   read   read pair  consider    sequence error   error occur   read  consider    primer synthesis error  additional information  useful  evaluation  primer synthesis quality  well   estimation   amplicon coverage moreover cutprimers  detect primer dimers  may form  amplification  algorithm allow achieve high accuracy  identify   primer sequence  ngs read  simultaneous search   primer sequence   pair   read  compare  tool   available tool cutadapt bbduk  alientrimmer use  trimmomatic   yield acceptable number  read examples  command use  execution  available  supplementary material",-0.1757690864558006,0.22431469498705006,0.09994663676944064,0.0963672689345031,0.012506377561149284,-0.10498677192261567,-0.034420743506070384,0.10680145099244874,-0.0674195764014966,0.16902623099040676,0.007771327017457938,-0.06159440839971684,0.09186771417203063,0.032459481040792874,0.17436009911003242,0.011952144735167088,0.04668391529653519,0.13729290673355687,-0.0474716505161458,0.12104091831008715,-0.004379539567680081,-0.25591917887835,0.04228440851567347,0.05825159011374405,-0.01385416248898976,-0.16854566005144292,0.055991677718774134,-0.16359519345708695,-0.047898672835364295,-0.01935798295436461,-0.058034068263461525,0.27643704610916736,-0.21219284623358514,-0.08637781277587465,0.1643326966446593,0.0691531138173933,-0.025126605593182284,0.004491877909949722,-0.09866866916760894,-0.07761056648504469,-0.1268842881591848,-0.1222187364579284,-0.11672872410190115,-0.11700274367056833,-0.11940760581405616,-0.03722188473490575,0.12395427789877632,-0.21241155780846127,-0.2925300168521999,-0.38799851200546204,0.16576381646628074,-0.004655511784824354,0.0388542154080383,0.6476995659723558,-0.03700906164127122,-1.18706246971387,-0.0011870848969127868,-0.23487314522377806,1.0279147026923263,0.21969261772264986,-0.1165074864568466,0.37302382775236703,0.011186579066654382,0.06270834401912667,0.5929931377723493,0.022656210105576228,0.06397846672523973,0.05365817146824497,0.2401439643056457,-0.20333785832069665,-0.0491593886303224,-0.03843773478492837,0.1280900421388093,-0.09827181469203412,0.22371819587367264,0.034232726969121975,-0.12071732164109185,-0.09619713388240547,-0.4645393314782781,-0.09904020819584468,0.2949610610044007,-0.0056498188474015595,-0.4181495818525176,-0.06295684241636891,-0.9382465670472354,0.14079909309447725,0.3268841150462445,-0.13439606768264795,-0.14051717837366842,-0.05088365339728335,-0.14423851871097382,0.049255615108835,-0.07989554692818955,-0.061609393785610526,-0.1872055531176596,-0.07397419984732395,-0.0919405784632188,-0.3348236783961851,0.2946164153981954,0.07033093223573947,Trimming,7
168,168,"afterqc automatic filter trim error remove  quality control  fastq data
 applications especially  clinical applications require high accuracy  sequence data usually   face  trouble cause  unavoidable sequence errors several tool   propose  profile  sequence quality      quantify  correct  sequence errors  unmet requirement motivate   develop afterqc  tool  function  profile sequence errors  correct    plus highly automate quality control  data filter feature different   tool afterqc analyse  overlap  pair sequence  pairend sequence data base  overlap analysis afterqc  detect  cut adapters  furthermore  give  novel function  correct wrong base   overlap regions another new feature   detect  visualise sequence bubble    commonly find   flowcell lanes  may raise sequence errors besides normal per cycle quality  base content plot afterqc also provide feature like polyx  long subsequence    base  filter automatic trim  kmer base strand bias profile   single  pair  fastq file afterqc filter  bad read detect  eliminate sequencers bubble effect trim read  front  tail detect  sequence errors  correct part    finally output clean data  generate html report  interactive figure afterqc  run  batch mode  multiprocess support   run   single fastq file  single pair  fastq file  pairend sequence   folder   include fastq file   process automatically base  overlap analysis afterqc  estimate  sequence error rate  profile  error transform distribution  result   error profile test show   error distribution  highly platform dependent much    another new quality control  tool afterqc  able  perform quality control data filter error profile  base correction automatically experimental result show  afterqc  help  eliminate  sequence errors  pairend sequence data  provide much cleaner output  consequently help  reduce  falsepositive variants especially   lowfrequency somatic mutations  provide rich configurable options afterqc  detect  set   options automatically  require  argument   cases
afterqc  design  process fastq file  batch  go   folder   fastq file   singleend  pairend output   typically data   sequence run  different sample  pass  fastq file  pair     filter pipeline  describe  fig  firstly afterqc  run  bubble detection  find  bubble raise   sequence process secondly  prefiltering    conduct  profile  data  percycle base content  quality curve thirdly afterqc   automatic read trim base  data quality profile fourthly  read   filter  bubble filter polyx filter quality filter  overlap analysis filter  ones fail  pass  filter   discard  bad read fifthly  error correction base  overlap analysis   apply  pairend sequence data finally afterqc  store  good read perform postfiltering  profile  generate html report fig  figure1 pipeline diagram  afterqc   single  pair  fastq file afterqc  perform prefiltering  automatic trim data filter error correction  postfiltering  read   categorize  good  bad read  store separately figure   include   final html report full size image bubble detection  visualisation  illumina sequencers especially   use twochannel sbs sequence technology   observe  phenomenon   polyx read could  find   bubble areas   background base   phenomenon  develop  method debubble  visualise  detect bubble firstly  detect  polyx read separate   tile  filter    local density since bubble areas tend   higher polyx density secondly  cluster  polyx read  small set filter  cluster  feature like size shape  number  polyx read thirdly   polyx cluster  fit  circle  include   polyx read   also perform circle filter  remove false positive bubble finally  plot  polyx  circle figure  use  circle  filter    read locate   figure  show   implement debubble algorithm fig  figure2 algorithm diagram  debubble  major step   algorithm  polyx detection polyx cluster  filter circle fit  filter full size image bubble detection  optional  afterqc    enable  default accord   study illumina nextseq sequencers   likely  raise bubble   suggest enable  option  nextseq sequencer output  disable   hiseq sequencer output figure  show  part  debubbles output     also find  nextseq sequencers produce much  polyx read fig  figure3  output image  afterqc debubble    subimage   lane  nextseq  sequencer     find  bubble detect  show enlarge detail   bubble  show  subimage   tile  hiseq   similar resolution     much fewer polyx read full size image automatic trim   whole sequence process  first several cycle    bias  errors since  signal coordination hasnt  establish yet   last several cycle  also  errors due  error accumulation  lack  follow correction   case  begin  end   read may  significant statistical bias  example library preparation bias  sequence bias  cause  percentage higher     begin  end cycle   cycle   consider  abnormal cycle  surely   remove   methods   two strategies  trim namely local strategy  global strategy  tool like trimmomatic  apply local strategy  perform trim read  read however local trim  two drawbacks  first drawback   local trim  use  quality information  trim  cannot utilise  global statistical information  discover  abnormal cycle  second drawback  local trim result  unaligned trim  mean duplicate read may  trim differently  consequently lead  failure  deduplication tool like picard     deduplication tool detect duplications   cluster read   map position  contrast afterqc implement global trim strategy  mean trim   read identically  algorithm  use  determine  many cycle  trim   front  tail  algorithm  base   find  mean percycle base ratio curve  usually flat   intermediate cycle  may  fluctuant   first  last several cycle also  intermediate cycle usually  higher mean quality score   first  last cycle  trim happen afterqc   prefiltering quality control  calculate  base content  quality curve  algorithm initialise  central cycle   good cycle   expand  good region  scan  base content  quality curve cycle  cycle   meet  front  end  meet  cycle consider  abnormal   cycle   good region   keep   rest cycle   front  tail   trim currently  cycle   mark  abnormal   meet  least one  follow criteria   high   low  mean base content percentages  higher    lower     significant change  mean base content percentages  ± change compare  neighbour cycle   high   low  mean  percentages  higher    lower     low  mean quality  less  q20 figure  give  example  automatic trim work fig  figure4  example   automatic trim work data  obtain   cellfree dna quality control sample  sequence  illumina nextseq  sequencer    base content percentage curve  trim  filter     find base content change dramatically  front  tail    curve  trim  filter     find   bad cycle   tail   trim   part   front  trim  result   fact   use different thresholds   front  tail since unflatness  front   probably cause  different fragmentation methods  unflatness  tail  usually cause  lab preparation  sequence artefacts full size image accord   experiment afterqc  trim   cycle  data  good sequence quality   base  front   base  tail  normally    significantly affect  data utilisation rate however   extreme case  sequence quality  quite low   mean base content percentage  quality curve   totally chaotic   trim  many data   case afterqc limit  trim cycle   front  tail  default set       front       tail filter  trim   afterqc  apply  series  filter   read afterqc implement quality filter  polyx filter quality filter  trivial   count  number  low quality base   calculate  mean quality   read   determine whether  keep  discard  read afterqc implement  errortolerantly method  detect polyx   one  atcg two arguments     use  configure  polyx detection algorithm  default   mean  long  polyx sequence     default   refer   many nonx base   tolerate   polyx subsequence accord   experiment nextseq sequencers   likely  produce polyx read      polyg  order  apply different filter   important  one read  filter   new sequence name contain  filter name   assign    read   stream   bad output overlap analysis  error correction let  denote  length   sequence dna template   denote  length  pairend sequence length   pair  read  totally overlap  ≤  overlap   length  2st  st2s    overlap  ≤ base  edit distance  optimisation  develop  method  check   pair  read overlap  data  pairend sequence   pair  read    let    offset  place     well  vertically align subsequences          calculate  edit distance edr1      method optimise offset   obtain  minimal edit distance edr1 or2 oedr1    edr1 or2   consider    overlap   offset    edit distance edr1      overlap length   meet  thresholds   pair  overlap afterqc   overlap analysis  error correction    edr1        indicate  mismatch   obvious sequence error   overlap base otherwise   correct  overlap mismatch  discard  read   cannot  correct   pair  mismatch base  overlap region  calculate  ham distance hdr1      check    identical  edr1      yes  mean    substitution difference          case  check  mismatch pair  see  one base    high quality       low quality   true afterqc  correct  low quality base accord   high quality mate accord   result  mismatch pair  unbalance quality score figure  show  example  overlap analysis fig  figure5  example  overlap analysis  original dna template    long  sequence length         overlap  offset    edit distance   overlap subsequences   brighter colour represent higher quality  mismatch pair  find  high quality    low quality      correct full size image sequence error profile  describe  afterqc  detect  mismatch   overlap regions   read   long overlap  overlap_len  edit distance  overlap subsequences  mainly cause  sequence errors   errorfree overlap  usually completely identical edit distance    base   assumption   count  total base   mismatch base   overlap regions    consider  ratio  mismatchtotal reflect  sequence error rate    call estimate sequence error rate furthermore  mismatch pair usually consist  one high quality base  q30  one low quality base   q15   case   consider   low quality base   pair   sequence error  furtherly profile  sequence error transform distribution   many  base  sequence     pair  pairend sequence fastq file afterqc estimate  sequence error rate  profile  sequence error transform distribution  look   error distribution result  lot  sequence data  find  interest phenomenon error distribution  clearly sequence platform dependent different sequence platforms  different error pattern    sequence platforms different sequence run share similar pattern figure  show  example  illumina nextseq sequencer pattern compare  illumina hiseq sequencer pattern  interest phenomenon   nextseq sequencers produce      errors  orange bar  guess   due   twocolour system  adopt  nextseq systems   illumina twocolour system base   require  red  green light signal   easy   misrecognised  base   require  light signal also base   require  red light signal   clearly distinguish  base   require green light signal fig  figure6  illumina nextseq  output run #  illumina nextseq  output run #  illumina hiseq xtenoutput run #  illumina hiseq xtenoutput run # sequence error transform distribution  platform associate data  obtain  internal quality control dna sample  sequence  illumina hiseq x10 sequencer  illumina nextseq  sequencer value  xaxis represent  sequence error   value  yaxis represent  count calculate   pair  fastq file fig     profile  two different sequence run   nextseq sequencers  fig     profile  two different run  different hiseq sequencers   find   pattern      nearly identical  pattern      similar   noticeable difference full size image automatic adapter cut   dna template length  less   sequence cycle  part   adapter   sequence   tail  fig    see    insert dna template length   less  sequence length   offset    best overlap   negative    hand   find   optimal offset   align  pair  read  negative  consider   length  insert dna  smaller  sequence length base   rule afterqc implement automatic adapter cut  pairend sequence data fig  figure7  example  automatic adapter detection  cut  offset make  best alignment   pair  read  negative  indicate   length  insert dna  less   sequence length   offset  detect   trivial  calculate  overlap region  cut  adapter base outside overlap region     read1  read2 full size image   overlap analysis process  get  optimal offset    best local alignment   pair  overlap length   pair   directly calculate use  offset     find negative  base outside overlap region   consider  part  adapter sequence    trim automatically quality profile besides normal percycle base content  quality profile afterqc implement two novel methods  give  information  sequence quality strand bias profile  reflect amplification bias  percycle discontinuity profile  reflect sequence quality instability  first one  base   hypothesis   dna amplification process  sequence process   little nonuniformity  repeat count   short kmer   close   repeat count   reverse complement   plot  kmer   reverse complement count  check whether  point  near  line  figure  give  example  kmer base strand bias evaluation  second method  base  another hypothesis  mean discontinuity     less stable   sequence cycle   short window  sequence cycle  use  average discontinue base number   window  calculate  discontinuity  example atcga   discontinue base number       neighbour base  different  aaaaa   discontinue base number    discontinuity drop  significantly cycle  cycle  usually reflect  sequence issue  may  cause   percycle wash process  work well fig  figure8 two examples  strand bias profile xaxis    count  relative forward strand kmers   yaxis   relative reverse ones  show  case   little strand bias   point  close   line    show  case  serious strand bias  lot  point  close  xaxis  yaxis  repeat count   kmers   high   figure seem  sparse  file  download  ncbi sequence read archive sra  accession number srr1654347  srr2496735  full size image software implementation afterqc   view   mix  quality control tool  fastqc  data filteringtrimming tool  trimmomatic cutadapt table  give  simple feature comparison  afterqc   exist tool afterqc differ   tool   feature like overlap analysis bubble detection  automatic trim   figure plot afterqc switch  use matplotlib   plotlyjs   create interactive figure table   feature comparison  afterqc  exist tool   table   find  afterqc  versatile  common quality control  data filter task  offer novel feature  implement   tool  full size table since afterqc provide  function   high throughput sequence   filter tool   possess  usually run slower    tool   evaluation  pairend sequence data afterqc  process * pairend read per minute  fastqc  process * read per minute    faster  afterqc however   time consume part  afterqc  overlap analysis  error correction process    useful  pairend data actually  singleend data afterqc  run  fast  fastqc since  overlap analysis  involve  tool  write  python   edit distance module write   pypy  support  performance consideration currently  fastest way  run afterqc  use pypy    also reimplementing afterqc use    performance   improve   slow python code  replace",-0.20297059946646304,0.1896066938471888,0.1587661116628158,0.07207326367117403,-0.035008858911838116,-0.03578607725928752,-0.1036121959210064,0.07606511641430055,0.012669535687955109,0.08862338975241398,0.0054674746990293396,-0.014844234727889188,0.1461364452524122,-0.07380721154343163,0.14896859586702774,-0.0649098237958085,0.005101426494068433,0.14939050045434266,-0.019099023661676245,0.08742341591059677,0.019188142003750124,-0.1814188977234296,0.043578198951482065,-0.013877024072944057,0.0045453731222235465,-0.15199993486257574,0.013670152297971236,-0.1883200762773109,-0.053601896295963486,-0.0675202340806492,-0.01103990208807508,0.27610198428200083,-0.14862324770963287,-0.0990905005101064,0.17206598173174525,0.11007588608850033,0.039220862011302884,-0.025031162958563127,-0.053614956970670834,-0.12271300842996433,-0.08303595436782807,-0.16589001787117771,-0.09191103811224216,-0.14982700556115636,-0.13569772592461782,-0.031100425374734363,0.1620462423044587,-0.12193364536293168,-0.17736862050731952,-0.4414081306434385,0.16292657795987714,0.0053172768802949065,0.006506970478243616,0.6076201848199986,0.017105854166069686,-1.238282808719472,0.050907688871712736,-0.15438155674438495,0.9937233535081887,0.1556975052904514,-0.17536713546352753,0.33891552567458405,-0.09001042568963545,0.0828237454791328,0.5562994018936177,0.03556117284466385,0.07297819977762496,-0.001722539769394732,0.17060731571363408,-0.1828183046591033,-0.025503129134722427,-0.05463790120058964,0.09294055020074077,-0.12863437459396992,0.21070249150191545,-0.03945202922175934,-0.09357260307537367,-0.07662376882329297,-0.3104697972943213,-0.07963624920627055,0.2374475006486077,-0.03296934140340065,-0.3748719588457869,-0.03169420387642005,-0.8813945469496716,0.0013884593729160404,0.2012932842250522,-0.12218192929583716,-0.11859979819332547,-0.05738929140386539,-0.1778492493736016,0.07912674532743698,-0.11900141090242015,-0.10127208955711764,-0.13712057295472904,-0.05844514233175505,-0.0985304143550189,-0.28461742829828474,0.3165810189732328,0.06553230336028013,QualityControl,8
169,169,"ngs  toolkit  toolkit  quality control  next generation sequence data
next generation sequence ngs technologies provide  highthroughput mean  generate large amount  sequence data however quality control   sequence data generate   technologies  extremely important  meaningful downstream analysis  highly efficient  fast process tool  require  handle  large volume  datasets    develop  application ngs  toolkit  quality check  filter  highquality data  toolkit   standalone  open source application freely available     tool   application   implement  perl program language  toolkit  comprise  userfriendly tool    sequence data generate use roche   illumina platforms  additional tool  aid  sequence format converter  trim tool  analysis statistics tool  variety  options   provide  facilitate    userdefined parameters  toolkit  expect    useful     ngs data  facilitate better downstream analysis
implementation  tool   toolkit   develop use perl program language  implement modularized structure use several subroutines  various task  allow better maintainability  module   use  generate various graph  statistics  stringapprox module  search primeradaptor sequence  input read parallelforkmanager  thread modules   utilize  parallelize   tool iozlib module   use  facilitate readingwriting compress gzip file  report  generate use hypertext markup language html  cascade style sheet css   tool   test  windows  linux centos operate systems  full functionality availability installation  usage ngs  toolkit   standalone  open source application freely available   detail description  installation  usage   toolkit  available  user manual   web site  brief  install  toolkit user need  download ngsqctoolkit_v2zip current version file   website  unzip  dependencies  use toolkit include perl interpreter usually supply    linux  activeperl  windows  additional perl modules  optional require  generate  graph  stringapprox  installation instructions   find   respective websites different tool available   toolkit categorize   basis  task   mean  perform fig   available  different folders  tool could  run use “perl tool name options” command   commandline prompt  parameter options   input sequence data  analysis process  output   default settings   view  use “” option    mention command  check whether dependencies  resolve  tool   run without  parameter   result  appropriate errorwarning message   miss modules    input  data  illuqc user need  use “” “”  singleend data option follow  forward  reverse end read file sequence assay  fastq variant  454qc “” option  use follow  read  quality file  fasta format  sequence assay  switch “”  provide  illuqcpl  454qcpl  specify number  file   process simultaneously  parallel number  cpus   specify  multithreaded tool use switch “”  default tool generate output   input file  locate test data   provide  download   website  include input data  illumina     roche  platforms  output data   trim  statistics tool major enhancements first version    ngs  toolkit include  tool illuqcpl  454qcpl  basic functionality  quality check  primeradaptor contamination removal  illumina  roche  data generate textual  statistics  sequence statistics analysis tool   major update   toolkit  parallelization  introduce    tool  speed   analysis  addition  feature  generate  statistics   form  graph  implement   also add  feature  readingwriting  compress file gzip  generate consolidate  report  html format   earlier update  recently illuqc tool  update  generate  graph depict percentage  read fall  different quality score range   base position trimmingreads tool  modify  provide  additional option  trim read base  quality score   new tool   incorporate     roche  pairedend data   current version ",-0.2943734222645378,0.1858802159377996,0.08232888949322535,0.05118361101507248,0.11614371951581473,-0.05703491851052244,-0.1320629559665455,0.054668318269954566,0.05043121439529248,0.12602098695590475,0.1067166098754012,-0.10645527699865692,0.11407897917595093,-0.11284814978582774,0.11826914354226947,0.004113141880778398,0.12442016527528793,0.14672979648296894,-0.04839574371159832,0.07870468731394492,-0.1413795854338372,-0.29136403844182696,0.09065350195315712,0.06739361779034687,-0.009373601142977995,-0.241944083158562,0.032774623611100735,-0.0757321518060455,-0.13119808221579216,0.017108066218598287,-0.01932463977133967,0.3376323812681976,-0.2797238443903561,-0.07912055375955758,0.2664614559709436,0.1729481880411437,0.0074122208889470815,-0.11322660630832808,-0.026807708144273763,-0.1734357892429941,-0.055962836172448883,-0.14980475095203705,-0.08722761418769127,-0.06915401557486177,-0.14662296884191064,0.014200699275299425,0.04086124485418681,-0.2285995912182355,-0.07922516486442258,-0.3174633769037348,0.1723581438456031,0.14411765689401532,-0.0007607290222983343,0.5414780113708726,0.03831558227474685,-1.1169711053199758,0.049805083389346784,-0.21755786382159745,1.111309352298675,0.1684339868893508,-0.15480697089159745,0.290690576159803,-0.07197951787142813,0.08161785446905664,0.5522656019236292,-0.031720840291673755,0.019174716024968584,-0.019023053943552932,0.21346285820977276,-0.16966301765483868,-0.03281902505124035,0.00964293298582452,0.15815984309288297,-0.18774273784451345,0.1884063514430196,0.06969737972686504,-0.10721022553295584,0.024288914815258786,-0.31486987898958857,-0.1280672239731946,0.2176858365990668,-0.15832329563762185,-0.35525090285589755,-0.013137344925445485,-0.8651054042154357,0.19952956694049528,0.31417134589588586,-0.12839822129513812,-0.10014498110834837,-0.020229629757489542,-0.1138532318578269,0.14592400703295927,-0.10878206315785133,-0.09849130178556008,-0.043796178182020515,-0.10467928535549596,-0.06196894919637092,-0.3262102341360932,0.4380390207317533,0.13787030421372035,QualityControl,8
170,170,"qcchain fast  holistic quality control method  nextgeneration sequence data
nextgeneration sequence ngs technologies   widely use  life sciences however several kinds  sequence artifacts include lowquality read  contaminate read  find   quite common  raw sequence data  compromise downstream analysis therefore quality control   essential  raw ngs data however although   ngs data quality control tool  publicly available   two limitations first  process speed could  cope   rapid increase  large data volume second  respect  remove  contaminate read none   could identify contaminate source  novo   rely heavily  prior information   contaminate species   usually  available  advance   report qcchain  fast accurate  holistic ngs data qualitycontrol method  tool synergeticly comprise  userfriendly tool   quality assessment  trim  raw read use parallelqc  fast read process tool  identification quantification  filtration  unknown contamination  get highquality clean read   optimize base  parallel computation   process speed  significantly higher    methods experiment  simulate  real ngs data  show  read  low sequence quality could  identify  filter possible contaminate source could  identify  quantify  novo accurately  quickly comparison  raw read  process read also show  subsequent analyse genome assembly gene prediction gene annotation etc result base  process read improve significantly  completeness  accuracy  regard  process speed qcchain achieve  time speedup base  parallel computation  compare  traditional methods therefore qcchain   fast  useful quality control tool  read quality process   novo contamination filtration  ngs read  could significantly facilitate downstream analysis
 overall quality control strategy  objectives  qcchain include  retrieve read  high quality  identify  quantify  source  contaminations  filter contaminate read  accomplish   process   relatively short time  achieve  objectives  overall method  qcchain include sequence quality assessment  trim  contamination screen  removal additionally evaluation  comparison  downstream analysis result use read    also include   important component   holistic approach  strategy  workflow   method  show  figure   detail procedures  describe  read quality assessment  trim  parallelqc  sequence quality assessment  trim   first step  ngs data quality control  require  accuracy  efficiency  accomplish  step  develop  parallel quality control software parallelqc  could  use  trim filter  remove low sequencingquality read  ngs data parallelqc  develop  linux   multithread technology base  multicore x86 cpu platform   compatible  x86  x86 linux specifically  parallelqc sequence could  trim   specific length lowquality base within read could  trim      end lowquality read could  filter  quality value  user define percentage duplications could  identify  remove  tag sequence filtration multiple tag sequence could  align  shift      end   read  mismatch allow   positive align read could  remove  significantly accelerate  speed  computation parallelqc parallelize  sequence quality evaluation  filtration step  assign balance  weight task  independent thread  could  execute  different cpu core simultaneously  addition  progress could  complete   one disk  operation  highly improve  efficiency  analysis    hand  multiple step   accomplish  use  single command line  userfriendly options therefore parallelqc significantly shorten  process time compare  traditional single core cpu base method  simplify users operation compare  use multiple single function  tool identification  removal  contaminate read  aim  contamination screen   identify  quantify  mostly unknown source  contaminations filter  contaminate read  obtain  process read  clean  possible  adopt two complementary strategies    could provide know  unknown species information   dataset   rdnareads base method ribosomal dna read  use  qualitatively detect  taxonomical structure   dataset quickly ribosomal rnas     prokaryote    eukaryotes sequence  good indicators  characterize prokaryotic  eukaryotic species   commonly use  phylogenetic analysis   also widely use  metagenomic analysis  detect  community structure   apply parallelmeta   highperformance 16s18s rrna analysis pipeline  report  taxonomic classification construction  distribution  ngs read parallelmeta   gpu  multicore cpu base software  firstly extract  user select    rrna sequence   input data  align  obtain rrna read  several optional databases include rdp  greengenes   silva   taxonomy information  produce   show   dynamic graphic view  correspond species proportion additionally  qcchain parallelmeta  update   able  accomplish eukaryotic species screen  identification   previous version  could  identify prokaryotic species   approach   possible species source   raw read include  prokaryotic  eukaryotic information could  detect  novo   method  randomreads base  could quantitatively provide  species information generally detect  possible contaminations require align read   comprehensive database  include species record  many  possible   popular  widelyused alignment method  blast  ncbi national center  biotechnology information database   however   know  blast   timeconsuming process   speed   bottleneck especially  analyze immense amount  read  alternative   reduce  size   query data  perform blast  get  species information quickly    consideration  develop  inhouse script  could randomly extract read   raw read   userdefined proportion   read  extract read   align  ncbint database use blastn  extract species information   relatively short time   two approach  complementary  synergetic    rdnareads base method could quickly screen  identify  possible contaminate species  randomreads base method could provide quantitative evaluation   contaminations  also help  verify  result  rdnareads base method  confirm  contaminate source  combine  result    two methods  contaminate read  filter   alignment tool bowtie    default parameters read align  contaminate species genomes  filter  assessment   overall  result  downstream analysis  evaluate  effect  qcchain downstream analyse  performedto assessand comparethe result obtainedfrom read  preqc  afterqc respectively   follow part   work  combine original preqc read  refer   total readsthe read passedthe contamination screeningwere referredto  clean read   read come   target genomic  metagenomic source  refer   control read   simulate genomic data  genome assembly  perform  velvet    total read clean read  control read respectively  parameters use  exp_cov  cov_cutoff  ins_length   others  set  default several index include number  contigs n50 size  assembly size  consider  evaluate  analysis result augustus    use  predict  open read frame orfs   assembly result  protein sequence   reference genome  use   reference  test  accuracy   gene structure predict specifically  protein sequence predict   assembly  total read clean read  control read  align  reference proteins  blastp respectively   false positive rate fpr  calculate    simulate metagenomic data  novo metagenome assembly  functional analysis  perform  total read clean read  control read respectively  dataset  firstly assemble use idba_ud  base   orfs  predict  metagenemark  simultaneously  contigs       length  submit  mgrast   organism abundance analysis  functional gene annotation  distribution  rarefaction curve  generate  mgrast automatically functional analysis  perform  align  predict orfs   dataset  cog database use  maximum evalue  1e25   minimum identity   differences  calculate use onetailed pair ttest  asterisk denote statistical significance   significant *  ** ",-0.22554501098335444,0.2036123954495316,0.0976638057943498,0.14676974864399178,-0.02233787905115218,-0.12098597526776154,-0.10849777905225873,0.0038112522291138453,-0.016637013349533478,0.17621690853550892,0.02585563233743473,-0.05598479715928911,0.16762908497533294,-0.14274362445328426,0.11695844534180184,0.038001233030685234,0.08572817639272197,0.17493701940986014,-0.010243766366484318,0.0874224513816521,-0.07121516607189056,-0.24682332275923285,0.057715693591509326,0.0014409990222663913,-0.08943782927792895,-0.1727070469951673,0.062009390533506674,-0.10053667747118372,-0.08787807046772944,-0.021489279470536516,-0.02446776582887941,0.25517702128978426,-0.21380310253725648,-0.06456554796843307,0.21851391598876094,0.04442997335486035,0.0350609506134246,-0.001525785479238851,-0.10797217439632847,-0.10372011963726377,-0.08427216615134657,-0.1633664052230241,-0.08949951594881217,-0.05685830467066015,-0.17528676585789071,-0.015499848192585559,0.1059503161716535,-0.12877740228097848,-0.24190532291655434,-0.3453561053245992,0.16482489445448625,0.03598867605676865,0.04892194309139357,0.5624595285855244,0.03880930274642603,-1.0401449314568767,0.047319643739103134,-0.2021150421948752,0.9647462647770496,0.16344070398322594,-0.1947307298146467,0.3046575190206529,-0.05195578688661509,0.0945969660632669,0.5742907348767596,0.035480257241362514,-0.02010352374147376,-0.022018841499833252,0.265789495613717,-0.1514544103177267,-0.028233688016080893,0.0017820392653099609,0.13904090158533286,-0.11621376809148873,0.20799267150033168,-0.04754408747899009,-0.1491585995951182,-0.12731253987418467,-0.35449606149459795,-0.1263088053748745,0.20161903930575328,0.004923247551097178,-0.3856517309991722,-0.032299670293875184,-0.8646243344274092,0.11651693227960347,0.2753230908667629,-0.16746090956997034,-0.1766242217678116,-0.03484496505931948,-0.14972517729930065,0.07571080041754535,-0.115030322302544,-0.09144215109297373,-0.08303234061632464,-0.07452327679152887,-0.08514305464105998,-0.3706623746698011,0.3317324000174189,0.10949922341511566,QualityControl,8
171,171,"samstat monitor bias  next generation sequence data
 sequence alignmentmap format sam   commonly use format  store  alignments  millions  short read   reference genome often certain position within  read  inherently  likely  contain errors due   protocols use  prepare  sample  bias   adverse effect   map rate  accuracy  understand  relationship  potential protocol bias  poor map  write samstat  simple  program plot nucleotide overrepresentation   statistics  map  unmapped read   concise html page collect  statistics also make  easy  highlight problems   data process  enable nonexperts  track data quality  time  demonstrate  study sequence feature  map data   use  identify bias particular  one sequence protocol  identify  bias   consider   downstream analysis  even  remove  read trim  filter techniques
samstat automatically recognize  input file  either fasta fastq sam  bam  report several basic properties   sequence  list  table  multiple input file   give  batch process   dataset  output consist   single html5 page contain several plot allow nonspecialists  visually inspect  result naturally  html5 page   view    offline  easily  store  future reference  properties  plot separately  different map quality intervals    present   input file  example mismatch profile  give  highand lowquality alignments allow users  verify whether poorly map read contain  specific collection  mismatch  latter may represent untrimmed linkers   subset  read dinucleotide overrepresentation  calculate  describe  frith    overrepresented 10mers  calculate  compare  frequency  10mer within  map quality interval compare   overall frequency   10mer table  overview  samstat output report statistics map ratea read length distribution nucleotide composition mean base quality   read position overrepresented 10mers overrepresented dinucleotides along read mismatch insertion  deletion profilea open   separate window aonly report  sam file  result  discussion  demonstrate  samstat   use  visualize map properties   next generation datasets  use data   recently publish transcriptome study plessy    ddbj short read archive dra000169  map   million ′ read   human genome grch37hg19 assembly use bwa   durbin   default parameters samstat parse  alignment information  ~ min   comparable    min  take  copy  sam file  one directory  another  majority  read   map   high confidence fig   inspect  mismatch error profile  notice    many mismatch involve  guanine residue    start  many read yellow bar  fig 1be  ′ add guanine residues  know  originate   reverse transcriptase step  prepare  cdnas carninci     compare  mismatch profile  high fig   lowquality alignments fig    clear   proportion  read contain multiple ′ add '   turn pose  problem   map  example   lowest map quality fig    frequent mismatch involve '  position one two    lesser extent  position five   highquality alignments  mismatch  confine   first position   read fig   external file  hold  picture illustration etc object name  btq614f1jpg open   separate window fig   selection  samstat' html output  map statistics   half   read  map   high map accuracy red     read remain unmapped black  barcharts show  distribution  mismatch  insertions along  read  alignments   highest map accuracy show  red    color indicate  mismatch nucleotides find   read   nucleotides insert   read    frequency  mismatch   start  read  map accuracies  ≤     ≤      ≤    respectively show  orange yellow  blue  panel   fraction  mismatch involve '  position  increase  percentage   dinucleotides  position   read split   map quality intervals  background color highlight large percentages  first  last row  nucleotides     show  comparison alongside  mismatch profile samstat give  table list  percentages   dinucleotide   position   read split   map quality intervals fig    present dataset   unmapped read start     percent contain    position  evidently ′  residues  add  library preparation   start position  mappings   adjust accordingly samstat  ideally suit  deal   ever increase amount  data  secondand thirdgeneration sequence project specific applications include  verification  quality control  process pipelines  track  data quality  time   visualization  data properties derive  new protocols  approach   turn often lead  novel insight",-0.20750211741250404,0.2185554290558888,0.17033034241322229,0.05121573885099457,0.04100778450088454,4.636957711192917e-05,-0.10990625981915954,0.09050854448152264,0.014565285086420547,0.09209258362804493,0.054095334714259376,-0.04118939699233858,0.15798686025984252,-0.052876740447613584,0.1465717792910839,0.03396508999257285,0.05738796307817357,0.12908777393219845,-0.02755799201834,0.05578456928511871,-0.02043979970859908,-0.1884790695926672,0.07015571460172636,0.018593384448240456,0.007773037573412266,-0.2540201862115426,0.0938465452628591,-0.12519377497540102,-0.044320381305861856,-0.07341945706146588,0.05283995773771272,0.24466605773563674,-0.16372407864608413,-0.06999192662741925,0.15848595297757753,0.08540829279639238,0.043381012183265226,0.03693288356454602,-0.07797035957623395,-0.1228451951596121,-0.119794324026011,-0.1635185331849784,-0.08501415288226223,-0.10362625667262068,-0.13343664359931812,-0.02337906298650064,0.10121215294576356,-0.17136970471632362,-0.17726174025029054,-0.3874642858857808,0.21121840349949025,0.008135086159690691,0.035082761553729025,0.5884088115231374,-0.03312387582733972,-1.2241963076259608,0.012761470621701368,-0.2189194739110531,1.0412141929294183,0.20078610399533128,-0.1852132250316628,0.3874375148319489,-0.04508673037639163,0.01719900506470173,0.6109299410368184,0.03207847019065415,0.1151478431161226,0.042175063514550734,0.1811946571714171,-0.15745014568136306,-0.06056749017888567,0.025059493859274525,0.0781875050792117,-0.1235905224729419,0.1817144965816968,0.02549088226920922,-0.106552683825515,-0.10749421407519824,-0.3391529224081688,-0.08765502631483453,0.21980446069552848,-0.07018366445820455,-0.3352586046796167,-0.061153682102201214,-0.8861316456315443,-0.004173007951145257,0.20176047599023125,-0.1440961561605808,-0.07142021656144391,-0.023990883378718447,-0.19876048843579566,0.06792630977477379,-0.1475633183901064,-0.09612140065231888,-0.13322696256966576,-0.07072667486419984,-0.1264180644916185,-0.3111002098431305,0.3179016271254041,0.057734972798934414,QualityControl,8
172,172,"clinqc  tool  quality control  clean  sanger  ngs data  clinical research
traditional sanger sequence   use   gold standard method  genetic test  clinic  perform single gene test     cumbersome  expensive method  test several genes  heterogeneous disease   cancer   advent  next generation sequence technologies  produce data  unprecedented speed   cost effective manner  overcome  limitation  sanger sequence therefore   efficient  affordable genetic test next generation sequence   use   complementary method  sanger sequence  disease cause mutation identification  confirmation  clinical research however  order  identify  potential disease cause mutations  great sensitivity  specificity   essential  ensure high quality sequence data therefore integrate software tool  lack   analyze sanger  ngs data together  eliminate platform specific sequence errors low quality read  support  analysis  several samplepatients data set   single run   develop clinqc  flexible  userfriendly pipeline  format conversion quality control trim  filter  raw sequence data generate  sanger sequence  three ngs sequence platforms include illumina   ion torrent first clinqc convert input read file   native format   common fastq format  remove adapters  pcr primers next  split barcoded sample filter duplicate contamination  low quality sequence  generate   report clinqc output high quality read  fastq format  sanger quality encode    directly use  downstream analysis   analyze hundreds  samplepatients data   single run  generate unify output file   sanger  ngs sequence data  tool  expect    useful  quality control  format conversion  sanger  ngs data  facilitate improve downstream analysis  mutation screening
clinqc tool  develop  python    use  multiprocessing capability  use four  tool include fastqc  prinseq  alientrimmer   tracetuner   clinqc workflow  depict  fig   consist  several sequential step  lead   raw sequence read   high quality sanger encode fastq file   patientsample  parameter settings   specify   single configuration file additional file     achieve  optimize performance clinqc use  available hardware physical memory  cpu   best possible way  buffer file read write concept  implement  input  output  partially store  memory   analysis  reduce  computation time  reduce  disk read  write workload  external file  hold  picture illustration etc object name  12859_2016_915_fig1_htmljpg open   separate window fig   workflow  clinqc pipeline clinqc tool   run   single command  flow  analysis  depict  top  bottom base call violet color step   applicable  sanger data analysis demultiplexing  duplicate  conatmination filter yellow color step   applicable  ngs data analysis   step green color  applicable   analysis flow clinqc generate three final output   result  discussion clinqc   opensource easytouse  integrate tool  facilitate  analysis  sanger  ngs sequence data   single platform   common input output model  support  rapid analysis  hundreds  samplepatient data  parallel  pipeline provide full flexibility  customize  parameters use  “clinqcoptions” file  handle  sequence platform specific errors  provide proper guidelines   analysis  components  clinqc workflow   input   summarize  fig  clinqc pipeline  clinqc pipeline fig  consist  nine sequential step  start  raw sequence read  end   three output   summary table  fastq file  high quality read    report  detail description   step  give  base call due  unclear signal  sanger pherogram file  base caller   sequencer always call ambiguous nucleotide   however  could output  specific ambiguous nucleotides    signal   clear       signal   clear     therefore clinqc use  tool tracetunner   improve  base call  assign  specific ambiguous nucleotides  format conversion   step clinqc check  raw sequence file   format   need convert  native file format  fastq  sanger quality encode fig  sanger sequence file  accept  ab1  scf format  ngs file  accept  sff fastaqual  fastq format  demultiplexing  external file  hold  picture illustration etc object name  12859_2016_915_fig2_htmljpg fig   format conversion workflow  clinqc clinqc take raw read   native file format   sequence platforms  return  unify fastq file  sanger phred quality encode  step   applicable  ngs data  multiple sample  sequence   single sequence run  use  multiplexing method base   barcode sequence mid multiplexed identifier provide   “clinqctargetfile” file  show  additional file  one fastq file per barcode  create  case  pairedend sequence two fastq file one  forward  one  reverse read  generate  step   skip   input data  already demultiplexed  adapter  primer trim   step clinqc trim  forward  reverse adapter  primer sequence provide   “primeradapter” file  show  additional file   use  alientrimmer  tool alientrimmer   flexible  sensitive sequence trimmer  mismatch tolerance  allow  customization   number  mismatch  kmers base   data quality  user requirements  duplicate  contamination filter pcr duplicate   critical know problem  arise  low abundant fragment   amplify   library preparation process  duplicate  substantially inflate  allele frequency lead  wrong mutation detection  unexpected species richness  metagenomic analysis  therefore clinqc identify  remove duplicate use  prinseq  tool  eliminate  technical artifact contamination  another problem particularly  metagenomic analysis  lead  wrong analysis  dna  unknown source  sequence hence clinqc assess  eliminate  contamination   sample use  prinseq  software  quality trim  ngs short read sequence errors increase   position   read  clinqc trim  low quality stretch        end   read  read filter   step clinqc eliminate  read    meet  minimum average base quality   minimum  maximum read length threshold thus  high quality read  fulfill  quality trim  filter criteria  keep   final output file   content assessment  content  crucial parameter  analyze ngs data      representation   content could effect  downstream analysis  biological conclusions therefore clinqc report  average  content       summary table   dataset  output generation   final step clinqc write three output file  summary output file  html format   report   fastq file  filter  low quality read clinqc input clinqc provide  uniform input  output data model  sanger  ngs sequence data analysis require  minimum  three input file target file  target file contain experimental  sequence information   patient additional file   file contain patient information include experiment detail  raw sequence file paths  first column patient_id  mandatory     unique identifier   sample  patient information  optional    ignore  genomic data analysis adapterprimer file  input file  optional   require   primer  adapter sequence need   trim    tabseparated text file  four columns describe  featuretype  forward sequence  reverse sequence see additional file  clinqcoptions file  options file contain  input parameters  various part   pipeline   path   third party tool  default clinqcoptions file  sanger  ngs data analysis  provide separately additional file    sequence read clinqc support sanger sequence read  ab1  scf file format illumina read  fastq format  read  sff  fastqqual format  ion torrent read  sff  fastq format clinqc output clinqc produce output file    format  sanger  ngs  make output handle   downstream analysis  efficient  output file   summary table   summary table fig  consist  one line   samplepatient include reference   two  patient specific output file  report  fastq file   summary table contain experimental patient  sequence information along   summary number  read  average  content    quality control  filter   report file  external file  hold  picture illustration etc object name  12859_2016_915_fig3_htmljpg fig  clinqc final output   summary table generate   run  include experimental patient sequence   information one row   samplepatient   report generate  fastqc  leave   right quality control   samplepatient  link  summary table  fastq file  high quality read   samplepatient  link  summary table  quality trim  filter  extensive  intuitive quality report  generate  html format  use  widely use fastqc  tool  generate various useful plot  read base quality read length distribution overrepresented sequence  sequence duplication level  get  detail view   quality  sequence data clinqc generate two  report   patientsample   fig     fig     use  direct comparison  two  report html file  link   variant summary table  fastq file  high quality read  external file  hold  picture illustration etc object name  12859_2016_915_fig4_htmljpg fig  clinqc quality control report generate  fastqc  per base sequence quality  quality control   per base sequence quality  quality control clinqc generate several useful  plot   patients fastq file    quality control  feature enable  directly compare  data quality improvements   number  filter read    quality control   file preprocessing quality filter  trim step  complete clinqc create  sanger encode fastq file  high quality read   patientsample fig   file   directly use   downstream analysis  mutation screen genome assembly  metagenomic",-0.2139695201751191,0.19245448012639266,0.11768320725532247,0.09528444012035972,0.021403806935636684,-0.054143531390768766,-0.1135386003423124,0.06324328037026601,-0.01278573648036959,0.1333976387213438,0.035021538278446174,-0.0566838253238716,0.11888425764638948,-0.08727102716310094,0.19325955733835984,0.008676955357599908,0.06505745406537197,0.13500285798871073,-0.0018979213701990933,0.0259951169277207,-0.07998760308091266,-0.27141802788186725,0.07777676703124553,0.0014949319358819571,0.031071474620153024,-0.15828614017914214,0.057070875808504076,-0.13768183058605366,-0.06374886999002252,-0.014253206821665981,-0.027492870665632958,0.2976631063031024,-0.19290169379912697,-0.04994924195194378,0.23816662338683206,0.06331702917993355,0.010048476590189892,-0.0002904844644945114,-0.08052394715307926,-0.09350577472777774,-0.07981957121504447,-0.16781812449503028,-0.0689563823502678,-0.11943170570660955,-0.13350267059166726,0.017530736854874145,0.11509533487391868,-0.17076913516562528,-0.21056509410875895,-0.3627427031742767,0.20724360824216348,0.0426423563633132,-0.0009001627368912195,0.6232447487970766,0.059499792864796924,-1.2091547132398073,0.0607326327463409,-0.2041086596236803,1.0993604703018298,0.15640319835190614,-0.12907198278079682,0.34993085020971004,-0.03303735851166913,0.09627292429288037,0.603086076462522,0.006940096074667497,0.02591784509877937,-0.01999705905551449,0.18919693764167814,-0.2076465147284743,-0.06051407793644242,-0.038729675029455214,0.15038022758940664,-0.1663899492782851,0.2417635671197413,0.011663729019272021,-0.12395197788480287,-0.11985609204335232,-0.3665894963521845,-0.10374622728156213,0.26179894453022057,-0.05796262183516191,-0.3466195032847631,-0.01908521500538485,-0.9521583414944008,0.1365675287992837,0.2745677633951299,-0.11034090476265797,-0.15020447160693434,-0.04386545051634013,-0.1566048888537364,0.09322062871681576,-0.0991365667910148,-0.07610565163672735,-0.09769085446038307,-0.06765547929994332,-0.05291385580591547,-0.3639313716918994,0.3710995572965401,0.12030911597853094,QualityControl,8
173,173,"urqt  efficient software   unsupervised quality trim  ngs data
quality control   necessary step   next generation sequence analysis although customary  step still require manual interventions  empirically choose tune parameters accord  various quality statistics moreover current quality control procedures  provide  “good quality” data set   optimal  discard many informative nucleotides  address  drawbacks  present  new quality control method implement  urqt software  unsupervised quality trim  next generation sequence read  trim procedure rely   welldefined probabilistic framework  detect  best segmentation  two segment  unreliable nucleotides frame  segment  informative nucleotides  software  require one userfriendly parameter  define  minimal quality threshold phred score  consider  nucleotide   informative   independent    experiment   quality   data  procedure  implement     efficient  parallelize software   low memory footprint  test  performances  urqt compare   bestknown trim program  seven rna  dna sequence experiment  demonstrate  optimality   result tradeoff   number  trim nucleotides   quality objective  find  best segmentation  delimit  segment  good quality nucleotides urqt greatly increase  number  read   nucleotides    retain   give quality objective
  section  present  probabilistic model   use  find  best position  trim  read  increase  quality without remove  nucleotides  necessary  also present  extension   model  homopolymer trim  read  define   vector  …    nucleotides associate   vector  phred score  …   want  find  best cutpoint  set membershipm   read  length    informative segment  nucleotide  iiset membershipk    segment  unreliable quality  nucleotide  iiset membershipk  figure ​figure1   find    want  find  best cutpoint  set membershipk    segment  unreliable quality  nucleotide  iiset membershipk    informative segment  nucleotide  iiset membershipk   give  shape   call error probability distribution   less signal  find    probability slowly increase   extremity   read    abruptly decrease therefore  want    highest number  nucleotides  support  choice         find   subsequence   read figure ​figure11  external file  hold  picture illustration etc object name  12859_2015_546_fig1_htmljpg open   separate window figure  quality trim position   cutpoints        read  trim  retain part correspond   section   green background  indicate  informative segment  nucleotides          quality value   nucleotide  probability   nucleotide   correct  define                 give  example  probability     phred   however    word “informative”  typically define   phred score   certain threshold    probability  call  correct nucleotide   probabilistic point  view  need  discriminate informative nucleotides   ≥     give threshold   nucleotides rather  discriminate fairly accurate nucleotides   ≥   others therefore  propose  define  probability    informative nucleotide                   minimal phred score acceptable   informative  definition shift  probability function        bqt therefore   threshold  nucleotides   bqt≥  informative   others       back   classical phred function figure ​figure2    bqtp   external file  hold  picture illustration etc object name  12859_2015_546_fig2_htmljpg open   separate window figure  probabilityphred function pqt accord   choice    white dark grey light grey  black dot represent respectively  position           correspond probabilityphred function             part   function        open starp     part   function    function  bqt low phred score  associate   low probability   correct     ≤  high phred score   correspond   high probability   correct  example   therefore   probabilistic point  view unreliable nucleotides    weight  informative ones  associate  high phred score   high probability    informative nucleotide  constrain  probability  reach    phred score    use  follow spline function figure ​figure22        ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩         ≤ max          ⋆            otherwise    open starp      cubic bezier curve start    toward    arrive    come   direction      open starset membership     maxtt   maxt    tangent   function        maxt  scale  bezier curve   interval    open starqtt  constraint maxt ensure     ⋆    ⋆                  open starset membership see figure ​figure22   maximum likelihood framework find  position   cutpoint   segment  informative nucleotides    segment  unreliable nucleotides  consist  estimate        arg max   ∏               ∏                          probability   nucleotide   come   segment  informative nucleotides      probability   nucleotide   come   segment  unreliable nucleotides   give                    ∏  ∈              f1ni     pqi              indicator variable       nucleotide    equal     otherwise      ∑               probability  observe  nucleotide         standard iubiupac dictionary  prnnset membershipω     estimate   complete data framework    algorithm   find      apply   procedure   interval         estimate  best cutpoint     segment  unreliable nucleotides ahead   segment  informative nucleotides  double binary segmentation ensure  provide  best two cutpoints   give read   pqtp    interpret  segment  informative nucleotides   segment    average   confident   give nucleotide   correct one whereas  segment  unreliable nucleotides  compose  uninformative nucleotides    average    four nucleotides   present   give position  cutpoint   maximize  probability   nucleotides  iiset membershipk   informative   nucleotides  iiset membershipk      model trim nucleotides  unreliable quality  somewhat similar  remove homopolymers   extremities   read  task  remove homopolymers   polya tail  rnaseq experiment   trivial   quality   give nucleotide decrease    end   read    size   homopolymer therefore   number  incorrectly call nucleotides increase   less likely  observe    end   polya tail urqt implement  procedure   unsupervised trim  polyn   straightforward modification  equation    f1ni   paqitniapaqit¼ni≠             replace    letter   standard iubiupac dictionary   definition     consider  call error probability   nucleotide  position        ≠  probability   nucleotide could    ",-0.208025954995661,0.18937295024755496,0.14850023140406718,0.1596566962585157,-0.06249989349071386,-0.004640466838262657,-0.10073727486157256,0.09007117306371468,-0.07284018954968886,0.1067132120440113,-0.004949686470844433,-0.03888085351906823,0.1521612102998064,-0.06739606647355917,0.1553038117882023,-0.05407483089081151,0.024999733385031364,0.166431105941809,0.023837203212356498,0.03597079497284804,0.026866760446297017,-0.20227135726156173,0.04107199742703151,-0.033206998896108064,0.06581659646414167,-0.14039809109828044,0.03132618395409362,-0.1941499064448587,-0.040253286164997855,-0.07601091072561074,0.02763029706621244,0.2374252010498473,-0.16117013454068194,-0.08166907529027947,0.17603941812976312,0.1127175464425302,0.048100663983950014,0.02547140344267328,-0.02147381249418918,-0.1289422757930208,-0.09768865023236407,-0.15447530299668688,-0.0268093470041475,-0.059889999233972264,-0.1624789899641339,-0.07349423478408684,0.14110219416766698,-0.1370342720121621,-0.21670729758635704,-0.3519604985390836,0.19949747050174427,-0.043352901416249465,0.05605580628823145,0.6104085173504097,0.0065613701858670045,-1.149359352410695,0.07162897374500778,-0.15146605232160815,0.9597984573850078,0.18648790206338267,-0.14018608390505125,0.2400462368671644,-0.13676517026363508,0.07314121389946511,0.5521106861774473,0.020339774872351384,0.012334844475638464,0.015138114050332403,0.14633959754335474,-0.1749562871019465,-0.062182028650026276,-0.034551670581720775,0.11425606435427366,-0.1268434657905984,0.2365522272422487,-0.05370022470236992,-0.1345438212585629,-0.10104756988089612,-0.3138484559319121,-0.17607430264530546,0.14690111631079428,-0.031671622181839665,-0.36518048682144394,-0.10266692356295698,-0.8165869288549409,0.04779581580449768,0.19656284606861985,-0.14085479104950865,-0.07692464484861253,-0.06735748205660487,-0.19095939980879267,0.055084141605188534,-0.10522975400296627,-0.08701865613652089,-0.13046562537494782,-0.0728905233554542,-0.10861585778019107,-0.29181272097275396,0.261863088657987,0.09382736173636737,QualityControl,8
174,174,"fqc dashboard integrate fastqc result   webbased interactive  extensible fastq quality control tool
fqc  software  facilitate quality control  fastq file  carry    protocol use fastqc parse result  aggregate quality metrics   interactive dashboard design  richly summarize individual sequence run  dashboard group sample  dropdowns  navigation among  data set utilize humanreadable configuration file  manipulate  page  tabs   extensible  csv data
fqc dashboard   combination   command line interface cli write  python   depend  fastqc  process fastq file  frontend website write  javascript html  css  utilize highcharts     javascript libraries  plot  bootstrapjs   style  interactivity  package  include   source code repository  cli   single executable  submodules   fastq process  either single  pairedend data  batch fastq process base  directory search  iii add custom plot onto exist dashboard page   dependencies outside  clone  source code repository  python     instal use anaconda   fastqc    instal use  bioconda channel  plot  table  dynamically generate  csv file  configure   user   display within fqc' support visualizations table line plot bar plot area range plot heatmap  plate heatmap configuration  set use json file  define  biological sample  sample group  well   plot  display   respective user settings  default settings  fqc  generate  standard  analysis  fastqc without  need   user  edit file though  modify  configuration file  user  personalize  add plot relevant   analysis protocol",-0.3199494597502053,0.21399690720284265,0.12691126542039596,-0.05533469486705391,0.1522155926973259,0.11499496568310058,-0.14673114908028936,-0.015124923158910569,0.09563209768384696,0.17011024871983138,0.17421137645319734,-0.15643549319830233,0.07512588669561733,-0.1359344078583043,0.09979712630432667,0.08701771852497199,0.24979429742542364,0.17263100814011134,-0.07296885854675103,0.05629838932644955,-0.19634905879748826,-0.2509641022011006,0.17122166726533009,-0.011978832822316722,0.019930206921930285,-0.30732459072970736,0.036693724458573496,0.0018142422629615009,-0.1537747861350338,-0.08098677435290005,0.04439848227331699,0.3952775766236423,-0.28215355426467703,-0.05335649935098491,0.3428749502478641,0.14203319512702273,-0.013595440333227677,-0.05007891496643424,-0.005826158733186075,-0.22719144930084376,0.013040600474272713,-0.16129948312448242,-0.13615562628670516,-0.016575507573009927,-0.18310073399679516,0.0531445323288346,-0.015304595324346722,-0.12122532975528452,-0.05214534819094559,-0.2372311264142331,0.11631370145409226,0.22496880506070616,-0.009789822410034428,0.4886891591851994,0.01500100817460314,-1.060621301560185,0.0980382657972938,-0.18900263375578985,1.0497035839736968,0.14392095035084096,-0.15592683725437875,0.25233958361638803,-0.03872385909149455,0.07060431544787361,0.5138910592028524,-0.0212234574857452,0.06163043787868663,-0.007721809634812555,0.2239128993034868,-0.14483568671364652,-0.02412630718840697,0.04491730430558071,0.2389096928527579,-0.2310442019893267,0.09656743312222978,0.016370066804653506,-0.06269094684571659,-0.025857022341924833,-0.3065509999218255,-0.09141596437873856,0.15235618067218654,-0.08540153680014093,-0.3438973182726501,0.04288944807219303,-0.7361931515762866,0.2663644061865822,0.2991882811785849,-0.14145077079124116,-0.08344069377507353,0.005973413379436706,-0.14116213382300685,0.1951025679265544,-0.02003887433842835,-0.060949202796633725,0.07127880901729658,-0.1289131144472098,-0.1084543605911214,-0.3803022520190452,0.4237475585571285,0.13898583747628065,QualityControl,8
175,175,"kat  kmer analysis toolkit  quality control ngs datasets  genome assemblies 
 novo assembly  whole genome shotgun wgs nextgeneration sequence ngs data benefit  highquality input  high coverage however  practice determine  quality  quantity  useful read quickly    referencefree manner   trivial gain  better understand   wgs data    data  utilize  assemblers provide useful insights   inform  assembly process  result  better assemblies   present  kmer analysis toolkit kat  multipurpose software toolkit  referencefree quality control   wgs read   novo genome assemblies primarily via  kmer frequencies   composition kat enable users  assess level  errors bias  contamination  various stag   assembly process   paper  highlight kats ability  provide valuable insights  assembly composition  quality  genome assemblies  pairwise comparison  kmers present   input read   assemblies
kat    application contain multiple tool    exploit multicore machine via multithreading  possible core functionality  contain   library design  promote rapid development  new tool runtime  memory requirements depend  input data size error  bias level  properties   biological sample    rule  thumb machine capable   novo assembly   dataset   sufficient  run kat   dataset see  section   detail kmer count  kat  perform   integrate  modify version  jellyfish2 marc¸ais  kingsford   support large  value   among  fastest kmer counter available zhang     assembly validation  comparison  read spectrum  assembly copy number  kat comp tool generate  matrix   sequence set kmer frequency  one axis  anothers set frequency     cells hold distinct kmers count   give frequencies  compare read   assembly kat highlight properties  assembly composition  quality  represent   stack histogram read kmer spectrum  split  copy number   assembly see  section    primer    interpret kats stack histograms  addition kat provide  sect tool necessary  study specific assemble sequence  track  kmer coverage across   read   assembly spectra   help identify assembly artefacts   collapse  expand events  detect repeat regions figure  show plot relate  two fraxinus excelsior assemblies create    dataset use  comp  sect tool  plot highlight different strategies take   assembler      see  homozygous content  duplicate       heterozygous content eliminate _excelsior read content  black  absent   assembly red occur  purple twice etc  kmer spectra show  error distribution   heterozygous content around   homozygous content around   contain      heterozygous content  introduce  duplications  homozygous content    collapse include mostly  single copy   homozygous content  less   heterozygous content    generate use kat sect show kmer coverage across example assemble loci  assembly kmer coverage black line  assembly   plot  show   assembly  two copy   locus whereas  read kmer coverage red line imply      single copy  incorrect duplication   correct  assembly    read  assembly kmer coverage agree  plot   increase read  assembly kmer coverage  position    indicate small regions  repetitive sequence   genome  halve read kmer coverage  position  indicate  heterozygous locus  likely cause  duplication   locus   assembly  see  section     extensive analysis   sequence   loci   impact       kat tool kat also include  hist tool  compute spectrum   single sequence set  gcp tool  analyse  content  kmer frequency  filter tool   use  isolate sequence   set accord   kmer coverage   content   give spectrum see  section   detail    tool  tool   use  various task include contaminant detection  extraction   raw read  assemblies analysis    bias  consistency  pair end read  several",-0.21373992689756185,0.21071404441626687,0.0602186587223384,0.07220823307182979,0.017061930200693833,-0.02502929159536861,-0.1198284651658768,0.02872353998109602,0.03988884131170132,0.14090704070545282,0.015888678765698494,-0.1149935294492009,0.13707640915464014,-0.10931061797909382,0.12959800367833224,0.015706330625485484,0.08857927132106601,0.18038368244865585,-0.024026480970553474,0.07062255766381836,-0.0475497403508657,-0.26507350601542146,0.07363712677845864,-0.052966444644254526,-0.04814110123915235,-0.21266214322556795,0.12924115634052127,-0.07363468749061614,-0.05786831465900525,-0.0037964564749116314,0.010017247235571795,0.28325865822243235,-0.19333871409450196,-0.05579395819398941,0.2316779939714039,0.055359875328750134,0.06155914420945353,0.030794727551504905,-0.13664268568340585,-0.11518766815689475,-0.0913251872870288,-0.16775626883655834,-0.16329580385896106,-0.13274095565366895,-0.1851138746873899,-0.009403279109644296,0.1362594959055492,-0.1376673486083746,-0.2553640504909913,-0.37547492174717934,0.13366125791799274,0.10098444693558042,0.015259916901445313,0.6045371755530243,0.0637231967805026,-1.1668464302788872,0.03776241037833356,-0.1979873956420995,1.0414064097262563,0.1470631301207508,-0.16360091345520286,0.37153710780495947,-0.0218191738693987,0.1186697762721577,0.6125101250731406,0.035416076644434635,0.06421548789729932,-0.040102778743503584,0.2648268741395756,-0.17636978922757518,-0.03363795705316087,-0.03686321694068752,0.14217360134365528,-0.12952087510798482,0.1960486751977048,-0.025206289227922885,-0.1010191898754681,-0.1154405470217832,-0.3896867772282073,-0.04591209595887902,0.27643388379526473,-0.02804384597484425,-0.3683397121375575,-0.017747636018643455,-0.918525770887152,0.1001717319774534,0.2541267625358585,-0.1323790028837441,-0.13286439674096062,-0.008565373051870268,-0.20645038896337053,0.08673987406340238,-0.10201925141595757,-0.07512966534011953,-0.10655329239885304,-0.1119835063572207,-0.129029961202084,-0.3747588356561733,0.383954700814294,0.08047675239869688,QualityControl,8
176,176,"ngsqc generator  quality control system  chipseq  relate deep sequencinggenerated datasets
 combination  massive parallel sequence   variety  modern dnarna enrichment technologies provide mean  interrogate functional proteingenome interactions chipseq genomewide transcriptional activity rnaseq groseq chromatin accessibility dnaseseq faireseq mnaseseq   recently  threedimensional organization  chromatin hic chiapet  systems biologybased approach several   readouts  generally cumulate   aim  describe live systems   reconstitution   genomeregulatory function however  issue   often underestimate   conclusions draw   multidimensional analyse  ngsderived datasets critically depend   quality   compare datasets  address  problem   develop  ngsqc generator  quality control system  infer quality descriptors   kind  chipsequencing  relate datasets   chapter  provide  detail protocol   assess quality descriptors   ngsqc generator   interpret  generate report    explore  database   indicators wwwngsqcorg   publicly available datasets
preliminary sequence quality assessment  step   analysis  experiment quality base  enrichment   ngsqc generator   important  check  quality   dna sequence    factor  directly influence  result  currently use fastqc   evaluate  dna sequence quality  potential contaminations fastqc aim  provide  simple way    quality control check  raw sequence data come  high throughput sequence pipelines prior  alignment    use  simple gui interface   commandline  easy batch process   tool  handle different format like fastq sam  bam file fastqc generate  html output contain  variety  graphical display illustrate  quality   data  different aspects   highlight  important modules  require close investigation  fastqc result  assess better  quality   data  sequence quality “per base sequence quality”  “per sequence quality scores”   two important plot     pay attention  understand  sequence quality   data  first plot   boxplot illustrate  average median  distribution  quality per base    read   data fig   illuminas sequence chemistry  sequence per cycle approach   cycle one base   read  sequence thus   cycle kit yield  read    length   recent versions  illumina sequence kit generate much longer read   even   length  fastqc analysis  still  helpful  identify potential abnormalities   sequence process open image  new windowfig  fig   fastqc generate “per base sequence quality” plot  gsm733720 nhek leave panel  gsm733737 hepg2 datasets right panel  fastqc generate “sequence duplication level”   datasets      data show similar harmless level  clonal read hence   expect   dip  hike  quality     particular base      sequence due  technical issue  pattern   easily observe  “per base sequence quality” box plot  average  distribution  quality per base   read   important  remember  due   reagents “burning”    period quality  base towards  end   read result   gradual decrease  average quality   plot   average view   read sequence provide  first way  evaluate sequence quality  presence  read  poor quality level  affect  alignment accuracy   reference genome false  multiple alignment outcomes one  address  problem  use  “per sequence quality scores” plot  show  distribution   read average quality  get  idea  altogether bad read unlike  “per base distribution” approach  analysis   “per sequence quality” context allow  estimate  fraction  read  low quality   important  note  fig    nhek dataset present  overall poor sequence quality   also reflect   lower percentage  map read  comparison   observe  hepg2 datasets table  note  tool like fastxtoolkit  ngsqctoolkit   seqqc   dedicate  trim  filter read present low quality score see note   clonal read “sequence duplication level”  important aspect  understand  quality  data rather   sequence     low amount  start material  start    overamplifying  fragment  library preparation could lead  high level  sequence duplication  clonal read bias  analysis  overrepresenting   fragment   generate falsepositive enrichments hence   highly recommend  remove duplicate read  keep  one copy also   important  point    currently exist methods  detect clonal read  singleend sequence assay may overestimate  presence clonal read  define  read align    start  end position indeed  analysis    two read generate  pairedend sequence   dna  treat separately  single read demonstrate  read consider  clonal   singleend sequence context   different alignment coordinate   correspond pairread analysis data  show   highly recommend  remove clonal read  alignment  sequence errors could bias  similarity estimation among read    carry  prior alignment hence  fastqc sequence duplication level   use   rough assumption       raw data    first million read  consider   calculation  deviation   observe  fastqc sequence duplication level  fig    actual unique read count  table  see note   adapter contamination  fragment dna molecules  shorter   apply sequence length dna sequence  continue   adapter sequence   end   process   rare     chromatin immunoprecipitated dna   average larger  several hundreds  nucleotides    happen  oversonication sequence library primerdimer contamination    detect   count  “overrepresented sequences”    bulk  read  adapter contamination tool like cutadapt  fastxtoolkit ngsqctoolkit  seqqc   use  trim  adapter sequence  retain  actual dna sequence  explore  ngsqc generator portal ngsqc   access   portal wwwngsqcorg  give access  different elements  ngsqc method among  various components available   main page   cite  direct access   customize galaxy instance host  ngsqc generator tool  access   ngsqc database  well    detail tutorial describe  principles  use  assess quality score   interpretation   context   enrichment behavior fig  open image  new windowfig  fig  home page  ngsqcorg website notice   part   main display access   ngsqc generator tool    dedicate database  available furthermore  access   database content statistics  illustrate   visitors could   glance   variety   publicly available datasets currently host   website  access   ngsqc generator tool via  dedicate galaxy instance   overview   galaxy interface galaxy      open webbased platform  biological data analysis  enable  run bioinformatics tool   userfriendly pointandclick environment  ngsqc generator  available   local galaxy server reachable     worth  mention   user require  create  login account    dedicate space  allocate   job   ngsqc generator associate server  log  users  access   main galaxy interface compose  three section  illustrate  fig  open image  new windowfig  fig  illustration   classical galaxy interface compose   “tools” panel leave side demarcate  red  central panel  tool parameters  result  display   history panel right side  purple contain  datasets available   example  current history panel contain two datasets import   “shared libraries”   panel contain  list  available tool group  field  analysis leave side   central panel   interaction   select tool  enable  well   display   generate result   panel contain  history  data request job  result right side   important  mention   last panel provide  history  every datasetjob associate   user thus  continuous clean   content   good practice  avoid overload  allocate space   servers see  run  tool  galaxy require import  dataset  interest   history locally store file   upload either   users web browser   use  ftp server nevertheless  might strongly recommend use  second option   case  large size datasets larger  2gbs   case  first option locally store file   upload  galaxy  click  “get data”   tool panel  select “upload file” either one  drag  drop file   desktop file manager   galaxy interface  select file   local disk  click  “choose local file” button  select click  “start” button  start  upload  upload file  ftp  connection   ftp server   ftp client  require  filezilla   open source  crossplatform tool   ftp client  host    give  “galaxyngsqcorg”  users  use  galaxy credentials  login fig    file  upload    import   history  click  “get data” “upload file”  “choose ftp file”   galaxy leave panel datasets successfully import   show  green color box   history panel right side open image  new windowfig  fig  screenshot   filezilla interface  ftp connection   establish  fill  “host” field  “galaxyngsqcorg”   galaxy userpassword   “username””password” field respectively  click  “quickconnect” button drag file   leftside panel  drop  onto  rightside panel  start  upload though  galaxy server  equip  high compute capacity  storage space  handle multiple users  cannot keep   every dataset upload   reason file   older   month   automatically remove  galaxy  case users  run   space   reduce  disk usage  permanently delete datasets    need anymore    two step action delete  unwanted dataset  click  “delete” “” button   history panel  click   history gear icon  click  “purge delete datasets”  ngsqc galaxy instance  currently host  variety  tool generate   galaxy community text manipulation operate  genomic intervals  also two dedicate tool   assessment  quality descriptors  chipsequencing  enrichment relate datasets available   “ngs ” group   tool panel   ngsqc generator compute global  local quality descriptors  perform multiple random subsamplings   map read retrieve   provide dataset   use   reconstruct  compare  enrichment pattern   original profile   local qcs viewer allow users  visualize  read count intensity level retrieve   datasets   context   compute local quality descriptors regions  display   choose   user either   gene name  genomic coordinate   let  tool  select  regions base  local  score rank  perform  global quality control analysis  mention earlier   go  run ngsqc generator  nhek  hepg2 datasets available   “shared libraries”  use  datasets  share libraries users   import  datasets   history panel  follow  click “shared data”   top   page  navigate  “data libraries” “examples”  select  “nhek”  “hepg2” datasets  finally select “import  current history”   “ select datasets” menu click  “” button   back   main page  click  “analyze data”   datasets    history   run  ngsqc generator  click  “ngsqc generator”  “ngs ”   tool panel    central panel select one   batch mode datasets   genome assembly   case hg19  follow options  also available  generate   three technical replicate  evaluate  result variability  remove  clonal read potential pcr duplicate  default    remove  exclude background noise users  switchoff  option  interest  assess  influence   score   default   active  select  resolution   readcounts intensity representation  display genomic regions  select  sample antibody target   user provide  target identity  output report  contain  scatterplot show  comparison   evaluate datasets quality   retrieve   ngsqc collection  click  “execute” button  launch  job   run  ngsqc generator produce two output   make available   history panel  first one   html page link   pdf report  summarize  quality descriptors   zip archive contain several supplementary file  ngsqc generator report fig   compose  three major elements open image  new windowfig  fig  first page   ngsqc report   hepg2 dataset gsm733737 replicate    upper right side   page  global quality stamp  display along   color bar represent  proportion  unique readsurs   dataset  dataset information  characteristics   dataset  analysis like  total map read  fraction  unique map read  without  clonal sequence read length size  genome assembly   target molecule  available  indicate   parameters   detail overview   various parameters use  generate  correspond  report  list    could  reproduce  require   result   compilation   global quality indicators assess   context   consider map read  display either   without clonal read  result panel  complement   scatterplot display  read count per genomic region   bin xaxis  comparison   recover count  multiple read random subsampling        subsampled read yaxis furthermore  global  certification score  “aaa”  “ddd”  designate  high  low quality datasets  stamp   main page    report    quality   analyze dataset  express   rather intuitive manner without  need  get deep   assess quality score   report   complement  series  genomic regions display illustrate  enrichment pattern associate   dataset  analysis complement   demarcation  genomic areas present high enrichment robustness local  indicators heatmap display  addition   target molecule identity  provide  scatterplot display  total map read versus  quality descriptors assess  entries available   ngsqc database  comparison  evaluate dataset  include   end    report fig  open image  new windowfig  fig  quality score yaxis relative   total map read xaxis assess  several public datasets blue  comparison   dataset  evaluation red   leave panel  analysis   perform   hepg2 dataset    right side   illustrate   nhek dataset  type  display  include int  last page   qcreport   target molecule identity  provide  addition    report  set  supplementary file  generate zip archive format  supplementary folder contain  genomic regions display  local  regions  either wiggle  bed format file      upload   genome browsers like igb     ucsc genome browser  furthermore  text file refer   “local qci file” contain  genomic regions present enrich regions  high robustness drci     also include   supplementary file  last file  also create   current history since   require  generate multiple genomic regions display see subheading   visualize local enrichment pattern   context   quality consider  interest  users  visualize genomic regions   way  confirm  potential low  high quality   dataset  study   develop  convenient way  display  together   demarcation enrich regions base   robustness  local  indicators score    new tool call “local qcs viewer” take alignment file bed  bam format   previously generate local qci file  input  produce    genomic regions display pdf report format  three selection strategies  default regions   display  select base   local  score  read count intensities   presence  genes near  highly enrich region users  also  possibility  provide  list  genes  genomic position   way  customize  display  perform    report genomic regions display enrichment pattern associate   dataset  analysis complement   demarcation  genomic areas present high enrichment robustness local  indicators heatmap display fig  open image  new windowfig  fig  comparison  three genomic regions  hepg2 top  nhek bottom regions  select use  rasl11a wrap53  znf37a genes  plot contain three part  top  representation   readcounts intensity  center  position   local regions   dispersion    yellow    black   genes position  hepg2 plot present conserve local  regions  highly peak intensity   contrary nfek plot  poor  enrich regions  explore  ngsqc generator database   general overview  addition   access  ngsqc generator tool users  retrieve  large collection  quality indicators compute   variety  publicly available datasets   dedicate website  access  users   select either “database”   top navigation bar  “ngsqc database”   main page   ngsqc portal   two ways  browse  result either  use  propose query panel    interactive boxplots table locate   query panel fig  allow specify  request  multiple options like  model organism target molecule quality grade  also  public identifier  geo database gsm  gse   encode consortium wgencode importantly    query options   use  combinations  example users  query    qualify datasets correspond  mouse mus musculus  human homo sapiens model systems target  histone modification mark h3k4me3  present quality grade  “”  “” fig  open image  new windowfig  fig  display illustrate  database page show  search panel top  boxplotsviolin plot table bottom  boxplot table display quality score qcstamp drci    distribution assess   whole database content currently    datasets  well   discretized qcstamp intervals     furthermore  quality score distribution per target molecule  display   users might   global overview   associate quality score   worth  mention   addition  display    distributions   boxplot format  violin plot  also display     detail view   distribution  population  available  target molecule  boxplot  complement   legend indicate  identity  well   number  entries available target molecules represent  less   datasets  categorize  “others”  click     target molecule boxplots users  redirect   result panel associate   target molecule    refinement query could  perform  require  instance  click   boxplot associate  histone modification mark h3k4me3 users  redirect   result page    score   datasets associate   target  display  result page fig   compose  five elements open image  new windowfig  fig  display illustrate  result obtain  perform  query   ngsqc database  scatterplot display  qcindicators relative   total map read  boxplotvioplots display  different target molecule retrieve   query  result table include several additional information   dataset right panel   refinement panel leave panel  query panel display  current request make  boxplot table display   score distribution     target include   request   scatterplot display  quality score qcstamp   dataset   context   total map read tmrs  result table present  important number  information   dataset retrieve  refinement panel provide  query options   apply   initial request  refine  result  specific interest   describe elements  mean  provide complementary information   user  well  mean  narrow   mine  users specific interest  instance  multiple target  part   initial query  boxplot panel provide  possibility  select one   fig  furthermore  scatterplot display provide  powerful way  visualize  quality score associate   dataset   context   relate tmrs  instance   context   query target  histone modification mark h3k27me3  user  pass  pointer   scatterplot    popup display element like  dataset identifier  associate tmrs  target identity  model organism   compute quality grade fig  consider   quality score  compute  three different read count intensity dispersion condition drci     summarize  one   letter correspond   qcstamp grade     —represented  short aaa— drci         respectively   context users  switch  display among  three correspond scatterplots use  button locate   top   panel furthermore users  zoom   scatterplot  perform   refinement   result   desire group  datasets    users might select  “zoom” icon locate   right top corner   plot   press  hold mouse button  select  region alternatively zoom   scatterplot  possible  scroll  wheel mouse button open image  new windowfig  fig  scatterplot illustrate  quality score compute  several h3k27me3 generate datasets   context   total map read  identity  one   datasets present    million tmrs  highlight     ngsqc generator website  result table fig  locate   scatterplot provide  information     datasets retrieve like public identifier  study  associate publication  pmid model organism data type target molecule tmrs complement   fraction  unique map read   exclude  clonal read global quality grade qcstamps   global  indicators report available   pdf format  supplementary information  available   zip file format available  download take  consideration  users might systematically wish  associate  qualify dataset   article describe  users  access   abstract   relate publication  available  place  mouse pointer   correspond pmid finally  time  initial query might include  many output   users might wish  focus  view   define subset thus  separate refinement panel  provide   leave   result table fig  importantly  refinement panel  compose   list   elements aim  provide  large flexibility   task   data type target molecule model organism sequence platform tmrs submission date abstract content author  public   elements like  cell linetissue  potential celltissue treatment   antibody reference  batch available   nonacademic access see    ngsqc database   source  information  provide potential hint  interpret chipsequencing assay  low quality performances  important application   database   provide potential hint  understand  reason   low quality grade associate  certain chipseq  relate datasets  illustrate  aspect  user could query   dataset “gsm733754”  describe   subheading   result two entries associate   histone modification mark “h3k27me3”  retrieve   database  correspond  two replicate retrieve    unique identifier  general  unique   associate   single dataset    case geo entries include replicate     surprisingly  compute quality grade  significantly different   two entries suggest  though   attribute  replicate technical differences  preparation  sequence could  lead   differences  fact  dataset present “cbb” quality grade   million tmrs whereas “ddd” qcstamp    million  difference   total map read among datasets   least partially explain  difference   quality grade  strongly suggest  replicate datasets might also  sequence  similar depths  avoid  potential source  quality differences   illustrate  use   ngsqc database user could perform  query target  entries associate   histone modification mark “h3k27me3”   human model system  time  scatterplot  populate     datasets    direct correlation   quality grade   tmrs per dataset   observe   observe pattern  instance   possible  infer  minimal sequence depth    majority   retrieve datasets might present high quality grade   tmrs higher   million    datasets  “ccc”  higher   important  mention  even  datasets generate  high tmrs level significant differences  quality score   observe  instance  illustrate  fig  datasets generate     million read could still present “ccc” quality grade  identify chipseq grade antibodies   ngsqc database content    silico approach could provide guidelines concern  sequencingdepth  use   give factor    guarantee   higher sequencingdepth experiment   successful  fact several  parameters like  antibody  use  cell linetissue  analysis  well   performance   experimenter  crucial factor  chipseq pipeline  could  influence   quality  illustrate  important aspect users might query  datasets generate   histone modification mark h3k9me3   context  human study fig    take advantage   zoom option available   result scatterplot   refine  query  datasets present quality grade  “” finally  refine output   sort base  tmrs use  result table   high quality datasets aaa generate   least number  tmrs might appear   top   result table panel   point users might  interest  retrieve  antibody source  give rise   optimal result   indeed possible  access  correspond public repository page  geo database  use  link embed   public  display   result table additionally   currently annotate  antibody source per qccertified datasets   ngsqc database   users might directly access   information   previously describe refinement panel open image  new windowfig  fig  example illustrate  procedure    ngsqc database   use  retrieve  antibody  use  high quality grade datasets  refine query   perform  retrieve high quality datasets associate   histone mark h3k9me3 follow   identification   best dataset “aaa”  grade   least tmrs finally  correspond gsm  link   use  explore   original information retrieve  geo",-0.16653817121840303,0.17923609325820622,0.13266525384746786,0.07986628352489222,0.02515483859506011,-0.007337103726809112,-0.1140146641845807,0.03164592331796105,0.029749022875302157,0.07718433143522417,0.019513743617051976,-0.06545532916718302,0.13993655923920936,-0.11417968189275995,0.1323809972715573,0.016019546033507127,0.07293910962435952,0.12445658332111174,-0.056704472249302584,0.08095593968359979,-0.04023299359284721,-0.1884927259701532,0.02665169390255432,-0.020578540873898026,-0.02009842868496492,-0.1804061914483047,0.05501692387406365,-0.12700205551438062,-0.031014501858363887,-0.06258209220693757,0.016696401054996916,0.2509260365268258,-0.17027616840698226,-0.02944269859869467,0.17461866231551715,0.10780510515432626,0.010769874350731273,0.01263674164602863,-0.06344199529177909,-0.12219365702609156,-0.09324330469006807,-0.14993322078711555,-0.06916987580604028,-0.10029087780770796,-0.12881126365893086,-0.005211552206479979,0.08780939070354259,-0.12060072738500666,-0.14359860617053713,-0.3464445548065095,0.1843146195086492,0.05126944539730281,0.03683693124905616,0.5330441314687511,-0.004602426827774447,-1.1088104590963463,0.02919702143606504,-0.19884402166588064,0.9531574142523628,0.15276033740756426,-0.16160125407951606,0.34272139059683165,-0.057386200345241126,0.045924659280131286,0.5330555125990729,0.02607461500272762,0.08063844051898697,0.007535919549058924,0.19156487521203175,-0.1485945571986625,-0.026779164733702558,-0.02263729571372167,0.12170126339916147,-0.1521872071526974,0.131283686450825,-0.002967201442586584,-0.09413476357602704,-0.10275261511242648,-0.3385492138576878,-0.08336743081846948,0.20088516078421276,-0.035474303484626886,-0.31794069633397865,-0.035795678577167714,-0.7976810987150122,0.0530041081155396,0.17950893415498956,-0.11028612890244474,-0.10235672270787248,-0.04355033545822523,-0.14587226516525634,0.08940658848230458,-0.05749804441331029,-0.09062543590084053,-0.08347035734197243,-0.05076275838104425,-0.10179149667555534,-0.2969528524597425,0.3191935835148064,0.08186150771971988,QualityControl,8
177,177,"easyqc tool  interactive user interface  efficient nextgeneration sequence data quality control
 advent  nextgeneration sequence ngs technologies  revolutionize  world  genomic research millions  sequence  generate   short period  time   provide intrigue insights   researcher many ngs platforms  evolve   period  time   efficiency   ever increase still primarily    chemistry glitch   sequence machine  human handle errors  artifacts tend  exist   final sequence data set  sequence errors   profound impact   downstream analyse  may provide mislead information hence filter   erroneous read  become inevitable  myriad  tool  available   purpose however many    accessible   command line interface  require  user  enter  command manually   report easyqc  tool  ngs data quality control    graphical user interface provide options  carry  trim  ngs read base  quality length homopolymer  ambiguous base easyqc also possess feature   format converter pair end merger adapter trimmer   graph generator  generate quality distribution length distribution  content  base composition graph comparison  raw  process sequence data set use easyqc suggest significant increase  overall quality   sequence test  easyqc use ngs data set   standalone desktop prove   relatively faster easyqc  develop use perl modules    execute  windows  linux platforms   various  feature easy interface  end users  crossplatform compatibility easyqc would   valuable addition   already exist tool facilitate better downstream analyses
easyqc   open source desktop tool  crossoperating system compatibility facilitate   process  huge ngs data set  great accuracy easyqc include various modules   format converter adapter trimmer   graph generator apart   pipeline  carry  filter base  length quality ambiguous base  homopolymer repeat  well  key feature  easyqc  describe hereunder  easyqc feature  pipeline  format converter  module  easyqc mediate  conversion  fastq file  fasta file  verify  accuracy   input fastq file  convert   fasta file upon successful format check  rangamaran   download  univ  western ontario  wwwliebertpubcom    personal use   adapter trimmer adapter  primer trim   vital step  ngs data    important  remove  forward  reverse adapter sequence   data set  adapter trimmer module  easyqc take  forward  reverse adapter sequence  input  trim  sequence accordingly  pair end merge many sequence protocols    use today sequence  dna fragment   end merge   pair end read  important  genome assembly   analyse  pair end merge module  easyqc use flash magoc  salzberg   merge  input fastq file  graph generator  feature  easyqc enable  user  obtain graphical output  length distribution average quality distribution atgc composition   content   input sequence data set  qualitybased trim removal  low quality sequence  essential since     significant impact   downstream analyse  ngs data  module  easyqc get  quality threshold   base along   percentage threshold   sequence  input sequence  contain lesser percentage  highquality base   threshold   remove   data set  lengthbased trim  time data set possess sequence    wide range  read lengths    important  remove  sequence  fall short   require length  module trim  sequence   shorter   input threshold length value  ambiguousbased trim presence  ambiguous base  significant impact   subsequent alignment process  feature fetch  threshold percentage   ambiguous base  shall  permit   sequence     greater percentage   remove fig   workflow  easyqc pipeline easyqc  standalone tool  ngs   download  univ  western ontario  wwwliebertpubcom    personal use  fig  user interface  easyqc contain multiple tabs enable  user  execute require process   pipeline  enable  user  set  threshold value  various filter parameters  pair end merge interface  facilitate merge  two fastq file base   userspecified thresholds   adapter trimmer module  enable  user  remove  adapter sequence      end   sequence  graph generator module  easyqc  provide sequence quality length   distributions along  base composition graph  dna nucleotides  quality control  download  univ  western ontario  wwwliebertpubcom    personal use  fig  result   trim pipeline  easyqc  graph represent  number  sequence filter   stage   trim process  download  univ  western ontario  wwwliebertpubcom    personal use  fig  comparison  per base quality   raw read   read process use easyqc   quality filter  q30  graph show significant increase  quality  process read  download  univ  western ontario  wwwliebertpubcom    personal use   homopolymer trim homopolymer repeat   sequence shall also cause misalignment   sequence lead  false result  module take  cutoff value   homopolymers   present   sequence    exceed  cutoff value   take    data set  trim modules  design   single pipeline  easyqc  user shall upload  input sequence data set  specify  threshold value    modules    time  execute  pipeline  input  output  easyqc easyqc take fastq file generate   ngs platform  input    modules  output  easyqc   hereunder  pair end merge  output fastq file contain  stitch pair end sequence base  user input use flash get store   new folder   statistics   number  sequence   merge fig  graphical output   ngs data set obtain  easyqc  base composition  sequence quality distribution   percentage   sequence length distribution ngs nextgeneration sequence easyqc  standalone tool  ngs   download  univ  western ontario  wwwliebertpubcom    personal use    statistics   pipeline  easyqc provide  statistics   total sequence  get filter   step    process base   filter parameters provide   user fig   output sequence  fastq  fasta format  generate  every step   pipeline  sequence  directly  use  downstream analyse  comparison  quality  raw sequence data set   process  easyqc   quality cutoff  q30  carry  use fastqc   result indicate significant increase   overall quality   read fig   graphical output  graph module generate four different graph  describe earlier fig    store   separate folder    location    input file  upload  comparison  exist tool  comparison  various feature available  easyqc      tool  describe  table  although many toolkits  available  many exist  desktop standalones   user interface easyqc provide  interactive facility   users   interface   flexibility  work across windows  linux platforms  performance evaluation  performance  easyqc  validate use various illumina sequence data set contain sequence range     million  evaluations  carry    standalone dell precision t7600 workstation  intel xeonr  processor  32gb ram operate system windows   time take   execution   pipeline  various sequence data set  give  table  comparison  easyqc   tool   ngsqc  prinseq  filter  sequence base  quality score  length  carry  use  data set contain  million sequence   carry    z620 workstation  intelr xeonr cpu   processor  32gb ram operate system ubuntu v16  quality cutoff  set  q30 whereas  length threshold  set     addition  percentage  highquality base per sequence  set      default value  easyqc comparison   postqc data set fig  indicate   filter  sequence  easyqc   stringent     significant deviation   quality distribution  well  time take    process   minutes  second  easyqc whereas  take  minute  second table  comparison  various feature  easyqc   quality control tool feature easyqc fastqc clinqc fastxtoolkit ngsqc toolkit qcchain prinseq tagcleaner format conversion yes  yes yes yes yes   adapter trim yes  yes yes yes yes yes yes pairedend merge yes        quality filter yes   yes yes yes yes  length filter yes   yes yes  yes  ambiguous base filter yes   yes yes yes yes yes homopolymers filter yes    yes    graphical output yes yes yes yes yes yes yes yes graphical user interface yes yes       table  execution time   quality control pipeline  easyqc  nextgeneration sequence data set   total sequence time minutes              rangamaran   download  univ  western ontario  wwwliebertpubcom    personal use  fig  comparison  postqc evaluation  sample data set use easyqc   prinseq   ngsqc   number  sequence filter    process   tool  indicate   graph   download  univ  western ontario  wwwliebertpubcom    personal use   ngsqc   minute  second  prinseq  relatively higher time take  easyqc   attribute   execution  percentage  highquality base filter module    present    two tool  addition   overall quality filter option furthermore easyqc provide  output data set contain  sequence  pass  fail   step    process  add   execution time    provide   tool compare herewith",-0.1863898846697205,0.18832947719528284,0.1542744066409273,0.06354452433665625,0.08982279917713219,-0.0923727814200373,-0.08304746348497133,0.06399501612749897,0.003750835670330844,0.10882083156678718,0.10499762511252762,-0.02282792277085169,0.12438023027552204,-0.10945834584471684,0.1356103562380964,-0.04382177292413567,0.03535908413232682,0.1850147425416878,-0.07284905148347239,0.10439781492320112,-0.039117923752514834,-0.238407950127812,0.09083713325314796,0.047059775139696114,0.03680371911192057,-0.19105704395902365,0.04685583766813898,-0.09577887290835783,-0.05291953483691659,-0.053337781155778,-0.0018975723543376945,0.3034657000953825,-0.2312526876812045,-0.05839170664794351,0.22054694392271126,0.09736585350537573,0.03914532432527528,-0.012160475673778846,-0.08805488641061389,-0.1611678422301838,-0.048016314016887184,-0.18420451143504524,-0.09571709413454828,-0.1031418680302656,-0.12391429781834165,-0.014990348269204838,0.1545644248337351,-0.22852898784578385,-0.13679163062501662,-0.33413029156294993,0.13904695250555135,0.05262099609577496,0.0181435963026242,0.5713672942657488,0.034838300180463744,-1.1903843083746208,0.0019442420616484109,-0.2049040394796493,1.0941338044183608,0.17686788734547368,-0.15364933031145855,0.3216132158640409,-0.0934792166797462,0.14571603798581226,0.5158633025610052,0.01201602725085978,0.06134467118697914,-0.04041735746097355,0.21407674425713027,-0.1825513025098956,-0.05007050624915053,0.023271371441697643,0.14585183597483728,-0.1520409775963321,0.17408183828210488,0.004350548156331808,-0.1176271754578827,-0.07622866092038492,-0.3432171089967457,-0.08268333950114196,0.26963636442161976,-0.03076824340552758,-0.3693699883267331,-0.004181162449538696,-0.9169417526093148,0.11337328423446895,0.26132532312927514,-0.13748547534373534,-0.10354986975171096,-0.031275409748576906,-0.1391118001587058,0.11688628853536763,-0.10261645333204693,-0.10424968194121274,-0.13264387464611985,-0.0966261236734254,-0.05064179579736278,-0.29481778337141146,0.40667462138906896,0.09634432780181472,QualityControl,8
178,178,"fastq screen  tool  multigenome map  quality control
dna sequence analysis typically involve map read   one reference genome map  multiple genomes  necessary however   genome  origin require confirmation map  multiple genomes  also advisable  detect contamination   identify sample swap   leave undetected may lead  incorrect experimental conclusions consequently  present fastq screen  tool  validate  origin  dna sample  quantify  proportion  read  map   panel  reference genomes fastq screen  intend   use routinely   quality control measure   analyse sample    origin   dna  uncertain   multiple sources
implementation  program utilise  short read sequence aligner  map fastq read  predefined reference genomes  tool record   genome  genomes  read map  summarise  result  graphical  text format operation  cod fastq screen  perl  make use   cpan module gdgraph   generation  summary bar plot  software require  functional version  bowtie bowtie   bwa    run   linuxbased operate system amendments  version  correct typographical errors   figure  caption text see referee report revise figure  graphical output  fastq screen  map  publicly available rnaseq sample srr5100711  several reference genomes read either  map uniquely  one genome  light blue  multimapped  one genome  dark blue iii map uniquely   give genome  map   least one  genome light red   multimapped   give genome  map   least one  genome dark red  read represent  blue shade  significant since   sequence  align   one genome  consequently   observe   unexpected genome  suggest contamination page    f1000research   last update  may  fastq screen use plotly  enable visualisation  result   web browser  tool take  input  text configuration file  fastq file   subsampled  default   read  reduce run time   map   panel  prespecified genomes",-0.2667419638436065,0.1763055178348962,0.16431867848358936,0.05152773090860626,0.016822875133557454,-0.030275708057486743,-0.07760177649654892,0.06414374659870015,0.03294219481828275,0.10692067393935772,0.05511415665517492,0.017004536065175685,0.1379958124094601,-0.1026106979089803,0.12635749270040508,0.08144188772039071,0.10015590907658324,0.12958288899233647,-0.03574464746069775,0.07927226687350603,-0.0815182921143054,-0.3072133379807668,0.09958036067728787,0.02618331873594825,-0.0008342248985349243,-0.2342157568643565,0.0537505511458574,-0.08479903349583384,-0.027900291155022915,-0.05472552134010788,0.07022807387541284,0.27486050607477586,-0.2724364196495917,-0.05326047878184203,0.19556381716306054,0.1440260975427036,-0.0293425676767339,-0.03968418785370886,-0.0662099553511909,-0.1252310578433324,-0.149772765740853,-0.11416562679727606,-0.1192859315118794,-0.09347743839598886,-0.16078706959318093,-0.0719434275246684,0.08061862850610932,-0.202179066385073,-0.20217458935760296,-0.3549459532612184,0.25677199042384835,0.08774100009911458,0.07094729237072518,0.5834763479182747,-0.04298285832420103,-1.2255082097627334,0.004376737797048999,-0.16357028839671844,1.0699349191846022,0.22844979399207066,-0.21441053731063792,0.35465887646232525,-0.06851357421420738,0.05706033786522475,0.6216762331974651,-0.02032690223110075,0.013995707162774042,0.06798470445460565,0.11045538170485576,-0.1548719666133732,-0.05013467925565957,0.0032749618751121987,0.10916502441891204,-0.1362378935611098,0.15358172379149151,-0.003568202528212942,-0.1217307419300691,-0.04436001719979903,-0.4342517195540522,-0.10560196939049596,0.207169491018398,-0.14303455107025245,-0.36075283366528255,-0.028580791817338608,-0.9304171575010934,0.01798307683593385,0.32141771633178,-0.09005584811214913,-0.11204536624753207,0.0050608838481373325,-0.12775374895288372,0.10226155009204103,-0.09839478273905984,-0.08863628397820822,-0.06493373950786972,-0.04819733180269015,-0.14390844426729452,-0.3130349880679504,0.28114561380387576,0.04735488657068128,QualityControl,8
179,179,"antismash rapid identification annotation  analysis  secondary metabolite biosynthesis gene cluster  bacterial  fungal genome sequences
bacterial  fungal secondary metabolism   rich source  novel bioactive compound  potential pharmaceutical applications  antibiotics antitumor drug  cholesterollowering drug  find new drug candidates microbiologists  increasingly rely  sequence genomes   wide variety  microbes however rapidly  reliably pinpoint   potential gene cluster  secondary metabolites  dozens  newly sequence genomes   extremely challenge due   biochemical heterogeneity  presence  unknown enzymes   disperse nature   necessary specialize bioinformatics tool  resources   present antismash antibiotics  secondary metabolite analysis shell  first comprehensive pipeline capable  identify biosynthetic loci cover  whole range  know secondary metabolite compound class polyketides nonribosomal peptides terpenes aminoglycosides aminocoumarins indolocarbazoles lantibiotics bacteriocins nucleosides betalactams butyrolactones siderophores melanins  others  align  identify regions   gene cluster level   nearest relatives   database contain   know gene cluster  integrate  crosslinks  previously available secondarymetabolite specific gene analysis methods  one interactive view antismash  available   
file  options input  input front end   antismash web server allow upload  sequence file   variety  type fasta gbk  embl file alternatively  genbankrefseq accession number   provide   use   web server  automatically obtain  associate file  genbank   user choose  use  fasta input file gene prediction  perform  glimmer3 —using  longorfs tool  construct  gene model base   input sequence —  glimmerhmm   eukaryotic input data  submit  start  antismash analysis run  user  select  gene cluster type    want  search  additionally   select    downstream analysis modules  include   users   work  proprietary data  standalone version   java graphical user interface  available    input options   web version finally expert users may choose  directly run  pythonbased pipeline program   command line  order  batch analyze  larger number  input detection  secondary metabolite biosynthesis gene cluster use  hmmer3 tool   amino acid sequence translations   proteinencoding genes  search  profile hide markov model phmms base  multiple sequence alignments  experimentally characterize signature proteins  protein domains proteins protein subtypes  protein domains    exclusively present   certain type  biosynthetic gene cluster use  exist phmms   new phmms  seed alignments  construct  library  model specific  type    iii  nrp terpene lantibiotic bacteriocin aminoglycosideaminocyclitol betalactam aminocoumarin indole butyrolactone ectoine siderophore phosphoglycolipid melanin  aminoglycoside biosynthesis signature genes additionally  construct  number  phmms specific  false positives    different type  fatty acid synthases  show homology  pkss  final detection stage operate  filter logic  negative  positive phmms   cutoffs  logic  base  knowledge   minimal core components   gene cluster type take   scientific literature  cutoffs  determine  manual study   phmm result  run   ncbi nonredundant  protein sequence database ftpftpncbinlmnihgovblastdb  technical detail   phmm library   detection rule  available  supplementary table    respectively gene cluster  define  locate cluster  signature gene phmm hit space within   mutual distance  include flank accessory genes gene cluster  extend         side   last signature gene phmm hit depend   gene cluster type detect   consequence   greedy methodology gene cluster   space  closely together may  merge  superclusters  gene cluster  indicate   output  hybrid cluster  may either represent  single gene cluster  produce  hybrid compound  combine two   chemical scaffold type   may represent two separate gene cluster   happen   space  closely together nrpspks domain architecture analysis nrpspks domain architectures  analyze figure  use another phmm library comprise exist model   well  newly construct model specific  nrpspks protein domains  functionalphylogenetic subgroups   domains supplementary table   external file  hold  picture illustration etc object name  gkr466f2jpg open   separate window figure  interactive xhtml visualization  result  number   banner represent  gene cluster   detect  type    show   leave    mouseover   gene cluster   select  gene cluster description tab  display  svg image   genes within  approximate gene cluster   detect signature genes display  red locus tag appear  mouseover   click  gene  small panel pop   annotation information  crosslinks   web service  pksnrps proteins  encode   gene cluster  domain annotations  give   pksnrps domain annotation tab  detail domain annotation information  crosslinks  provide  mouseover   predict core structure tab  prediction   core chemical structure  give  pks  nrps gene cluster base   predictions display    tabs contain  wide range  link  popups   detail  prediction information conserve motifs within key pks  nrps domains  also detect use  phmms describe earlier   clusean package    write   detail downloadable embl output pksnrps gene name  annotate accord   domains  domain subtypes   genes contain  hybrid nrpspks enediyne pks glycopeptide nrps transat pks etc substrate specificity stereochemistry  final structure predictions substrate specificity prediction  pks  nrps modules base   active sit   respective acyltransferase   adenylation  domains  perform  various available methods pks  domain specificities  predict use   amino acid signature sequence   active site   well   phmms base   method  minowa      also use  predict coenzyme  ligase domain specificities nrps  domain specificities  predict use   signature sequence method   supportvector machinesbased method  nrpspredictor2   use  method  minowa    finally  predictions  integrate   consensus prediction   majority vote ketoreductase domainbased stereochemistry predictions  pkss   perform  well  estimate   biosynthetic order  pksnrps modules  predict base  pks dock domain sequence residue match  type  modular pkss   assume colinearity   final predict core chemical structure  generate   smile string    unique text description   chemical structure  visualize   picture file figure   increase  reliability   core structure prediction monomers      consensus   predictions  represent  generic amino acids  ketides  unspecified rgroups secondary metabolite cluster  orthologous group  order  rapidly annotate  accessory genes surround  detect core signature genes   various type  secondary metabolite biosynthesis gene cluster  construct  database   gene cluster contain   latest ncbi  database  february     phmms describe   use  detect  secondary metabolite biosynthesis gene cluster signature genes    database  accession number   hit meet  describe cutoffs  extract  use  download  correspond genpept file   taxonomy identifier include bacteria  fungi  nucleotide source accession number  extract  correspond nucleotide genbank file   download  well  crosschecked  presence   query protein accession number   nucleotide genbank file gene cluster  detect  describe  amino acid sequence   genes contain within  gene cluster  write   fasta file  headers contain key information   summary   detect gene cluster nucleotide accession nucleotide description cluster number cluster type protein accession number  write   text file  construct  smcogs cluster   gene cluster proteins  perform use orthomcl   consensus annotations  manually assign base   frequencies   five  prevalent annotations   smcog  genbank   smcog  seed alignment  create   randomly pick sequence use muscle     phmm   smcog  generate base   conserve core   alignment supplementary figure  within  antismash software pipeline  smcog phmms  use  functional annotation   accessory genes within  gene cluster  assignment   smcog   gene—based   highestscoring phmm   sequence   certain evalue threshold— predict protein sequence  align   smcog seed alignment   rough neighborjoining phylogenetic tree  calculate use fasttree    visualize  treegraph   supplementary figure  clusterblast comparative gene cluster analysis secondary metabolite biosynthesis gene cluster  highly modular   genes  transfer frequently  one gene cluster  another  evolution  therefore  try  obtain  functional understand   gene cluster   highly beneficial   able  compare   part   gene cluster  show similarity     may   characterize experimentally  order  facilitate   apply  annotate database  gene cluster  link  protein sequence   parent gene cluster  create  comparison tool—based    recent blast implementation — rank gene cluster  similarity   query gene cluster cluster  sort first base   empirical similarity score                 number  query genes   significant hit    number  core query genes   significant hit    number  gene pair  conserve synteny    number  gene pair  conserve synteny involve  core gene     core gene bonus three point give   least one core gene   hit   subject cluster   similarity score  equal  hit  subsequently rank base   cumulative blastp bite score   gene cluster  feature enable  rapid assessment   comparative genomics   annotate cluster figure   external file  hold  picture illustration etc object name  gkr466f3jpg open   separate window figure  example  clusterblast alignment  gene cluster homologous   query gene cluster   case  ten best hit   calciumdependent antibiotic nrps gene cluster  streptomyces coelicolor   display homologous genes blast evalue    minimal sequence identity shortest blast alignment cover     sequence  give   color  select gene cluster alignment dropdown menu provide link  onebyone gene cluster alignments   gene cluster hit   onebyone gene cluster alignments pubmed andor pubchem link  provide  gene cluster associate   know compound genomewide blast  pfam analysis  prediction  potential unknown secondary metabolite biosynthesis gene cluster type  facilitate  thorough manual genome analysis antismash  also  link    wholegenome blast  pfam analysis modules   previously publish clusean framework   clusean result  integrate   embl output file furthermore  unknown biosynthetic gene cluster type  likely  exist  may  miss   antismash gene cluster detection module  pfam result  also use  predict genomic regions   high probability  constitute secondary metabolite biosynthesis gene cluster    generalize fashion   signature genes phmms method    genome sequence  convert   string  predict pfam domains   feed   hide markov model  cimermancic   manuscript  preparation  transition   gene cluster state   restofthegenome state  model  train  pfam domain frequencies   set   clone gene cluster gene cluster state    set  ~ genomes currently   jgi img database restofthegenome state  result   analysis  visualize   png graph output  visualization  pipeline analysis result  visualize   userfriendly interactive xhtml page figure     use  browse   different gene cluster  pks  nrps gene cluster  predict core chemical structure  show  image gene cluster map  draw  scalable vector graphics svgs   interactive onclick  mouseover function  add  javascript  provide annotation information pipeline result score  blast hyperlinks detect signature genes    gene cluster identification  base  show   distinct color clusterblast result  display   similar way  align gene cluster map   genes  mutual blast hit  give identical color additionally available   bottom right   page fully annotate embl output file provide  user   additional possibility  browse  genome   genome browser   artemis ",-0.19147039957586048,0.20154868351331984,0.06420373784588669,0.07931373912310079,0.0684138387815901,0.0048131545224042145,-0.07351793841073012,-0.004768680719092991,0.0006040951078665628,0.12198807536186004,0.0664402311525124,-0.07715343724163212,0.1632110817228869,-0.05124825869767958,0.1286476953558915,0.09735660759035702,0.07334377519246878,0.15914044523740695,0.011074189137837802,0.0827779696593028,-0.06837621706432033,-0.2532796299010168,0.06407674132826859,0.025139480353859097,-0.0377714318048778,-0.19385314862883601,0.13091528994866836,-0.04938871729920484,-0.049975820789396934,-0.020213393529949025,-0.006581601666821726,0.2620181671706017,-0.19276644136892304,-0.104002779382769,0.2547550342743286,0.06335728330056714,0.014662016529075431,-0.008358260641266553,-0.060010256820158175,-0.09279545311444147,-0.0331519948076465,-0.09850931111454893,-0.0910188231847148,-0.1222869441656356,-0.08825620886213005,0.030472533367524587,0.061401965787537476,-0.04898213680157831,-0.20390469513913756,-0.22270063875672336,0.1463828781101899,0.05065909672669528,0.03980227593581902,0.4425033401692912,0.011318382878310577,-0.9194422972654894,-0.021234797965052832,-0.19640364047995112,0.8647150978314496,0.1878802608319559,-0.15879403783126733,0.3652983317848503,0.0010555508471264457,0.047612486873855935,0.552304460402813,0.038105111623134916,0.03652342622681996,0.0069931920872596896,0.18604211217961994,-0.17307496000485342,-0.06743029170124577,-0.018962798387037183,0.1404344647693519,-0.15588262386133706,0.09437518334905344,-0.022427261984852502,-0.10294847724649916,-0.14601594187752684,-0.34325668930620296,-0.08952907905384541,0.13400792039209272,-0.04691700402245697,-0.36763121799270576,0.01210560808975587,-0.685057535634391,0.11425996654882835,0.2385675901560308,-0.12694760660678528,-0.13567523100919154,-0.022609318741322226,-0.15652781297770355,0.07833595746726155,-0.07677702175938816,-0.07001974798559474,-0.02730028142223753,-0.0683792843406881,-0.12799591029337468,-0.3388444712463283,0.3062124501903033,0.09100518761211793,Annotation,9
180,180,"csn unsupervised approach  infer biological network base   genome alone
 organisms cannot  cultivate   live  unique ecological condition  cannot  mimic   lab understand  functionality   organisms genes   interactions  perform largescale measurements  transcription level proteinprotein interactions  metabolism  extremely difficult    case impossible thus efficient algorithms  decipher genome functionality base    genomic sequence    experimental measurements  need   study  describe  novel algorithm  infer gene network   name common substring network csn  algorithm enable infer novel regulatory relations among genes base    genomic sequence   give organism  partial homologorthologbased functional annotation   specifically infer  functional annotation  genes  unknown homology  approach  base   assumption  relate genes  necessarily homologs tend  share subsequences  may  relate  common regulatory mechanisms similar functionality  encode proteins common evolutionary history    demonstrate  csns   base   cerevisiae   coli genomes  properties similar  traditional biological network infer  experiment highly express genes tend   higher degree nod   csn genes  similar protein functionality tend   closer   csn graph exhibit  powerlaw degree distribution also  show   csn   use  predict gene interactions  function  report result suggest  silent code inside  transcript  help  predict central feature  biological network  gene function  approach  help researchers  understand  genome  novel microorganisms analyze metagenomic data   help  decipher new gene functions
methods algorithm description  subsection give  indepth look   different step  generate  csn graph efficiently see fig   supplementary section run time  space complexity   give set  genomic sequence  algorithm first calculate  commonchimeraars score   pair  genomic sequence   summarize  score   matrix score matrix  matrix   transform   correlation matrix  base  correlations  row   score matrix  correlations matrix represent  undirected weight graph   edge weight correspond   score   correlation matrix   graph edge  low value relate  low similarity  remove  make sure   edge represent high similarity score  thus  meaningful ones next  greedily add  minimal number  edge   graph  connect components  make  graph connect finally  sequencebased graph  embed   twodimensional layout   display   sequence common substring network calculate normalize chimeraars score  unique sequence similarity measurement call chimera average repetitive substring chimeraars  give   significant impact  long substrings   share  pair  sequence   show   version   measure could  use  rank different regions  genes accord   expression level suggest   measure may capture regulatory signal  signal relate   genes functionality   encode  different part   genes  genes  similar functionality  similar protein expression  likely  share subsequences  thus    higher chimeraars score   study  chimeraars score  compute   pair  sequence  compare  target gene    reference gene   algorithm scan  target gene nucleotidebynucleotide     nontranslated region  codonbycodon     cod region   position  find  length    longest common substrings  start  position   also appear   reference gene  average length   substrings  calculate define   arss  next analysis repeat     target gene     reference  get arsr   final normalize chimeraars score   pair  genes   average   two ars score see example  fig   score  compute   pair  sequence   set  arrange  symmetric matrix  figurea algorithm implementation  calculate  normalize chimera ars score   give pair  sequence efficiently  create  different suffix array  data structure   sequence  specifically  every sequence   input set  algorithm create  unique     use  calculate  longest common substring   pair  sequence supplemental fig  one   consider  target     reference    position   target sequence  suffix   target   search use  binary search  longest match prefix   reference  combine chimeraars score  normalize ars score mention   compute separately   utrpromoter region   cds sequence  utrpromoter region include  nucleotides   nucleotides   start codon   cerevisiae   coli respectively  cds sequence include  first    nucleotides   cerevisiae   coli respectively   second sequence type  score  calculate base  codonsnucleotide triplets fig  however  result report   robust  change   length threshold supplemental section determine sequence range  fig   combine  two score  perform weight arithmetic mean   cod regions  weight five time higher     utrpromoter weight  reflect  relatively longer region   cod region   use aggregate ars scorers  utr_length * normalize ars scoresr_utr s_utr  cds_length * normalize ars scoresr_cds s_cds utr_length  cds_length  report result  robust  change   relative lengths   two segment see supplemental section csn base  cod  regulatory regions separately  supplemental fig s11  combine score  compute   pair  sequence   input set  arrange  symmetric matrix   score matrix  correlation matrix   next step   algorithm spearmans correlation   pair  row     aggregate chimeraars score matrix  compute  generate  correlationbased score matrix   mrx   rho  spearman_correlationx   algorithm compare row  represent  sequence score set note  compare columns would yield   result due  matrix symmetrically  use  measure   compare   pair  sequence   set  normalize chimeraars score relate  sequence    set  normalize chimeraars score relate  sequence   type  comparison include  information   use one normalize ars score relate     since  consider  relations instead   one   denote  number  input sequence  use spearmans rank correlations   case     expect  linear relationship  pair  analyze variables    expect  see monotonic relations see example  fig  step  figureb  correlations matrix   csn graph  matrix    represent   complete graph  edge represent similarity score among pair  genes however   graph  noisy   include edge   low weight thus  filter edge base   correspond correlation score  edge   minimal weight  specific correlation  include  report  result relate   threshold  rho   note   pvalue relate    edge  significant however  result  robust  change   threshold supplemental fig  figurec determine edge cutoff   cerevisiae  edge weight threshold    keep  graph sparse enough  visualize  properly   coli  minimum correlation score  set    achieve   edge density   cerevisiae csn supplemental fig s12f ensure graph connectivity  previous step may generate  disconnect graph  cannot  efficiently deal   network embed algorithm see next subsection thus   next step  transform  graph obtain   previous step   connect graph  add  minimum number  edge    include   initial graph  greedily choose   step  maximal additional edge weight  algorithm   modification   kruskal algorithm  connect graph components instead  nod figure network embed  visualization finally  visualize  graph    use cytoscape software   use  forcedirected layout algorithm   embed algorithm  set  node  edge locations     forcedirected layout algorithm set  graph topology  force equation  nod push   away  edge  nod pull  together  attraction  two nod  correlate   weight   edge    way nod  heavier weight   case higher similarity tend   physically closer   graph randomization  validation  estimate  importance  silent aspects   genes  csn performance  create  reference network  call ppcsn  maintain  amino acid sequence   gene   content   codon frequencies    exact nucleotide order randomization    follow   randomize  genes nontranslated sequence  promoters  introns  perform permutations   nucleotides   randomize  genes translate sequence  cds  keep  amino acid chain  genomic codon bias  rearrange  synonymous codons within   sequence fig     use   pipeline  csn   partlyshuffled sequence fig    make sure   number  edge  nod   csn  ppcsn  identical  add edge accord   weight  addition  ppcsn edge",-0.19437993045151236,0.1947867281616976,0.11132731409805516,0.17695780777465553,-0.0371359363195176,-0.03656710723166665,-0.12755116614419967,0.028906540747731926,-0.06849425754137338,0.1374487137986968,-0.00374562948414435,-0.03998534472441922,0.18921130786805104,-0.08252045488264413,0.1870078516791885,0.06086695496489605,-0.0017273380185166994,0.22068745112263907,0.030576945327455182,0.07274125465269511,-0.0016805075866480669,-0.2449767743833363,0.058454467653141676,-0.0108203375536638,0.0006737915240228176,-0.18402114614471796,0.10656528022342053,-0.13125707823286453,-0.02229663292760961,-0.0658648985796608,-0.021561318454953533,0.2615643165614456,-0.15585080092027784,-0.08219020098820329,0.2219110415451384,0.06559137243932732,0.0817797063079973,0.03739240016291539,-0.05640189112660785,-0.1088644166449085,-0.01745914507486547,-0.14331797399856927,-0.12170298987130325,-0.1141172547545284,-0.14600991105257224,0.02609839365755518,0.10978523557819428,-0.08380798668895538,-0.2314243204185429,-0.3239770984599988,0.18129194578621532,-0.021379571578154958,0.12249452607287095,0.5870740686456363,0.05336150560714305,-1.133078007123433,0.037675371223439766,-0.21418517200555653,0.957570815400686,0.2361192741311049,-0.20203540557002028,0.3400742461094633,-0.0644003541674465,0.014721939905236162,0.6186055435935657,0.09832181799729976,0.040512390646462636,-0.003414245625792925,0.2252464015128401,-0.20853299634329356,-0.09621547396458724,-0.0554284162769715,0.14703562054558034,-0.14531363282026724,0.1959391543349872,-0.05708364546174805,-0.11384901450326045,-0.21132691389756894,-0.3672618849811455,-0.0788980209302778,0.12119914038913945,-0.05272451176618536,-0.43693656111260254,-0.030411616992050163,-0.8727574839480221,0.13023972717641544,0.2433858542529245,-0.15547289115190505,-0.1663222898505628,-0.043026986835834884,-0.21241926864224173,0.10242254254842798,-0.15078452011321986,-0.10402541919859748,-0.09668165760456274,-0.12185893123969435,-0.10598451032318797,-0.3935112587362528,0.26539367737000186,0.1161501474203542,Annotation,9
181,181,"csn  cava variant annotation tool  rapid robust nextgeneration sequence analysis   clinical setting
nextgeneration sequence ngs offer unprecedented opportunities  expand clinical genomics  also present challenge  respect  integration  data   sequence methods  historical data provision  consistent clinically applicable variant annotation  ngs data  prove difficult particularly  indels  important variant class  clinical genomics annotation  relation   reference genome sequence  dna strand  cod transcripts  potential alternative variant representations    well address   present tool  address  challenge  provide rapid standardize clinically appropriate annotation  ngs data  line  exist clinical standards  develop  clinical sequence nomenclature csn  fix variant annotation consistent   principles   human genome variation society hgvs guidelines optimize  automate variant annotation  ngs data  deliver highthroughput csn annotation  create cava clinical annotation  variants  fast lightweight tool design  easy incorporation  ngs pipelines cava allow transcript specification appropriately accommodate  strand   gene transcript  flag variants  alternative annotations  facilitate clinical interpretation  comparison   datasets  evaluate cava  exome data   clinical brca1brca2 gene test pipeline cava generate csn call   variants   exac database   hours  annotate  icr1000 exome series   hours evaluation   different indels   single individual reveal    alternative representations  leave align  right align data annotation  leave align data  perform  many annotation tool would thus give clinically discrepant annotation      indels  genes transcribe   forward dna strand  contrast cava provide  correct clinical annotation   indels cava also flag   indels  alternative representations   different functional class  may profoundly influence clinical interpretation cava annotation   brca1brca2 gene mutations   clinical pipeline give   concordance  sanger data   brca2 mutations  correctly clinically annotate   tool cava   freely available tool  provide rapid robust highthroughput clinical annotation  ngs data use  standardize clinical sequence nomenclature
clinical sequence nomenclature  develop  standardize clinical sequence nomenclature csn  dna sequence variant annotation  aim  csn    provide  fix standardize system   every variant   single notation    identical   mutation detection methods   use  logical terminology understandable  nonexperts    provide  nomenclature  allow easy visual discrimination   major class  variant  clinical genomics  csn follow  principles   hgvs nomenclature   minor amendments  ensure compatibility  integration  historical clinical data whilst also allow highthroughput automate output  ngs platforms  csn  fully detail  additional file  clinical annotation  variants cava  provide csn annotation   robust  automate fashion  develop  tool call cava clinical annotation  variants   write  python cava  dna strandaware perform cod transcriptdependent alignment   indels  consistently report    ′ position   cod transcript  line   hgvs recommendation cava also classify variants base   impact   protein accord   simple ontology table  within  cava classification system  variant  assign   single class  ensure consistency  facilitate data utilization  comparison   datasets  sequence ontology  class  also give  cava  provide  impact flag  stratify variants  categories accord  predict severity  impact  protein function  three default class category   ess   category   nsy ss5      category     int 5pu 3pu table  cava variant classification system full size table default variant annotations output  cava include  csn call variant type substitution insertion deletion  complex hugo gene nomenclature committee hgnc symbols  affect genes ensembl transcript identifiers withintranscript locations   exonintron number  ′′ untranslated region utr  cava class   term  impact category   alternative  ′ annotation  appropriate  snp database  also  use  assign dbsnp identifiers   user  specify  set  ensembl transcripts use  variant annotation instead    addition   default whole exome canonical transcript set provide  installation cava support overlap ensembl transcripts   single variant call   annotate accord  multiple transcripts cava also provide various filter options include remove intergenic variant call  call  overlap   include transcripts   output call affect specific genes  genomic regions cava  lightweight   easily add  ngs pipelines   read variants  vcf file  output either  vcf  annotations append   original input   easily parsable tabseparated text file     write   standard output process speed    increase  parallelization   line   vcf file  process independently cava  fully detail  additional file  cava  freely available    download   cava webpage  cava exome data annotation  exome aggregation consortium exac   collaborative effort  reanalyze germline exome sequence data   unrelated individuals contribute   number  diseasespecific  population genetic study   vcf file contain  variants  version   download  annotate  cava use  single core inhouse exome sequence data  available   individuals obtain    birth cohort collection  icr1000  exome series   use  illumina truseq exome  sequence  perform   illumina hiseq2000 generate     read read  map  hg19 use stampy   duplicate read  flag  picard  variants  call  platypus  generate raw vcf file  icr1000  exome data  available   european genomephenome archive  annotation    vcf file  perform  cava  five independent job  job utilize     available core  process file  batch    parallel  one core per file four job process  file    fifth process  remain  file cava indel annotation  evaluate cava indel annotation   typical clinical scenario  use  raw vcf data   single individual   icr1000 series  exclude intergenic variants     affect intronic  utr sequence cava class int 3pu  5pu cava clinical sequence data analysis  use data   clinical gene test laboratory tglclinical    individuals  brca1 mutations   individuals  brca2 mutations  mutations   identify  ngs use  illumina trusight cancer panel tscp    mutation   verify  sanger sequence   sanger data  use  generate  clinical report ngs analysis  tscp use stampy  alignment   platypus  variant call   default vcf file output  platypus  use  input  cava  vep  annovar v2014jul14  snpeff      recent versions available  november    analysis  perform",-0.1537785795588906,0.20680800397199794,0.0863668802086837,0.12620066064230812,0.0520700194249646,-0.031716419673488976,-0.051211170555772983,0.011336296514894529,-0.004526103044358585,0.15061554069702446,-0.02336567949073819,-0.05887313013932166,0.13601588275408946,-0.09656861064561573,0.13496668988982072,0.05324048715858505,0.1127429806913894,0.1629084876214172,-0.025932127468001383,0.0705350888792712,-0.12150153868186933,-0.2544777982773331,0.07022887735985793,-0.010336560806116231,-0.05319308171765162,-0.21803760793203344,0.08938812671748635,-0.10897333413935624,-0.08863410814450337,-0.0016114713570389609,0.012626232328609778,0.2811683239071863,-0.20851025847503196,-0.09311940863155402,0.21141079630425128,0.06441606505988882,0.04283491544604588,-0.0090980301806345,-0.15880189162034256,-0.07532932435950407,-0.08625122166883488,-0.12484840686038995,-0.09384802904266576,-0.07298666638572915,-0.1436586719722702,-0.00927774110235847,0.09270684264456996,-0.13123702712108545,-0.2678629594249651,-0.3048973120910187,0.1833684739203622,0.09509260642904198,0.030821219578098788,0.4914481036479657,-0.0027582917820948823,-1.00903596271116,0.09158396336035086,-0.21784185625469452,0.9427338634122414,0.18293213003476225,-0.15844243825816262,0.3179892074692851,0.0009805584325938699,0.045597045902126966,0.6003712037019432,0.010065887053855336,-0.059440778781068876,0.03125397328788845,0.2241152872198906,-0.19629537764256105,-0.04535548006336634,0.026731324597852883,0.14931243674113198,-0.15131916923161884,0.19683141531637652,-0.033015062639919615,-0.1238761292763341,-0.1105479703635837,-0.3736975406812361,-0.16072176158284912,0.1549956410649331,-0.09556116730735924,-0.2943079594307794,0.02302845519107695,-0.8691968522303236,0.13755411935808998,0.23961676894436376,-0.14534214411611454,-0.13599404961999076,-0.0005679365469572637,-0.14806931538650622,0.08924290485859204,-0.1335681569375671,-0.09475476222256056,-0.019775489221971768,-0.037375509885963616,-0.1138713769021874,-0.3618132895589448,0.2900452662479634,0.07940699455185005,Annotation,9
182,182,"variantdb  flexible annotation  filter portal  next generation sequence data
interpretation   multitude  variants obtain  next generation sequence ngs  labor intensive  complex webbased interfaces   galaxy streamline  generation  variant list  lack flexibility   downstream annotation  filter   necessary  identify causative variants  medical genomics   end  build variantdb  webbased interactive annotation  filter platform  automatically annotate variants  allele frequencies functional impact pathogenicity predictions  pathway information variantdb allow filter   annotations  dominant recessive   novo inheritance models
interface  database variantdb consist   php  base web interface drive  cgi  backend  data  store   mysql  database  solid state drive figure  structurally data  order  sample  variant specific table additional file  one additional table link variants  sample  hold quality information  gatk variant annotations  store  separate table base   annotation source  structure optionally allow variantdb  retrieve annotation  filter data  multiple source  parallel use  perl parallelforkmanager library  improvements  performance   achieve  enable memcached  perl cachememcachedfast library  reduce database load  cache  preloading frequently use data  memory query source  documentation   filter  annotations  store  xml file additional filter rule   specify  separate nod   configuration file figure  figure1 schematic representation  variantdb implementation depend   expect platform load server elements   host either   single machine default   separate physical host  high performance compute hpc infrastructure  available annotation process   distribute hpo human phenotype ontology full size image  public variantdb instance  available  academic use furthermore local installation  support  either  downloadable virtualbox application  full installation  local infrastructure instructions   approach  available   online documentation  keep local installations   date automatic update   web interface  possible   local administrator data import vcf file   import   ftp server accessible use variantdb user credentials  directly   galaxy server use  variantdb tool additional file   installation see  import vcf file  comply   vcf4 standards quality annotations generate   gatkbased genotypers   extract  store variantdb provide  option  store  import vcf file  associate bam file  available direct link  present  load vcf  bam file  integrative genomics viewer igv  visualization  filter result  annotation data annotation within variantdb  available  sample  variant level  regard  sample annotation family  experimental relations   provide   later  apply  formulate inheritance pattern  variant filter second gender  phenotype information base   human phenotype ontology   available finally sample   label  control  allow exclusion  common variants  filter variant annotation  trigger  import vcf file annotation proceed  collect variants miss  respective annotation annotate  list  variants  store  result   database  annotationspecific table   database structure allow  process   parallelize   high performance compute infrastructure  available variantdb   configure  distribute  process use  perl scheduledrmaac module   total  annotations  add   variant table  take  eight source  annotation engine utilize annovar snpeff  perl wwwmechanize library  web tool   set  inhouse parsers  retrieve  annotations   annotations  present  checkboxes  variantdb  inclusion   result figure  users  also define set  annotations    load simultaneously table  summary  annotations available  variantdb full size table figure  figure2 selection  annotations top leave sample selection box use either  dropdown menu  autocompletion top right  raw data file  available hyperlinks  present  download vcfbam file  load  file  igv bottom leave  available annotations  list users  select annotations use checkboxes  inclusion   filter result bottom right previously save set  annotations   enable    select  checkbox  press `add annotations full size image gatk genotyping modules provide  set  quality parameters   identify variant variantdb store  value   allelic ratio phred score   polymorphism qual phredbased genotype quality  genotype  allelic depths  quality  depth  map quality  strand bias   rank sum baseqranksum mqranksum readposranksum  available filter entries    vqsr tranches filter  also store minor allele frequencies mafs  available    genomes project v2012apr   exome sequence project vesp54002012jul11 vesp65002013jan22  global  population specific  second dbsnp rsids mafs  population size value  available  versions      start  version   clinical association label  also extract transcript information  extract  ucsc refseq  ensemblbased format available information include gene symbol   transcript   case  multiple variants affect position  cdna  protein level   effect   protein level intronexon missensesynonymousnonsense splice predictions  regard  pathogenicity  include  several tool use annovar dbsnfp annotations  lrt mutationtaster phylop polyphen2  sift  include  gerp   cadd  score  add   respective tool data uptodate score  provean sift grantham  mutationtaster  retrieve use  respective web tool  finally  snpeff annotations also provide  estimate   variant impact   protein function  two source  provide  functional annotation first gene ontology term   first level parental term associate  affect genes  provide  second  summary   information available  clinvar  available   summary include hyperlinks   clinvar entry  variants  exactly match  overlap  variant   query sample  type  variant  clinvar snpindel  affect gene  transcript latest update evidence type pathogenicity classification  associate disease  gene disease  alleles list  clinvar hyperlinks  provide  several external databases finally users  specify additional information  inheritance experimental validation  diagnostic classification   per variant level annotation update variantdb provide two functionality layer  automatically keep annotation source   date first use schedule execution   frequency specify   system administrator thirdparty resources  check  update release  new data  available  variants  reannotated use  new release  maintain data traceability  discard annotations  archive   change  variant annotation  log finally users  inform  email  possibly relevant novel annotations second variantdb automate  conversion  genome build   web interface upon conversion  platform administrator need information   new build include annovar snpeff  igv genome versions hg19 grc37  hg19 respectively   current variantdb version availability   request build  check   available  annotation table  download genome coordinate  currently store variants  convert use  ucsc liftover tool  fail conversions  present   platform administrator  manual curation  finally  variants  reannotated  regard   new coordinate  users  inform previous genome versions remain accessible   final annotations  readonly mode  current genome build  always state   user interface also  import data  external pipelines   galaxy variantdb require  source genome build version   pass along   variant file   generate  error message  conflict versions variant filter variantdb allow filter   combination     available annotations list  table   set filter users select  criteria  dropdown menus figure   optionally group    multilevel decision scheme figure  successful filter settings   save  future usage next   functional filter criteria parental  sibling relationships enable filter   novo dominant  recessive inheritance model populationbased variant selection   perform  two level first users  select variants   present  least      specify number  time   selection  sample second genes   select  mutation burden  specify  minimal  maximal number  sample contain  mutation    gene figure  figure3 selection  filter leave filter criteria  organize  highlevel categories filter  add  select  relevant filter  settings  dropdown menus numeric  example quality control value  textual  example gene symbol criteria   add  text field  appropriate right previously save filter scheme   enable    select  checkbox  press `apply filter full size image figure  figure4 graphical representation   select filter scheme individual filter   group use logic andor rule group  order  handle use  draganddrop interface full size image next  general gene  population level information users  create  silico gene panel  target evaluation  candidate genes  gene panel exist   set  refseq identifiers optionally augment  additional comment gene panel  private   user level    make available   public resource   users visualisation  default result  present   tabular overview figure   select annotations  igv hyperlinks  variantdb aim  present  information relate   variant   compact single screen view alternatively  classic wide table format  available present  annotations   single line per variant additional file  result  also  export  csv file  downstream analysis finally various chart  available  review  quality  characteristics   result variant set  chart include among others  trtv ratio know versus novel ratio maf distribution  snp versus indel ratio figure  figure5 result table     result variants select annotations  present  top genomic position   also  hyperlink   position  igv   essential variant information  provide  relevant annotations  group  subtables  affect feature userspecified information relate  validation  classification  present   separate box   lefthand side",-0.17820668078076882,0.16730356789066275,0.116222304382529,0.05311604342740445,0.07907672356970312,0.00511208612061171,-0.08968665777368971,0.015377696560945637,0.03206075802426482,0.1290299085279306,0.04798524961068591,-0.08114894234591423,0.14589344709083815,-0.09791067188247904,0.14504310716223168,0.04039836173136037,0.11638491784691635,0.15876595800559365,-0.011675939023990669,0.0917159977205272,-0.13790623737381755,-0.26362211103844496,0.09238813211478868,0.02577103924704716,-0.008274396093528173,-0.2169448451291177,0.1231994873066092,-0.07904708654973731,-0.09496798817896733,-0.02363674381839649,0.022174368719773827,0.31336767966073475,-0.1884782056904885,-0.0430808612138385,0.22509262809224428,0.0885657084971142,-0.005885431614687394,0.02556444235558705,-0.1031605880873134,-0.12251108493707975,-0.06718009170494989,-0.13780641735064544,-0.07271600859258627,-0.06379823378340257,-0.10803441558249967,-0.004391994721746465,0.053341918355194716,-0.15060067032175176,-0.1686286190747117,-0.27336050724782,0.16313404815632454,0.06612729054792382,-0.005755655299867428,0.4919098863416973,0.07212355680329767,-1.046202282252347,0.052437184897996286,-0.2169581857697785,0.9746567869627076,0.17848696034887665,-0.1261223234728166,0.23962856882124145,-0.04426590739021185,0.06278062781170664,0.5626956478032904,-0.0008666918582729692,-0.029860996096527464,0.009594957007027735,0.210267200939309,-0.1731942883376562,-0.056854165930535674,-0.007309761559044113,0.16311729966578353,-0.17094226451912456,0.15424170227422251,-0.005043025816387565,-0.11377990297590786,-0.08440484401057248,-0.3490251126510803,-0.14056926609534673,0.17641735078411247,-0.08062112906676096,-0.2900628629930855,-0.009499097472587714,-0.7874865443918975,0.1432544540342254,0.2255267854382443,-0.15142175176761086,-0.09381949356511024,-0.03960265845775049,-0.14126069416486986,0.1471848847974864,-0.06517049622020639,-0.044015977389346685,0.0005142056573432212,-0.055029391600017824,-0.04865018077638583,-0.3131424110128196,0.3834991442635646,0.08894525703782882,Annotation,9
183,183,"mgrast  metagenomics service  analysis  microbial community structure  function
approaches  molecular biology particularly   deal  highthroughput sequence  entire microbial communities  field  metagenomics  rapidly advance  understand   composition  functional content  microbial communities involve  climate change environmental pollution human health biotechnology etc metagenomics provide researchers    complete picture   taxonomic   organisms    functional     organisms  composition  natively sample microbial communities make  possible  perform investigations  include organisms   previously intractable  laboratorycontrolled culture currently  constitute  vast majority   microbes   planet  organisms contain  environmental sample  sequence   cultureindependent manner  often   ribosomal amplicon methods  investigate  taxonomic  wholegenome shotgunbased methods  investigate  functional content  sample communities metagenomics allow researchers  characterize  community composition  functional content  microbial communities   cannot show  functional process  active however near parallel developments  transcriptomics promise  dramatic increase   knowledge   area  well since  mgrast meyer   bmc bioinformatics    serve   public resource  annotation  analysis  metagenomic sequence data provide  repository  currently house    data set contain  terabasepairs     publically available mgrast   metagenomics rast rapid annotation use subsystems technology server make  possible  users  upload raw metagenomic sequence data  preferably fastq  fasta format assessments  sequence quality annotation  respect  multiple reference databases  perform automatically  minimal input   user see subheading    end   chapter   detail postannotation analysis  visualization  also possible directly   web interface   tool like matr metagenomic analysis tool   cover later   chapter  utilize  mgrast api   easily download data   stage   mgrast process pipeline   years mgrast  undergo substantial revisions  keep pace   dramatic growth   number size  type  sequence data  accompany constantly evolve developments  metagenomics  relate omic sciences  metatranscriptomics
 pipeline diverge  upload   ribosomal amplicon  wholegenome shotgun wgs sample  wgs pipeline  compose  several step   removal  lowquality read dereplication gene call  annotation  creation  functional abundance profile rrna sample run  rna detection cluster  identification   production  taxonomic abundance profile subheading  find   end   chapter include additional detail   wgs pipeline  preprocessing  upload data  preprocessed  use solexaqa   trim lowquality regions  fastq data platformspecific approach  use   data submit  fasta format read   two standard deviations away   mean read length  discard   sequence submit   system  available  discard read   analyze   dereplication   shotgun metagenome  shotgun metatranscriptome data set  perform  dereplication step  use  simple kmer approach  rapidly identify   character prefix identical sequence  step  require  order  remove artificial duplicate read adrs  instead  simply discard  adrs  set  aside  use  later   mean  assess sample quality  note  dereplication   suitable  amplicon data set   likely  share common prefix  drisee  mgrast  use drisee duplicate read infer sequence error estimation   analyze  set  adrs  determine  degree  variation among prefixidentical sequence derive    template see   detail  screen   pipeline provide  option  remove read   nearexact match   genomes   handful  model organisms include fly mouse cow  human  screen stage use bowtie   fast memoryefficient short read aligner   read    match  model organisms pass   next stage   annotation pipeline note   option  remove  read similar   human genome  render  inaccessible  decision  make  order  avoid store  human dna  mgrast  gene call   previous version  mgrast use nucleotidebased similarity  annotation  wgs data  approach   significantly  expensive computationally   novo gene prediction follow  protein similaritybased annotation   indepth investigation  tool performance    move   machine learn approach  utilize fraggenescan   predict proteinsprotein fragment   novo sequence data fraggenescan use  well test algorithm   perform  silico translation  predict protein cod nucleic acid sequence utilize  approach   predict cod regions  dna sequence    base pair  longer  novel approach also enable  analysis  userprovided assemble contigs  note  fraggenescan  train  prokaryotes     identify proteins  eukaryotic sequence  result   view critically   cluster mgrast build cluster  proteins     identity level use  uclust  implementation  qiime  preserve  relative abundances  cluster greatly reduce  computational burden  compare  pair  short read  cluster    identity preserve sufficient biological signal  protein identification   create  representative  longest sequence   cluster  subject  similarity analysis functional identification  representative sequence   use blast instead  use  much  efficient algorithm sblat  implementation   blat algorithm   parallelize use openmpi  reconstruct  putative species composition  wgs data  look   phylogenetic origin   database sequence hit   proteinbased similarity search note  process  rrna  amplicon data  cover  subheading    annotation map  sequence similarity search  compute   protein database derive   m5nr  provide nonredundant integration  many databases users  easily change view without recomputation  example cog  kegg view   display   show  relative abundances  histidine biosynthesis   data set  four cow rumen metagenomes help  interpret result mgrast search  nonredundant m5nr  m5rna databases    sequence  unique  two databases  build  multiple sequence database source   individual sequence may occur multiple time  different strain  species  sometimes genera    identity   circumstances choose  “right” taxonomic information    straightforward process  optimally serve  number  different use case   implement three methods  end users  determine  number  hit occurrences   input sequence   database   sample best hit  best hit classification report  functional  taxonomic annotation   best hit   m5nr   feature   case   similarity search yield multiple samescoring hit   feature    choose  single “correct” label   reason mgrast double count  annotations  identical match properties  leave determination  truth   users   approach aim  inform   functional  taxonomic potential   microbial community  preserve  information subsequent analysis   bias   single feature may  multiple annotations lead  inflate hit count  users look   specific species  function   result  best hit classification  likely   want representative hit  representative hit classification select  single unambiguous annotation   feature  annotation  base   first hit   homology search   first annotation   hit   database  approach make count additive across functional  taxonomic level   better suit  comparisons  functional  taxonomic profile  multiple metagenomes lowest common ancestor lca   avoid  problem  multiple taxonomic annotations   single feature mgrast provide taxonomic annotations base   widely use lca method introduce  megan    method  hit  collect    bite score close   bite score   best hit  taxonomic annotation   feature   determine  compute  lca   species   set  replace  taxonomic annotations  ambiguous hit   single higherlevel annotation   ncbi taxonomy tree  abundance profile abundance profile essentially table  indicate detect taxa  function   relative abundance  determine   methods describe  subheading  step —examples   find   mgrast user manual see  “additional documentation”  subheading  find   end   chapter   primary data product   mgrasts user interface use  display information  annotate data set use  abundance profile  mgrast system defer   user  select several parameters   define  abundance data evalue percent identity  minimal alignment length     possible  arbitrarily select thresholds suitable   use case users  select   thresholds     value taxonomic profile use  ncbi taxonomy  taxonomic information  project   ncbi taxonomy functional profile  available  data source  provide hierarchical information  currently include seed subsystems kegg orthologs  cog seed subsystems represent  independent reannotation effort utilize  rast   mgrast manual curation  subsystems make   extremely valuable data source  current subsystems hierarchy   view    allow browse  subsystems subsystems represent  fourlevel hierarchy  subsystem level —highest level  subsystem level —intermediate level  subsystem level —similar   kegg pathway  subsystem level —actual functional assignment   feature  question kegg orthologs mgrast use  kegg enzyme number  implement  fourlevel hierarchy  note  kegg data   longer available  free download therefore  rely   latest freely downloadable version   data  kegg level —first digit    number ecx***  kegg level —first two digits    number ecxy**  kegg level —first three digits    number ecxyz*  kegg level —entire four digits    number  highlevel kegg categories   follow  cellular process  environmental information process  genetic information process  human diseases  metabolism  organizational systems cog  eggnog categories  highlevel cog  eggnog categories   follow  cellular process  information storage  process  metabolism  poorly characterize   rrna pipeline  rrna pipeline start  upload  rrna read  proceed   follow step  rrna detection  read  identify  rrna   simple rrna detection  initial blat search   reduce rna database efficiently identify rna  reduce database     identity cluster version   silva database   use merely  differentiate sample contain solely rrna data   sample  wgs  transcriptomic sample  rrna cluster   rrnasimilar read  cluster    identity   longest sequence  pick   cluster representative  rrna identification   nucleotide blat similarity search   longest cluster representative  perform   m5rna database integrate silva  greengenes   rdp   use  mgrast user interface  mgrast system provide  rich web user interface  cover  aspects  metagenome analysis  data upload  ordination analysis  annotation abundances  web interface  also  use  data discovery metagenomic data set   easily select individually    basis  filter   technology include read length quality sample type  keyword  dynamic filter  result base  similarity  know reference proteins  taxonomy  example  user may want  perform  search   “phylum  actinobacteria  function  kegg pathway lysine biosynthesis  sample  ocean”  extract set  read match  appropriate function  taxa across metagenomes  result   display  familiar format include bar chart tree  incorporate abundance information heatmaps principal component analyse  raw abundance table export  tabular form  raw  process data   recover via download page    matr package   see subheading   metabolic reconstructions base  map  kegg pathways  also provide sample selection  crucial  understand largescale pattern  multiple metagenomes  compare accordingly mgrast support mix  mimarks   well  domainspecific plugins  specialize environments  extend  minimal gsc standards several project include terragenome hmp tara  emp use  gsc standards enable standardize query  integrate new sample   massive data set one key aspect   mgrast approach   creation  smart data products enable  user   time  analysis  determine  best parameters   example  comparison  sample    without  need  recomputation  result  navigation  mgrast website  rich  functionality  offer several options  site    five main page   home page show  blue  fig  open image  new windowfig  fig  sitemap   mgrast version  website   site map  main page  show  blue management page  orange  green box represent page    directly accessible   home page download page—lists  publicly available data  download  data  structure  project browse page—allows interactive browse   data set   power  metadata search page—allows identifier taxonomy  functiondriven search   public data analysis page—enables indepth analyse  comparisons  data set upload page—allows users  provide  sample  metadata  mgrast home metagene overview page—provides  overview   individual data set  upload page data  metadata   upload   form  spreadsheets along   sequence data  use   ftp   http protocols  web uploader  automatically split large file  also allow parallel upload mgrast support data set   augment  rich metadata use  standards  technology develop   gsc  user   temporary storage location inside  mgrast system  inbox provide temporary storage  data  metadata   submit   system use  inbox users  extract compress file convert  number  vendorspecific format  mgrast submissioncompliant format  obtain  md5 checksum  verify  transmission  mgrast   alter  data  web uploader   optimize  large data set    gigabasepairs often result  file size  excess     browse page metadataenabled data discovery  browse page list  data set visible   user  users  data set  well   public data   data share   users  page also provide  overview   nonpublic data set submit   user  share  users  interactive metagenome browse table provide  interactive graphical mean  discover data base  technical data  sequence type  data set size  metadata  location  biome  project page  project page provide  list  data set  metadata   project  table   bottom   project page provide access   individual metagenomes  click   identifiers   first column  addition  final column provide download  metadata submit data   analysis result via  three label arrows   data set owners  project page provide  edit capability use  number  menu entries   top   page figure  show  available options open image  new windowfig  fig  project page provide  summary   data   project   interface  download share project—make  data   project available  third party via send  access tokens add jobs—add additional data set   project edit project data—edit  content   page upload info—upload information   display   page upload metadata—upload  metadata spreadsheet   project export metadata2—export  metadata spreadsheet   project  overview page mgrast automatically create  individual summary page   data set  metagenome overview page provide  summary   annotations   single data set  page  make available   automate pipeline   computation  finish  page   good start point  look   particular data set  provide information regard technical detail  biological content  page  intend   single point  reference  metadata quality  data  also provide  initial overview   analysis result  individual data set  default parameters  analyse  available   analysis page  technical detail  sequence  analysis  overview page provide  mgrast    data set  unique identifier   usable   accession number  publications additional information    name   submit  organization   userprovided metagenome name  display   top   page  static url  link   system    stable across change   mgrast web interface  provide  additional information fig  mgrast provide  automatically generate paragraph  text describe  submit data   result compute   pipeline  mean   project information  display additional information provide   data submitters   time  submission  later one   key diagram  mgrast   sequence breakdown pie chart fig  classify  submit sequence submit  several categories accord   annotation status  detail   description   mgrast  pipeline   feature annotate  mgrast  protein cod genes  ribosomal proteins open image  new windowfig  fig  sequence   pipeline  classify  one  five categories grey  failed   red  unknown sequence yellow  unknown function  protein cod green  protein cod  know function  blue  ribosomal rna   example     sequence  either filter    fail   recognize  either protein cod  ribosomal note   performance reason   sequence feature  annotate   default pipeline  feature type   small rnas  regulatory motifs  crisprs     require significantly higher computational resources  also  frequently  support   unassembled short read  constitute  vast majority  todays metagenomic data  mgrast  quality   sequence data come  nextgeneration instrument require careful design  experiment lest  sensitivity   methods  greater   signaltonoise ratio  data support  overview page also provide metadata   data set   extent   information   make available metadata enable  researchers  discover data set  compare annotations mgrast require standard metadata  data share  data publication   implement use  standards develop   genomics standards consortium  metadata store   specific data set  available  mgrast  merely display  standardize subset   table  link   bottom   table “ metadata” provide access   table   complete metadata  enable users  provide extend metadata go beyond  gsc minimal standards  mechanism  provide community consensus extensions   minimal checklists   environmental package  explicitly encourage   require  use mgrast  metagenome quality control  analysis flowchart  analysis statistics provide  overview   number  sequence   stage   pipeline  text block next   analysis flowchart present  number next   definitions  source hit distribution  source hit distribution show  percentage   predict protein feature annotate  similarity   protein  know function per source database  addition ribosomal rna genes  map   rrna databases  addition  display  print  number  record   m5nr protein database    m5rna ribosomal databases   statistics mgrast also provide  quick link   statistics  example  analysis statistics  analysis flowchart provide sequence statistics   main step   pipeline  raw data  annotation describe  transformation   data  step sequence length   histograms display  distribution    quality control step metadata  present   searchable table  contain contextual metadata describe sample location acquisition library construction  sequence use gsc compliant metadata  metadata   download   table  biological part   overview page  taxonomic hit distribution display divide taxonomic units   series  pie chart    annotations group  various taxonomic rank domain phylum class order family genus  subsets  selectable  downstream analysis  also enable download  subsets  read  example  hit  specific taxonomic unit  rank abundance  rank abundance plot provide  rankordered list  taxonomic units   userdefined taxonomic level order   abundance   annotations  rarefaction  rarefaction curve  annotate species richness   plot see fig    total number  distinct species annotations   function   number  sequence sample  slope   righthand part   curve  relate   fraction  sample species   rare   leave  steep slope indicate   large fraction   species diversity remain   discover   curve become flatter   right  reasonable number  individuals  sample  intensive sample  likely  yield   additional species sample curve generally rise quickly  first   level  toward  asymptote  fewer new species  find per unit  individuals collect open image  new windowfig  fig  rarefaction plot show  curve  annotate species richness   number  unique species  curve   plot   total number  distinct species annotations   function   number  sequence sample  rarefaction curve  derive   protein taxonomic annotations   subject  problems stem  technical artifacts  artifacts   similar   ones affect amplicon sequence    process  infer species  protein similarities may introduce additional uncertainty  alpha diversity   section  display  estimate   alpha diversity base   taxonomic annotations   predict proteins  alpha diversity  present  context   metagenomes    project see fig  open image  new windowfig  fig  alpha diversity plot show  range  diversity value   project  data set belong   min max  mean value  show   standard deviation range  different shade  alphadiversity   metagenome  show  red  specieslevel annotations     annotation source databases use  mgrast  alpha diversity estimate   single number  summarize  distribution  specieslevel annotations   data set  shannon diversity index   abundanceweighted average   logarithm   relative abundances  annotate species  compute  species richness   antilog   shannon diversity  functional categories  section contain four pie chart provide  breakdown   functional categories  kegg cog seed subsystems  eggnogs click   individual pie chart slice  save  respective sequence   workbench  relative abundance  sequence per functional category   download   spreadsheet  users  browse  functional breakdowns   detail functional analysis allow  user  manipulate parameters  sequence similarity match  available   analysis page  analysis page  mgrast annotation pipeline produce  set  annotations   sample  annotations   interpret  functional  taxonomic abundance profile  analysis page   use  view  profile   single metagenome   compare profile  multiple metagenomes use various visualizations  heatmap  statistics  pcoa normalization  page  divide  three part follow  typical workflow fig  open image  new windowfig  fig  threestep process  use  analysis page  select  profile  hit see text type  select  list  metagenomes  set annotation source  similarity parameters  choose  comparison  data type selection   mgrast analysis scheme   selection   particular taxonomic  functional abundance profile map  taxonomic annotations since    always  unique map  hit  annotation  provide three interpretations best hit representative hit  lowest common ancestor  choose  lca annotations   downstream tool  available  reason   fact    lca annotations   sequence   annotate    level classifications  return  different taxonomic level functional annotations   group  mappings  functional hierarchies    display without  hierarchy  addition  recruitment plot display  recruitment  protein sequence   reference genome  select data type  data selections  data visualizations specific    data selection selection  sample  parameters  dialog allow  selection  multiple metagenomes    compare individually  select  compare  group comparison  always relative   annotation source evalue  percent identity cutoffs selectable   section  addition   metagenomes available  mgrast set  sequence previously save   workbench   select  visualization  data visualization data visualization  comparison depend   select profile type  profile   metagenomes   visualize  compare  use barcharts tree spreadsheetlike table heatmaps pcoa rarefaction plot circular recruitment plot  kegg map  data selection dialog provide access  data set  four ways  four categories   select   pulldown menu private data—list  private  share data set  browse  available metagenomes collections—defined set  metagenomes group  easier analysis    recommend way  work   analysis page projects—global group  data set group   submit user  project name   display public data—display   public data set  use collections  project data  also  group  one set per collection  project  subsequently compare  add  normalization normalization refer   transformation  attempt  reshape  underlie distribution  large number  biological variables exhibit  lognormal distribution mean    data  transform   log transformation  value exhibit  normal distribution log transformation   count data make  normalize data product    likely  satisfy  assumptions  additional downstream test   anova  ttests standardization   transformation apply   distribution   group  distributions    distributions exhibit   mean    standard deviation  remove  aspects  intersample variability   make data  comparable  sort  procedure  analogous  commonly practice scale procedures    robust    control   scale  location  rarefaction  rarefaction view  available   taxonomic data  rarefaction curve  annotate species richness   plot see fig    total number  distinct species annotations   function   number  sequence sample  show   figure multiple data set   include open image  new windowfig  fig  rarefaction plot show  curve  annotate species richness  curve   plot   total number  distinct species annotations   function   number  sequence sample  slope   righthand part   curve  relate   fraction  sample species   rare   rarefaction curve  flat  intensive sample  likely  yield    additional species  rarefaction curve  derive   protein taxonomic annotations   subject  problems stem  technical artifacts  artifacts   similar   ones affect amplicon sequence    process  infer species  protein similarities may introduce additional uncertainty   analysis page  rarefaction plot serve   mean  compare species richness  sample   way independent   sample depth   leave  steep slope indicate   large fraction   species diversity remain   discover   curve become flatter   right  reasonable number  individuals  sample  intensive sample  likely  yield    additional species sample curve generally rise  quickly  first   level  toward  asymptote  fewer new species  find per unit  individuals collect  rarefaction curve  calculate   table  species abundance  curve represent  average number  different species annotations  subsamples   complete data set  heatmapdendrogram  heatmapdendrogram allow  enormous amount  information   present   visual form   amenable  human interpretation dendrograms  tree  indicate similarities  annotation vectors  mgrast heatmapdendrogram  two dendrograms one indicate  similaritydissimilarity among metagenomic sample xaxis dendrogram  another indicate  similaritydissimilarity among annotation categories  functional roles  yaxis dendrogram  distance metric  evaluate  every possible pair  sample abundance profile  cluster algorithm  wardbased cluster  produce  dendrogram tree  square   heatmap dendrogram represent  abundance level   single category   single sample  value use  generate  heatmapdendrogram figure   download   table  click   download button  ordination mgrast use principle coordinate analysis pcoa  reduce  dimensionality  comparisons  multiple sample  consider functional  taxonomic annotations dimensionality reduction   process  allow  complex variation find   large data set   abundance value  thousands  functional roles  annotate species across dozens  metagenomic sample   reduce   much smaller number  variables    visualize  simple two  threedimensional scatter plot  plot enable interpretation   multidimensional data   humanfriendly presentation sample  exhibit similar abundance profile taxonomic  functional group together whereas   differ  find farther apart  key feature  pcoabased analyse   users  compare components        metadata record variables  sample  biome dna extraction protocol  reveal correlations  extract variation  metadatadefined characteristics   sample   also possible  couple pcoa  higherresolution statistical methods  order  identify individual sample feature taxa  function  drive correlations observe  pcoa visualizations  couple   accomplish  permutationbased statistics apply directly   data  calculation  distance measure use  produce pcoas alternatively one  apply conventional statistical approach  anova  kruskalwallis test  group observe  pcoabased visualizations  bar chart  bar chart visualization option   analysis page   builtin ability  drill   click   specific category   expand  categories  show  normalize abundance adjust  sample size  various level  abundance information display   download   local spreadsheet   subselection   make   domain bacteria select data   send   workbench  detail analysis  addition read   specific level   add   workbench  tree diagram  tree diagram allow comparison  data set   hierarchy  subsystems   ncbi taxonomy  hierarchy  display   root tree   abundance normalize  data set size  raw   data set   various categories  display   bar chart   category  click   category inside  circle detail information   request   node  table  table tool create  spreadsheetbased abundance table    search  restrict   user table   generate  userselected level  phylogenetic  functional resolution table data   visualize  use krona     export  biom  format   use   tool  qiime  table also   export  tabseparated text abundance table serve   basis   comparative analysis tool  mgrast  pcoa  heatmapdendrograms  workbench  workbench  design  allow users  select subsets   data  comparison  export specifically  workbench support select sequence feature  submit    analysis   analysis  number  use case  describe   important limitation   current implementation   data send   workbench exist    current session  close  metadata publish  share mgrast    analytical platform   data integration system  enable data reuse  example  metaanalyses  require   data  make available  third party contain  least minimal metadata  mgrast team  decide  follow  minimal checklist approach use   gsc mgrast provide  mechanism  make data  analyse publicly accessible   submit user  make data public  mgrast  state  metadata  mandatory  data set publication metazen    web base tool  assist endusers   creation  metadata   correct control vocabularies    correct format  addition  publish data  analysis  also  share  specific users fig   share data users simply enter  email address via click share   overview page open image  new windowfig  fig  data set share  mgrast  users orange dot show  connect edge  matr metagenomic analysis tool     recently produce  package    environment  statistical compute wwwrprojectorg  provide accessory analytical capabilities  complement  already available   mgrast website  matr package  primarily design  download  analysis  mgrastbased annotation abundance profile  make  possible  download annotation abundance data  mgrast   friendly data object suitable  analysis  include analysis function  note  matr   specifically design  perform largescale analyse  abundance profile  dozens  thousands  data set  suitable preprocessing normalization statistics  visualization tool users  utilize  builtin tool     enormous variety  tool available within   universe  release version  matr  available  cran  prerelease  development versions  available  github   google group  available #forummatrforum  publication demonstrate  ease   matr   use  conduct largescale analyse  forthcoming",-0.1827009958512928,0.19043440449602486,0.11839511123624688,0.10303287663001856,0.029605628504511292,-0.016774218410355732,-0.10915263490336008,0.01670781963006396,0.01588714841144933,0.11672787083719505,0.008207188797196452,-0.049968408523652134,0.1648289235834753,-0.10004916541483866,0.1077980439494552,0.036863510363692634,0.08477466057831894,0.16222693406349045,-0.029426499360958067,0.07282955582459139,-0.06658502589023624,-0.1868722465959161,0.06336348298876962,0.002328183148012545,-0.024969246086201026,-0.16741151361425075,0.06136272106015784,-0.09338767855010596,-0.0766370976609648,-0.03930833590608538,-0.010173582542630814,0.23721523586306184,-0.16763092007295627,-0.07650039664084272,0.19142255630812,0.09844064859573907,0.023266932336049085,-0.01851911511788136,-0.06973800297537949,-0.12087503070194285,-0.08918696824240416,-0.14101607251141446,-0.09576593827146887,-0.07562768005781279,-0.1314228032697036,0.017073397985817355,0.0815943480437484,-0.058697060409751874,-0.18094495397608756,-0.30265191375232026,0.1741978952855968,0.043740760048243614,0.04313944807804098,0.5046464873001224,0.023105732773041503,-0.9955119882367044,0.055463111410387504,-0.2082899501702438,0.9147064342174436,0.1741629795073761,-0.16457282922245964,0.30525325566012096,-0.03314907912029928,0.034753514680232064,0.5492493106878664,0.02168619717903623,0.03262352970579886,-0.015417054789235784,0.23033459910465964,-0.18423032310737752,-0.055912479860580365,-0.02288080351678611,0.11172215489076534,-0.14927563170559194,0.13805928782148924,-0.05093410843152536,-0.12134771509644765,-0.12683915150736594,-0.33076205981978396,-0.07537088333574417,0.16329621453539953,-0.017838518529831968,-0.315709823668482,-0.0007132845460584808,-0.7622683364125143,0.10267684042749996,0.21663718657248912,-0.1396997291922401,-0.12085855969620275,-0.03485070025641799,-0.15263366717003513,0.07140559882071512,-0.0905915540655197,-0.07763304437884783,-0.05732416605884035,-0.06675218106651933,-0.09536997315363452,-0.3231410801326369,0.3166536384830011,0.10325708625123,Annotation,9
184,184,"vapid  lightweight crossplatform viral annotation pipeline  identification tool  facilitate virus genome submissions  ncbi genbank
 sequence technologies become cheaper  easier  use  group  able  obtain whole genome sequence  viruses  public health  scientific importance submission  genomic data  ncbi genbank   requirement prior  publication  play  critical role  make scientific data publicly available genbank currently  automatic prokaryotic  eukaryotic genome annotation pipelines    viral annotation pipeline beyond influenza virus annotation  submission  viral genome sequence   nontrivial task especially  group    routinely interact  genbank  data submissions  present viral annotation pipeline  identification vapid  portable  lightweight commandline tool  annotation  genbank deposition  viral genomes vapid support annotation  nearly  unsegmented viral genomes  pipeline   validate  human immunodeficiency virus human parainfluenza virus  human metapneumovirus human coronaviruses 229eoc43nl63hku1sarsmers human enterovirusesrhinoviruses measles virus mumps virus hepatitis  virus chikungunya virus dengue virus  west nile virus  well  human polyomaviruses bkjcmcv human adenoviruses  human papillomaviruses  program  handle individual  batch submissions  different viruses  genbank  correctly annotate multiple viruses include   contain ribosomal slippage  rna edit without prior knowledge   virus   annotate vapid  program  python   compatible  windows linux  mac  systems   create  portable lightweight userfriendly internetenabled opensource commandline genome annotation  submission package  facilitate virus genome submissions  ncbi genbank
vapid   download    installation guide usage instructions  test data  also  find    webpage  invocation  vapid  show  fig  users must provide  standard fasta file contain    viral genomes  wish  annotate users also must provide  genbank submission template sbt file  include author publication  project metadata  genbank submission template   use  multiple viral sequence  submissions   easily create   ncbi submission portal   optional sample metadata file csv file   provide  vapid  expedite  process  incorporate sample metadata  optional file  also  use  include    source modifiers support  ncbi    sample metadata file  provide vapid  prompt  user  input  require sample metadata  runtime additionally users  provide  specify reference    annotate  viruses   run  well  provide   blastn database  force vapid  search ncbis  database   internet  external file  hold  picture illustration etc object name  12859_2019_2606_fig1_htmljpg fig  example usage  vapid  two require file  show  genomefasta  author_infosbt genomefasta     viral genomes  wish  submit name   want   appear  genbank   example code provide   github repository  example file  call examplefasta  author_infosbt file   ncbi specific file  attach sequence author name  sequin file    require part  properly submit sequence  ncbi  file   generate     first optional command   comma separate file     include  relevant metadata   create additional columns   long   correspond  ncbi approve sequence metadata  list  format requirements   find   note  fasta sequence name must  identical  name   optional metadata sheet additionally one could omit  metadata sheet  vapid  prompt  strain name collectiondate country  coverage data automatically  runtime  second optional argument   location   local blastn database   force vapid  use  specify database instead   include database  last optional argument  force vapid  send  online search query  ncbis  database  vapid pipeline  summarize  fig   first step  find  correct reference sequence   accomplish  three ways  use  provide reference database default  force vapid  execute  online blastn search  ncbis  database   inputting  accession number   single ncbi sequence  use   reference  external file  hold  picture illustration etc object name  12859_2019_2606_fig2_htmljpg fig  general design  information flow  vapid first  provide sequence  use  query   local blast search default   online blastn search  result   return  reference annotation  download   specific reference accession number  give   reference  download next  original fasta file  align   reference fasta   result alignment  use  map  reference annotations onto  new fasta  custom code run   file  handle rna edit ribosomal slippage  splice  finalize annotations   plug  ncbis tbl2asn   author information  sequin file  generate  well  gbk file    use  manually verify accuracy  new annotations quality check sqn file   email directly  genbank   default case ncbis blast tool  call   command line  search   reference database   include   vapid installation  database  generate  download  complete viral genomes  ncbi  may    best result   search  pass   reference   next step   online option  find  reference  specify vapid find  appropriate reference sequence   genome   annotate  perform  online blastn search   word size   use biopythons ncbi wwwqblast function   online ncbi  database  blastn output  parse   best score alignment among  top  result  contain “complete genome”   reference definition line   complete genome  find   top  blastn result  topscoring hit  use   reference sequence   specific reference  provide vapid simply download  directly  ncbi   correct reference  download gene locations  strip   reference   pairwise nucleotide alignment   reference   submit sequence  generate use mafft   relative locations   genes   reference sequence   map onto  new sequence base   alignment  putative alignment  require  start codons   regions  high homology    rely  intergenic space  gene lengths gene name  take   annotate reference sequence genbank entry spellchecking  perform use ncbis espell module  module provide spellchecking  many biological string include protein product name  optional argument   provide  execution  enable  step  diverse array  methods viruses use  encode genes  present problems   viral genome annotator ribosomal slippage allow viruses  produce two proteins   single mrna transcript    ribosome slip one  two nucleotides along  mrna transcript thus change  read frame since ribosomal slippage  well conserve within viral species  complete reference genomes often list exactly   occur custom code  use  strip  correct junction site  include    annotation rna edit  another process   viruses  include multiple proteins   single gene  rna edit  rna polymerase cotranscriptionally add one  two nucleotides      template  change  specifically create  viral mrna transcription    viral genome replication rna edit present  annotation issue   annotate protein sequence   match  expect translate nucleotide sequence  correctly annotate genes  rna edit vapid parse  reference genome viral species detect  rna edit locus  mimic  rna polymerase vapid add  correct number  nontemplated nucleotides   viral species  provide  alternative protein translation  process  hardcoded  human parainfluenza  nipah virus sendai virus measles virus  mumps virus although rna edit occur  ebola virus reference  ebola virus  annotate    way  ribosomal slippage  code write  ribosomal slippage handle ebola virus annotations  ribosomal slippage  rna edit  process file require  genbank submission  generate   provide author  sample metadata vapid first generate  fsa file tbl file  optional cmt file submission file   viral genome  package   separate folder   sequence vapid  run tbl2asn   folder use  provide genbank submission template file sbt tbl2asn generate error report  sequin sqn  genbank gbk file  manual verification  genbank submission via email attachment  gbadmin@ncbinlmnihgov",-0.20172954653512945,0.16273737142802458,0.15710371234605122,0.027501311342579327,0.08232317335832656,0.04820082986002995,-0.07427052042487682,0.0011493315570371807,0.07994910207498207,0.11063318209422053,0.057225758033045734,-0.017990737091860783,0.17937930229382085,-0.0581299521675805,0.1194942384304124,0.039782805465009036,0.12174006599856532,0.15755492267169602,-0.040467837786689415,0.061926076269681475,-0.1163646558511549,-0.2414263439612345,0.12410346762814298,0.05544634533444882,0.02191831621436264,-0.16681565393363593,0.06916010288861038,-0.028416423054372583,-0.0279349440218457,-0.002943863223119585,0.02383575038525532,0.3386778528297015,-0.14803947078645546,-0.02540564656389444,0.2507241084241147,0.06427590875170643,-0.02651093182894377,-0.058728291397013764,-0.05484731830213042,-0.0994803419667136,-0.08141526742923016,-0.06875222855275738,-0.10987837875487344,-0.127889020983179,-0.08705830089710949,0.0035553005176716295,0.03531817315705613,-0.1994709153739716,-0.19046163899520974,-0.27542333678181025,0.17499486839142506,0.11975482688223815,0.03971326131223967,0.5005819501722399,-0.025725392766405272,-1.0698018424735258,-0.03131053870834568,-0.19998078138805264,1.0389613849740715,0.2281783972158486,-0.19751977354789949,0.3772398092098431,0.0038698630742531603,0.035273467760321205,0.58913469606907,0.046644593725133715,0.009798381231212742,0.05460099659312282,0.1920205448321732,-0.1865433615463892,-0.10635717474649446,-0.039671256390176025,0.15805341041876034,-0.18385789245268494,0.1745067370664969,0.04348861203293646,-0.15739476707364833,-0.10188948681206003,-0.4036016676996258,-0.12281028936227792,0.2160941971174599,-0.1275816600760211,-0.3555525563911057,-0.016066952444835955,-0.8729023947331207,0.1538813633246165,0.2823738386243503,-0.12638195704609628,-0.14010460728797294,0.009461879138254236,-0.12973671435457335,0.16534483868064526,-0.08744918934695384,-0.10447597506249116,-0.04868801684234607,-0.09553950484293863,-0.05195797449002466,-0.34735321523695595,0.347680408715778,0.101581763017979,Annotation,9
185,185,"dnascan personal computer compatible ngs analysis annotation  visualisation
next generation sequence ngs   commonly use technology  study  genetic basis  biological process   underpin  aspirations  precision medicine however   significant challenge  deal  ngs data firstly  huge number  bioinformatics tool   wide range  use exist therefore   challenge  design  analysis pipeline secondly ngs analysis  computationally intensive require expensive infrastructure  many medical  research centre    adequate high performance compute facilities  cloud compute   always  option due  privacy  ownership issue finally  interpretation   result   trivial   available pipelines lack  utilities  favour  crucial step   therefore develop  fast  efficient bioinformatics pipeline  allow   analysis  dna sequence data  require little computational effort  memory usage dnascan  analyse  whole exome sequence sample       whole genome sequence sample      midrange computer  pipeline  look  single nucleotide variants small indels structural variants repeat expansions  viral genetic material    organism  result  annotate use  customisable variety  databases   available   onthefly visualisation   local deployment   geneiobio platform dnascan  implement  python dnascan   extremely fast  computationally efficient pipeline  analysis visualization  interpretation  ngs data   design  provide  powerful  easytouse tool  applications  biomedical research  diagnostic medicine  minimal computational cost  comprehensive approach  maximise  potential audience  users bring  analyse within  reach  nonspecialist laboratories    centre  limit fund available
pipeline description  dnascan pipeline consist  four stag alignment analysis annotation  report generation    run  three modes fast normal  intensive accord  user requirements fig   table   modes   design  optimize computational effort without compromise performance   type  genetic variant  user  test see mode recommendations  table   user  restrict  analysis   subregion   human genome  prove either  region file  bed format  list  gene name  use  wholeexome option reduce  process time  generate region specific report fig  figure1 pipeline overview central panel dnascan accept sequence data  optionally variant file  pipeline firstly perform  alignment step detail   leave panel follow   customisable data analysis protocol detail   right panel finally result  annotate  userfriendly   result report  generate  annotation step use annovar  enrich  result  functional information  external databases right panel detail description   post alignment analysis pipeline align read  use   variant call pipeline freebayes  gatk   align  unaligned read  use  manta  expensionhunter   repeat description file    provide  look  structural variants  unaligned read  map   database  know viral genomes ncbi database  screen   dna   input sequence data leave panel alignment stage description raw read  align  hisat2 result softclipped  unaligned read  realign  bwa mem   merge   others use samtools full size image table  key tool use  dnascan   three modes full size table table  dnascan mode usage recommendations full size table alignment dnascan accept sequence data  fastqgz    sequence alignment map sam file   compress version bam hisat2  bwa mem    use  map  read   reference genome fig  leave panel  step  skip   user provide data  sam  bam format hisat2   fast  sensitive alignment program  map nextgeneration sequence read   reference genome hisat2 use  new reference index scheme call  hierarchical graph  index hgfm  thank     guarantee  high performance comparable  stateoftheart tool  approximately one quarter   time  bwa  bowtie2  see additional file  variant call pipelines base  hisat2 generally perform poorly  indels   address  issue dnascan use bwa  realign softclipped  unaligned read  alignment refinement step  skip  dnascan  run  fast mode samblaster   use  mark duplicate   alignment step  sambamba   sort  align read   variant callers freebayes   gatk haplotype caller   use   follow step  duplicateaware mean   automatically ignore read mark  duplicate  user  optionally exclude    workflow accord   study design    intensive polymerase chain reaction pcr amplification  small regions  require analysis various analyse  perform   map sequence data fig  right panel snv  small indel call  perform use freebayes whose reliability  well report   however take advantage   document better performance  gatk   small indel call  decide  add  customise indel call step  dnascan call intensive mode  step firstly extract  genome position    insertion   deletion  present   cigar   least one read  secondly call indels use gatk    select position  reduce number  position   occur allow   target use  gatk  limit  require computational effort  time  result snvs  small indel call  genotype quality smaller    depth smaller    discard  user  customize  filter accord   need see github   detail   complete list  available filter two illumina develop tool manta   expansion hunter   use  detect medium  large structural variants    include insertions deletions translocations duplications  know repeat expansions  tool  optimise  high speed   analyse   wgs sample   one hour use  thread maintain   high performance dnascan also  options  scan  sequence data  microbial genetic material  perform  computational subtraction  human host sequence  identify sequence  infectious agents include viruses bacteria  fungi  align  nonhuman  unaligned read   whole ncbi database   know viral bacterial   custom set  microbial genomes  report  number  read align   nonhuman genome  length   number  base cover   least one read annotation variant call   annotate use annovar   annotation include  use  databases   clinvar  exac  dbsnp   dbnsfp   information    customise  annotation   select alternative databases andor focus  specific genome regions  available  github report  visualization utilities dnascan produce  wide set  quality control   result report  provide utilities  visualisation  interpretation   result multiqc   use  wrap   visualise  result fastqc  samtools   bcftools   use  perform    sequence data  alignment   call variants  example  available  github   tab delimit file include  variants find within  select region  also generate   report would include  annotations perform  annovar    format   easy  handle   excellike software  users   level  expertise three iobio service bamiobio vcfiobio  geneiobio  locally provide   pipeline allow   visualisation   alignment file   call variants     gene base visualisation  interpretation   result  dnascan benchmark benchmarking every dnascan component   need since  range  literature  available      however   knowledge none exist assess hisat2   shortread mapper use   pipeline either  dna read map   part  dna variant call pipelines   manuscript   assess  performance  hisat2  bwa  bowtie2  map  billion wgs read sequence   illumina hiseq    million simulate read see additional file   compare  snvindel call pipeline  fast normal  intensive modes   gatk bpw   speedseq    whole exome sequence  na12878 illumina platinum call  use  true positives   also show  dnascan represent  powerful tool  medical  scientific use  analyse real dna sequence data  two patients affect  amyotrophic lateral sclerosis als   hiv infect human cells   als patients  use   gene panel   alsrelated genes whose feasibility  diagnostic medicine   previously investigate  sequence   illumina miseq platform   wgs data   project mine sequence dataset  dnascan  use  look  snvs small indels structural variants  know repeat expansions  wgs   hiv infect human cell sample   use  test dnascan  virus detection variant call assessment  assess  performance  dnascan  call snvs  indels  use  illumina genome analyzer  whole exome sequence  na12878 illumina platinum call   use  true positives gatk bpw call  generate use default parameters  follow  indications   gatk website   germline snvs  indels call  include  preprocessing  variant discovery step  single sample  skip  merge  join genotype step speedseq call  generate run  “align”  “var” command  describe  github  rtg tool  “vcfeval” command  use  evaluate  call fmeasure precision  sensitivity  define    follow 𝑃𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛𝑇𝑝 𝑇𝑝𝐹𝑝 𝑆𝑒𝑛𝑠𝑖𝑡𝑖𝑣𝑖𝑡𝑦𝑇𝑝 𝑇𝑝𝐹𝑛  𝐹𝑚𝑒𝑎𝑠𝑢𝑟𝑒𝑃𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛𝑆𝑒𝑛𝑠𝑖𝑡𝑖𝑣𝑖𝑡𝑦𝑃𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛𝑆𝑒𝑛𝑠𝑖𝑡𝑖𝑣𝑖𝑡𝑦    true positives  false positives   false negative als miseq  whole genome sequence test case use dnascan  fast mode  analyse real dna sequence data  two als patients case   case  case  carry  nonsynonymous mutation   fus gene  variant c1561t amino acid change r521c variant dbsnp  rs121909670  know    cause  als clinvar  rcv000017611  panel   als relate genes  sequence   illumina miseq platform  case   miseq gene panel  design  test  diagnostic purpose     genes bscl2 cep112 fus matr3 optn sod1 spg11 tardbp ubqln2  vcp  full exon set  sequence generate  baselong pair read dnascan  use  call snvs indels  structural variants  case  case    confirm c9orf72 expansion mutation  one allele also know   causative  als   expansion mutation  thousands  repeat long   wgs data  generate   illumina hiseq   case   wgs sample pair read read length   average coverage depth    sequence  part   project mine sequence dataset    sample  run dnascan   whole genome however   practical reason   simulate  specific medical diagnostic interest  focus  analysis report    als relate genes report   alsod webserver   also look   c9orf72 repeat   sample  also report variants link  frontotemporal dementia    neurodegenerative disease  cause neuronal loss predominantly involve  frontal  temporal lob   genetic  clinical overlap  als",-0.1655372023823294,0.207873637114893,0.0956127023844008,0.08404845566523568,-0.02209719182184233,-0.06908882978720214,-0.07084245951551202,0.013179054761429871,0.018734290438369355,0.10890987592571816,0.007303242910148353,-0.03930738048851197,0.1436897172448033,-0.07216516598667548,0.16141257653047636,0.020240717037573592,0.05968480656779561,0.15839096850685044,0.005636341624135291,0.07658110016694819,-0.08409088041929781,-0.2113672565967979,0.017843025265731994,-0.011281461703768531,-0.017122257948193918,-0.11854703887182788,0.09419845905457302,-0.0935379679796006,-0.08832326029755097,-0.012589182984975874,-0.013938345113624628,0.27058436296433,-0.18350843012331544,-0.04731183952934608,0.2136810797160653,0.05023544976347783,0.00824225417311781,0.00429035813416961,-0.09562781892777722,-0.05121707687305821,-0.0702405081635793,-0.11882066400124155,-0.09745254649937132,-0.12850145296232998,-0.1091478265140824,0.037216548913070184,0.1108509737651517,-0.11859193500904422,-0.20974327912080706,-0.3039665537271539,0.1688486385827725,0.0812773992773946,0.021898290620543145,0.4716223227152919,0.034290792464076465,-0.9915262079026462,0.03422214120774199,-0.21629124352308668,0.9125120932408308,0.16524434596101598,-0.11546495794219125,0.3371676680204698,-0.0006967832975653099,0.058663096245971075,0.5188884756236002,0.07187709169419325,0.02479283833750574,-0.000966794474699035,0.2584965474580411,-0.16379914323370245,-0.030341748243805262,-0.02937892869347935,0.08881126559578012,-0.15120008974489327,0.1420472817511361,-0.03465396161725212,-0.1043979691356157,-0.10137972459155876,-0.35494056578326705,-0.04838183406975545,0.22384920869684047,-0.03080497032730366,-0.3032520250730701,0.02903059774402288,-0.8375037332815127,0.12734829680479548,0.25539437358744244,-0.06710781717937338,-0.15571636894856414,-0.015552857354963073,-0.12276132651403444,0.06394069226049727,-0.06887319618159053,-0.08592263315914085,-0.05378046902289984,-0.004794174102446053,-0.0581651395918666,-0.3312663764222608,0.33456911336530404,0.07964823160490682,Annotation,9
186,186,"savant genome browser  highthroughput sequence data
 advent  highthroughput sequence hts technologies  make  affordable  sequence many individuals' genomes simultaneously  computational analysis   large volumes  data generate   new sequence machine remain  challenge   plethora  tool  available  map  result read   reference genome   conduct primary analysis   mappings   often necessary  visually examine  result  underlie data  confirm predictions  understand  functional effect especially   context   datasets  introduce savant  sequence annotation visualization  analysis tool  desktop visualization  analysis browser  genomic data savant  develop  visualize  analyze hts data  special care take  enable dynamic visualization   presence  gigabases  genomic read  reference  size   human genome savant support  visualization  genomebased sequence point interval  continuous datasets  multiple visualization modes  enable easy identification  genomic variants include single nucleotide polymorphisms structural  copy number variants  functional genomic information  peak  chipseq data   context  genomic annotations
savant retrieve  render data every time  range change  request   user together  process happen quickly    confer seamless navigation around  genome  renderer   track  adaptive    display mode   length   view region choose   user  dynamic resolution change savant dynamically adjust  resolution— amount  information  displays— optimize  nucleotide  genomescale visualization  track  example read alignments   visualize   coverage track   number  base pair within  region   large  enable  visualization  individual read   region  small enough savant seamlessly switch   readalignment view  show  figure   addition  present   intuitive visualization  feature also reduce  program' memory footprint  improve overall speed fig  read alignments visualize  various resolutions  use two modes  chromosomewide view  read mappings show  overall coverage   coverage   centromere  regional view still visualize   coverage map show higher coverage  certain regions   genome  local view  read  show separately  differences   read   reference genome  color read   forward  reverse strand  show  different shade  blue  matepair arc mode show  relative distance   two read   pair taller arc indicate larger distance   pair open  new tabdownload slide read alignments visualize  various resolutions  use two modes  chromosomewide view  read mappings show  overall coverage   coverage   centromere  regional view still visualize   coverage map show higher coverage  certain regions   genome  local view  read  show separately  differences   read   reference genome  color read   forward  reverse strand  show  different shade  blue  matepair arc mode show  relative distance   two read   pair taller arc indicate larger distance   pair individual track  also  lock   particular range      update    unlock lock track   use  overview profile   subregions   select  specify range change   track track lock also enable simultaneous view  high  lowresolution profile  display modes particular data type   display  different modes  example interval annotations   squish together   single line  pack neatly   none overlap mimic  squish  pack modes   ucsc browser  representation   dynamically toggle within  browser   representation option emphasize different aspects   data  variant  strand modes  read alignments  instance use color  emphasize mismatch  read   strand   read  map respectively  novel mode  represent matepairs show arc   map locations  pair read   height   arc  proportional   infer insert size arc  anomalously map pair    suggestive  inversions  duplications  color differently  various modes  read alignments  illustrate  figure   file format  performance savant support  number  common textbased format   describe  table  however  textfiles   enable fast random access savant format  save  file    provide  efficient search operations  runtime  speed   savant  sift  large datasets  enable   way    format  index data  particular format involve convert text record   index binary data structure specific   data type sequence  continuous track  store  fixedwidth record enable direct lookup  record  interest annotation range   genes  store use  bin scheme similar   one use   ucsc browser kent      bam file      retrieve  range correspond   region usually require  one    olog  disk seek file format    directly   application  savant keep  memory usage low  adjust  sample rate depend   size   visualize range table  support file format file format        description fasta         standard format  nucleotide sequence bed         format  describe coordinate  localize feature  genomes   genes sambam         relatively standard format  large set  nucleotide sequence alignments wig         standard format  continuousvalued data useful   percent probability score  transcriptome data gff         general feature format  annotations  range tab delimit          tabdelimited file contain point interval  continuous genome annotations open  new tab  time  space requirements   process  data format  visualization  measure   collection  human chromosome  datasets include  genetic sequence genes snps mammalian conservation  alignments  sequence read   individual    genomes project  coverage  test  perform   lenovo t61p laptop computer   intel core  duo cpu   ghz     ram  result  summarize  table  format   gene snp sequence  conservation track take less   min total   computation   coverage track   large set  read alignments take   additional  min  latter conversion  optional  allow  dynamic switch   alignment view   coverage view  illustrate  figure  runtime performance  assess  measure  time take  navigate  range  various size  measurement  perform   newly start instance  savant   start location   range  randomize  seek arbitrary range  size  million    savant take less   second  fetch  render data  performance  worst  range  slightly shorter   long   large number  bam record   display require     fetch  disk savant render virtually instantaneously  regions  size   order  hundreds  base pair   finescale visualization   table  time  space requirements  file format  visualization data file format retrieval  visualization  read alignments show   range   data file section describe input file  format section show time require  format  input file   result format file size  retrieval  visualization section show  time take  retrieve data  range  various size   number  record retrieve  draw  operations require    memory atracks  continuous value  smooth  render  large range sequence  point track   render beyond certain range denote   hyphen  read alignments bam file  replace  coverage precomputed   bam file  visualize longer regions open  new tab  plugin framework savant  able  integrate userdefined plugins allow one  accomplish  specific task  plugin   one  two general type interactive plugins  allocate dockable modules   graphical user interface gui elements   button  text field   place  respond  user input  retrieve data noninteractive plugins   designate  gui component  still  extensive access   innards   browser  number  helper function  provide  plugins   summarize  table  plugins   use  example  prototype  snp finder  identify variable columns currently  view   compute genomewide statistics    fraction  snps  exons table  helper function provide  plugins category        function descriptions range         change range track         add remove retrieve data change display modes  resolutions bookmarks         add remove  seek          rearrange modules          take screenshot export data etc open  new tab plugin development  straightforward  require implementation  one java interface  bookmark intersection plugin show  figure    example   interactive plugin  plugin allow  user  select two track intersect   load  intersect regions   list  bookmarks enable easy navigation     regions  interest  develop plugins   share among users   plugin section   savant web site fig  code use  make bookmark intersection plugin  detail     allow  user  select two track   omit   two track  select  bookmarktrackintersections method  run    interval  one track find overlap intervals     save intervals  overlap   bookmark panel open  new tabdownload slide code use  make bookmark intersection plugin  detail     allow  user  select two track   omit   two track  select  bookmarktrackintersections method  run    interval  one track find overlap intervals     save intervals  overlap   bookmark panel",-0.27559507734693545,0.2499875559848894,0.11461400456322444,0.1173483916205065,0.08535966705290023,-0.011663369841381223,-0.10520188398137367,0.056707283378118416,0.010488865213821929,0.11117138418411816,0.05435454352737415,-0.07532138960976582,0.16212452369924074,-0.14663354356200484,0.19895203949116844,0.004122233412753063,0.05652449639867349,0.1941896126199789,-0.030698112079180537,0.0573032284966381,-0.06857789733564887,-0.2475722606402913,0.10096860430738623,-0.0012721208624017221,0.021407860533023872,-0.2269876259229221,0.0664785396060826,-0.09025469212471668,-0.09059793904755564,-0.0662528990215258,0.00248865055498378,0.2781086702630373,-0.21349139810518367,-0.05487189573187638,0.2453790471391972,0.09764074968072403,0.014695383819427619,-0.0056217704230555506,-0.03899903508095906,-0.1364504698813818,-0.00956675736982932,-0.19751803677749216,-0.08124411859035749,-0.07953722454746649,-0.20088035668749574,0.04925015722669061,0.07269770789091293,-0.13156992920618182,-0.16395513363511718,-0.32367354336558657,0.14999429150323929,0.05599542279759871,0.04517714376307103,0.5782882945740532,0.05169880088076167,-1.1514896861084831,0.05180075773327001,-0.19369672147674893,1.0578745115496186,0.18211730787016708,-0.1721925053641805,0.3661493385280215,-0.03406608182643861,0.08739305896257671,0.5689938896726389,0.04244917656707139,0.03124922722264932,-0.005695919421714803,0.25285463548725706,-0.14630619707188153,-0.0555122528755743,-0.013811631367713129,0.17344181241531825,-0.15428366307129054,0.19741846843483465,-0.04189947523690503,-0.12837376868052558,-0.0925149079813654,-0.3091365479703607,-0.1256283357867907,0.1865222355787075,-0.07431154874977709,-0.35562380808372124,-0.0280276855443144,-0.8770717780528612,0.1568020624191575,0.25145479562938555,-0.1499436143071166,-0.08360882336675221,-0.009840405147305914,-0.16064416506841522,0.19086226326682407,-0.08282496037173095,-0.11872212010671268,-0.10281198113546547,-0.13152096582785378,-0.11270440356543653,-0.3709492150683427,0.3775253689625761,0.08872861409474207,Annotation,9
187,187,"fastannotator  efficient transcript annotation web tool
recent developments  highthroughput sequence hts technologies  make  feasible  sequence  complete transcriptomes  nonmodel organisms  metatranscriptomes  environmental sample  challenge  generate hundreds  millions  sequence   annotate  transcripts  classify  transcripts base   putative function  many biological scientists lack  knowledge  install linuxbased software package  maintain databases use  transcript annotation  develop  automatic annotation tool   easytouse interface  elucidate  potential function  gene transcripts  integrate wellestablished annotation tool blast2go priam  rps blast   webbased service fastannotator   assign gene ontology  term enzyme commission number  number  functional domains  query sequence use six transcriptome sequence datasets  examples  demonstrate  ability  fastannotator  assign functional annotations fastannotator annotate      transcripts   wellstudied organisms caenorhabditis elegans  streptococcus parasanguinis respectively furthermore fastannotator annotate        sequence   transcriptomes  sweet potato clam amoeba  trichomonas vaginalis respectively  lack reference genomes  demonstrate  fastannotator  complete  annotation process   reasonable amount  time   suitable   annotation  transcriptomes  model organisms  organisms   annotate reference genomes   avaiable  sequence process  longer represent  bottleneck   study  genomics  automatic annotation tool  become invaluable   annotation procedure  become  limit step  present fastannotator    automate annotation web tool design  efficiently annotate sequence   gene function enzyme function  domains fastannotator  useful  transcriptome study  especially   focus  nonmodel organisms  metatranscriptomes fastannotator   require local installation
 annotation process  fastannotator consist  four main part find  best hit   ncbi nonredundant database assignment   term identification  enzymes  identification  domains  assignment    term require  result  last search   ncbi nonredundant database   four main step  therefore  divide  three independent modules  term assignment enzyme identification  domain identification figure ​figure1 fastannotator run  three step  parallel  accelerate  annotation procedure  also calculate  basic statistics   input sequence  provide  statistical report   result  external file  hold  picture illustration etc object name  s7s9jpg figure  flowchart   fastannotator pipeline  users upload sequence   fastannotator server three different process lastblast2go priam  domain identification  execute  determine  gene ontology enzyme  domain annotation   submit sequence  implement  three process  parallel  accelerate  annotation procedure     annotation program  complete fastannotator present  term  best hit    database enzyme annotations  domain annotations together   statistical report   website  addition  explore  annotation result online users  also download    annotation result   zip file  identification   term last   blast2go b2g4pipe   use together  identify  annotations   query sequence  download  nonredundant protein sequence   ncbi database   construct  local database  blast2go  fastannotator last  use  find  similar sequence within  nonredundant protein sequence database  output  last   transform   equivalent blastx xml output format    require input file format  blast2go  use  statistical parameters    provide   last output result  derive  bite score base   follow definition  '    𝖨𝗇𝟤  alignment result generate  last   use   input  blast2go  final assignments   term  extract  present   table   website   make available  download  identification  domains  download  standalone blast  program  ncbi   use  database   domain model pfam v26   conserve domains database cdd  fastannotator apply  rpstblastn  identify domains   query nucleotide sequence  search   preformatted domain database  mostly default parameters except  expectation value evalue   set   less     hit align length   longer     domain pssm    domains   query sequence  identify fastannotator calculate  length coverage  present  percentage  coverage   domain   report table  identification   number fastannotator utilize priam   identify potential enzyme function priam  detect specific enzymes pattern  annotate  enzymes   number  latest version   enzyme profile release   oct   download   priam website  nucleotide sequence input  translate  protein sequence  six frame use transeq  tool  part   european molecular biology open software suite emboss   translate protein sequence   use  input  search   enzyme profile database fastannotator identify transcripts  may act  enzymes  present  transcripts together   number   output table",-0.21957586724820136,0.1913817707201285,0.09529008934187594,0.08747433613361752,0.08759075620066495,-0.06516146112840457,-0.09106327741508664,0.03282940629417235,0.038439890793958285,0.1430498891149983,0.0764607348882778,-0.07972440738721114,0.13490938808047165,-0.09260075959152644,0.08796661509908378,0.04559620446808305,0.12999287926731445,0.2156460316331401,-0.04279371323290202,0.13293350860193706,-0.11353121061624605,-0.25943754284125603,0.07624516761692067,0.03478618876665438,-0.0373474385236816,-0.23562484756413746,0.10531217557967733,-0.08589418712053222,-0.08608527496638085,0.003898440675455549,0.005409025104984129,0.3172060290091343,-0.21714562243453947,-0.0715833384951818,0.2268489708174029,0.06715741916488939,-0.014143191243456829,-0.031077385322484927,-0.057413102012610275,-0.13903038104551166,-0.06948232636534843,-0.13255208234294688,-0.12080256631579026,-0.09242284814365254,-0.12807165271850485,0.003501854800649349,0.051123702941982735,-0.12905692381252673,-0.2239884473614372,-0.26633053223427144,0.11368832858100247,0.04303374060670947,0.06624083822830637,0.5461425629297371,-0.0009266027225358676,-1.052213828149157,0.03823361451726271,-0.2257407734996304,1.0302695586018054,0.19343063289390097,-0.1840653764621283,0.3347818101737422,-0.046846426817445226,0.02664128183608739,0.6085267765815124,0.04026014699745803,0.0038465825597631185,0.0019659101208935863,0.2631838666251578,-0.17945629619966874,-0.03515204077652575,0.00976316856412662,0.1603983785141248,-0.1678309453300649,0.14800350454226815,-0.015841909390138954,-0.12261712692512072,-0.10848926346718904,-0.3981601546465717,-0.13188922482586055,0.21445640366593272,-0.06093176289533194,-0.3460478120575836,-0.01838549993543882,-0.8302433121749596,0.15257139255383206,0.28959575767401674,-0.13938725256617462,-0.13503244205902099,-0.011095278501898986,-0.11532418040920668,0.15119166176309926,-0.06579693740041481,-0.12001470965692662,-0.01236582156421564,-0.09516208149164704,-0.09150268446639,-0.3876494581147515,0.3756176632440645,0.11442893077119776,Annotation,9
188,188,"theviral metagenome annotation pipelinevmgapan automate tool   functional annotation  viral metagenomic shotgun sequence data
  past  years  field  metagenomics   grow   accelerate pace particularly  response  advancements  new sequence technologies  large volume  sequence data  novel organisms generate  metagenomic project  trigger  development  specialize databases  tool focus  particular group  organisms  data type   describe  pipeline   functional annotation  viral metagenomic sequence data  viral metagenome annotation pipeline vmgap pipeline take advantage   number  specialize databases   collections  mobile genetic elements  environmental metagenomes  improve  classification  functional prediction  viral gene products  pipeline assign  functional term   predict protein sequence follow  suite  comprehensive analyse whose result  rank accord   priority rule hierarchy additional annotation  provide   form  enzyme commission  number gomego term  hide markov model together  support evidence
 jcvi vmgap consist  two consecutive step  database search   functional assignments  pipeline use  input  multifasta file contain  translations   open read frame orfs predict   metagenomic sample protein cod genes  predict use  structural annotation pipeline    base   combination  naïve frame translations  metageneannotator    initio gene finder program  use empirical data include sequencebased composition distance  orientation  genes  completely sequence genomes  identify protein cod genes  upload protein sequence  use  query several databases  identify protein feature  similarities  schematically represent  figure   step   vmgap perform  follow sequence similarity search  external file  hold  picture illustration etc object name  sigsf1jpg figure  name rule use  functional annotation   vmgap  blastp search   nonredundant protein database  nonredundant protein database encompass several public protein databases genbank  uniprot pir  omniome   set  redundant peptides  condense   single database entry without lose useful information record   fasta headers    number product name  taxon identification number  vmgap report  top  hit  evalues ≤1x10  blastp search   aclame database aclame   public protein database  mobile genetic elements mges include bacteriophages transposons  plasmids  proteins  organize  families base   function  sequence similarity  families     members  manually annotate  functional assignments use   mego term  ontology dedicate  mges develop  aclame  blastp hit  evalues ≤1x10  report  blastp  tblastn search  environmental protein databases  vmgap query three different environmental composite databases   amino acid level  env_nr  genbank nonredundant protein database  include many environmental datasets   inhouse database sanger_pep compose  proteins cod  sangerbased viral metagenomic sample  represent  env_nr table   iii env_nt  collection  nucleotide sequence  metagenomic datasets deposit  genbank  purpose   analyse   determine  similar  viruses  within  query metagenomic sample  viruses  microbes  inhabit  different environments represent   subject databases  vmgap report  blast hit  evalues ≤1x10 table  metagenomic libraries incorporate   sanger environmental protein database library name        reference viral metagenomes  yellowstone hot spring bear paw         rna viral community  human feces         viral metagenomes  yellowstone hot spring octopus         virus  human blood         virus  human feces         virus  marine sediment         uncultured marine viral communities mission bay         uncultured marine viral communities scripps pier         coastal rna virus communities         chesapeake bay virioplankton         virus  equine feces          hmm search  pfamtigrfam  aclame hmm  addition  similarity search  protein databases  vmgap look   presence  hmms  two databases pfamtigrfam  database  hmms represent conserve protein domains  aclamehmms  compilation  hmms  describe    protein families find  aclame pfamtigrfam hmm search  carry   two different ways either require  global  local alignment   hmms local hmm alignments increase sensitivity   detection  conserve protein domains particularly   predict peptide  truncate  extend   end   read   note frequently  metagenomic datasets  hmm hit  evalues ≤l1x10  record   analysis  rpsblast  ncbi cdd database  ncbi conserve domain database cdd database   collection  position specific score matrices represent conserve protein domains protein families  superfamilies compile  ncbicurated domains  pfamtigrfam smart   cog   spite   overlap pssms derive  pfamtigrfam   behave exactly     hmm counterparts    case  search  identify domains  hmms fail  vmgap store  hit  evalues ≤ 1x10  identification  transmembrane domains  signal peptides  discover transmembrane proteins  signal peptides  could  associate   surface  viral particles  vmgap utilize two program signalp   identification  signal peptides  tmhmm  program  detect candidate transmembrane domains  assignment   number  aid   metabolic reconstruction  metagenomes  vmgap make use  priam  collection  pssms   matrix represent  enzymatic function   assign   particular  number metagenomic sample  scan   presence   pssms  rpsblast record   hit  evalues ≤1x10  rule hierarchy functional assignments  predict peptides  carry   retrieve  functional information produce   result   analyse perform   previous step follow  series  predefined rule figure  rule prioritize  use   certain piece  evidence  another base   informative trustful  accurate  evidence   show  figure  hit  equivalog tigrfam hmms   highest rank support evidence  functional assignments   vmgap therefore  protein  hit   trust cutoff  one entire copy  coverage  respect   length   hmm   equivalog tigrfam  automatically inherit  functional annotation associate   particular hmm  second  third tiers  evidence  constitute  highly significant blastp hit  aclame    nonredundant protein database respectively   least  coverage  respect   shortest sequence  identity   evalue ≤ 1x10 although proteins  aclame   also include   nonredundant protein database entries   former   higher priority since   curated  therefore provide better functional annotation hit  hmms describe aclame protein families  pfamnonequivalog tigrfam hmms comprise  4th  5th layer  functional evidence give higher priority   hmms represent protein families   describe conserve protein domains rank 6th  7th   rule list  respectively rpsblast hit   least  coverage percent identity ≥   evalue ≤ 1x10  ncbicdd profile  locallocal hit  pfamtigrfam hmms  evalues ≤ 1x10 finally lowconfidence blastp hit   least  coverage percent identity ≥   evalue ≤ 1x10  aclame    nonredundant protein database occupy tiers      priority list respectively proteins  lack  evidence type describe   still contain   evidence   hit   environmental dbs  name “hypothetical protein” otherwise proteins  label  “unknown protein”   implementation  vmgap consist  three major modules implement  perl figure    control module  initialize  pipeline create  sqlite    store  status  computations   result coordinate   modules  allow interrupt pipelines   resume   point  interruption   compute module  track  status   individual computations  load complete computations   sqlite database  iii  annotation module  read  computational result   sqlite   apply  set  predefined rule  generate  tabdelimited annotation file contain  final annotation   peptide  ecgo assignments  protein name   tabdelimited evidence file  store   evidence  support  annotation  line   annotation file contain  functional annotation   individual peptide    evidence file  line represent one particular evidence   single protein table   table  additionally  vmgap contain  optional module also implement  perl call com2go commonnametogo mappings com2go   run   annotation module  attempt  classify  protein name use   hierarchy  external file  hold  picture illustration etc object name  sigsf2jpg figure  schematic representation   implementation   vmgap  three main modules   pipeline  depict  yellow square orange  red circle represent input  output file respectively vics stand  venter institute compute service sge stand  sun grid engine job scheduler single  doubleheaded arrows indicate information flow  one   directions respectively table  description   content   evidence file generate   vmgap                                                                                 cdd_rps          subject definition            cov            ident           evalue                    ident            group_pep          subject            subject definition           query length           subject length            cov            ident           evalue           aclame_pep          subject            subject definition           query length           subject length            cov            ident           evalue           sanger_pep          subject            subject definition           query length           subject length            cov            ident           evalue           env_nt          subject            subject definition           query length           subject length            cov            ident           evalue           env_nr          subject            subject definition           query length           subject length            cov           hmm description           evalue           frag_hmm          hmm begin           hmm end            cov           total evalue           hmm accession           hmm description           hmm length           pfamtigrfam_hmm          hmm begin           hmm end            cov           total evalue           hmm accession                   hmm length           priam           number           evalue                                   hmm description           aclame_hmm          hmm begin           hmm end            cov           total evalue           hmm accession                   hmm length           pepstats          molecular weight           isoelectric point           tmhmm          number predict helixes           signalp          signal pep           cleavage site position open   separate window field    correspond   protein identifier   flag specific   analysis respectively  cov percent coverage  ident percent identity cdd_rps rpsblast  cdd  allgroup_pep blastp  protein   aclame_pep blastp  aclame protein  sanger_pep blastp  inhouse viral metagenomic  env_nt tblastn  env_nt  env_nr blastp  env_nr  frag_hmm hmm search  local pfamtigrfam hmm  pfamtigrfam_hmm hmm search  global pfamtigrfam hmm  priam rpsblast  priam profile  aclame_hmm hmm search  global aclame hmm  pepstats peptide statistics tmhmm transmembrane domain search signalp signal peptide search table  explanation   annotation file generate   vmgap column           description           example            unique peptide            jcvi_pep_metagenomicorf             protein common name tag           common_name            functional description            phosphonate  lyase system protein phnl putative            source  functional description assignment           allgroup highrfyp_001889651             tag                       gene ontology             gogo            source  gene ontology assignment           pf00005pf00005             tag                       enzyme commission number                         source  enzyme commission            priam            hit  env_nt  tag           env_nt            env_nt  libraries hit  evalues ≤             hydrothermal vent metagenome foss10958y2 whole genome shotgun sequence  lake washington formate sip enrichment freshwater metagenome  human gut metagenome healthy human sample inm infant female            best hit evalue per environmental library                           number  hit  evalue ≤   per environmental  library                           hmm  tag           pfamtigrfam_hmm            pfamtigrfam hmm hit  trust cutoff           pf000005            signalp tag           signalp            presence   absence   predict signal peptide                       cleavage site position                       transmembrane domain tag           tmhmm            number  predict transmembrane domains                       protein statistics tag           pepstats            molecular weight                       isoelectric point            open   separate window  lane contain  annotation   single predict peptide multiple value within  field  separate   symbol “”  heart   vmgap   compute module figure   module accept  compute configuration file see table    current configuration   sqlite result database  compare  computations specify   configuration   result load   sqlite result database miss computations  initiate stale computations outdated reference dataset  obsolete program options  refresh  interrupt computations  resume  computations   execute either   local machine  job     computational intensive   signalp    jcvi highthroughput compute platform name vics webservices vics   j2ee server back    node sgegrid    terabyte scratchdisk    computations  start  restart    compute module wait    complete   computation  complete  result  parse  load   sqlite database   status   computation  update   computations  complete  module exit  allow  controller  proceed  module may  interrupt manually  restart   later time",-0.16984134588673516,0.18520999568241397,0.0965046739681594,0.044393921083100536,0.04836764897205875,-0.032582752607398166,-0.06380101320940701,0.052574805715170606,-0.01374632035667176,0.10888782155624473,0.050869680212636534,-0.04098074248050729,0.15909008302066674,-0.04148744424083147,0.11440949649109615,0.03813602704007829,0.07842034774518701,0.15009884771547954,-0.025469081608760887,0.06279793222056212,-0.06298996253855645,-0.18363984039079395,0.046773809069998375,0.03545901899836215,0.012996007014079122,-0.17396308736123367,0.055420553295793436,-0.08540190937452517,-0.007840224679286805,-0.03269305603058822,-0.0034280082458717264,0.25403491792275623,-0.13818705259334474,-0.05213524876848172,0.1676630172694231,0.0646593449742006,-0.0001986441590512792,0.010334038914171437,-0.03756581272897467,-0.08573615073011938,-0.0519658229740339,-0.12064080607209983,-0.07849167667937464,-0.1042851112894648,-0.06648981136857487,0.04980300952445525,0.06411329686815803,-0.07909283726402218,-0.17501714788282838,-0.25905026479873056,0.13189920995875576,0.03210918526957715,0.05794758892866965,0.4934327229762999,0.008167866696077983,-1.0173993145355484,0.028309881388015937,-0.18897481625152315,0.8988194256294946,0.21362630300641852,-0.1666505171708365,0.3393412506736723,-0.004294425468379385,0.07422005853747515,0.5468384852309299,0.050402861781462666,0.039765956592327234,0.005759609058835082,0.23433792374053286,-0.1621198275122821,-0.06025629762224665,-0.03487416304866792,0.1327392565976743,-0.16633037710849793,0.1181871282188074,-0.02737621562736112,-0.10497620637484248,-0.09348437168025224,-0.34648405187935744,-0.10907712469277396,0.15024826234055444,-0.00788111653007695,-0.32213845534792795,0.02077181625584012,-0.6978212153412585,0.10470522955413973,0.22079884352875345,-0.1409757945374906,-0.06658731951229226,0.0008974735156655133,-0.13537454154337075,0.08199684306317234,-0.07173373086086016,-0.042981484413687585,-0.061558845432227186,-0.08983322444747201,-0.08542660551373166,-0.3223717672703336,0.2990904991688269,0.091627864465216,Annotation,9
189,189,"pyrobayes  improve base caller  snp discovery  pyrosequences
previously report applications    life sciences pyrosequencing technology  rely  deep sequence coverage  accurate polymorphism discovery   frequent insertion  deletion sequence errors   report  new base call program pyrobayes  pyrosequencing read pyrobayes permit accurate singlenucleotide polymorphism snp call  resequencing applications even  shallow read coverage primarily   produce  confident base call   native base call program
 sequence read produce    life sciences pyrosequencers   result  cyclical nucleotide test   ideally  nucleotides within  homopolymer  example aaa  incorporate   single test   light intensity signal observe   cycle  proportional   actual number  incorporate nucleotides1  reality  signal   fix number  incorporate base vary substantially    usually  nonzero signal even   base  incorporate supplementary fig  online  make accurate base call difficult  lead  nucleotide overcalls  undercalls  manifest  insertion  deletion errors2  errors often lead  misalignments  artificially inflate sequence error estimate  cause  assignment  lower estimate   base calls' accuracy   refer   base quality  warrant   true accuracy fig  figure  comparison   error profile  pyrobayes   native  base caller figure1  illustration   effect  call     many base   alignment   read gray   reference sequence black top   thymines  call result  two spurious mismatch arrows  misalign  correctly call cytosine   insert guanine    read middle  correct number  thymines  call result   correct read alignment   single insertion error red    read bottom  many thymines  call result   correct read alignment   two base insertion errors red    read  base error rat  pyrobayes   native  base caller  relative contribution   error type base  pyrobayes call  show   pie chart full size image accurate base qualities  crucial  resequencing applications   true allelic variation must  distinguish  sequence error reliable snp call    make   base error rate   call allele  substantially lower   expect polymorphism rate  example  human study    average pairwise polymorphism rate    order       snp call   make   single allele   base quality lower       error rate however   base call  resequencing read  well    threshold snps   detect  high confidence even  singleread coverage unfortunately  find   majority   base qualities assign   native  base caller version    sufficiently high  snp call  lowcoverage condition      native  base call    fig  however  find   read   call accurately   base qualities assign   native base caller underestimate  actual base accuracy fig   develop  new base call program pyrobayes  produce  accurate higher base qualities  hence make  highquality base call   pyrosequences figure  comparison   base qualities assign  pyrobayes   native  base caller figure2   cumulative distribution  base qualities assign   program  comparison  assign base quality   base quality calculate  measure base accuracy  value    assign   errors  find   distribution  base call accord  base quality full size image  base caller first determine   likely number  incorporate base   measure incorporation signal   nucleotide test  bayesian strategy supplementary methods  supplementary fig  online require 'data likelihoods'    distribution  observe nucleotide incorporation signal  every possible homopolymer length  estimate   collect shotgun resequencing data    life sciences gs20 instrument   finish mouse bacterial artificial chromosome bac clone  extrapolate  higher homopolymer lengths      examples could  find supplementary fig   supplementary fig  online  'prior probabilities'  use  relative frequency  homopolymer lengths tabulate  several different reference genome sequence  find   frequencies  consistently different   theoretical expectation    proportional       homopolymer length supplementary fig    software  use  single distribution   frequencies   similar across  eukaryotic genomes  consider use data likelihoods  prior distributions  determine  'bayesian posterior probability'   correct number  base give  measure incorporation signal supplementary fig   call base sequence  produce  concatenate   likely number  base  every consecutive incorporation test  base quality assign   base   probability   base  question    overcall  find  also useful  call one extra base  long   presence   base    minimum probability see   compare  pyrobayes  native base call accuracy   read   inbred reference iso strain  drosophila melanogaster supplementary methods  overall base accuracy fig   quite high   pyrobayes   native base caller  versus  notably    sequence errors  insertions  deletions  pyrobayes insertion error rate  higher  versus    deletion rate  lower  versus   importantly  snp discovery  pyrobayes substitution error rate   lower  versus      native base caller  large fraction    base call errors  share   two methods characteristically    errors solely make  pyrobayes  insertions whereas    unique  base caller errors  deletions  substitutions supplementary fig   pyrobayes base qualities correspond substantially better   actual base accuracy   native base qualities fig   therefore  base qualities  typically higher fig   example    pyrobayes base call  assign base qualities    higher  compare     native base call fig 2ac additionally pyrobayes produce base qualities    whereas  highest native base quality    investigate  effect   higher overall base qualities  snp detection first  search  singlebasepair differences   sequence iso read   iso reference sequence  expect  true polymorphisms   sequence     inbred  melanogaster strain   overall accuracy    melanogaster genome reference sequence   high therefore snps discover   comparison estimate  false positive snp rate  rate    use  native base call     use  pyrobayes base call   important  consider   false snp discovery rate depend   polymorphism rate   resequenced organism  example   melanogaster   pairwise polymorphism rate    ref   result correspond   false snp discovery rate    estimate snp call error rat directly  also sequence  inbred  melanogaster isolate  malawi   single  run   alignments    read base call  pyrobayes  find  snp candidates     polybayes snp probability6 cutoff value    validation rate   candidates       correspond  false positive snp rate observe   experiment   composite effect  false snp call emulsion pcr errors   sequence   usual artifacts associate  capillary sequence validation experiments7  also estimate   miss    snps supplementary methods  repeat  snp discovery experiment   alignments process   native  base caller  false positive rat  identical  twice  many  snps  miss  primary cause  spurious substitution errors   read   erroneous alignment   base undercall follow   overcall  vice versa   base substitution fig   supplementary fig   alignment algorithm mosaik supplementary methods use gap penalties  properly align read   situations additionally  find  call  base  homopolymer run often also improve  alignment fig  eliminate spurious base errors result  alignment artifacts lead  assignment  higher base qualities higher base qualities increase snp call sensitivity  cost  tend toward call  base  homopolymer run   slightly increase insertion rate fig  even though  extra call base  typically assign  low base qualities    logical choice  snp discovery applications however    yet clear  effect  extra call base     novo sequence assembly   read  natural although undesirable consequence    determine homopolymer length   single incorporation signal    likelihood  overcalling error increase  every consecutive nucleotide accordingly  first call base   homopolymer run  assign  highest base quality   last call base  lowest supplementary fig  online  introduce  unintended directionality   base qualities   sequence alignment supplementary fig  clearly    possible   base call program  resolve  ambiguity within  standard base quality framework define   phred8 base call program consequently one must rely  alignment  snp call software  account   phenomenon  also evaluate base call accuracy   new  life sciences flx sequence machine model use two sequence run   k12 strain  escherichia coli  find   base callers underestimate  flx base accuracy supplementary fig  online  primary reason      overall error rate   flx machine   much lower     gs20  although  fact   pyrobayes base qualities  much closer   actual accuracy suggest   calibration procedure  robust   clearly  need  recalibrate  method   flx  future model  increase accuracy   base qualities  likely permit  sensitive biological study use   machine although  data  illustrate  directly  lowcoverage surveytype applications statistical fluctuations10  result  regions  shallow read depth even  deeper nominal coverage  ability  call snps   regions without  substantial loss  accuracy  permit  complete analyse  wholegenome alignments pyrobayes  process  single sequence run    min",-0.19701506405717456,0.1847786986011098,0.17703636043156573,0.1350417914095253,-0.10212340922462128,-0.07314580750454233,-0.07516255959002517,-1.4445050088472705e-05,-0.04556259136591779,0.11689857538422264,-0.07326116729250925,-0.01571438140499876,0.18121978064548025,-0.08410788019795028,0.210746946115513,-0.03396992003797198,-0.015007719752341556,0.15371268649211095,0.029236169058404086,0.09543959657060336,0.03841202078415945,-0.2018766805656211,0.028740604995112606,0.011554288979410916,-0.003395729898067057,-0.14702181652375526,0.07570761311682273,-0.16996779249811222,-0.05351922350292653,-0.08680647044097099,0.059510504796299324,0.24248097987831135,-0.17309574387291302,-0.049711052960831406,0.21783123795999532,0.05213666236875387,0.01931889200542295,0.026080645351387446,-0.07893985687765849,-0.10027578959515146,-0.1077216356921012,-0.11237681220567182,-0.11410398696838475,-0.11274192323722185,-0.16248666027428213,-0.0568132170184381,0.19119266408481206,-0.17254629977975766,-0.27790336807308835,-0.4170308949104174,0.1861594126295159,0.007574384573522413,0.05305950836453721,0.5900229252526805,0.007668124885687163,-1.1390345807177658,0.07489780428190476,-0.19153477934239546,0.9368392288827064,0.2052176421618908,-0.18237807044779492,0.307147554072405,-0.07842374548943684,0.07296618627091468,0.5740046097768576,0.03933599347713135,0.008494140264542458,-0.059219792204550176,0.21360910943704514,-0.15860196329069987,-0.06867158457122602,-0.0037969252413868437,0.11684621116908545,-0.07609962851478785,0.23161198020901905,-0.01559468614838816,-0.1333979150057127,-0.21261408844285826,-0.380241101179224,-0.0441753302988518,0.18754515542106265,-0.018018228956018144,-0.381903480940028,-0.0692310721129503,-0.8834887975322793,-0.012704526060278836,0.2243499628570622,-0.1039592962176179,-0.11982395317580685,-0.08431888519467956,-0.22521099988695176,0.09180204051255114,-0.15142227333793945,-0.08854160775981372,-0.12608829426690793,-0.05864836298620577,-0.15382764241826175,-0.35721294503459783,0.2516647874717913,0.0600743110240053,SNPDiscovery,10
190,190,"redundancy base detection  sequence polymorphisms  express sequence tag data use autosnp 
autosnp   program  detect single nucleotide polymorphisms snps  insertiondeletion polymorphisms indels  express sequence tag est data  program use d2cluster  cap3  cluster  align est sequence  use redundancy  differentiate  candidate snps  sequence errors candidate polymorphisms  identify  occur  multiple read within  alignment   candidate snp two measure  confidence  calculate  redundancy   polymorphism   snp locus    segregation   candidate snp   snps   alignment
 autosnp script  run   command line  startup  user  ask  supply fasta format input file name together   similarity cutoff  d2cluster  cap3 default value   similarity  d2cluster    cap3 program flow  dependencies initial cluster  carry   d2cluster burke    autosnp read  output table create  d2cluster  use  information  build sequence cluster file  fasta format  cluster   pass   sequence assembly program cap3 huang  madan  autosnp read  ace format output file   cap3 run  generate gap fasta format alignment file   finally pass   snp detection  cosegregation subroutines program output  primary output  autosnp   set  link html format snp report preface   index page contain statistical information relate   sequence contig assembly  candidate snpindel identification  snp report page  three components   key   sequence   alignment   summary table show  candidate snpsindels together  confidance score  iii  full vertical alignment   sequence   snps highlight figure   snp report also   hyperlink   underlie sequence alignment  fasta format  addition   main report several support file  produce  hold information    frequency distribution  cap3 sequence contig size   number  snps associate   size  sequence contig nucleotide substitution ratios  table  indel sequence  size frequency performance   maize test data  input file contain   maize ests  download  zmdb    autosnp program execute    ghz intel pentium iii     ram run redhat linux   d2cluster program take  days  organize  sequence  primary cluster  cap3 assembly  snp detection take      complete analysis     cluster produce  cap3   find  contain one   candidate snp  total   candidate polymorphisms  identify  discoverhtm indel size frequencies nucleotide substitution ratios  segregation  candidate polymorphisms  haplotypes indicate   majority  snps  indels identify use  approach represent true genetic variation  maize  autosnp report summary  report depict  candidate snps identify  base position   sequence alignment along  two measure  confidence  snp validity  min informative score measure  minimum number  sequence  represent  polymorphism  cosegregation score   measure   number  snps   alignment  share   pattern  polymorphism  align sequence  weight cosegregation score take account  miss data   alignment  ests  may otherwise bias  cosegregation score  key relate  align sequence  original genbank sequence  also identify  maize line  available derive   genbank annotation  full snp report include  complete sequence alignment along    snp summary",-0.19891933784577887,0.21437808877401215,0.11050910936268801,0.00020962007373377596,0.06892688425979174,-0.0471668951603654,-0.06789049758263621,0.035359466713557094,-0.08013731155630653,0.09131393848643826,0.056392117142354314,0.0034025551810473037,0.12393600606720227,-0.05974485808472025,0.21498648915439844,0.022060457369409543,0.12515179986118022,0.16827452329828235,-0.0004086624084018989,0.10399462274919033,0.04485917764828901,-0.30424569587147865,0.08945828545407923,0.05197565429278709,0.008723601510457566,-0.2796783512350538,0.13928200265209625,-0.09266558827864642,0.026818282121652468,-0.07335396038470628,0.0768408998308671,0.3142195193115837,-0.1381596709134574,-0.008728915454706748,0.20058319725670226,0.05543384394969124,0.06505540475004347,0.02445349144154481,-0.058752444567363386,-0.11324609793464227,-0.03225445014160837,-0.14929005711494522,-0.06665569561065278,-0.07045355007103564,-0.18760221477091915,-0.0618283620987066,0.10818475658461624,-0.2304119871450841,-0.2515396866974329,-0.3390510423234099,0.10140686179511248,0.09553197669430576,0.07802472767996134,0.5709350440392776,0.05214891838605618,-1.1974554204723846,0.004788951689547003,-0.2167576807026208,1.034611209236473,0.2394880930868898,-0.17013476904824165,0.2634353854410341,-0.0276394079337058,0.08745981389360577,0.5476806950217079,0.020007804786447286,0.028522302022451436,0.02347717421786117,0.25122977816600706,-0.06734959752301584,-0.10949087930682408,0.04150536578859208,0.12041482814056717,-0.17055305379383653,0.18970074489405864,0.018160140497147,-0.09922467075648983,-0.1323092155181399,-0.4013635985811666,-0.07268366846996173,0.140588232773663,-0.10540528309254267,-0.3601973293822883,-0.13107211780976613,-0.8626694984174188,0.059039364053431714,0.2754521320622436,-0.1938290037887677,-0.03305807991210382,0.04661155995950533,-0.2093863626995872,0.17973523282424433,-0.13762313373537596,-0.04435734528606768,-0.11745647104279368,-0.11558213480008026,-0.07548474310493539,-0.3876010121998372,0.3698562027138222,0.08100523872871619,SNPDiscovery,10
191,191," snp discovery method  assess variant allele probability  nextgeneration resequencing data
accurate identification  genetic variants  nextgeneration sequence ngs data  essential  immediate largescale genomic endeavor     genomes project   crucial   genetic analysis base   discoveries  key challenge  single nucleotide polymorphism snp discovery   distinguish true individual variants occur   low frequency  sequence errors often occur  frequencies order  magnitude higher therefore knowledge   error probabilities  base call  essential   develop atlassnp2  computational tool  detect  account  systematic sequence errors cause  contextrelated variables   logistic regression model learn  train data set subsequently  estimate  posterior error probability   substitution   bayesian formula  integrate prior knowledge   overall sequence error probability   estimate snp rate   result   logistic regression model   give substitutions  estimate posterior snp probability   use  distinguish true snps  sequence errors validation result show  atlassnp2 achieve  falsepositive rate  lower       lower falsenegative rate
bacterial data set use   train  validation experiment  coli substrain k12mg1655   aureus substrain usa300_tch1516   previously sequence  finish  high accuracy use sanger method  resequenced use   platform  read  process    basecaller version leonardo v2008b1  produce base call  quality metrics  reference genome sequence  obtain  ncbi  coli k12mg1655 accession  nc_000913  aureus usa 300_tch1516 accession  nc_010079  identify mismatch  define  sequence errors  set  read  also map   alternative reference genome   genetically different strain    species  coli dh10b accession  nc_010473   aureus usa 300_fpr3757 accession  nc_007793 respectively  identify  sequence errors  first map  read   genetically identical reference genome  remain mismatch  define   initial set  snps subsequently  improve  snp identification stringency  map one highquality reference genomic sequence  one strain   highquality reference genomic sequence   second strain   coli   aureus respectively  list  intersect    initial set  snps     illumina snp data finally  obtain  snps   coli data   snps   aureus      illumina data set    almost perfect concordance   publish   discuss  detail  two previous publications  identify  report  genetic variations   two  coli strain   two  aureus strain respectively durfee    report  snps  genic regions list  table   durfee      snps  intergenic regions   total number  snps  durfee        coli detail genomic coordinate   snp loci   provide   two  aureus strain highlander    describe   main text     snps  two base deletions  supplemental table  however list  six deletions two insertions   snps   aureus— total   polymorphisms— identify  snp genomic position give  highlander' supplemental table  use usa300mr   reference whereas  snp position use fp3757   reference   genomic position information could   use  comparison  use blat  cross_match  uniquely map     coli      aureus read back   respective reference genome sequence result   average coverage     coli     aureus supplemental table  slightly lower read map yield  achieve   genome sequence   relate strain  use    coli dh10b     aureus usa300_fpr3757 supplemental table    coli dh10b sequence      reference genome cover yield  greater genetic difference   reference  resequenced genomes   coli data set  use  train data   resampling process  produce  data point  errors  snps   aureus data set  use  validation data  well   tune parameters    closer genomic composition    content   human genome watson genome  platform sequence data wheeler    sequence  entire genome sequence  watson   average read coverage   use   platform  recall   watson genomic sequence read    version   basecaller leonardo v2008b1 use  process  bacterial sequence read  also obtain  approximately  watson genotypes determine use affymetrix  genotyping microarrays wheeler     validate  variant call   method  genotypes  convert  acgt nucleotides use  affymetrix map file   check   hapmapceu genotypes  allele frequency match  filter  snps  retain  comparisons map  align  read  genomic sequence  fundamental issue  read map  relate   presence  repeat sequence   resequenced genome owe   nature  genome assemblies repeat sequence  occasionally collapse   single place   reference genome  process occur   draft  finish assemblies   result  read   repeat region   resequenced genome   map incorrectly   reference genome generate falsepositive snps  recent duplication   resequenced genome  find   reference genome  also lead   errors  reduce false positives due   case  regard  read   “ambiguously mapped”    multiple best hit    mismatch rate   best hit  larger   predefined cutoff value   ratio   best hit   second best hit exceed    base   idea develop  polybayes marth    detect duplicate read    sequence  shotgun fragment share   ′ start position   account       overall ngs data obtain   production center  create  skew coverage distribution  may subsequently bias  error model  thus substantially increase  number  falsepositive snp discoveries data  show currently  simplistic approach   detect  duplicate  remove    except  best quality read   give position   future iterations   worth explore whether    additional value  retain    duplicate satisfy certain criteria  might maintain  data integrity  maximize highquality coverage logistic regression  improve base error prediction  sequence read  use  logistic regression model  improve  accuracy  error estimation   read  model  train   coli k12mg1655 read  identify  priori  set  predictors base  empirical observations  result   reference brockman    dohm    include raw quality score swap  boolean variable base nqs  threshold  boolean variable homopolymers  content relative position   end nqs  immediate flank nucleotides   specific substitution classifications  generalize linear model  use   statistical train process   stepwise procedure  primarily use  model selection  achieve  balance  model parsimony  prediction accuracy  choose   variables  significant pvalues  result   train experiment  show  table    current version   titanium  basecaller leonardo v2008b1   show  equation    significant predictors   model   quality score   substitution base whether  base  involve  “swapbase”  phenomenon define   two adjacent mismatch base invert  nucleotides relative   reference sequence  multinucleotide polymorphism mnp events  boolean variable indicate whether  nqs pass  default requirement   quality score   substitution base call  greater     quality score     five flank base  either side  greater  —“base nqs  threshold”  relative distance   base   ′end   read normalize  read length  infer logistic regression model  overall significance  equation image  note   new titanium basecaller  much improve performance  deal  homopolymers   previous versions cause  basecaller  overcall  undercall  number  contiguous base   data brockman     train result indicate  homopolymers  longer contribute significantly  increase  sequence error probability   read   consistent   vendor' feedback  basecall error probability   give read  equation image bayesian framework  consider  map read  assess variant allele probability   locus  derive  locus error probability estimation  equation image   read   {  … }    substitution   map   particular locus   derive  locus snp probability  equation image  use   stand  prsnpj  refer   measure signal   locus   multiplication step assume  error base  fully stochastic  therefore arise independently  one another  assumption   certain extent may cause inaccuracy  total sequence read coverage vary   inaccuracy  difficult  model  read coverage variations  apply  bayesian framework  try  take  read coverage variation  consideration  order   improve  variant allele probability estimation   give locus equation   show  equation image prsnpsj    posterior variant allele probability  locus   signal     specific variant read coverage  prsjsnp   prsjerror   infer   probability density distribution    snps  errors   specific variant read coverage     derive empirically    coli train data set  illustrate  supplemental figure  priorsnpc  priorerrorc   prior estimations   substitution snp rate   error rate  condition   variant read coverage respectively   paper  use three set  parameters supplemental table   particular    two   read    variants “set ” priors  set  priorsnpc    priorerrorc   “set ” priors  priorsnpc    priorerrorc    “set ” priors  priorsnpc    priorerrorc  ",-0.1649066901141974,0.18820890902369272,0.13937179080131015,0.17211300521692047,-0.05962332083589553,-0.06635872105044363,-0.06230725960662061,0.003205686951311309,-0.05116825769557258,0.13017461282872886,-0.02312106924923246,0.015155973513148544,0.16296527706977745,-0.08284177455017278,0.16899322885943607,-0.013682388272507234,0.0267509432941396,0.1933967405755334,0.006387341620053756,0.10746804826437066,0.01102276707495578,-0.22405506533666555,0.04948945316884986,0.050700439028147457,-0.01994204582031424,-0.17377676514234444,0.14549555909058975,-0.1449549519456923,-0.054315934165512315,-0.07393979212305721,0.020781161297664517,0.22103080010335088,-0.15990740624834418,-0.05491883084625093,0.17223777738018115,0.04562016182693062,0.054396281006857235,0.04534714430160559,-0.12627218413740324,-0.09234172784201518,-0.08535631896957398,-0.10874578089495404,-0.07656465376268165,-0.09543072301769014,-0.16876016574624414,-0.023368426903960158,0.14488605485326095,-0.17762321493530045,-0.2823086845623362,-0.3583382097189042,0.20181860385513894,0.04733922820045085,0.04347793572032672,0.5754728495332563,0.01934728162544201,-1.0921876447147687,0.07828141450560247,-0.21515709471935732,0.8584441855043801,0.20782882620283868,-0.16038882249969807,0.2837845999968349,-0.0702639004696527,0.07175169617921306,0.594028069394525,0.017146139487662884,-0.03606743930099615,-0.027749043511471054,0.19065997427952666,-0.18182966822365176,-0.0934721484987736,0.0222642821361626,0.12371044479624314,-0.0964587112878879,0.2190076741787978,-0.04466147132412,-0.09548718523887363,-0.15613126837532856,-0.3890814732370868,-0.0771756041884985,0.1456419484778711,0.004181810283506686,-0.351734498865346,-0.0783736618034366,-0.797603919262675,0.04226309159989807,0.20128450729689,-0.13847736148321804,-0.10197945945447452,-0.05406118326364314,-0.25142402441701056,0.09177872744897073,-0.16431165256251776,-0.10579541240834066,-0.09851836338252117,-0.04791575197683346,-0.0916690444797321,-0.31906862522296026,0.2710029015258125,0.08319154163480101,SNPDiscovery,10
192,192,"snpserver  realtime snp discovery tool
snpserver   realtime flexible tool   discovery  snps single nucleotide polymorphisms within dna sequence data  program use blast  identify relate sequence  cap3  cluster  align  sequence  alignments  parse   snp discovery software autosnp  program  detect snps  insertiondeletion polymorphisms indels alternatively list  relate sequence  preassemble sequence may  enter  snp discovery snpserver  autosnp use redundancy  differentiate  candidate snps  sequence errors   candidate snp two measure  confidence  calculate  redundancy   polymorphism   snp locus   cosegregation   candidate snp   snps   alignment
sequence input assembly  cluster  realtime autosnp web server snpserver act   web interface  wrapper   three program blast cap3  autosnp  make   snp discovery pipeline  figure    complete pipeline accept  single sequence   input  entry sequence  compare   specify nucleotide sequence database use blast     identify relate sequence  result sequence may   select  assembly  cap3     subsequent snp discovery use autosnp    alternatively users may enter  list  sequence  fasta format  assembly   precalculated sequence assembly  ace format complete options  blast sequence comparisons cap3 assembly  snp discovery may  specify   user interface snp discovery snp discovery  perform use  redundancybased approach   modify version   autosnp perl script      alignment data generate  cap3    user submit ace file  use  load  sequence   assembly    array space character  add  sequence alignment  consider   fifth element  addition   four nucleotides       permit  identification  insertiondeletion polymorphisms  sequence  row represent  single base locus   assembly  assess  differ nucleotides minimum redundancy score specify   user  associate  alignment width  number  sequence include   contig determine  number  different nucleotides   base position require  classification   snp   snp  record  snp score  allocate equal   minimum number  read  share  common polymorphism  several snps  present   alignment  cosegregation score  calculate   snp   measure   frequency  haplotype specify snp pattern occur   alignment  figure   normalize   number  sequence   alignment  produce  weight cosegregation score html format file  generate  allow  user  input data select comparison assembly  snp discovery parameters  browse  snp result  figure   figure   overview  components   realtime autosnp web server  snpserver open  new tabdownload slide  overview  components   realtime autosnp web server  snpserver figure   entry   sequence  specification   sequence database  comparison       blast job  initiate  completion  summary  match sequence  display permit  selection  sequence  assembly     assembly page permit users  specify cap3  autosnp parameters     summary page provide information   assembly   snp discovery  permit users  return   assembly page  modify parameters  result page consist  two windows  first provide  complete vertical alignment highlight snps      second list  assembly member sequence  provide  snp summary    open  new tabdownload slide  entry   sequence  specification   sequence database  comparison       blast job  initiate  completion  summary  match sequence  display permit  selection  sequence  assembly     assembly page permit users  specify cap3  autosnp parameters     summary page provide information   assembly   snp discovery  permit users  return   assembly page  modify parameters  result page consist  two windows  first provide  complete vertical alignment highlight snps      second list  assembly member sequence  provide  snp summary",-0.2562365411025173,0.23237406642920466,0.15915739951097355,0.060497202400891285,0.10193799579305188,-0.015942576779169763,-0.093203541326319,0.0812611014570502,-0.045234654245183525,0.1533093542569323,0.08446884978820318,-0.08563946256832858,0.1493437198465163,-0.0953253087069277,0.17927195305010574,0.0835361892793843,0.11177903856004373,0.21069339451339072,-0.04546600366421278,0.11098777523934958,-0.07983054097671552,-0.3263850503735853,0.10754389093556213,0.032560316144354035,0.07237611442757477,-0.33479847109425553,0.14417059764078574,-0.100629639220219,0.02119670071750411,-0.07799363080792879,0.035806698229679336,0.3880751256131034,-0.20452037416164232,-0.04504013057789361,0.2746001002754,0.08734262970703766,-0.014323146056102694,-0.04263286742838627,-0.08314391809849525,-0.11145695276432466,-0.05681357809976505,-0.16509872089863506,-0.03866407405087174,-0.07264935073908417,-0.1726069079851878,-0.002167258996765588,0.04042363522351725,-0.22660807970107336,-0.23116684975776144,-0.3503912857934282,0.17743137911468768,0.06734012251093094,0.037027684678821435,0.5978130346410117,0.01202337958545383,-1.196645980681814,0.03587924972551424,-0.2422202323217812,1.1478938921061843,0.2856630561639022,-0.2483125256014616,0.34484878792749635,-0.032802139079409105,0.09138782948267253,0.6444338848023623,0.0012899672922988732,0.012126686581580332,0.09271283288421872,0.18526599128289828,-0.18406733143093568,-0.15423726833207366,0.02887447941140418,0.1173313094781486,-0.17721587893664367,0.20629510753963776,-0.0023090690140079397,-0.14305555414988325,-0.16584637775979116,-0.35531583747316925,-0.16516140229566573,0.17348457650845628,-0.13464935217345567,-0.349192748631134,-0.08603087038060933,-0.8554869809674109,0.12047373232835867,0.3360636507178534,-0.17343704189384745,-0.04727735204304387,0.05115354812701098,-0.19967709956749244,0.17609325838099532,-0.1386673551773266,-0.11279994678982305,-0.017864876059206117,-0.07236905339460982,-0.07545464907614689,-0.3320809184052285,0.3989398823582432,0.0542923482662102,SNPDiscovery,10
193,193,"snpsearch simple process manipulation  search  snps  highthroughput sequencing
 typical bacterial pathogen genome map project  identify thousands  single nucleotide polymorphisms snp interpret snp data  complex    difficult  conceptualise  data contain within  large flat file    typical output   snp call algorithms one solution   problem   construct  database    query use simple command   snp interrogation  output   easy  comprehensible   present snpsearch  tool  manage snp data  allow  manipulation  search  snp data  creation   snp database   vcf file snpsearch   use  convert  select snp data  fasta sequence construct phylogenies look  unique snps  output contextual information   snp  fasta output  snpsearch  particularly useful   generation  robust phylogenetic tree   base  snp differences across  conserve position  whole genomes query   design  answer critical genomic question    association  snps  particular phenotypes snpsearch   tool  manage snp data  output useful information    use  test important biological hypotheses
snpsearch  write  ruby  popular script language  use  ruby activerecord library  map database table  ruby object   run   modern unixbased architectures    instal   command gem install snpsearch snpsearch  two fundamental feature  creation   local sqlite database  schema  create  database data  source  two input file reference genome  genbank  embl format   vcf file snpsearch require  reference genome use   map process  import  feature genes etc  annotations   database  require  vcf file  populate  database table   snp information  database schema create  snpsearch  design  facilitate construction  simple query   address complex biological question annotations   genbank file  populate   annotations table   relate   feature table  contain information   type   feature   nucleotide sequence snp position   vcf file  import   snps table   relate   feature table   features_snps table  snp   occur   resequenced genome  record   allele   alleles table  strain name  description strain table  relate  alleles via  genotype table  contain  allele_id  strain_id thus query  relate strain  snps  annotations may  easily compose  relationships  schematise  figure   external file  hold  picture illustration etc object name  jpg open   separate window figure  snpsearch database schema  output request object  database   database   populate snpsearch provide several filter  output options figure   external file  hold  picture illustration etc object name  jpg open   separate window figure  snpsearch machinery give  genbank   vcf file snpsearch first create  sqlite database  populate  data   database  user     choice  various output options options include produce  snp concatenate fasta file generate  newicktree format file  phylogenetic analysis   list  snps depend  query  information  every snp     snp  synonymous  nonsynonymous output format concatenate fasta file snps   sample  collect   database  concatenate  convert  fasta format tabdelimited tabular file information  individual snps  provide  tabdelimited tabular format newickfile format snpsearch use fasttree    generate  newick file  snp phylogeny filter options filter snps accord   snp quality  phredscaled score   snp exist   give site default  filter snps accord   genotype quality  phredscaled score   genotype  true also know  genotype quality score default  filter snps accord    ratio  ratio   unfiltered count   read  carry  specific allele compare   ref  alt alleles   site default  ignore snps  feature ignore particular snp call  feature   phages transposases  insertion sequence  remove horizontally transfer dna   result   recombination event ignore snps  specify range snps   define specify range   ignore ignore sample certain sample   exclude   snp output ignore noninformative snps  snp   find   sample   include   output analysis unique snps   set  strain give  set  define strain  input snpsearch query  database  unique snps share   define strain  output  result  concatenate fasta  tabular format snp phylogeny concatenate fasta file  use  generate robust phylogenetic tree   base  snp differences across whole core genomes snp annotation snpsearch process  data   database  output information   snp  follow   description   output  synonymous  nonsynonymous snp   calculate  translate  cod sequence  report   snp  whether cause  amino acid change    function  cod region   snp position   extract   annotate genbank file  possible pseudogene   stop codon  detect   cod region    end   sequence  original amino acid provide  amino acid   snp region   nonmutated sequence   amino acid  change due   mutation  answer  'yes   give     least one amino acid change   original nonmutated sequence   mutate sequence     change  hydrophobicity   amino acid  answer   question  base   predefined set  hydrophobic  nonhydrophobic amino acids take  livingstone   hydrophobic  ilvcagmfywht   nonhydrophobic amino acids  keqdnspb     change   polarity   amino acid  answer   question  base   predefined set  polarise  nonpolarised amino acids take  hausman    polar  rndeqhksty  nonpolar  acgilmfpwv     change  size   amino acid  answer   question  base   predefined set  small  nonsmall set  amino acids take  livingstone   small  vcagdnstp  nonsmall  ilmfywhkreq database query sqlite database   interrogate  user define query require  knowledge  sql  view administer  query  database one may download  sql gui tool  simply use  unix version  sqlite3",-0.2289640923373793,0.24613432401930094,0.1047437896537431,0.07848150920400625,0.03329825309440167,0.011403872922988069,-0.129852798591131,-0.03029155537492204,0.053094570159814065,0.11008169314775028,-0.0012230565869494488,-0.02728049661596551,0.17021412373941164,-0.09665813609516542,0.1477328944575499,0.09014377908438052,0.08863285054011565,0.17325273051269746,0.01322562533692179,0.10905591043308704,-0.07499400313224709,-0.2518396353684039,0.11753750732842537,-0.016614401384599898,-0.02123550290258177,-0.21770413151795145,0.07818983594739908,-0.09192610754909222,-0.040489535173503365,-0.017906070336201146,0.02076826382381433,0.3033318328867225,-0.1710206985293904,-0.07058593379619547,0.2466904505923913,0.047169861280392016,0.019079810483871317,-0.009482301240215046,-0.026390566416248155,-0.1641780286798613,-0.08300947282185549,-0.12149092108736287,-0.12045987184392287,-0.13857995632611084,-0.1533931730870615,0.03780531554825997,0.06570837739058526,-0.10954026637022923,-0.2569267533278387,-0.2899806183648476,0.19406688253664853,0.1108335236462217,0.0907561799274398,0.4951588329875417,0.0029121805325542627,-1.0561388153411253,-0.0011205471807012432,-0.19042593232405028,0.9487711944241536,0.1774862126724002,-0.16147634669241756,0.3990632156204236,0.002921913460861042,0.014120383925017037,0.6526680146098921,0.04551044565404912,0.0551389684859794,0.0058238471882711895,0.1974284705532339,-0.23513155424162716,-0.10393506077745228,0.01966744333407596,0.15872859241718654,-0.1931282351716634,0.16283463274798635,-0.04002672808996418,-0.13585842888508187,-0.1592342028402511,-0.4042737680618047,-0.06987541786868844,0.16609353767176924,-0.09001747973869849,-0.3660213288981794,-0.02719509418596301,-0.7689445780647363,0.15190621496529502,0.2643148604286181,-0.12400762765799045,-0.10107512361137196,0.010681086779049222,-0.14936768676137974,0.10952218779313723,-0.09127079178334067,-0.08093606417083687,-0.050936808567820936,-0.08415501759134299,-0.1153029159789807,-0.3855472094297671,0.3003782783473613,0.10203100861532187,SNPDiscovery,10
194,194,"indepth annotation  snps arise  resequencing project use ngssnp
ngssnp   collection  commandline script  provide rich annotations  snps identify   sequence  whole genomes   organism  reference sequence  ensembl include among  annotations several     available   exist snp annotation tool   result  detail comparisons  orthologous sequence  comparisons   example identify snps  affect conserve residues  alter residues  genes link  phenotypes  another species 
 main component  ngssnp   perl script call annotate_snpspl  accept  snp list  input  generate  output  snp list  annotations add table  information use  snp annotation  retrieve  ensembl hubbard    ncbi maglott     uniprot uniprot consortium  use  locally instal version  ensembl  annotation script  process  million snps    days   standard desktop system users analyze many snp list  different individuals    species  example  take advantage   script' ability  create  local database  annotation result  database allow   annotations   flank sequence   previously process snps   obtain much  quickly additional components  ngssnp include  script  merge filter  sort snp list  well  script  obtain reference chromosome  transcript sequence  ensembl    use  snp discovery tool   maq   annotation script identify  amino acidchanging snp  calculate  alignment score change value   process involve compare  reference amino acid   nonreference amino acid   orthologue briefly  amino acid encode   variant  nonreference allele   compare   available orthologous amino acid  use  logodds score matrix blosum62  default  provide  score svo      orthologues similarly  amino acid encode   reference allele   compare   orthologues  set  species  ensembl   use   source  orthologous sequence  average score   reference amino acid  subtract   average score   variant amino acid    result  scale       divide   maximum possible value   score matrix  positive value indicate   variant amino acid   similar   orthologues   reference amino acid whereas  negative value indicate   reference amino acid   similar   orthologues snps  large positive  negative value may    initial interest  candidates   study equation image          annotation script include  model option    use  specify  wellstudied species  use   additional annotation source   snp  locate near  within  gene annotations describe  model species orthologue   gene  obtain  ensembl entrez gene  uniprot  annotations  use  generate value  appear   model_annotations field   form  keyvalue pair examples  information provide   field include kegg pathway name kanehisa     number  interact proteins phenotypes associate   orthologue  name  protein feature overlap   snp site   orthologue  phenotypes associate  mutations affect  snp site   orthologue  sample output give  supplementary file  begin   result   contrive snp design  change  residue   bovine hbb protein  resemble  mutation responsible  sicklecell disease  humans  annotation script  optionally provide  genomic flank sequence   snp  use   design  validation assay know snp sit   flank sequence    snp position   include   output  lowercase iupac character   flank   potentially additional alleles   snp site supplementary file  contain  flank sequence provide   annotation script  know snps indicate  lowercase    snps describe  supplementary file     discussion many exist snp annotation tool work   human snps  snps already present  dbsnp     use  process   thousand snps   time chelala    johnson    schmitt    apart  ngssnp   aware  two tool design  annotate   large snp list generate  wholegenome resequencing  humans  nonhuman species annovar wang      commandline tool  use information   ucsc genome browser  provide annotations seqant shetty     webbased    download  also rely  resources   ucsc genome browser   place snps  functional class describe nearby genes  indicate  snps  already describe  dbsnp neither compare affect residues  orthologous sequence report overlap protein feature  domains provide gene ontology information  provide flank sequence  ability  map snpaltered residues   protein  another species  retrieve additional information  also  support however annovar  seqant provide  measure  dna conservation   snp site  handle indels  return annotations much  quickly  ngssnp  feature  others give  tool  unique advantage  option  submit snps  seqant online may  particularly appeal   users  summary ngssnp   use  annotate  snp list return  program   maq  samtools snps  classify  synonymous nonsynonymous ′ utr etc regardless  whether    match exist snp record numerous additional field  information  provide several     available   tool",-0.1617909713297276,0.20857445737208,0.10562501918983216,0.05316003519909651,0.03575701851731361,0.00321076188651096,-0.05581609177474391,-0.004826278657280604,0.040518510716605866,0.068395029915038,0.009232220008844204,-0.02598408722368012,0.1930138484759251,-0.08669652198719334,0.14912542283844285,0.04638147830473148,0.10308152588408824,0.17636999093541708,-0.01874408602963007,0.14307362631435938,-0.055113247568795536,-0.2316351015039949,0.08576321163941905,0.008926301705477232,-0.03081087069064657,-0.20706103210087254,0.1283818033357488,-0.07698622480931401,-0.054734704206322336,-0.010625072050997778,0.06996505489875215,0.3598750195102836,-0.20632666225698013,-0.07491542854078752,0.21734607096992992,0.05376215320499266,0.04563844043747591,0.044081020304922766,-0.11845192052910465,-0.0586285535719614,-0.0968318930323194,-0.1321700593311541,-0.09922305407278838,-0.15235300370276586,-0.0799940458467185,0.051234582789980616,0.041429734291246426,-0.10317108497186912,-0.24710301013573055,-0.3137641850391528,0.1942455413262186,0.04942961655810837,0.07592270368147197,0.5333854967881161,-0.004165415930754588,-1.1061262369100282,-0.05373688192309207,-0.2440020286255697,0.9254021272557368,0.2367624359921233,-0.16124152787352927,0.4655084253602432,0.03387767259450065,0.0372199453276655,0.6742305453387158,0.06680953597959215,0.06402656813708148,0.05590519117068557,0.2529217028306665,-0.17394118274734946,-0.08277455212916733,-0.016667177748637022,0.12746593714261656,-0.17939914359728268,0.1552260948636972,-0.04006016013254203,-0.1252150098973913,-0.15734668314168507,-0.4443962116701417,-0.06397116430704969,0.1657297970052051,-0.0994543236901431,-0.3772898443467193,-0.06265710584372769,-0.8240879147188432,0.11769998747613905,0.2329140671897235,-0.13327241951248733,-0.12929455077457208,-0.02979133828660845,-0.15494009071557935,0.05546369994799398,-0.093035592066833,-0.1151864631379496,-0.08982710932957448,-0.06487760973404468,-0.15456818655105448,-0.38043703135874457,0.318057881376303,0.0599905202059256,SNPDiscovery,10
195,195,"varscan  somatic mutation  copy number alteration discovery  cancer  exome sequencing
cancer   disease drive  genetic variation  mutation exome sequence   utilize  discover  variants  mutations across hundreds  tumors   present  analysis tool varscan    detection  somatic mutations  copy number alterations cnas  exome data  tumornormal pair unlike  current approach  algorithm read data   sample simultaneously  heuristic  statistical algorithm detect sequence variants  classify   somatic status germline somatic  loh   comparison  normalize read depth delineate relative copy number change  apply  methods   analysis  exome sequence data   highgrade ovarian tumors characterize  part   cancer genome atlas tcga  validate   somatic cod mutations achieve  sensitivity   precision  single nucleotide variant snv detection exomebased cna analysis identify  largescale alterations   focal events per tumor  average    previous analysis   data  observe frequent amplification  oncogenes  ccne1 myc  deletion  tumor suppressors nf1 pten  cdkn2a  search  additional recurrent focal cnas use  correlation matrix diagonal segmentation cmds algorithm  identify  significant events affect  genes take together  result demonstrate  robust performance  varscan   somatic mutation  cna detection  shed new light   landscape  genetic alterations  ovarian cancer
mutation detection algorithm give pileup input   tumor sample  match normal control  mutation detection algorithm perform several step   position first  determine   sample meet  minimum coverage requirement  default three read  base quality ≥  determine  genotype   sample individually base upon  read base observe  default  variant allele must  support   least two independent read   least    read   variant allele meet  criteria  position  call wild type homozygous reference   sample  multiple variant alleles  observe  mostsupported  read count    base quality variant allele  choose variants  call homozygous  support       read   position otherwise   call heterozygous position  neither sample  determine   variant  exclude unless  validation flag  set   next  position  one   sample   variant  algorithm perform  direct comparison  normal  tumor  follow   genotypes   match   read count  evaluate  onetailed fisher' exact test   twobytwo table see supplemental fig  compare  number  referencesupporting read outcome   variantsupporting read outcome  observe  tumor category    number   observe  normal category    result pvalue meet  significance threshold default    variant  call somatic   normal match  reference  loh   normal  heterozygous   difference   meet  significance threshold  variant  call germline  process  describe    genotypes match  variant  call germline  variant pvalue  compute  onetailed fisher' exact test fet   twobytwo table compare  total number  referencesupporting read   total number  variant support read normal  tumor value  combine   expect distribution   nonvariant position due  sequence error   example  expect read distribution   nonvariant position   coverage   sample would   referencesupporting read  one variantsupporting read due  sequence error germline loh  somatic mutations   categorize       varscan processsomatic command  default somatic mutations  deem    variant allele frequency   least   tumor   normal   fet pvalue  less   germline variants  deem      least  variant allele frequency   normal  tumor sample loh variants  deem    variant allele frequency   least    normal sample   fet pvalue  less    variant  meet   criteria  deem  position   homozygous  normal  heterozygous  tumor gain  heterozygosity    variant allele       snp   indel  presume   sequencingalignment artifacts   discard cna detection algorithm give pileup input   tumor sample  match normal  cna detection algorithm first determine   least one   sample meet  minimum coverage requirement  reduce noise  spurious differences  low coverage  default set   parameter   higher    mutation detection next  algorithm compute  depth  highquality base phred base quality ≥ individually  tumor  normal sample  depths  record   consecutive position    gap  minimum coverage  encounter   end   chromosome  reach    ratio  tumor depth  normal depth change significantly  compute  fisher' exact test   contiguous region  relative copy number change    tumor  infer   log base    normalize depth ratio equation image     average tumor depth    average normal depth    number  uniquely map base   normal bam     number  uniquely map base   tumor bam  number  uniquely map base  compute use samtools flagstat information   bam file specifically  equation image     number  read map dup   proportion  map read mark  duplicate     average read length raw copy number regions  chromosome start position stop position  log2 value undergo cbs   dnacopy package seshan  olshen   produce segment call delineate  significant changepoints   least three standard deviations supplemental methods adjacent segment  similar copy number   cbs algorithm  merge   internally develop perl script mergesegments  classify  size events encompass    chromosome arm  classify  largescale  others  consider focal events software implementation  varscan  core software  develop  java  falsepositive filter  implement  perl binary executables script  source code  free  noncommercial use  available    falsepositive filter require  bamreadcount utility  larson      write  compile   ovarian cancer data  ovarian cancer data set include exome sequence data snp array data  validate somatic mutations  generate  publish   cancer genome atlas research network cancer genome atlas research network   wgs data   five case utilize   crossplatform copy number comparison   describe   separate publication exome  wgs sequence data  available  bam format   dbgap database  identifiers  sample   study   supplemental table  mutations  call  exome data   tumornormal pair   varscan somatic command   follow parameters mincoverage minvarfreq pvalue strandfilter minavgqual   mutations  filter  remove false positives use  criteria describe  table  see supplemental methods filterpassed somatic mutations  annotate use gene structure  ucsc karolchik    annotation information assign  mutation  one  four tiers  previously describe ley    mardis     tier  mutations  alter cod sequence nonsynonymous synonymous splice site  noncoding rna  report  figure   select  orthogonal validation cnas  call  exome data   tumornormal pair nine poorcoverage tumors  exclude   varscan copynumber command   follow parameters mincoverage minregionsize  raw cna call undergo cbs   subsequent merge procedure  describe  supplemental methods rcna identification annotation  pathway analysis  cmds algorithm zhang     apply  identify regions  statistically significant rcnas   tumor sample  merge segment copy number events see supplemental methods  crossreferenced   coordinate    proteincoding exons  obtain  mean log2  copy number change   start position  stop position   exon cmds  configure  run   minimum   markers exon start  stop correspond  roughly one region test per gene regions meet  significance threshold     merge  within    one another yield  set   candidate rcna regions   visually review  identify target genes  remove peak encompass six   unrelated genes   target   nonfocal events  unclear  cytobandtxt  refgenetxt file   ucsc genome browser database karolchik    version hg18  use  annotate cna events  cytogenetic band  refseq gene information respectively use  customize perl script information  specific genes   refseq  kegg databases  retrieve use genecards safran    version  pathwaybased analysis   rcna genes  perform use kegg   database information use webgestalt gene set analysis toolkit version     default settings hypergeometric test  correction  least two genes per category",-0.18652607687401146,0.1308379690233996,0.08475869868353719,0.09191740283595676,-0.03055515364928212,-0.025826847422093808,-0.018382092206317632,0.06271976345471474,0.006896777147390768,0.12107778355179805,-0.021118610489072875,-0.0024834161528675363,0.14533794592127894,-0.11080838152216542,0.19933090589981536,0.018361448789070058,0.07548527307186474,0.16780971367438555,0.039787956735478996,0.1083665715862398,-0.042845042514635265,-0.2347659262806394,0.03660297732171773,0.020132147519186613,0.003858107265681575,-0.20005762865561946,0.14142049476732033,-0.10932871777550623,-0.056711335316947074,-0.061017300301142635,0.07236549104672052,0.2346603557311837,-0.1409999218168509,-0.02514310920193181,0.21367993825981973,0.0253424615212682,0.03517368431704023,0.004874902846824496,-0.08688579594504663,-0.05149203231489891,-0.08177660356123742,-0.09721363593356268,-0.10562615430000047,-0.07877058042543496,-0.14759960695150512,0.023308007103791755,0.08869674080919615,-0.15580381549129713,-0.2672221518886187,-0.3042807632736739,0.1618476696718031,0.04618613661692676,0.050811493609892996,0.4778996316060278,0.02452763560351012,-0.9780528303019448,0.04723784464757552,-0.18330244977149,0.8520289572880292,0.21050108028538772,-0.14767415835705705,0.31646752583112314,0.005921411719104881,0.047149697123841136,0.5357828473815727,0.07928079425937651,-0.02582683563852924,0.01529582134251025,0.2117453267323058,-0.12736170293639748,-0.0867953545315517,0.0032045039673712136,0.11823025631055425,-0.09541389702256853,0.19185909504084545,-0.039660742699936004,-0.11330492447829445,-0.1611504804981704,-0.3434732062639646,-0.10062142953382376,0.16549215375754325,-0.0866467729465601,-0.3294235475060774,-0.035651772386055165,-0.7423283593270308,0.08833370353126542,0.2374310436269182,-0.12629629665767106,-0.08921196713288199,0.03020401218391426,-0.19340739101581367,0.1464366799454981,-0.127727695383259,-0.0868766151697655,-0.0861439495671923,-0.0669064576664147,-0.058143212790156926,-0.2971490629263277,0.2637676222381936,0.025746001619481297,SNPDiscovery,10
196,196,"ngs_backbone  pipeline  read clean map  snp call use next generation sequence
 possibilities offer  next generation sequence ngs platforms  revolutionize biotechnological laboratories moreover  combination  ngs sequence  affordable highthroughput genotyping technologies  facilitate  rapid discovery  use  snps  nonmodel species however  abundance  sequence  polymorphisms create new software need  fulfill  need   develop  powerful yet easytouse application  ngs_backbone software   parallel pipeline capable  analyze sanger  illumina  solid sequence  oligonucleotide ligation  detection sequence read  main support analyse  read clean transcriptome assembly  annotation read map  single nucleotide polymorphism snp call  selection  order  build  truly useful tool  software development  pair   laboratory experiment  public tomato sanger est read plus  million illumina read  employ  test  tool  predict polymorphism  tomato  clean read  map   sgn tomato transcriptome obtain  coverage    sanger    illumina  single nucleotide variations snvs  predict  total   snvs  experimentally validate    find   real ngs_backbone   new software package capable  analyze sequence produce  ngs technologies  predict snvs  great accuracy   tomato example  create  highly polymorphic collection  snvs     useful resource  tomato researchers  breeders
  architecture  ngs_backbone  create several characteristics  regard  important  use  standard file format  thirdparty free software tool modularity  extensibility analysis reproducibility  ease  use  facilitate interoperability   tool  input  output file   standard format   fasta fastq bam vcf  gff    produce  use   tool  instance    easy  view  map  annotation obtain  load  bam  gff file   viewer   igv  ngs_backbone use thirdparty tool  recognize quality   samtools  gatk whenever possible  order  maintain  quality   analyse  approach take  toll   installation process   order  make  less complicate   package  precompiled    third party tool   write  detail stepbystep installation manual   distribute   tool  modularity  also  important design aim   ngs_backbone architecture users demand  everchanging set  analyse   carry    analyse    adjust  every project  meet  requirement  collection  mapper function focus  different task   clean  annotate  create  function   common interface   take  sequence  generate  new modify sequence  constitute  step   pipelines   generate  runtime  every analysis finally even though   present ngs_backbone   commandline tool      way  use   underlie library  power  tool  call franklin   write  python  library   capabilities    time   expose   present command line interface   api  document  easy  use  python programmers   develop   script  tool  top    welcome     development   follow   github website    license  also open agpl result  discussion ngs_backbone pipeline algorithms  section describe  methods use internally  ngs_backbone  thirdparty software cite   suppose   run   user      use internally  ngs_backbone   couple  command backbone_create_project  backbone_analyze  suffice  complete  analysis  typical analysis carry   ngs_backbone start   set  sanger  illumina  solid read file  first step   read clean   process adaptor vector  lowquality regions  remove  exact algorithm use  every clean step depend   type  read  instance quality trim   long read    lucy     shorter read  internally implement algorithm  use instead   detail   host  readcleaning modules available refer   documentation distribute   tool    clean  finish quality  length distributions   create   raw  clean read   quality assessment   clean process   reference transcriptome  unavailable one   assemble   clean read  use  mira assembler  mira allow hybrid assemblies  sanger   illumina read ngs_backbone automate  preparation   mira project  run mira  obtain set  contigs may  annotate   available annotations microsatellite orf functional description  term intron location  orthologs   reference transcriptome  genome  available  read may  map onto    map  algorithm employ also depend   read length short read  map   standard bwa  algorithm   longer read use   bwtsw ngs_backbone generate  bam file    map read    generate bam file  process use samtools   picard    merge  adapt  gatk  run  custom code one frequent objective   project  use ngs sequence   look  sequence variation snps  small indels  improve  process  bam file realignment may    use gatk  prior   snv call   snv call  read   map quality lower     consider  allele qualities  calculate  use  quality   three  reliable read pq1 pq2 pq2 use  formula pq1   * pq2  pq3  method   slight variation   one use  mira   calculate  quality   consensus position  snv annotation take  account  accumulate sequence quality  every allele  well   map quality   read  threshold  set   parameters   position  two   highquality alleles  consider  snps  indels thousands  snvs  typically generate   bam file   order   able  select   useful ones  set  snv filter   develop table ​table1  code use  run  snv filter   custom code write  ngs_backbone  snvs finally obtain along   filter information  store   vcf file  table  ngs_backbone filter  snv selection description  pass condition        value maf        frequency   frequent allele   select pool allele  less          hvr        percentage  divergence   unigene  smaller   equal          ucr         duplicate  fragment regions  detect  blast         i30         distance  intronexon boundary  greater                   distance  end  unigene  greater                   distance  neighbor snps  greater          cef         snv   detect  endonuclease restriction                 select  kind  marker snp  indel                 frequency   frequent allele   select libraries  less          open   separate window although  analysis explain   typical one    step   fact optional  pipeline  several entry point  result one could start  raw sequence     clean  alternatively start   bam file  use  tool  call  snvs every analysis  independent   others   take  set  standard file  input  generate another set  standard file  output use  software tomato ngs_backbone analysis  test  tool  complete analysis   tomato transcriptome  carry    read clean   experimental snv validation   analyse   use ngs_backbone  public tomato sanger est read available   sgn  genbank databases   know tomato accession origins  include   study  addition   sanger sequence  million illumina read obtain   normalize cdna library build   equimolar mix  floral rna extract   tomato line   rp75  add additional file   remove  lowquality regions  vector  adaptor contaminants  million illumina   sanger sequence remain  mostrepresented tomato line  micro tom  sequence ta496  sequence   rp75uc82 mix  million sequence ngs_backbone calculate statistics  sequence feature   clean process figure ​figure11  external file  hold  picture illustration etc object name  jpg open   separate window figure  ngs_backbone statistical analysis sequence length distribution  clean sanger   illumina  sequence boxplot  quality pair base lecture  respect  sequence position  sanger   illumina  sequence alignment sequence coverage distribution  sanger   illumina  sequence  clean read  map   sgn tomato transcriptome   million illumina  well   sanger read  map obtain  average coverage     sanger     illumina sequence figure ​figure1  improve  alignment  realignment functionality provide  gatk   apply prior   snv call  snv annotation take  account  accumulate sequence quality  every allele  well   map quality   read  threshold  set   parameters   position  two   highquality alleles  consider  snps  indels   snvs find  report   vcf file additional file  despite satisfy  quality criteria   snvs seem equally reliable several filter  apply  tag   likely   real table ​table1  example   frequent allele frequency maf filter  apply   illumina set   ratio   alleles close    expect   case  two equimolar cdna sample  mix   case  mix correspond   tomato line   rp75   alleles present      expect  appear   ests  equal number  time   unigenes also  filter  label  snvs  highly variable regions hvr  apply  avoid unigenes   much variation   snvs  pass  filter  consider    higher likelihood   real  constitute   set table ​table2  snv count present   point    include  snvs    pass  filter unless explicitly state table  snvs detect                  snvs                         indels                         snps                         snvs_hvr4                         snvs_maf0                         snvs_hvr4_maf0                         open   separate window  sanger collection snvs detect  sanger sequence  illumina collection snvs detect  illumina sequence  higher likelihood collection snvs detect  illumina  sanger sequence  use snvs   experimental set    equally useful  easy  use depend   technique use  detect  several snv characteristics  ease  hinder  experiment like closeness   intron boundary  another snv    end   unigene also  snvs locate  unigenes    similar   unigenes  tag  avoid gene families  could make follow  pcr  primer design process difficult     apply  unique  continuous region filter i30  cl30 available   ngs_backbone filter collection table ​table1  filter apply  order  label  snvs  well   result obtain  show  table ​table3   snvs  pass  filter make   easily usable set  table  snvs select   different collections use different ngs_backbone filter                                  snvs                                         ucr                                         i30                                         cl30                                                                                  cs60                                         cef                                         open   separate window  sanger collection snvs detect  sanger sequence  illumina collection snvs detect  illumina sequence  higher likelihood collection snvs detect  illumina  sanger sequence  common collection snvs detect  illumina  sanger collections  polymorphic collection snvs   estimate frequency   common allele    easily usable snvs set snvs select use ucr i30  cl30 filter   also desirable  tag  snvs  high polymorphism  main advantage   highly polymorphic markers consist   ease  use across different individuals snvs   low pic polymorphic information content   low likelihood   different alleles  two randomly choose individuals  enrich  selection  highly polymorphic snvs  proportion  discriminate snvs   experiment deal   random collection  individuals  increase thereby reduce laboratory cost  polymorphism   population    correctly infer    extensive  wellgenotyped sample  individuals since ests convey genotyping information  different individuals ngs_backbone   crude estimate   polymorphism   snv  count  number  tomato accession    allele appear  reliability   infer polymorphism depend  among  parameters  number  individuals sequence take  account   snvs sequence   least six different tomato accession   snvs   frequency    common allele    include   polymorphic  set  set  small  spite   good sequence coverage  four   tomato accession   many sequence  available   tomato materials  intersection    set   easily usable one  produce  snvs  augment  number  putative highly polymorphic snvs less stringent criteria  also apply create  new set   variable snvs    illumina    sanger sequence regardless   estimate polymorphism  snvs  select     also present    selection table ​table3  snvs  denominate common     polymorphic   public est collection  well    illumina sequence  snvs find    polymorphic   sanger    illumina collections  name    respectively experimental validation  software predictions  quality    silico snv call  test   collection   tomato accession  include  commercial cultivars   tomato landraces additional file   technique use  genotype  materials  hrm pcr high resolution melt pcr   assign  melt curve   snv alleles  accession rp75    comprise  illumina est set  use  control  possible   polymorphism  expect   accession restriction enzyme polymorphism also predict  ngs_backbone  use  differentiate  alleles  total    silico snvs  experimentally test additional file    hrm technique  able  confirm    table ​table4  high success rate make  use    silicopredicted snvs possible even without  previous extensive experimental validation moreover  success rate    probability underestimate due   experimental technique use hrm pcr   able  distinguish  allele pair    quite likely    case  failure  detect     silicopredicted snvs  due   flaw   pcr table  statistics  assay snvs   different collections snvs        hrm detect         polymorphic markers        average frequency         pic                                                                                                                                                                      open   separate window  percentage  polymorphic markers number  polymorphic markers  respect  detect hrm markers  total markers   set  average frequency   frequent allele   detect markers  total markers   set  pic polymorphic information index   detect markers  total markers   set  high success rate  achieve despite  low coverage employ   sanger    illumina although   probably obtain   expense   low specificity    assess   experimental design present  parameters use    selection  even adjust    tag  unreliable  snvs  even though   support  enough coverage   regions  high variability   present  allele frequency    balance   equimolar rp75   illumina sample one   aim   study   devise  test  strategy  select   polymorphic snv subset  use   publicly available  well   new illumina ests although    possible    accurate pic estimate   use  collection  public sequence gather  different heterogeneous project  rough index relate  polymorphism might  calculate  count  number  individuals    allele appear despite several confound factor  low pic snv  tend  produce  offbalance individual count   different alleles  expect mean polymorphism   svn set  different pics  estimate  genotyping  tomato accession two snv set  use  define  polymorphism baseline  expect   polymorphismrelated filter apply   set   requirement    least two different alleles   illumina  sanger sequence   tomato collection  genotyped use snvs randomly select   set  find      snvs test   sanger set        illumina set  polymorphic    say    frequent allele frequency  lower    snv set   expect   somewhat  polymorphic   build  sieve  snvs   polymorphic    sanger   illumina sequence  set  well      set  sequence   least  plant  available   allele count  quite balance   set    markers test  polymorphic   clearly higher      find   polymorphism baseline   set  polymorphic information content pic  also expect   higher   one find   sanger  illumina set  pic     respectively    set  pic   fact higher  lastly  snvs   expect    polymorphic   ones    set    sequence   least  plant  available   allele count  quite balance  pic find   case     look  highly polymorphic snvs  final strategy pay  unfortunately  selection like  cannot   directly   nonmodel species  public ests   many case almost  sequence come    handful  different individuals  fact  even  public tomato sequence   much diversity    public sequence come    individuals give  result show  would recommend   look  snvs  number  individuals sequence  take  account",-0.1956132758711966,0.21103421559488705,0.14740250389776285,0.10377763229671293,-0.009495097204591057,-0.06081695482566076,-0.09389541370046044,0.05556301876443088,0.014617041156963375,0.1108296110340246,0.0031940183652241464,-0.04166104219900521,0.1467185217131331,-0.1272589928163709,0.12105000249995998,-0.022825525888929526,0.07174112030650166,0.16652436189482409,-0.022993502677821118,0.0991395069194555,-0.03456373689680774,-0.20169275570814055,0.06536528371462971,-0.028871150799704686,-0.02383648371632328,-0.1865697216549684,0.05826645306882445,-0.1285643267653619,-0.059059630341190675,-0.08114783913993805,-0.0025627053152331896,0.27683511821479195,-0.18037010119284086,-0.056927051719512074,0.22647871867359795,0.09742064904714534,0.056588935881848476,0.0021041936548704294,-0.07407662693707161,-0.11897142926236424,-0.08800454656502914,-0.1428704511164196,-0.09111286042931194,-0.12050848947768562,-0.1412062992379208,-0.05328371084592227,0.1444514455652579,-0.15310717425728815,-0.20665442094136266,-0.36361999035676457,0.15516048785652164,0.029524444930474368,0.04671629434678895,0.5752419527097364,0.022521617328065804,-1.1278392456518949,0.05338630515200067,-0.20824286231978503,0.97498030669483,0.13942778865334154,-0.14746802225012204,0.30909406654833543,-0.04892445264410363,0.07814051789217721,0.5788068360901925,0.03749083702811749,0.03384868885060489,0.017542406221499378,0.2155879271968957,-0.19568167680005974,-0.044295069018944734,-0.021218070316632257,0.12211332922458876,-0.14464535055002073,0.1800506228746057,-0.023658917777954192,-0.10359363139759084,-0.12686105197760436,-0.3707588770860862,-0.09637808891661644,0.21350673811340304,-0.046695756360819865,-0.35799712227379504,-0.04749843273097911,-0.8433133106332177,0.08656746117232,0.22449732327262106,-0.11479300353160499,-0.13274817886680984,-0.04004500879067118,-0.15107184278278374,0.08438877992903265,-0.10210933982755446,-0.11624914530467315,-0.14874592647107265,-0.05253590146482102,-0.09248661557065987,-0.3240637778083251,0.3214503329747205,0.1099995170609674,SNPDiscovery,10
197,197,"snphood investigate quantify  visualise  epigenomic neighbourhood  snps use ngs data
 vast majority   many thousands  diseaseassociated single nucleotide polymorphisms snps lie   noncoding part   genome   likely  affect regulatory elements   enhancers  promoters rather   function   protein  understand  molecular mechanisms underlie genetic diseases   therefore increasingly important  study  effect   snp  nearby molecular traits   chromatin  transcription factor bind  develop snphood  userfriendly bioconductor  package  investigate quantify  visualise  local epigenetic neighbourhood   set  snps  term  chromatin mark   bind sit use data  ngs experiments
snphood   opensource  package  core team    publicly available  bioconductor huber     build upon several   establish package  well  ggplot2 wickham   produce publicationquality visualisations snphood comprise  set  easytouse function  extract normalise quantify  visualise read count  enrichment  input   local neighbourhood  roi  snps across multiple sample  individuals ' functionalities  largely complementary   extend current tool use  chipseq data analysis qualitative comparison show  fig   instance  contrast  peak callers  identify regions  enrich signal snphood provide functionalities  perform indepth analyse   bind pattern  predefined roi group  accord   signal shape profile    data  provide test  allelespecific  genotypedependent bind pattern  resolution   bind pattern   control  userdefined window  bin size  define  local region surround  roi   size  individual bin within  neighbourhood   read count  quantify separately users   choose  different analysis function  detection  allelic bias across roi    implement  procedure  identify   significant bin within  region control   empirically determine fdr  exploration  visualisation  genotypedependent bind pattern include generation  publicationquality figure  unsupervised clusteringbased  iii optionally genotypedependent comparisons  group   bind pattern across roi  sample methodological detail   functionalities   find   snphood vignette   external file  hold  picture illustration etc object name  btw127f1pjpg open   separate window fig   snphood overview comparison  distinction  snphood  regard  commonly use tool  chipseqrnaseq data green yellow  red feature fully partially   support respectively  visualisation   asb region  plot   direct output  snphood upper panel overview  asb   snps within  particular genomic location  chr21 across two datasets base   fdr threshold     snp   significant pvalue log10 transform across  bin  show lower panel  detail view around  snp rs2822749 vertical line   individual gm10847  summarise  allelic fraction estimate  confidence intervals top  log10 pvalue   binomial test within  bin middle   read count   bin  well   genotypes   snp position   different alleles bottom  input  require   set  bam file   chipseq   list  genomic positionsroi  gwassnps  optionally iii correspond genotype data  available snphood also allow background normalisation  input dna  employ  chipseq peak callers   macs2 zhang     snphood application example   briefly illustrate  functionalities  snphood   typical workflow example   comprehensive documentation   functionalities  refer  reader   snphood workflow vignette   start   set  rois   case snps    identify  histone quantitative trait loci hqtls within  yoruba yri population grubert     aim  determine  many yri hqtls also show asb within  caucasian population ceu     employ snphood  h3k27ac chipseq data  two ceu individuals kasowski    around  hqtl snps  quantify  allelic bias  find     share heterozygous snps show significant asb   empirical fdr ~  investigate    asb events   detail  use  function plotallelicbiasresultsoverview   highlevel overview   allelic bias across  chromosomal region  visualise  bind pattern  specific roi  employ  function plotallelicbiasresults fig   reveal   select region harbour two asb peak potentially affect    snp  analyse would involve cluster   roi  identify common pattern similar    perform  grubert    despite  name snphood  flexible    apply   roi  believe      helpful tool  generate new biological hypotheses  integrate molecularphenotype data   unbiased  positionspecific manner",-0.18005779711999978,0.19981145649457152,0.07270533798371445,0.1442138050907834,0.027535318648238803,-0.02485394070900174,-0.11880443464872124,0.02088132683150094,-0.014547441859481862,0.10994309400245923,-0.06744737209209714,-0.052325675733091916,0.22160431103530395,-0.06623853627013776,0.1639770342316165,0.06209972540625318,0.07489603553994273,0.12398850309854782,-0.04132767498527688,0.07435658620631241,-0.04597979243248952,-0.22448303470362968,0.06782934845892417,-0.011881040161873779,-0.0566863929535347,-0.22928244927553115,0.1414113699971825,-0.10184080844512994,-0.061488580469121236,-0.016688733101392836,0.03426404172195567,0.22077071320920907,-0.1377741889050152,-0.08813298882860518,0.21095562721085215,0.03156753136111605,0.08265497151218193,0.04348927410437039,-0.09551479889907773,-0.08903307833172606,-0.12850908276402334,-0.15260346820629914,-0.07739301255503545,-0.09606995650720766,-0.17727854810278826,-0.02975429975120382,0.11501699072553673,-0.0327547326578558,-0.2540831598076932,-0.3087892297871712,0.10882063207501916,0.0240122885419752,0.052217124237738534,0.5203246000200912,-0.0036606371601861634,-1.0412119559042927,0.041225129893670484,-0.2565386049552924,0.8841978602945454,0.17345964752125118,-0.1439911364465019,0.3751187352181384,0.021395478859349386,0.05052039218025426,0.5915272956469444,0.046229476095036116,-0.00741270763237266,0.023111366321919145,0.20667088841266854,-0.1585335042241409,-0.04237388783356817,-0.015625457922118224,0.0899757646562795,-0.1830264560781068,0.13656032711190252,-0.09077179057269613,-0.06122607311864167,-0.14262369732444585,-0.3667201427676204,-0.09479209951771153,0.2008502597290308,-0.009761330624571955,-0.3028142261036644,-0.02589040963894057,-0.7890654525622375,0.09493851936453646,0.18680882876933325,-0.07442940420452318,-0.08007983712053007,-0.04117428299873716,-0.21516290872580426,0.046213411548494766,-0.1030773306457539,-0.09741232312293817,-0.06496843503702272,-0.016472181850912596,-0.13968161650955274,-0.3688078858083748,0.3142657363532512,0.1032968652356253,SNPDiscovery,10
198,198,"fastgbs  new pipeline   efficient  highly accurate call  snps  genotypingbysequencing data
nextgeneration sequence ngs technologies  accelerate considerably  investigation   composition  genomes   function genotypingbysequencing gbs   genotyping approach  make use  ngs  rapidly  economically scan  genome    show  allow  simultaneous discovery  genotyping  thousands  millions  snps across  wide range  species   users  main challenge  gbs   bioinformatics analysis   large amount  sequence information derive  sequence gbs libraries  view  call alleles  snp loci herein  describe  new gbs bioinformatics pipeline fastgbs design  provide highly accurate genotyping  require modest compute resources   offer ease  use fastgbs  build upon standard bioinformatics language  file format  capable  handle data  different sequence platforms  capable  detect different kinds  variants snps mnps  indels  illustrate  performance  call variants  three collections  sample soybean barley  potato  cover  range  different genome size level  genome complexity  ploidy within  small set  sample  call        snps  soybean barley  potato respectively  assess genotype accuracy  compare  gbsderived snp genotypes  independent data set obtain  wholegenome sequence  snp array  analysis yield estimate accuracies       soybean barley  potato respectively  conclude  fastgbs provide  highly efficient  reliable tool  call snps  gbs data
 fastgbs analysis pipeline  develop  integrate public package  internally develop tool  public package include sabre demultiplexing  cutadapt read trim  clean  bwa read map  samtools file conversion  index   platypus postprocessing  read haplotype construction  variant call  fastgbs function  software tool  present  fig  fig  figure1 schematic representation   analytical step   fastgbs pipeline  main step   analytical process  indicate   central portion   diagram   different software tool use  indicate   leave  input  output   step   right full size image create directory structure  develop  bash script  create  directory structure  run  fastgbs pipeline  command line create  directories  data fastq file barcodes key file reference genome  result fastgbs output input  input data  sequence dna fragment   restriction enzymebased gbs protocol fastgbs handle raw sequence data  fastq format prepare  parameter file  parameter file   text file contain key information   analysis include  path   fastq file barcodes  reference genome  also contain information   type  sequence pair  singleend  adaptor sequence   sequence technology   file   define critical filter options    minimal quality score  read minimal number  read require  call  genotype  maximal amount  miss data allow number  cpu name  output file  also define   file  file come   fastgbs pipeline data demultiplexing  cost efficiency  gbs  partly due   multiplexing  sample   result pool read  need   demultiplexed prior  snp call fastgbs use sabre   demultiplex barcoded read  separate file  simply compare  provide barcodes   ′ end   read  separate  read   appropriate barcode file   clip  barcode   read   read     recognize barcode   put   “unknown” file sabre also   option   allow mismatch within barcodes sabre support gzipped input file  demultiplexing sabre output   summary log file   many read go   barcode file trim  clean  demultiplexing fastgbs use cutadapt  find  remove adapter sequence primers   type  unwanted sequence  highthroughput sequence read  read map algorithms fastgbs use  mem maximal exact match algorithm implement  bwa  work  seed alignments   extend seed   smithwaterman  algorithm use  affine gap penalty   algorithm  perform local alignment  read      1mbp  algorithm  perform parallel alignment thus markedly increase  speed   analysis  ability  align read  variable size allow  use  data obtain use different sequence platforms illumina ion torrent etc align read may  gap  allow  indels postprocessing  map read  initial alignment  map read   process  platypus   order  improve  sensitivity  specificity  variant call  postprocessing seek  improve  quality  map  perform  reexamination  poorly map read  read map  multiple locations platypus classify poorly map read  three categories  read  numerous mismatch high level  sequence errors  read map  multiple locations   genome    remain linker  adaptor sequence cause poor map variants call use  potentially incorrectly map read see next step  highlight use  badreads flag haplotype construction  variant call  fastgbs variants  call use platypus unlike alignmentbased variant callers  focus   single variant type snp  indel platypus use multisample variant call  help  exploit information  multiple sample  call variants  may  look reliable   single sample  approach decrease  errors around indels  larger variants mnps  first  local assembler look   small window ~    time  use   read   window  generate  color  bruijn graph  use  candidate variants  generate  exhaustive list  haplotypes candidate haplotypes  generate  cluster  candidate alleles across windows haplotype frequencies  estimate   expectationmaximization  algorithm  variants  call use  estimate haplotype frequencies  approach work   local haplotype level rather    level  individual variants   well  highly divergent regions  also decrease computational requirements variant  individuallevel filter platypus  originally design  use  detect variants  human mouse rat  chimpanzee sample  optimize platypus options   context   analysis  gbsderived singleend read  modify several options see   detail  platypus options    filter use  fastgbs variant call step  number  read  per locus default   map quality score  read  call  variant  ≥  minimum base quality default   mnps distance minflank    maximum miss data maxmd allow default ≤  see fastgbs user manual   full description   filter options output data  main output file  fastgbs  avcf file  contain detail information     variants  addition fastgbs also generate  simple text file contain   genotypic data  fastgbs log file contain  complete step   pipeline    run  case   error occur  prematurely terminate  run   pipeline  log file show  step    analysis stop  analysis   start   point   exist intermediate file simply  create  log file    previously complete step  list fastgbs  reinitiate  analysis start   point onwards",-0.19991705595321432,0.23742721184902146,0.0972633533786037,0.11592392259341938,0.04006531626875249,-0.04678857937308393,-0.11628146129774193,0.057630083927348176,-0.01606811864336993,0.14361520249867285,0.022520793610728226,-0.04736730424171938,0.1410895878243339,-0.1177791895125942,0.1558286681911736,0.024824388309397087,0.0605885276125501,0.1786068371955322,0.00882287126043356,0.045194913954891607,-0.0558607336329853,-0.2270907107664717,0.1082416748218036,0.008176464736132639,0.029293352325507643,-0.1907662390756583,0.08826653049072775,-0.08513092211417286,-0.07232058449825791,-0.04323857251311774,0.023290968985985157,0.27101034999182244,-0.17578957876519227,-0.07005807424360208,0.24913862612170895,0.08872872543123896,0.021970507900455825,-0.003305017449905711,-0.07934366272314472,-0.06418084557916028,-0.06583274756580383,-0.1866884847086903,-0.1116857099619744,-0.09641416180586572,-0.14128324849930915,0.004859948001230014,0.11735669224277526,-0.1539251355741568,-0.1767697048013835,-0.30685478419099643,0.1417176436162149,0.05966241412573689,0.052464327606645864,0.6028825137409908,0.00962400455271405,-1.1434934938518817,0.05073740062245792,-0.2174310662316123,1.033298954775724,0.15802431228234048,-0.15696372138787093,0.33384248819967743,-0.06010656794545788,0.08660308479343455,0.5917360160940165,0.032413574140699224,0.006380695277703521,-0.010249842092256902,0.2578617352252838,-0.16942286270631998,-0.07238239892016597,-0.0048739913011598655,0.12805949451435678,-0.16184823179830107,0.22014373847101207,-0.03508126219600419,-0.08733407399078083,-0.08924118403408852,-0.3612707120229733,-0.06877822913330696,0.22401583088282245,-0.07771006485729784,-0.37953593674667546,-0.06576103697775777,-0.8568720999303522,0.10855831152951832,0.2371290729250809,-0.15214426536555908,-0.10596879574475916,-0.00716653432154208,-0.16662607657433354,0.1088490591764244,-0.1123189731132816,-0.08907023496399431,-0.10402487096839848,-0.08569924089090858,-0.10158161526709117,-0.33671453840899,0.3510884690862756,0.06664230226369514,SNPDiscovery,10
199,199," universal snp  smallindel variant caller use deep neural networks
despite rapid advance  sequence technologies accurately call genetic variants present   individual genome  billions  short errorful sequence read remain challenge   show   deep convolutional neural network  call genetic variation  align nextgeneration sequence read data  learn statistical relationships  image  read pileups around putative variant  true genotype call  approach call deepvariant outperform exist stateoftheart tool  learn model generalize across genome build  mammalian species allow nonhuman sequence project  benefit   wealth  human groundtruth data   show  deepvariant  learn  call variants   variety  sequence technologies  experimental design include deep whole genomes   genomics  ion ampliseq exomes highlight  benefit  use  automate  generalizable techniques  variant calling
calling genetic variants  ngs data  prove challenge  ngs read    errorful  rat  ~  result   complex error process  depend  properties   instrument precede data process tool   genome sequence itself1 stateoftheart variant callers use  variety  statistical techniques  model  error process  thereby accurately identify differences   read   reference genome cause  real genetic variants   arise  errors   reads3  example  widelyused gatk use logistic regression  model base errors hide markov model  compute read likelihoods  naive bay classification  identify variants    filter  remove likely false positives use  gaussian mixture model  handcraft feature capture common error modes6   techniques allow  gatk  achieve high  still imperfect accuracy   illumina sequence platform3 generalize  model   sequence technologies  prove difficult due   need  manual retuning  extend  statistical model see  ion torrent8  major problem   area   rapid technological progress1    describe  variant caller  ngs data  replace  assortment  statistical model components   single deep learn model deep learn   revolutionary machine learn technique applicable   variety  domains include image classification10  translation11 gaming12   life sciences14  toolchain   call deepvariant figure  begin  find candidate snps  indels  read align   reference genome  highsensitivity  low specificity  deep learn model use  inceptionv2 architecture5  emit probabilities     three diploid genotypes   locus use  pileup image   reference  read data around  candidate variant figure   model  train use label true genotypes     freeze     apply  novel sit  sample throughout  follow experiment deepvariant  train   independent set  sample  variants    evaluate  deep learn model   specialize knowledge  genomics  nextgeneration sequence  yet  learn  call genetic variants  accurately  stateoftheart methods  apply   platinum genomes project na12878 data18  deepvariant produce  callset  better performance   gatk  evaluate   heldout chromosomes   genome   bottle grind truth set figure    validation  sequence  replicate  na12878 use  standard wholegenome sequence protocol  call variants   replicate use  gatk bestpractices pipeline  deepvariant use  model train    eight replicate see methods    deepvariant produce  accurate result      greater consistency across  variety  quality metrics figure    confirm  performance  deepvariant  submit variant call   blind sample na24385   food  drug administrationsponsored variant call truth challenge  may   win  ""highest performance"" award  snps   independent team use  different evaluation methodology like many variant call algorithms gatk rely   model  assume read errors  independent6  though longrecognized   invalid assumption2   true likelihood function  model multiple read simultaneously  unknown6  deepvariant present  image     read relevant   putative variant together  convolutional neural network cnn  able  account   complex dependence among  read  virtue    universal approximator21  manifest    tight concordance   estimate probability  error   likelihood function   observe error rate  see  figure   deepvariant' cnn  well calibrate strikingly     gatk   cnn  approximate  true  unknown interdependent likelihood function   essential technical advance enable   replace  handcraft statistical model   approach   single deep learn model  still achieve  high performance  variant call   explore  well deepvariants cnn generalize beyond  train data first  model train  read data align  human genome build grch37  apply  read align  grch38  similar performance overall     one train  grch38   apply  grch38 overall    thereby demonstrate   model learn  one version   human genome reference   apply   versions  effectively  loss  accuracy table  second model learn use human read  grind truth data achieve high accuracy  apply   mouse dataset22    outperform train   mouse data     table   last experiment  especially demand      species differ  nearly    sequence parameters   well  2x148bp   illumina truseq prep sequence   hiseq    human sample   2x100bp read   custom sequence preparation run   illumina genome analyzer   mouse22 thus deepvariant  robust  change  sequence depth preparation protocol instrument type genome build  even species  practical benefit   capability  substantial  deepvariant enable resequencing project  nonhuman species  often   grind truth data  guide  efforts22  leverage  large  grow grind truth data  humans   assess  capabilities  train deepvariant  call variants  eight datasets  genome   bottle24  span  variety  sequence instrument  protocols include whole genome  exome sequence technologies  read lengths  fifty  many thousands  basepairs table     use  already process bam file  introduce additional variability   bams differ   alignment  clean step  result   experiment  exhibit  characteristic pattern  candidate variants   highest sensitivity   low ppv mean   vary significantly  dataset  retrain    callsets achieve high ppvs mean    largely preserve  candidate callset sensitivity mean loss    high ppvs  low loss  sensitivity indicate  deepvariant  learn  model  capture  technologyspecific error process  sufficient detail  separate real variation  false positives  high fidelity  many different sequence technologies   already show   deepvariant perform well  illumina wgs data  analyze   behavior  deepvariant  two nonillumina wgs datasets  two exome datasets  illumina  ion torrent  solid  pacific biosciences pacbio wgs datasets  high error rat   candidate callsets solid  ppv  snps   indels   overall  many snp artifacts   map short colorspace read  pacbio dataset   opposite  many false indels  ppv  snps   indels   overall due   technology' high indel error rate train deepvariant  call variants   exome  likely   particularly challenge exomes  far fewer variants ~  find   wholegenome ~  nonuniform coverage  sequence errors   exome capture  amplification technology also introduce many false positive variants27  example    ppv   candidate variants  ion ampliseq   lowest    datasets despite  low initial ppvs  retrain model  deepvariant separate errors  real variants  high accuracy   wgs datasets ppvs      solid  pacbio respectively though   larger loss  sensitivity candidates   final   solid      pacbio   technologies despite  challenge  retrain deep learn model  limit data  exome datasets also perform strikingly well   small reduction  sensitivity          ion  truseq candidates  final call   substantial boost  ppv          ion  truseq  performance  deepvariant compare favorably    callsets submit   genome   bottle project site use tool develop specifically   ngs technology   callsets produce   gatk  samtools table   accuracy number present  '  view   maximum achievable  either  sequence technology  deepvariant  consistency  use   model architecture image representation train parameters  candidate variant criteria   technology  deepvariant achieve high ppvs   technologies  overall accuracy     harmonic mean  sensitivity  ppv  effectively drive   sensitivity   candidate callset improvements   data process step  deepvariant   algorithm use  identify candidate variants  likely translate  substantial improvements  overall accuracy particularly  multiallelic indels conversely despite  effectiveness represent variant call  image  apply general imageclassification model  certainly suboptimal    unable  effectively encode    available information   read  reference   fourchannel image  accuracy  deepvariant  likely improve  transition   expressive tensorbased28 model specialize  genomic data take together  result demonstrate   deep learn approach employ  deepvariant  able  learn  statistical model describe  relationship   experimentally observe ngs read  genetic variants   data  potentially  sequence technology technologies like deepvariant change  problem  call variants   laborious process  expertdriven technologyspecific statistical model    automate process  optimize  general model  data  deepvariant create  ngs caller   new sequence technology become  simpler matter  develop  appropriate preprocessing step train  deep learn model  sequence data  sample  grind truth data  apply  model  new even nonhuman sample   core deepvariant  generate candidate entities  high sensitivity  low specificity  represent  experimental data   entity   machinelearning compatible format    apply deep learn  assign meaningful biological label   entities  general framework  infer biological entities  raw errorful indirect experimental data  likely applicable  many  highthroughput instrument",-0.1649398758662146,0.22364768132065055,0.11556453953313013,0.14054782992488155,-0.012581212766654871,-0.07989731336299953,-0.07258022950342452,0.012192422474870344,-0.021992442924355184,0.109961822476872,-0.02946814548454457,-0.05868665509861914,0.1677644401309698,-0.1195195757980354,0.1262312750893214,-0.02672779554889801,0.07581350243287102,0.2044458272474649,-0.01593460396757196,0.10239407533521803,-0.02252015815929649,-0.21157226392661613,0.050686024724019514,-0.024384396869628188,-0.04392443479769263,-0.1494099094180969,0.07778971722035967,-0.13500232487497554,-0.06986477486119777,-0.03967209551725207,0.019580459458473868,0.2232613981160952,-0.1987239208838353,-0.0703469536779276,0.2154988503821581,0.05666719290972284,0.03506682590378673,0.019475112485071253,-0.09922041373790574,-0.10457372740087673,-0.08767768211739559,-0.111424602496436,-0.1050796946759255,-0.08815447797572504,-0.16625006110840584,-0.04173811304440326,0.16629310365102745,-0.11379651451882332,-0.22457520547249094,-0.337434627405165,0.11880792462071067,0.025150963543049392,0.054923533085545616,0.5812578276026182,0.07768063687699223,-1.0879218432536428,0.09187588461204166,-0.17796151162855905,0.8980088282441011,0.1480807261168612,-0.15455095847430772,0.3341460206041372,-0.0796569019755896,0.023408481791658803,0.5343906818687262,0.0517242542201216,0.009746163528416028,-0.023969555698457247,0.22021109293545765,-0.17212370638199048,-0.020630250550534805,-0.029281426560471863,0.08742700977196541,-0.11358333996499065,0.188022430484571,-0.055478301517769744,-0.09788588077237488,-0.14494919347508867,-0.3618686068232071,-0.0717500583394993,0.21331483880417268,0.014140165427672118,-0.3232835900138406,0.007513539464373917,-0.8644038320853262,0.08745420524561541,0.22357432199071064,-0.10664291275272847,-0.16653270166119696,-0.07104338371085621,-0.16294326905440368,0.0653967681554168,-0.11452011494571443,-0.076864508430062,-0.08994105303843149,-0.07062443449525221,-0.1718546864628323,-0.3362461760463922,0.3215166052264884,0.12796953957514093,SNPDiscovery,10
200,200,"snpaamapper  efficient genomewide snp variant analysis pipeline  nextgeneration sequence data
many ngs analysis tool focus  read alignment  variant call function  exome sequence data   develop  recent years however publicly available tool deal   downstream analysis  genomewide variants  fewer   limit functionality  develop snpaamapper  novel variant analysis pipeline   effectively classify variants  region  cds utrs intron upstream downstream predict amino acid change type  synonymous nonsynonymous mutation  prioritize mutation effect  cds versus utrs additional functionality afford   pipeline include check variants  exonintron junctions customize homozygosity  allele frequency cutoff parameters  annotation  know variants  dbsnp information list original  mutate amino acid sequence contain variants  final result  report   spreadsheet format table contain  variant associate information  prioritize amino acids effect  investigators  examine
several initial data process step  use  annotate  variants first  short read sequence  align   reference genome use bwa    samtools package   use  call variants snps  indels second depend   biology question  ask several intermediate  filter stepsparameters could  apply  select  filter  variants   algorithms  call  filter variant call format vcf file  use   input   process  overall view   snpaamapper  show  figure    two major algorithms involve  classify variants  regions   variant analysis pipeline algorithm  generate  new annotation table  “coding”   information annotate   exon  follow  university  california santa cruz ucsc internal database  annotation coordinate zerobased start  onebased end  populate andor calculate  start  end   feature cod region sequence  cds upstream  downstream sequence untranslated regions  utrs intron   exon feature  annotate accord   “neighboring”  derive feature annotation coordinate   ucsc  example   “intronstart”  calculate   previous exonend   onebased annotation  ucsc annotation  “intronstart”   onebased  well  external file  hold  picture illustration etc object name  97320630009870f1jpg open   separate window figure   snpaamapper analysis pipeline workflow  configure file generate  algorithm   read  algorithm   assign identify variants   genomic locusgenes   classify  variants  regions   two subalgorithms  algorithm  algorithm2sub1 generate  list  feature cds upstream downstream utrs  intron annotation file     genomespecies specifically two pair file feature_start  feature_end  feature_start  ucsc gene    feature  one main file chromosome_number  feature_start  produce  describe   start coordinate  every chromosome   feature main file  record  sort   purpose  quickly locate variants genomic coordinate   genome  “end coordinate”  associate ucsc gene ids correspond  every start annotation   feature  store  two separate file algorithm2sub2 use  annotationsfiles  map identify variants onto  genomic location  report annotation class  download  human hg19 proteincoding genes full cod region sequence cds exons include introns  cdss   genomic coordinate annotate   begin  end  cdss   ucsc genome browsers “gene  gene prediction” data track   download output sequence type  set  “genomic”   also stipulate download sequence format  “exons  upper case everything else  lower case”  easy manipulation  also download ucsc annotation table “kgxreftxt”  convert  ucsc knowngene   hugo gene symbol  final report  pipeline use genomic coordinate  automatically classify variants  regions nonsynonymous missense nsm nonsynonymous nonsense nsn  synonymous syn mutation   hit fall   cds upstream downstream     utr  intron region  ucsc “knowngenetxt”  “kgxreftxt” annotation file  ucsc genome browser  use  obtain  information relative   genomic location  gene  detect variants  final mutation effect  prioritize accord   category order list  snpaamapper input  output  current snpaamapper pipeline accept  vcf input file  tabdelimited format  current final output file consist   follow columns sample number chromosome number variant genomic position start gene symbol ucsc gene  variant map strand amino acid position  mutation  cds hit variant type snp  indel reference amino acid  codon → mutant amino acid  codon variant class syn nsm  nsn reference amino acid sequence mutate amino acid sequence hit type cds upstream downstream utrs  intron hit dbsnp    know reference nucleotide alternative  call nucleotide quality depth allele frequency read categories   useful information  variant call result  sample output  snpaamapper   ngs dataset  show   additional illustration caveats  future development  pipeline provide  convenient tool  allow detect variants    elucidate  pipeline facilitate  fast downstream analysis  detect variants  believe  pipeline  supply researchers   convenient downstream interpretation  identify variants  compare  snpeff   opensource state   art variant effect predictor tool although  performance  similar snpaamapper   functionality  annotate regulatory variants   mutation effect prioritization step  snpaamapper also greatly simplify downstream analysis snpaamapper provide maximum flexibility  allow analysis  ngs read data generate   short long singleend  pairedend protocols  different ngs sequence platforms current version  snpaamapper process  vcf file generate  samtools   earlier version   also  easytouse pipeline  process vcf input data researchers  easily run  pipeline command  set  customize parameters  prioritize  snps  wetlab validation  initial pipeline  write  human data     easily modify andor extend   species also  current pipeline  report detail annotation information   snp variant class well extend  algorithmspipeline  handle indels  pipeline  also freely available  academic users  use users  download  input file onto  machine  run  pipeline  long  perl  instal",-0.17158925095025232,0.16282267260311847,0.11834658552541458,0.07045144997839888,0.06766435324362892,-0.03764015963064448,-0.08206830101538934,0.015184480672408091,0.027099954486239253,0.08727975166907344,0.0333597099606017,-0.015730985468786915,0.13841456361187066,-0.08195352686955464,0.1218037969971958,0.04861799161349591,0.09820909628892552,0.15971695387108112,-0.020563952410078228,0.08753624027767926,-0.06575463761232403,-0.19370357536829014,0.09708366179319773,0.027622082082182742,-0.03057096725302365,-0.19335587560804704,0.057286610073754525,-0.1435910236867485,-0.0190899703498849,-0.0163603627799445,0.022266793353108244,0.29106146287628604,-0.18127591001596474,-0.05576109415024147,0.17165048342551706,0.053169876886690295,0.006485166297014514,-0.013901707554458072,-0.048989723222625764,-0.09858103790363706,-0.05911013709767592,-0.14743995566555226,-0.09165566338366042,-0.10252790794968776,-0.1163756659120356,0.022917286928270254,0.07298677627320889,-0.17476179094728508,-0.18913067770806852,-0.2637135501390168,0.15211168731218233,0.0716506601113036,0.059930633523590834,0.5023086091428534,0.01796471702595221,-1.0487044017110307,0.02435903778536124,-0.17194184989217184,0.9076223275086289,0.20634454513794376,-0.1563887280364623,0.3440331509412517,-0.0068599629521261096,0.03608811836838924,0.5687301728170546,0.06364180764504895,0.02126745440227329,0.05558709125827433,0.2008703847649297,-0.16969444599177766,-0.04914077340362842,-0.01783995277865721,0.1249419614952346,-0.17496041444219626,0.15126158309316165,-0.03318410475187626,-0.11526550521105294,-0.1114851202572128,-0.34007701151421776,-0.1346032814617952,0.17188681955139326,-0.12475453023207675,-0.3663546400333556,-0.058540059820512434,-0.7844813323670554,0.11816237921229687,0.21653049448851047,-0.16004734001938406,-0.1154021740757324,0.004070754631331635,-0.14157077720357775,0.1252818094359584,-0.14050358421192288,-0.10862856714095308,-0.1102326620750752,-0.06123070387261986,-0.08841692219811258,-0.3088044876970881,0.3215655559814829,0.09203230020022106,SNPDiscovery,10
201,201,"machine learn   effective method  identify true snps  polyploid plants
single nucleotide polymorphisms snps  many advantage  molecular markers since   ubiquitous  codominant however  discovery  true snps  polyploid species  difficult peanut arachis hypogaea    allopolyploid     low rate  true snp call  large set  true  false snps identify   axiom_arachis  array  leverage  train machinelearning model  enable identification  true snps directly  sequence data  reduce ascertainment bias  model achieve accuracy rat   use real peanut rna sequence rnaseq  wholegenome shotgun wgs resequencing data   higher  previously report  polyploids   least  twofold improvement  peanut   snp array axiom_arachis2  design use  approach result   accuracy  call snps  different tetraploid peanut genotypes use  method  simulate snp variation  several polyploids model achieve  accuracy  select true snps additionally model build  simulate genotypes  able  select true snps   accuracy use real peanut data  work accomplish  objective  create  effective approach  call highly reliable snps  polyploids use machine learn  novel tool  develop  predict true snps  sequence data designate  snp machine learn snpml use  describe model  snpml additionally provide functionality  train new model  include   study  customize use designate snp machine learner snpmler
data set  resequencing data set  create use  tetraploid  hypogaea genotypes describe  clevenger      deposit publically  ncbinlmnihgov bio project prjna340877  bio sample samn05721179  samn05721198  rnaseq data set  information  nine tetraploid peanut genotypes describe  clevenger       validate true  falsepositive snp set  base  test  arachis affymetrix array   peanut genotypes  map parameters  extract   vcf file use   original design   array  position  snps  surround sequence  base    duranensis   ipaensis  pseudomolecules   create  test  new affymetrix array base  snpml  new affymttrix array  design contain  snps   extract  snpml use peanut real data resequencing model  neural network  tree bagger  table  previously describe  genotypes alongside   genotypes   minicore peanut line   assay   array    snpmlderived markers  manually curated  polymorphism  total   markers  validate  polymorphic  genotypes  create  test  machine learn model  data set  prepare   statistical software  extract  attribute randomly create train  test set  prepare fasta file  snp flank segment various toolboxes  matlab r2015b  university  georgia campuswide site license agreement  use  different purpose bioinformatics toolbox  use  calculate  thermodynamic parameters molecular weight   content statistics  machine learn toolbox  use  create  test  different model  supervise machine learn  graphics function  use  produce  bar plot  roc receiver operate characteristic graph  specific arguments   different machine learn model  give   table snpml construction  build pair neural network   specific trainer model   two data type wgs resequencing  rnaseq  model  build  store  four file   python script  addition three  class  build vcfh csv_writeh  csvh  process vcf  csv file  snpml main step  illustrate  fig   use  class vcfh  extract  eight select attribute   input file    vcf file   output  snp call  mpileup  samtools either directly   primary filtration  sweep  output  save use   class csv_writeh   csv file   read   python script   apply  one pair  store model two file one  neural network      depend   data type  two score set  save   csv file   read   class csvh  score  filter  pass  snps    value higher   cutoff  neural network    select   user  default    occur   two score set share snps   output   neural network   score file  case  user select  option  score  store  csv file   correspond snps  store   vcf file fig  download figureopen  new tab fig  snpmlsnpmler infrastructure  extend  program applications  second tool  design designate snpmler pronounce snip miller  allow users  create predictors   suitable  interest speciesexperimental condition snpmler use readingwriting approach  describe   take validate truepositive  falsepositive vcf file  input  generate predictor model  output  tool snpml  snpmler allow  user  skip  select    eight attribute   apply new user define attribute  csv file snpml requirements  script  write    python   file   use  process  data input output  filter  binary file  create  gcc    run  red hat  linux system python  use  create  neural network  bag machine learn model  apply  prediction use  different python package  use   purpose  numpy scipyorg scipy scipyorg pandas pandaspydataorg pythondateutil pypipythonorg pytz pypipythonorg scikitlearn scikitlearnorg  pyrenn  pyrennreadthedocsio create  test model use simulate data  pseudo molecule assembly ad1_bgi  cotton   pseudomolecule assembly    chromosome  wheat   contigs  tgacv1 wheat genome   pseudomolecule assembly  fragaria vesca genome      contigs   nipponica genome  fni_r1  nubicola genome  fnu_r1   orientalis genome  for_r1   download  random loci  assign  chromosomes aradua01 at_chr1   lg1  peanut cotton wheat  strawberry respectively  loci  randomly mutate five time  form five synthetic genotypes use art tool  hiseq   pair end sequence  different depths     generate  fastq produce file  map use bwa    default parameters  synthetic reference  follow  synthetic tetraploid reference contain aradua01  araipb01 chromosomes  peanut  synthetic tetraploid reference contain at_chr1  dt_chr1  cotton  synthetic hexaploid reference contain  chromosome   contigs     genomes  wheat   synthetic octoploid reference contain lg1 chromosome   contigs  fni fnu   genomes  strawberry snps  call use samtools mpileup   bcftools   default parameters without filtration  snp call  carry  twice  every species snps  two genotypes  call   first instance  snps among  five genotypes  call   second   species  snps locate among   loci  extract   separate vcf file  consider   truepositive  snps  others identify   program  extract  another vcf file  consider   falsepositive  snps seventy percent   one  randomly select  combine   use  train set   remain   use  test set  neural network model use matlab r2015b  university  georgia campuswide site license agreement test simulate data   real data  peanut  synthetic genotypes   depth  generate  snps  call  four batch three  five  one  six genotypes  simulate data  use  train  model  mimic  condition   real data  set      simulate data  use  train  model  increase  strength   test set   real data  reapplied   simulate model  generation  synthetic genotypes  carry   machine learn train  test  apply  describe ",-0.14694417254238,0.20801495527914005,0.05424767218136459,0.035354712311683016,0.0254309146780798,-0.03888752663003155,-0.007597702908855496,0.058766479913951064,-0.038508569828909565,0.11365642135484105,0.016322796071047,-0.0273487629001261,0.1319974271130612,-0.0685009413916785,0.11823764434282134,0.029480385653585656,0.10729586761623028,0.1798361059699438,-0.017679873057981178,0.06868670101923699,-0.03352024963222381,-0.1897692169948825,0.059468381106853485,-0.009012239710480142,0.01936192672799101,-0.16521964941809494,0.06788370158903306,-0.11166038440757567,-0.062472321392050716,-0.03113392992579545,-0.010808672871881458,0.27027262402685315,-0.1383096092548012,-0.05400862326725187,0.2045074712689129,0.06498811463171386,-0.010703395655459795,0.015483168437763043,-0.033311430825276316,-0.10777700055793472,-0.04290888812200015,-0.11365564282312518,-0.05064288600448655,-0.10124342580550884,-0.10810557115571888,0.013081354847007164,0.04887004851591402,-0.13754668350733215,-0.2135310412042518,-0.2544808450447307,0.04884068377275449,0.026964439856139628,0.03685341579403848,0.4952817368739693,0.0060314700407044074,-0.9606023960108504,-0.0017570876114180293,-0.16286446141233415,0.8754410978128383,0.1738635202805352,-0.12992723961695934,0.2929830414375808,0.005373206539628922,0.0689432891824785,0.5050061544046339,0.05607319033732167,0.03538725121415042,0.02470672040722553,0.19384060091315508,-0.1403025011684068,-0.09226413088822227,0.015456709756844237,0.0948666544421674,-0.10762968509058399,0.14317129630584982,0.025497917273589358,-0.07056332085467351,-0.11564398617444435,-0.3255157083798765,-0.062475116553603875,0.184994415076269,-0.047611140928699135,-0.3685586045077921,-0.03436755148263575,-0.6936222078707697,0.0972434133935453,0.27754247775484464,-0.10672011793580616,-0.07945463759513975,0.0007314852717152032,-0.14304134124965834,0.1151755371590778,-0.1050008459520602,-0.10159057131157456,-0.12055159966445665,-0.08686870546570688,-0.10704849199117214,-0.2810277141881793,0.2944492960824197,0.029192919260168218,SNPDiscovery,10
202,202,"bambino  variant detector  alignment viewer  nextgeneration sequence data   sambam format
bambino   variant detector  graphical alignment viewer  nextgeneration sequence data   sambam format   capable  pool data  multiple source file  variant detector take advantage  samspecific annotations  produce detail output suitable  genotyping  identification  somatic mutations  assembly viewer  display read   context  either  userprovided  automatically generate reference sequence retrieve genome annotation feature   ucsc genome annotation database display histograms  nonreference allele frequencies  predict proteincoding change cause  snps
bambino' assembly viewer display alignments  one   bam file   reference sequence either load   file fasta ucsc 2bit  nib format  support  generate   underlie read nucleotides  display colorshaded base  quality value   style similar   con program gordon    display  various sam alignment tag  support include soft  hard clip  splice alignments pad character  add   reference sequence  alignments  necessary  provide complete visualization  insertions  short tandem repeat  viewer generate  summary histogram  nonreference allele frequencies   tumor  normal sample provide  quick impression  whether potential snp sit  homozygous  heterozygous germline  somatic another panel display  bird' eye view   wider region show normalize depth  coverage  exon position  viewer also display dbsnp entries  ncbi refseq protein translations retrieve   configurable mysql ucsc genome annotation database rhead      predict whether  give variant alter protein cod  variant detection bambino include  variant detector   identify single nucleotide variants snvs insertions  deletions directly  one   bam file samspecific feature include  ability  specify  minimum read map quality matepair read consistency check  sam tag filter  latter feature allow  user  leverage even custom sam tag  example   bam data  generate use bwa filter use     tag could ensure variant call  perform exclusively  uniquely map read minimum read quality depth  coverage  allele frequency  also configurable  variant  assign  bayesian quality score buetow    base   conversion  associate sam reads' phredscaled ewing    quality score  probabilityoferror value  score   helpful  evaluate call  lowcoverage regions  variety  lowlevel options  settings  available  configuration   user increase transparency  make  easier  adapt  detector  different use case  example  analysis  assemblies  long sangerbased read align  bwa' bwasw command variant detection may  configure  run   command line  interactively  within  assembly viewer various techniques  use  avoid false positive variation call several   focus  ambiguously map  mismapped read  give read may  reject altogether  variant call   contain    maximum number  mismatch   reference sequence  one  two sequence quality thresholds  default settings permit  maximum  three highquality mismatch  six lowquality mismatch mismatch  extremely low quality  ≤  may  optionally ignore  accommodate illumina' reserve usage   value  mismapped read filter track highquality mismatch   reject read disqualify candidate variants elsewhere   alleles appear  frequently   mismatch set  prevent false positive call base  read  even partially overlap problematic regions another filter discount reference mismatch near read termini occur within regions delete   read consider  possible indel alignment errors read matepair consistency check  also perform exclude overlap read  variant call   base call disagree table  summary  result validation  novel variants  detection  variants confirm   group dataset        sample        variants        detect        validation rate  validation  novel snps  liver cancer                                 tcgavalidated variants find via nextgen sequence                                 tcgavalidated variants find via snp6                                     open   separate window  variant detector  pool data  multiple bam file facilitate analysis  tumornormal pair  data  multiple run  platforms  file may  annotate  tumor  normal detail count  read support  variant  provide break   tumornormal status allele  strand  add  additional level  granularity beyond  provide  pileupformat file    use  determine whether detect variants  homozygous  heterozygous germline  somatic  measure  support read diversity count  unique clone name observe   variant  provide  well   summary flag indicate whether  variant  observe bidirectionally  optional readlevel report provide extend detail  participate read   sam annotations  bam file contain regions  extremely highread coverage  liver albumin  optional limiter may  employ  restrict memory usage  process  variant detector use  stream model  manage memory usage  along   limiter feature make  capable  analyze even  large wholegenome datasets memory consumption  dependent   limiter settings use  program generally run well use     ram",-0.2306226552624764,0.1613314393647101,0.0993048285760494,0.0427260813167593,0.014855379376342974,0.01979170890401426,-0.10758989615554412,0.05876296762508437,0.013376929148734529,0.07214533993431532,-0.020012899059116657,0.004183014473760718,0.15518354083785638,-0.0860835133799626,0.19965453600036726,0.02422465108966375,0.04115406662351423,0.1563684862326478,-0.0017504324116836946,0.09609437498915367,-0.0569508858824983,-0.22242858420137568,0.06376034514053633,-0.025092928881394142,0.00463570846084711,-0.186602313821404,0.06000952798254685,-0.12046895994079168,-0.022238040377923,-0.0036487873447944687,0.04962292797663506,0.2937025559910407,-0.20435337869003534,-0.02202498720011794,0.2557329566781645,0.06562994509982517,0.02163637590636014,-0.0273988037159455,-0.1060222222262985,-0.09631194751759692,-0.06205215613644119,-0.1527249764570623,-0.0945954381185084,-0.11770124685846305,-0.13026777077273413,-0.003705938886979629,0.1008551360637898,-0.1832466357854692,-0.2263389338226417,-0.3513108425730114,0.15121296101086915,0.08383842075321797,0.019185597885491474,0.5437749807045801,0.02941223804998223,-1.0834865052298717,0.054522636130829256,-0.2064474692712452,0.9282460962336488,0.17966867458400962,-0.18232266070987915,0.3506555957626837,0.037989152061175896,0.0790326501202821,0.5835292793394701,0.04131072730131653,0.033691409338130675,-0.009296620768919564,0.18523662439704605,-0.17749776711321058,-0.08900687014683413,-0.059844220606710165,0.1577854720704926,-0.16902504659734918,0.1986577388090567,-0.0074764226853956065,-0.08933536775847269,-0.12184613980167185,-0.2873442033862844,-0.07453068735133685,0.19322895001801466,-0.1297118709545134,-0.3471059216432091,-0.061641221204479776,-0.8126715261541291,0.05325126282687219,0.26547018167894176,-0.07070674919708991,-0.07830704313894288,-0.01270182385249349,-0.18798923591277533,0.13179241515886386,-0.08822553884095162,-0.11281903836579045,-0.07102832530435542,-0.061277160833946735,-0.08792138707458379,-0.3146878539311751,0.3174315602347209,0.04911171314677944,Visualization,11
203,203,"con  graphical editor  nextgeneration sequencing
 rapid growth  dna sequence throughput  recent years imply  graphical interfaces  view  correct errors must  handle large number  read efficiently pinpoint regions  interest  automate  many task  possible   adapt con  reflect   allow fullfeature edit  large datasets  keep memory requirements low  develop  viewer bamscape  read billionread bam file identify  display problem areas  user review  launch  con graphical editor  userselected regions allow  addition  longstanding con capabilities   assembly edit  variety  new feature include direct edit   reference sequence variant  error detection display  annotation track   ability  simultaneously process  group  read many batch process capabilities   added
conseds graphical editor gordon  gordon     centerpiece   con package   rich  flexible set  edit  analysis feature whose full functionality require memoryintensive data structure   improve  resource management  reasonably handle     million read    millionread dataset require   ram   min  startup   desk station sufficient   bacterial genomes  deal  larger assemblies  implement  twostep approach    limitedfeature viewer bamscape  readily handle several billion read  use  identify regions  interest    launch con graphical editor  full edit  analysis capability  read set extract   regions bamscape take  input  reference sequence   bam     file  read align   resource requirements  modest  ~  ram     start   display    region   bam file   billion human read     jump   locations  read  reference window supplementary fig  display read depth depth  inconsistent mate pair    anomalous relative orientation  map location  readreference discrepancy rate potential problem sit misassemblies  sequence variants  find use userdefined thresholds   variables supplementary fig  problem sit  add   interactive list    click   list item scroll  window   location   region  interest  user  click  bring  con graphical editor take  ~    ~  region  coverage depth ~ examine  read data  greater detail   desire edit  reference sequence   assembly   regions  con graphical editor  restrict  datasets    million read  method  currently fix misassemblies  regions    size edit  various locations   reference may  make  one  several edit sessions  con  create  new version   reference  reflect  edit     use   read alignment program  create  new bam alignment file track    ucsc genome browser kent      show   align read window supplementary fig  either   graph  genes  indications  untranslated regions introns   translate amino acid sequence   bar  grayscale indicate quantitative data  conservation score  tag   label attach   region   read  reference sequence gordon      expand  tag feature  allow comment userdefined tag type  userspecified tag field  may contain number text  reference   tag con  flexible tagsearch capabilities  generate interactive list   tag   find con detect putative snps  indel polymorphisms  calculate genotype qualities use  method      produce  interactive list  allow putative variants   view along   support read data  vcf format danecek    report  also  generate  batch  con graphical editor provide several capabilities alternative    bamscape  misassembly detection  correction  assembly view window supplementary fig  nielsen    give  closeup view  potentially misassembled regions show  order  orientation  contigs  scaffold read depth cluster  inconsistent mate pair  sequence similarity  highly discrepant position window supplementary fig  show  interactive list  locations  multiple read disagree   consensus  reference sequence  interactive list  high  low depth coverage regions   generate  user  select  read   place near  top   align read window supplementary fig   determine  visually compare    read  informative sit  read belong        latter    move  another location read   remove   contig  rightclicking  read name  click  inconsistent mate pair  assembly view  highlight read name see later   text  request  highlight read  remove   supply  list  read   batch program  group  read   remove together   single contig  preserve alignments remove individually  separate contigs   read  delete entirely   assembly optionally mat  read  also  remove  remove read  either  add   different location use  join feature gordon     reassemble  click miniassembly contig join   make    three ways manually use sequence similarity  show  assembly view   find   searchforstring feature  click  display  alignment   compare contigs window supplementary fig  bottom   click join  semiautomated fashion use  interactive list  potential join supplementary fig  top generate  batch  con autoreport program   fully automate batch mode accept  join recommend  autoreport false join   correct use  tear function gordon      allow  user  sort  read  two new contigs  look  base discrepancies con  pick pcr  walk primers  close gap  contigs either  manual control   batch mode  new read   generate  button click   script run  batch add    assembly  run cross_match  find  best gap alignment   read   exist consensus sequence incorporate  read   align location optionally read   target   approximate location  interactive list  newly add read  display  batch feature correct  extend  contig sequence  appropriate consensus base  base qualities ewing  green   optionally  recalculate follow change   assembly  interactive list questionable consensus base indicate potential errors   consensus sequence identify use  choice  three different algorithms involve read frequency quality  strand  user review  edit  consensus   trim read   group  highlight  name   operate    group highlight     various ways   click  read name   specify  sequence   particular location  read   particular reference position   edit       base  read base   leave  right   particular position   change   indicate vector additional new feature  describe  supplemental information",-0.24766893794984815,0.1939577523596601,0.1242042044698813,0.07540313935693797,0.036883279066641135,-0.03898430637406797,-0.1211736014300313,0.06044705375918352,0.012481601684094342,0.12321130805554105,0.03615986904857658,-0.031634890183002334,0.17308253718020264,-0.1042322952041083,0.1635916703969489,0.015524409885983912,0.08477353091828177,0.15867529975299094,-0.07516157144422067,0.062399626995821286,-0.034256609702255414,-0.2363262935852913,0.06620751337424396,-0.01755415415865109,-0.02199524807944071,-0.2059223509656244,0.05969628875044331,-0.12136655386255076,-0.06192893304267823,-0.031286606339393945,0.011708206802892206,0.3270778931916941,-0.19104957562867214,-0.04246465133220163,0.21180430967044314,0.0857008996640933,0.008014373658603966,-0.0318167108685715,-0.07944612900288586,-0.1304401192288889,-0.06767350897804812,-0.16358292273633745,-0.08170172666148066,-0.12381906500918692,-0.16392455131037506,0.013950685105492295,0.04439123871964321,-0.16570616038150673,-0.20965612996664024,-0.3597078238892082,0.15108134721683816,0.05729207709170391,0.02122662455956235,0.5963875994439573,0.0125785295521234,-1.2613317438043914,0.06107854864343565,-0.21949243889312764,1.0567163732985771,0.19547786692723895,-0.16979723946852301,0.4035046030990617,-0.033637893845754954,0.0749540802952292,0.6050964999506737,0.0041440732088102415,0.06812385939160459,0.061199755005154025,0.1832935442893528,-0.16840964986020185,-0.023253969431491068,-0.02203487598832675,0.08377805617791911,-0.23008781634772,0.20799031571368687,-0.01548108735749888,-0.15139219737381587,-0.09695621630241877,-0.3525483907690423,-0.0929223143310844,0.2056490062415494,-0.08651763342133438,-0.3532211236802247,-0.06163437124666606,-0.8796922410459279,0.056970318685607924,0.2733784799144582,-0.1117340693690071,-0.1187756672764852,-0.03098539129504663,-0.1780502884400004,0.11330186865708065,-0.10871450113793184,-0.13699922950662194,-0.13254987972796636,-0.06844616600489623,-0.1119784310515591,-0.33531930755017064,0.3902625893655525,0.09948620009104056,Visualization,11
204,204,"tablet—next generation sequence assembly visualization
tablet   lightweight highperformance graphical viewer  nextgeneration sequence assemblies  alignments support  range  input assembly format tablet provide highquality visualizations show data  pack  stack view allow instant access  navigation   region  interest  whole contig overviews  data summaries tablet   multicore aware  memory efficient allow   handle assemblies contain millions  read even   bite desktop machine
tablet  write  java   compatible   javaenabled system   runtime level  ≥  provide installable versions  include everything require  run  application include  suitable java runtime  installers  available  windows mac   linux  solaris     bite versions  instal  run tablet  also monitor  server  new versions   prompt download  update quickly  easily whenever  new release  available along  redirect  user   web page describe  new feature    add  prime requisite  development  tablet   compute efficiency  speed  two main approach  handle assembly data  viewers  either memorybased    data  load  memory  diskcached   data reside  disk    currently visible segment   dataset hold  memory memorybased applications  faster  view  navigation   initial delay  load  data   provide whole dataset overviews  statistical summaries   size  dataset   handle  limit   amount  available memory  contrast cachebased applications  display view  much larger datasets use  minimum  memory  access   data   order  magnitude slower   affect navigation  render   feature set available  often limit  tablet   choose  hybrid solution  provide   advantage   approach  hold  skeleton layout   read  memory  data   read limit    internal   position   consensus  reference sequence   length  nucleotide data  efficiently compress     read  quickly  possible along   supplementary information—   read' name   orientation— hold   index diskcache    access via  read'   require tablet also allocate memory   percontig basis include information  feature     pack  data  display coverage calculations paddedtounpadded mappings etc  data  calculate  store   contig  render  discard   display  approach allow   provide maximum functionality—instant access   portion   data extremely fast  highquality render entire dataset overviews—yet memory usage  keep relatively low compare data indexingloading time  memory consumption across  range  tool   assembly file contain  million illumina solexa read  length   find   cachebased viewers maqview mapview tview  fairly constant  memory usage        view  index time vary       although memory consumption  index  peak  high     mapview   memorybased viewers  compare hawkeye     con      eagleview     tablet   hybrid load  data     use     memory",-0.3099742010840916,0.2196640989191065,0.19721565687784576,0.06026815879043412,0.07079457139047693,0.0038147155889356045,-0.11912836540619486,0.05467941632752519,0.05381958930301341,0.06796683507077028,0.07851767421487978,-0.07730098698509506,0.10530913656457597,-0.20740883474383448,0.18222176466505435,-0.1074895397759974,0.09013798112386266,0.18523390178849905,-0.0042187199204016725,0.08584632528058281,-0.07155683719654485,-0.2156984108848276,0.09261394164174576,0.032940922974664166,0.03319144928320726,-0.19249263308518152,0.023485539651632602,-0.08388554671949862,-0.09100982502775988,-0.001445299140085457,0.09047680592514797,0.3194317405001436,-0.2486680998572951,-0.020581861224260624,0.274959813572909,0.1710375201021607,0.037742902895915184,-0.04870668608559259,0.011443090775813262,-0.16969896923165104,-0.036345631333911166,-0.2298618667839829,-0.11667263798189745,-0.07552043641087516,-0.1283478093878735,-0.019390593568729884,0.09265914691829973,-0.2526395694539412,-0.028789635073960675,-0.3207055659386062,0.14263498838437666,0.07443957973391481,0.06337449061545995,0.5500785102719086,0.07078156266032977,-1.2032612763232284,0.037146346376157637,-0.15364132265417405,1.1515278861590539,0.14537956665205484,-0.1262953695525602,0.30497414234329456,-0.12154242191993918,0.1083365357048708,0.5286521190065098,0.02749920307282856,0.061356722989861875,-0.057112098779266526,0.2765102375547706,-0.16218479159449475,-0.011690873310366405,-0.00855044642288127,0.1860388292835064,-0.15245393279820016,0.16000402474886566,0.055559517165051205,-0.1044169472147812,-0.03744773659163552,-0.2837713262582622,-0.1104712521900552,0.2828228949283314,-0.06463080084430847,-0.4013764383582546,-0.05062754898756226,-0.8625462559002248,0.11551843660636946,0.24802114848522375,-0.1378259433866801,-0.05557704857022658,-0.03292474319632765,-0.058341289045160075,0.2061917020127841,-0.05646801604266915,-0.1346249397536325,-0.08505731493771758,-0.15342865223848806,-0.022993760533852152,-0.2764643569128809,0.5005166505113022,0.07864368150914365,Visualization,11
205,205,"integrative genomics viewer igv highperformance genomics data visualization  exploration
data visualization   essential component  genomic data analysis however  size  diversity   data set produce  todays sequence  arraybased profile methods present major challenge  visualization tool  integrative genomics viewer igv   highperformance viewer  efficiently handle large heterogeneous data set  provide  smooth  intuitive user experience   level  genome resolution  key characteristic  igv   focus   integrative nature  genomic study  support   arraybased  nextgeneration sequence data   integration  clinical  phenotypic data although igv  often use  view genomic data  public source  primary emphasis   support researchers  wish  visualize  explore   data set    colleagues   end igv support flexible load  local  remote data set   optimize  provide highperformance data visualization  exploration  standard desktop systems
igv   desktop application write   java program language  run   major platforms windows mac  linux   describe   detail  components   igv implementation include  datatiling approach  support large data set  igvs support  different categories  file format  also provide  highlevel overview  igvs software architecture data tile  primary design goal  igv   support interactive exploration  largescale genomic data set  standard desktop computers  pose  difficult challenge  ngs  recent arraybased technologies  generate data set  gigabytes  terabytes  size simply load  entire data set  memory    viable option  addition researchers search  meaningful events  many different genomic resolution scale  whole genome  individual base pair  problem  analogous   face  interactive geographical map tool  provide view   large geographical databases  many resolution scale tool   google map solve  problem  precomputing image represent section  map  multiple resolution scale  provide fast access   image  need  construct  view  consider   approach  igv base  precomputed image  genomic data however millions  image would  require  support  resolution scale   large genome thus make image management difficult without introduce  requirement   database furthermore  representation   data would  fix   image  compute make  difficult  provide interactive graph options consequently  adopt  different approach   base  precomputing summarizations  data  multiple resolution scale  render   data defer  runtime  refer    data tile  distinguish   image tile igvs data tile implementation  build   pyramidal data structure    describe  follow   resolution scale zoom level  genome  divide  tile  correspond   region viewable   screen   typical user display  first zoom level consist   single tile  cover  entire genome  next zoom level contain  single tile   chromosome  number  tile  increase   factor     level   next zoom level consist  two tile per chromosome  four etc  tile  subdivide  bin   width   bin choose  correspond   approximate genomic width represent   screen pixel   resolution scale  value   bin  calculate   underlie genomic data   summary statistic   mean median  maximum  organize data   way tile size   zoom level  constant  small contain   data need  render  view   resolution support   screen display hence  single tile   lowest resolution  span  entire genome    memory footprint   tile   highresolution zoom level  might span    kilobases   user move across  genome   zoom level igv  retrieve  tile require  support  current view  discard tile  longer  view  free memory  method support browse  large data set   resolution scale  minimal memory requirements  large genomes precomputing tile   zoom level would  inordinately expensive  respect  disk space  example  human genome require approximately  zoom level    order   tile  cover  whole genome  base pair resolution  practice igv use  hybrid approach combine precomputed lowerlevel zoom level  highresolution tile compute   fly   possible   highresolution tile cover relatively small portion   genome  number  precomputed zoom level require  achieve good performance vary  data density  genome size   experience seven level give acceptable performance  even  highest density human genome data file format  support  multiresolution data model describe earlier  develop  correspond file format  tile data format  tdf store  pyramidal data tile structure  provide fast access  individual tile tdf file   create use  auxiliary package igvtools  note however  igv   require conversion  tdf  data   load  fact igv support  variety  genomic file format    divide  three categories  nonindexed  index  iii multiresolution format nonindexed format include flat file format   gff  bed   wig  file   format must  read   entirety    suitable  relatively small data set index format include bam  goby   sequence alignments additionally many tabdelimited feature format   convert   index file use tabix   igvtools index format provide rapid  efficient access  subsets   data  display    zoom    sufficiently small genomic region zoom  require everlarger portion   file   load thus index format  efficiently support view    limit range  resolution scale  range depend   genomic density   underlie data   span tens  kilobases  ngs alignments hundreds  megabases  typical variant snp file  whole chromosomes  sparse feature file igv use heuristics  determine  suitable upper limit   genomic range    load quickly   reasonable memory footprint  zoom  beyond  limit  data   load multiresolution format    tdf describe earlier   bigwig  bigbed format  include   index   raw data  precomputed index summary data  lower resolution zoom  scale multiresolution format  efficiently support view   resolution scale software architecture  igv software structure  design around  core set  interfaces  extendable class  components   separate  three conceptual layer  illustrate  figure    toplevel application layer   data layer  iii  stream layer   describe   detail   application layer include  main igv window  user interface elements along  controllers  user interaction events  also contain representations  genomic feature  data igv display   horizontal row know  track track  display   data panel   implement   class derive  java swing components  data panel  responsible   coordination  track layout  render  manage mouse events  handle certain globally share mouse action   zoom  pan  delegate  events   object represent track track  responsible  handle  events  well  request feature  need   data layer  draw  feature   panel  track implementations delegate  draw task   renderer object renderers  design   pluggable    swap  runtime  example  switch graph type  response   menu action  data layer read  parse  different genomic file format  supply  application layer  data tile  demand  also implement cache  tile  improve efficiency   previously visit genomic region  request   stream layer  responsible  support random access  section  file access     protocols support  igv  local file http https  ftp random file access  necessary  take advantage   index  multiresolution file format  local file   straightforward use javas randomaccessfile class  alternatively positionable file channel remote file present  challenge     java builtin function  libraries  support  access pattern initially  solve  problem use  web service however  approach   ideal  users  wish  host igv file  also require  install  run  web service   systems consequently  design  implement  set  class  provide  uniform interface  random file access    protocols igvs implementation   http protocol use byte range request   standard http specification   ftp protocol igv use  mechanism  restart download   support   ftp servers via  rest command  external file  hold  picture illustration etc object name  bbs017f1jpg open   separate window figure  igv class diagram illustrate  igv software structure feature igv   desktop application   visualization  interactive exploration  genomic data   context   reference genome  key characteristic  igv   focus   integrative nature  genomic study  allow investigators  flexibly visualize many different type  data together— importantly also integrate  data   display  sample attribute information   clinical  phenotypic information  support interactive exploration  data igv provide direct manipulation navigation   style  google map  instance  click  drag  pan  view across  genome  doubleclick   region  zoom     detail view  support realtime interaction   scale  genome resolution  whole genome  base pair even   large data set  broad igv data server host many genome annotation file  data set   variety  public source include  tcga  genomes project encode project   others however  primary emphasis   support biomedical researchers  wish  load visualize  explore   data set align   select reference genome researchers  also make  data set available  others  view  igv share   colleagues   community  large",-0.24743261951646145,0.25221252333613337,0.11663387784220094,0.14431735900215353,0.09225337941859654,-0.005972086607093493,-0.14479594365680834,0.056362862152221437,0.044371833670935536,0.12731617828524047,0.058392892729050926,-0.11660473816925762,0.18929832352348988,-0.151204815255171,0.13750511574364466,-0.015499952132749668,0.06749999806698115,0.20799553022255535,-0.06625243991173313,0.0641230824068291,-0.08939834956008083,-0.23186918935523584,0.09464557862605204,-0.039383722417015626,0.013201172956250158,-0.1987262078366437,0.06812627312777164,-0.09478072842460247,-0.1070247818833565,-0.05370455684321344,0.013941345564447916,0.3443724553858104,-0.21067217929432025,-0.0659435818066493,0.287047747244539,0.12214353495945253,0.04317568711818779,0.013400367522039092,-0.018094373701119812,-0.15551081329000765,-0.06343676571575617,-0.20665948829776096,-0.07239223721048252,-0.0778406363752975,-0.16828525035967026,0.02582738073772986,0.09180076321558822,-0.11676829691098715,-0.14150320264142374,-0.3012713863890475,0.14351272157090844,0.04523007704148448,0.02545931445905468,0.6075743625912774,0.03415074520680419,-1.2383432322271308,0.08401666623591393,-0.2156872914095952,1.1530857502027403,0.16801021028844804,-0.15623621365373985,0.34023400488626826,-0.06826527078436423,0.05608722645441418,0.5980774149692689,0.014337233934106285,0.02950239926162445,-0.017453597689711966,0.2653769613642778,-0.18069588011680784,-0.03838767176453225,-0.010882686503976072,0.1574923277561998,-0.17020683725170055,0.1808138102896839,-0.04589009923210552,-0.09094486991813468,-0.05251618779755637,-0.3287568993038744,-0.09999342832156548,0.2492007062297089,-0.03688227691493192,-0.3574830041340617,-0.012224515904621272,-0.8978561058154351,0.1616649263551213,0.2362019746001441,-0.1432735889919798,-0.07696840998660362,-0.03171816498270145,-0.1206392545570302,0.14569525958306234,-0.06985327596852944,-0.11275383131220365,-0.07585000748526059,-0.09244624413780173,-0.09498900856469646,-0.3525186761246564,0.4494918548873022,0.12671512061417242,Visualization,11
206,206,"magicviewer integrate solution  nextgeneration sequence data visualization  genetic variation detection  annotation
new sequence technologies   roche  abi solid  illumina   increasingly develop   astound pace   advantage  high throughput reduce time  cost  satisfy  impend need  decipher  largescale data generate  nextgeneration sequence  integrate software magicviewer  develop  easily visualize short read map identify  annotate genetic variation base   reference genome magicviewer provide  userfriendly environment   largescale short read   display   zoomable interface  userdefined color scheme   operate systemindependent manner meanwhile  also hold  versatile computational pipeline  genetic variation detection filtration annotation  visualization provide detail  search option functional classification subset selection sequence association  primer design  conclusion magicviewer   sophisticate assembly visualization  genetic variation annotation tool  nextgeneration sequence data    widely use   variety  sequencingbased research include genome resequencing  transcriptome studies
different tool often use   define format   data input  xml format  use  input  ngsview  mvf format  mapview etc  show  weakness   compatibility  lead  laborious efforts  convert various format  contradiction  especially prominent  process huge mass  data obtain  highthroughput sequence  recently  generic alignment sam format   develop  store align short read   flexible style  compact size  hence   compatible    powerful format magicviewer employ  sam format  enable  easy conversion  various input file format include psl maq bowtie soap  zoom  start   new project magicviewer require  reference genome sequence  fasta format  sort bam file contain  align short read obtain  samtools    optional reference genome annotation file  gff format magicviewer  save intermediate result   log file thereby facilitate  easier manipulation  project  later reuse take exist archive  account magicviewer introduce  conspicuously new feature  workspace  users  load   frequently use resources  quick access    convenient way users  easily load browse  update  modify  previous result instead  reconstruct  new project   alignment visualization magicviewer write   java program language provide  userfriendly interface    perform   standalone operate systemindependent manner figure  largescale short read map onto  reference genome  optimally place  multiple line  compact arrangement    visualize intuitively  get  better graph view users  acquire scrollable thumbnail image  zoom    theoretically  short read image   zoom   resolution  whole chromosome  individual base   desire level   mouse hover   specific read auxiliary information   show   tooltip   read  location base quality read length  orientation  sequence depth distribution  map read   visualize   top  graphical representation  short read alignments  addition magicviewer provide extensive flexibility  change  appearance   display short read alignment  sequence depth users  change font  color  many different combinations   nucleotide  background color   color  format set function   trivial  users usually need  better display  explore snps  hundreds  fold coverage  short read alignments  external file  hold  picture illustration etc object name  gkq302f1jpg figure   workflow  screenshots  magicviewer   genetic variation detection filtration  annotation nextgeneration sequence technologies   widely use  effective easy  indepth investigation  genetic variation include snps  indels insertiondeletions   better understand  human health   satisfy  requirements beyond  sophisticate short read visualization tool magicviewer  devote  serve   comprehensive workflow  genetic variation detection filtration  annotation figure   order  efficiently identify genetic variation  largescale short read  reference genomes  genome analysis toolkit gatk   incorporate  gatk   structure software library design  enable rapid development  efficient  robust analysis tool  nextgeneration sequence data  magicviewer user interface allow users  change many   parameters   heterozygosity confidence threshold  max coverage  output  genetic variation call  organize   variable call format vcf     standard variant call file format use    genomes project meanwhile  identify genetic variations   display   top   main window  magicviewer  easily interpret  result  candidate snps magicviewer provide  number  versatile display  filter options  users  remove low confidence snps  options include thresholds  coverage quality variant frequency  number  read another predominate feature  magicviewer      use  link  detect genetic variations   annotation information   reference genome users need  provide  information   general feature format gff format   launch  new project magicviewer also provide  variety  genetic variation analysis function include snp category selection result organization  visualization users  select  subset  different snps categories  custom set  achieve  extensive annotation include intergenic intron missense nonsense readthrough splice site synonymous ′  ′utr  graphical display  output   customize use supply options  define view mode arrow mode read height color vertical space track display height  background color  many genetic variation project sanger sequence  usually necessary   verification   detect genetic variations therefore magicviewer  also provide  facility  help users design primers  specific genomic region flank  snp site   batch mode   implement  primer3   fulfill  function magicviewer allow users  adjust  number  important parameters include primer length   content product    number  primers   case study  determine  effectiveness  magicviewer  simulate  million  illumina pairedend read  fold coverage   divergence  human chromosome  use  maq program    result magicviewer identify  total    snps   accuracy    comparison   original simulate snps   observation   undetected snps  find   majority    locate  repeat  low coverage regions  real data set magicviewer  apply  five pool human exon sample   obtain use  nimblegen  human exome array  illumina genome analyzer iix instrument data  show originally  total  approximate  million singleend  read  obtain   size    among    million read  read   target exon regions could  map onto  reference genome use  soap program   default set data  show among  five pool sample magicviewer identify  number    snps  target exon regions base  default settings among  homozygous mutations account     total snps   remain part  heterozygous alleles functional annotation   snps indicate  synonymous mutations account  approximate     kinds  mutations   follow nonsynoymous  nonsense   readthrough   experimentally evaluate  robustness  magicviewer  snps  randomly select  validation use sequenoms massarray system data  show      confirm reveal  accuracy  magicviewer  identify genetic variants",-0.2103304489189191,0.2065843697367932,0.08529987874264806,0.11330982956314095,0.0571333227171946,-0.023993630682277244,-0.08381517073962974,0.03572570611041312,0.03080598439839555,0.16476039093373934,0.008658687357518185,-0.08690482717182732,0.13492222050594935,-0.15302174872741467,0.17399900598932774,0.02292346378288618,0.1023307267600591,0.18950977280956727,-0.013511137750919729,0.044658276885918266,-0.11335292309806567,-0.22381434660889749,0.07242432558659191,-0.04804475355209079,-0.0042610665130224535,-0.2147191129181188,0.08907657439086485,-0.09655115465724433,-0.10644932975886083,-0.05187394652439696,-0.009627066731166162,0.30588624633326217,-0.2312041407762657,-0.04920475892836183,0.2679612866839218,0.06987885071586522,0.03278750825518772,-0.015283641359689303,-0.06279521296226714,-0.13978135443204534,-0.05216023077089453,-0.17988838715859967,-0.10750158509869899,-0.08571184153289522,-0.16671683500554954,0.025877716604310725,0.09233976839814426,-0.11655879295715015,-0.18258497119063466,-0.3039671346264119,0.14865397307624267,0.08269694047673355,0.035917848493852766,0.580267958833677,0.07372072809205459,-1.1262701219106774,0.060821489714761826,-0.19949220674930185,1.0058409373735917,0.12622804771299564,-0.11990741879612535,0.3043644560384032,-0.02457883009607563,0.07669624063333996,0.5958931613554497,0.04871769100257264,0.035384401580511884,-0.011588618606958513,0.23299199993801645,-0.18299273739898256,-0.026563949123028136,-0.026515716557794184,0.14117473931273264,-0.16757615498301187,0.19051364562530976,-0.06218110420173261,-0.13886303522570126,-0.0890673011444827,-0.31987926935231903,-0.1190562176410245,0.19872507520533586,-0.07705003832390236,-0.32185775277534184,-0.020034124716412187,-0.8687507823413443,0.1491549158862099,0.2659331214455206,-0.1146063374352596,-0.12627693063511355,-0.03584390983280794,-0.1333960715970933,0.1236413767067971,-0.05477088114116114,-0.10595660796275408,-0.048003599929577874,-0.06900401728755863,-0.09304974662344448,-0.3740932462727026,0.3698665626778653,0.12589992417261095,Visualization,11
207,207,"eagleview  genome assembly viewer  nextgeneration sequence technologies
 emergence  highthroughput nextgeneration sequence technologies   life sciences roche illumina sequence formerly solexa sequence  dramatically speed  wholegenome  novo sequence  resequencing   low cost   sequence technologies provide  unparalleled opportunity  genomewide polymorphism discovery  analysis   new data type  huge data volume pose formidable informatics challenge  base call read alignment  genome assembly polymorphism detection  well  data visualization  introduce  new data integration  visualization tool eagleview  facilitate data analyse visual validation  hypothesis generation eagleview  handle  large genome assembly  millions  read  support  compact assembly view multiple navigation modes   pinpoint view  technologyspecific trace information moreover eagleview support view coassembly  mixedtype read  different technologies  support integrate genome feature annotations  genome assemblies eagleview   use    lab     research labs worldwide  nextgeneration sequence analyses
efficiency test  test  efficiency  three tool con ver  hawkeye ver   eagleview ver    bite linux server   memory  bite version   tool  use   test  genome assembly file use   test   referencebased genome assembly   coli  genome  illumina sequence technology   collaborators   washington university genome sequence center wugsc  assembly contain  reference genome  length  base   illumina base read  data set  select   assembly could  load    memory linux server   three program   test  con  eagleview load  assembly file   ace format  hawkeye load  assembly file   native bank format convert   ace assembly file  cpu time  memory usage   tool  measure   load  display contig view two larger test assemblies  subsets   wholegenome resequencing study   elegans    primary sequence data  also  wugsc hillier     two larger assemblies contain    illumina base read respectively  assembly file  available   eagleview web site data file format eagleview read  genome assembly file   standard ace format  tagbased format commonly use  genome assembly program  detail description   ace format  available   eagleview use three optional auxiliary data file read egl  map file see table   read  egl file  pair together  store base qualities  technologyspecific trace signal  sequence read  read file contain  read data   egl file    index   contig start locations   correspond read file eagleview automatically load base quality  trace information    read   egl file  present    directory   ace assembly file  map file   store location map information  genome feature   genes exons  snps  present  map file  also load automatically  three optional file   tabdelimited text format detail format descriptions  provide   eagleview documentation table  eagleview data file  external file  hold  picture illustration etc object name  1538tbl3jpg file  identify   file extension utility tool eagleview come  three data conversion tool  prepare  optional data file eagleindexfasta convert fasta file contain base quality  read trace information   correspond read  egl file eagleindexsff  eagleindexsffm  specific   read extract base quality  flow signal information    binary sff file  convert   read  egl format eagleindexsff convert   single sff file eagleindexsffm  convert  multiple sff file detail usage  describe  eagleviews documentation",-0.18961255474285665,0.2522345199157778,0.12259493603181144,0.056894427064291535,0.11292972898993052,-0.07440602103199223,-0.011254553019534796,0.003721050708554685,-0.0162807307794298,0.10766764633161456,0.05051555592860831,-0.13574991017629048,0.0994254373161024,-0.047475635211326576,0.19258162175476748,0.038071559892820295,0.21084216387917928,0.18301351582141295,-0.04284972189557984,0.07726543497441238,-0.09862470792263353,-0.2412354650833693,0.08216804366215671,0.03054153959965333,0.015807352141526183,-0.20593146833983303,0.11188462992385642,-0.04978755436053402,-0.08544008922027914,-0.0032994677214638183,-0.017850571400240847,0.3016509427639999,-0.2613894685220561,0.02746446215682418,0.2381501268693491,0.058110258516267325,-0.01904734750278294,0.007288166709660896,-0.0106879758329964,-0.1549552590586245,-0.087137589027713,-0.21572591778469932,-0.1349975508766396,-0.07346651542588678,-0.1354010347423977,0.028396818000137027,0.08926847960652881,-0.11371570550959165,-0.132879840015544,-0.22004059511665744,0.1391020185124178,0.10714896004034304,0.034947698516771195,0.5447059960420072,0.032037896285519785,-1.1706325931768669,-0.011008535060835512,-0.17235733347172902,1.053802842031674,0.17978901622914953,-0.12046751824382225,0.34977639366774577,0.024172998809157624,0.07156534574337696,0.5323935476585144,0.02617132606805841,0.027667887300547016,-0.010020956252762852,0.2947338849189691,-0.05593631667434238,-0.03424974102166935,0.06285837752205369,0.11401510371667285,-0.20573529377579688,0.1635279994359926,-0.01583559714551819,-0.012073657903697734,-0.08429351994816801,-0.384211565262491,-0.10699024036722747,0.1990719757526868,-0.08090346866336308,-0.34025639399861624,-0.006768962493362395,-0.8829804974749047,0.15167710188727238,0.28680283425155245,-0.19279612409146996,-0.061959577736285465,-0.012570501989562456,-0.08707608865745561,0.09653893188990063,-0.012663991101037124,-0.026158353000095017,-0.07347620894617744,-0.08344811130266049,-0.1014326315213877,-0.40831613576921977,0.3810709850813605,0.10716048848668212,Visualization,11
208,208,"icarus visualizer   novo assembly evaluation
data visualization play  increasingly important role  ngs data analysis  advance   sequence  computational technologies   become  new bottleneck  genomics study indeed evaluation   novo genome assemblies  one   areas   benefit   visualization however even though multiple quality assessment methods   available exist visualization tool  hardly suitable   purpose   present icarus— novel genome visualizer  accurate assessment  analysis  genomic draft assemblies   base   tool quast icarus   use  study   relate reference genome  available  well   nonmodel organisms  tool  available online    standalone application
icarus pipeline consist   follow step see supplementary fig  run quast align contigs   reference  available gene find detect assembly errors postprocessing detect similarities   assemblies create javascriptbased web page icarus output two type  interactive html file contig alignment viewer  contig size viewer  viewer contain  least two pan  assembly overview   contigs show  full scale   pane  users  zoom   region  interest  pan display  assemblies  several track next     viewers support standard genome browser functionality navigate drag zoom click  elements  detail information   contig name type  length specific feature   viewer  describe  examples  icarus output  assemblies  bimpatiens saureus  cami  metagenomic dataset  demonstrate   supplementary material    website  contig alignment viewer  type  viewer  available    reference genome  provide   genome consist  large chromosomes  ≥   sequence  display   separate viewer   also true  multiple reference genomes see mikheenko     example   viewer  give  figure  fig   example   contig alignment viewer  aby simpson    spade bankevich     velvet zerbino  birney  assemblies  saureus singlecell dataset  chitsaz     top grey panel show icarus control  move  zoom   also include checkboxes  show  hide  type  detect misassemblies  right grey panel present detail   select block   example  highlight block   fragment   misassembled contig node_5  consist  three misassembled block users  expand detail information   block   panel  switch       detail view pane  main viewer section  divide  four panel  top  bottom detail assembly view detail read coverage minimize  show read coverage button  assembly overview  read coverage overview    contigs  correct color green  blue   assembly overview panel clearly show    two regions   three assemblers generate erroneous contigs misassemblies color red  orange one   regions  depict   detail assembly view  orange color  aby  spade misassembled block mean    similar mappings   reference worth note  velvet also make  misassembly    position   contig  shorter open  new tabdownload slide  example   contig alignment viewer  aby simpson    spade bankevich     velvet zerbino  birney  assemblies  saureus singlecell dataset  chitsaz     top grey panel show icarus control  move  zoom   also include checkboxes  show  hide  type  detect misassemblies  right grey panel present detail   select block   example  highlight block   fragment   misassembled contig node_5  consist  three misassembled block users  expand detail information   block   panel  switch       detail view pane  main viewer section  divide  four panel  top  bottom detail assembly view detail read coverage minimize  show read coverage button  assembly overview  read coverage overview    contigs  correct color green  blue   assembly overview panel clearly show    two regions   three assemblers generate erroneous contigs misassemblies color red  orange one   regions  depict   detail assembly view  orange color  aby  spade misassembled block mean    similar mappings   reference worth note  velvet also make  misassembly    position   contig  shorter  contig alignment viewer place contigs accord   map   reference genome produce  nucmer aligner kurtz     color scheme  design  differentiate  correct contigs green  blue  contigs  assembly errors misassemblies red  orange misassembled contigs  break  correctly align block  users  easily identify  switch  block    erroneous contig  side   block   misassembly event  highlight icarus support  type  misassembly events detect  quast relocations inversions etc users  show  hide  block contain specific type  misassemblies  several assemblies  provide icarus identify  contigs   similar     assemblies  color   blue  correct contigs  orange  misassembled ones  feature help researchers  assembly algorithms developers  see analogies  various assembly approach detail  icarus similarity identification algorithm  examples   performance  present   supplementary material  viewer  additionally visualize genes operons  read coverage distribution along  genome use two additional track  annotation track help  understand  assembly contain  functional elements  whether      cover   assemblies    coverage distribution track help  monitor behaviour  assembly algorithms  regions  extremely high  low coverage  contig size viewer  type  viewer show contigs sort  size  descend order  order  suitable  compare  largest contigs     interest ones   genomic study  viewer also label  commonly use assembly quality statistics n50  n75   approximate genome length   organism  know ng50  ng75  also label see gurevich     detail   full reference genome  provide  viewer share  color scheme   contig alignment viewer  order  highlight correctly map contigs green block unaligned contigs grey block  misassembled contigs red block misassembly breakpoints  mark  dash line  block  link   representations   alignment viewer allow  quickly navigate   viewers",-0.2382601875151849,0.20852238426936398,0.1098398290793981,0.05022344920740684,0.08709289704905086,-0.015880834215089068,-0.09659162715995323,-0.002738670287687305,0.0230792008638516,0.06296769591138812,0.04709075939030849,-0.07400510220722674,0.17562849650240298,-0.10280888581735573,0.15167271664697785,0.0837914765872758,0.1342858855944234,0.16800587145679066,-0.042108877901182167,0.07691096482114203,-0.03602252443984365,-0.20633776411412053,0.09260647374761403,-0.014928205203006997,0.033671737105833544,-0.21754079964179407,0.07971811573784933,-0.10638745809216787,-0.08890027286511637,-0.06769478995425847,0.027910241237406038,0.2862878603343149,-0.15585926967013874,-0.05089951542971602,0.23284285404700986,0.09754847702000746,0.025436858748749114,0.03249149223104481,-0.0597242508965072,-0.102573127197443,-0.08084000802846801,-0.16262041388537854,-0.1351392142216695,-0.11822338256165855,-0.2107412627950083,0.016460141992839655,0.07477384287023937,-0.13705477910179129,-0.16204725033243475,-0.32413668563403525,0.1492140068699398,0.06171755497293587,0.048265372152128685,0.5992592701071994,0.025631956926131585,-1.26704710356392,0.020697663939958304,-0.15194537435036834,1.037738741635556,0.1884867098484366,-0.19239603059934604,0.4509147371227431,-0.019058273057034576,0.07974378618858956,0.6083817120956377,0.017000733814017996,0.06898215000447315,0.021209499511445653,0.17916392757060684,-0.15305764521321402,-0.035482445386700714,-0.006324895559504407,0.09347169250285456,-0.1746765359500825,0.15961572448991024,-0.015124920554201138,-0.050945848846312265,-0.0497502123287095,-0.3379660366294008,-0.07942501098761777,0.17935710084053402,-0.04284177303754744,-0.3435452863919086,-0.03265227104885597,-0.8839411817276649,0.042277607143849885,0.1846819659929535,-0.13895174886373027,-0.07690744132821938,-0.006142645269647415,-0.12683261560214176,0.0678576900780355,-0.08927237523532064,-0.10000947486816926,-0.10258298096324067,-0.07579404400182528,-0.18324924623861694,-0.348705765135459,0.3659410518493584,0.12503879812877733,Visualization,11
209,209,"mapview visualization  short read alignment   desktop computer 
 introduce  new visual analytics tool name mapview  facilitate  representation  largescale short read alignment data  genetic variation analysis mapview  handle hundreds  millions  short read   desktop computer  limit memory  support  compact alignment view   singleend  pair end short read multiple navigation  zoom modes  multithread process moreover mapview offer automate genetic variation detection mapview   use   lab     research labs worldwide
mapview format mvf   novel file format design  fast  memory efficiency visualization  huge amount  short read alignment data  mvf supplementary material consist  four section file header data index  statistics information  mvf binary file combine  effective compress  index   alignments  enable reduction  disk usage  fast retrieval  alignments   specify region  load  navigation algorithm mapview   diskbased viewer    load  tiny portion   mvf file  memory specifically mapview load current display page  six neighbor page  fractional load  neighbor cache algorithm lead   small burden  memory resources   compromise  speed  mvf file offset  alignment data  index  reference position  quickly find alignments associate   specify region mapview use  index  locate  offset address  short read map   specify region   retrieve  alignments data  index navigation algorithm enable  users  quickly jump  different regions",-0.226323535699736,0.22069524397586726,0.13889878058636732,0.08748140763279727,0.1805775641167367,-0.0947097749068317,-0.10254782485055992,0.014766394357535647,0.05653948736885055,0.14057493880073624,0.06319356987951323,-0.1508170574596575,0.08702777587300674,-0.16404977064283394,0.2008054370060563,0.05009664596397091,0.14197089983658354,0.14573063725243132,-0.004430975367061115,0.037490926323119886,-0.08430589209734039,-0.21376992261582267,0.07223304563879289,0.00631793509025804,0.03779069044711915,-0.22806585567410695,0.07487685919146646,-0.04680988195098259,-0.13047045438539828,-0.04229815435511145,0.0221188531849872,0.34142141473394905,-0.3316542026332834,-0.056721011990554286,0.19885495589961386,0.008614047533641993,0.04074260333806954,-0.04071865536124361,0.028864644840359686,-0.15977986190383406,-0.1033647400877354,-0.2615425693971867,-0.14848454548045992,-0.10829472038894893,-0.20021520696834408,0.059855090479620475,0.09638531615756536,-0.1449843600963835,-0.1000639184505086,-0.2871206746796485,0.18434931890277026,0.11873495371334933,0.017815864190395752,0.6497375258159909,0.14147544200426307,-1.3529210099442441,0.01755766047334129,-0.21778538056056607,1.2988480809398673,0.13783846397630192,-0.12439607709609185,0.3427586378868331,-0.021145537023601883,0.12695771987465296,0.5584934777093374,0.010916579527441751,0.07199665584008802,0.019872562496245583,0.35548759160394017,-0.093274978418644,-0.0494346893879331,0.013033539691770618,0.2111842322374948,-0.172392386126078,0.18494562899101186,0.01870323813266375,-0.10458730081498452,-0.025608029337176545,-0.4039673432961784,-0.0581419745079157,0.3534810986226975,0.021461943223733796,-0.3806597896735184,-0.09641334021633323,-1.0256343568929218,0.1637758930044418,0.3452757709649053,-0.22874710409140045,-0.08914651801619171,-0.006111433840653097,-0.15302730590655386,0.19740136848466305,-0.009985048205337741,-0.09681669337336313,-0.092291903718036,-0.1241488246628168,-0.08149099555607378,-0.3733319196511399,0.4509623016823422,0.08485104174734177,Visualization,11
210,210,"metasee  interactive  extendable visualization toolbox  metagenomic sample analysis  comparison
 ngs next generation sequencingbased metagenomic data analysis  become  mainstream   study  microbial communities face   large amount  data  metagenomic research effective data visualization  important  scientists  effectively explore interpret  manipulate  rich information  visualization   metagenomic data especially multisample data  one    critical challenge  different data sample source sequence approach  heterogeneous data format make robust  seamless data visualization difficult moreover researchers  different focus  metagenomic study taxonomical  functional samplecentric  genomecentric single sample  multiple sample etc however current efforts  metagenomic data visualization cannot fulfill    need    extremely hard  organize    visualization effect   systematic manner  extendable interactive visualization tool would   method  choice  fulfill    visualization need   paper   present metasee  extendable toolbox  facilitate  interactive visualization  metagenomic sample  interest  main components  metasee include   core visualization engine   compose  different view  comparison  multiple sample global view phylogenetic view sample view  taxa view  well  linkout   indepth analysis  frontend user interface  real metagenomic model  connect    core visualization engine  iii opensource portal   development  plugins  metasee  integrative visualization tool   provide  visualization effect  also enable researchers  perform indepth analysis   metagenomic sample  interest moreover  opensource portal allow   design  plugins  metasee  would facilitate  development   additional visualization effects
metasee  implement base     taxonomical  functional information  could  retrieve  metagenomic sample  take advantage  modern computer visualization technology include html5 canvas javascript svg  modern web browsers   requirement  view  result  metasee   update web browser   result   view online  offline  almost  operate systems   graphical user interface gui  highperformance computational backbone visualization tool  particularly powerful  use  combination  highthroughput automate analysis software  parallelmeta   feature   easytouse cross  platform  open source  metasee make  easy  build  visualization tool  highthroughput automate analysis pipelines   work   use parallelmeta    analyze  metagenomic data   interactive visualization effect  build base   result   core visualization engine  core visualization engine  compose  multiple view components  view components include  exclusive    overall framework figure  metasee visualization panel figure  global view figure  taxa view figure  phylogenetic view figure  phylogenetic file figure  link  annotations figure   sample view figure   components  capable  provide gui  visualization  upload file  aim  answer question regard  relative abundance  taxa across multiple level   hierarchy  multiple sample simultaneously  external file  hold  picture illustration etc object name  poneg002jpg open   separate window figure  overview   components  metasee  pie stand   element  metasee  direct arrow stand   frontend link  one component  another component  framework figure   external file  hold  picture illustration etc object name  poneg003jpg figure  overview   visualization result  metasee   framework  leave side bar  navigation  main window   work area  visualization  framework include  leave sidebar  figure     main window  figure    leave sidebar   navigation bar  visualization result    flip     main window   work area    view   display   area  metasee visualization panel figure   metasee visualization panel   main interactive operation panel  metasee   design  interactive analysis   structure  metagenome  panel   pie chart    sector represent  taxa    select  area   highlight  turn   right  right side bar  metasee visualization panel  display  detail information   node  link   view  lengths  layer   chart indicate  part   dataset  classify  precisely   color   sector indicate  abundance   sector taxa red color indicate  abundant taxa  global view figure    sample  global view   hierarchical tree  contain every taxa   proportion   sample two   sample   show   single global view   node compose   barplot show  relative abundance  different sample   taxa thus global view show  whole picture   sample  compare  global view   taxonomy units    level     rank    easy  find  part   input dataset  enrich classify   detail  heights   pillar stand   relative abundance   sample   taxonomy unit  detail information   certain taxonomy unit  link  small bar chart   taxa view  pair  piecharts   pair  barcharts  relative abundance absolutely abundance  legend  global view  color indicate  sample  indicate  figure legend    convenient  find  difference among multiple sample   global level   certain taxonomy unit  taxa view figure   one   set  sample  taxa view focus   detail information  one node taxa  global view  taxonomical hierarchy tree structure  click  barplot   node  detail information include  abundance information   specific taxa   useful  compare different sample  specific taxa    show  either piechart  barchart format  phylogenetic view figure    sample  phylogenetic view   unweighted phylogenetic tree  elucidate  evolutionary relationship   microbes   microbiome community  phylogenetic tree file figure  unweighted phylogenetic tree file  present  newick format   also  import   phylogenetic tree visualization tool  phylogenetic tree maker    sample view figure    sample  taxonomical community structure  represent   dynamic multilayer piechart    taxons   level proportion   vividly see  interactively zoomedin  zoomedout moreover piecharts  multisamples   smoothly shift  one  another  comparison  structure  proportion  sample view  implement   krona software   sample view  also  view directly  link   global view  click  legend box   upright corner  linkout annotation figure     taxa  function could  linkedout   annotation  external source  metasee visualization panel global view  click  name   node sample view  taxa view   use  taxonomy browser database  ncbi   external linkout annotation source  would facilitate dig  detail information   certain taxa  speed   manual analysis process  multisample comparisons metagenomic data  often generate  discrete point across multiple locations  time metasee  able  store  data  multiple sample   single framework individual sample may   step  thus  make  comparison among sample come  different time point  condition easy figure   global view figure   bar    color come    sample   height   pillar represent  relative abundance  correspond sample  correspond nod taxa taxa view figure   figure  include  piechart   barchart   node   pie chart  bar chart  two graph  represent  relative abundance  absolute number respectively  addition   visualization function  provide high quality graph  publication purpose   graph produce  metasee  vector graph  external file  hold  picture illustration etc object name  poneg004jpg open   separate window figure  comparison across multiple sample  global view  taxa view  piechart format  taxa view  barchart format   frontend interactive analysis interface  frontend interface mainly serve   set  real metagenome project base  metasee visualization system two areas may need  metagenomic visualization system dentistry  field experimental study  dentists  system would help   quick diagnosis  use  novel sample    collect  query  search   database  know sample  microbial communities    prove   workable  dentists  far   field study experts     ocean expeditions   soil sample test  tool would help   analyze  data quickly  get illustrative result easily   two areas   design two interfaces “digital mouth”  “metagenome global survey”  examples  frontend  opensource portals  plugin development opensource portals  design  extend  usability   metasee visualization system firstly community structure file  many format   import  metasee  xml  easy  expand   select   default format yet  run time community structure file  many format could  store  random access memory ram  double link tree   independent component  tree build base   design model    easy  develop  apis  new input file format  examples  develop apis  import output file  parallelmeta   megan   mgrast    apis  input data manipulations   development secondly  work flow  metasee could build  tree structure   output  tree   variety  view therefore add new apis   view   backtoback sample view  modify exist view would  facilitate thirdly  search function   metasee toolbox  provide  portal  search  metagenomic sample   metagenome database right   sample  “metagenome global survey” could  search   prebuilt database  annotate metagenomic sample   showcase  function yet  opensource portal could facilitate  redevelopment  search function  search  userspecified metagenomic sample   metagenome database finally   establish  repository     provide  view options   view service  apis     online tool  database connections   development  online web service  resources  online version   metasee accept file  many format    file  upload  gui   produce users  analyze  result dynamic graph online  also download  additionally high quality vector graph could  use  publication purpose additionally standalone metasee application could  download   virtual machine   develop  java   run almost    use  gui figure   command line  metasee  multithreaded   accept   large dataset  output result   set  html page  highresolution figure  external file  hold  picture illustration etc object name  poneg005jpg figure   gui  standalone version  metasee firstly select  format  input data   dropdown list secondly click  “input file”  select input file multiple file   accept   file    uniform format thirdly press  “output folder” button  assign  output path finally press “submit” button  run metasee  release  source cod  development document   document example source cod sample data   discussion group  developer  develop new apis  metasee   purpose   would like  accept  cod contribute   developers  ",-0.23189287480003504,0.2508738829749715,0.09017650944630752,0.0904155678497732,0.1452987982546178,-0.04306977377492239,-0.1334942791359813,-0.011898654160348784,0.07266288942374875,0.09770746931768537,0.06834281197006112,-0.13175652846693992,0.16659385192124931,-0.1415275560597774,0.09694002826764836,-0.008417367977037859,0.11906122260169764,0.1767432808013387,-0.09745362988552812,0.1110468767580754,-0.07191513884090557,-0.18351543284691035,0.09536379410288807,-0.028380504759352942,0.016087334627923926,-0.1899883120760238,0.07285328060087716,-0.115020178341087,-0.08321836018369774,-0.051556549610549146,-0.035261332976181864,0.33448664725057026,-0.18856326649174765,-0.06313599041922102,0.2511698011253971,0.12460708005649425,-0.02294274134577116,0.0038048625695113656,-0.01653698842064739,-0.18097209919236204,-0.10065137872202948,-0.1392674144573596,-0.09379106231290177,-0.10604006790325797,-0.1465909571355481,0.02853254031074715,0.10456273331100203,-0.08606820651016125,-0.11067132886153844,-0.2947187156243815,0.14022872431025174,0.06460449816031234,0.029926361076225094,0.5781181914655994,0.06058572374880732,-1.259536626564569,0.04752273515371731,-0.19616454671885236,1.106902648249034,0.15793884569763342,-0.14920992875351372,0.3535217857051097,-0.07635144772396549,0.07177613527877674,0.6052161737162034,0.016059689097409922,0.07841205587218192,0.009760486105132554,0.2274037186307519,-0.16859182898685066,-7.782796367720356e-05,-0.0016626889984191428,0.13637311936930355,-0.20978750803931667,0.13006866244766652,-0.03966808590692667,-0.07419342999503517,-0.07344747412756211,-0.3440562623934925,-0.11056916127486607,0.24607397133191486,0.0064895650878119574,-0.35282472715872665,0.02885378621011093,-0.870165132626033,0.12076261344671856,0.2403309127289718,-0.1076366876411576,-0.10949449966860454,-0.09152039252496272,-0.1051069881395552,0.09501688913873847,-0.039275911513171835,-0.07261017398631431,-0.05246211282929845,-0.07189761872456953,-0.13619381540842104,-0.3709289363543555,0.4106979532816102,0.1569284265228806,Visualization,11
211,211,"strainer software  analysis  population variation  community genomic datasets
metagenomic analyse  microbial communities   comprehensive enough  provide multiple sample   loci   genomes   dominant organism type  also reveal pattern  genetic variation within natural populations new bioinformatic tool  enable visualization  comprehensive analysis   sequence variation  inference  recent evolutionary  ecological process   develop  software package  analysis  visualization  genetic variation  populations  reconstruction  strain variants  otherwise coassembled sequence sequence read   cluster  match pattern  single nucleotide polymorphisms  generate predict gene  protein variant sequence identify conserve intergenic regulatory sequence  determine  quantity  distribution  recombination events  strainer software  first generation metagenomic bioinformatics tool facilitate comprehension  analysis  heterogeneity intrinsic  natural communities  program reveal  degree  cluster among closely relate sequence variants  provide  rapid mean  generate gene  protein sequence  functional ecological  evolutionary analyses
strainer  build around  interactive display  community genomic data  provide  suite  automate  manual tool  explore quantify  visualize  pattern  variation  sample populations strainer use  biojava  program framework  read  write  number  different file format include fasta blast output  genbank data preparation strainer display sequence read relative   user define reference sequence  reference    fully assemble chromosome  genome  contig   assembler   phrap    genome   relate organism reference sequence   input  either fasta   genbank  format file  latter format allow  gene annotations   include read alignments   reference sequence   import   strainer xml format  two source first  contig   align read   read directly   ace file produce  phrap alternatively  blastn procedural query  blast   use  align read   reference sequence   work  blast alignments read may align  multiple place   reference sequence  validate read placements alignments  compare  correspond matepair alignments matepairs  leave  right end read   clone dna fragment read  typically  least  base pair   length completely sequence fragment   obtain    small insert clone libraries  size   unsequenced region  typical libraries   precisely know   constrain   average clone size      small insert libraries  ~   fosmid libraries strainer allow flexibility  mate pair placement  gene insertions   subset  strain result  larger  expect mate pair separation  strain lack  insert strainer find alignments  place pair read within  window  separation supply   user    alignments  find   pair  read  best individual alignments   choose yellow outline  apply  read  could   place within  user specify range   matepair  range  average clone size   result regions   gene order   constant across  population  mark  yellow read figure  visualization figure  show  image   strainer interface  black bar along  top   window represent  reference sequence   overlay red frame indicate  scope   current field  view   genbank file  use  genes  display  dark grey arrows immediately   region bar link  thin horizontal line represent align matepaired read  display  point tip  bar indicate  sequence direction  thus point   expect placement   pair read use  toolbar  user  zoom     pan leave  right  explore  read alignments   zoom level  high enough   single base   least  wide   pixel color tick appear   read bar  indicate basebybase   read sequence differ   reference sequence figure 1bc  default read  sort  length   identity   reference sequence    array base  read length click   gene symbol reveal  gene position relative   align read  display gene information   box   bottom   read display color   three options  color read bar  default option   color regions within  read  indicate locations    disagreements   reference sequence  column  pixels  assign one  two userdefined color base   percent sequence identity   small window  base center   correspond position   read   window size  average   threshold   color occur  userdefined regions without sequence information    line  read   mate pair   color accord   overall sequence identity   read   reference alternatively  single read   shade   extent  depend   percent sequence identity   read   reference sequence finally  single solid color   use   read regardless   identity   reference sequence quality data strainer  read  confidence value assign  base call  phred score   fasta format quality file generate  phredphrap base call differences  score   userdefined confidence level   gray  user   set  threshold confidence level   base call differences   deemphasized color gray strainer allow  user  specify whether unknown base '  low quality base   ignore  calculate sequence divergences read group  apparent recombinant read  major goal   group read  similar sequence    reconstruct variant gene sequence   manual strain reconstruction mode  user click  read  select  select read  highlight  blue   use  ""make strain"" button  bring   select read   single strain fragment indicate   surround color rectangle similarly strain group   join strain fragment  give random color  default    color use    methods available  read  choice  independent   read color method choose group  strain fragment  often highlight read   divergent    portion   length  may  due  insertion  sequence   transposon    subset  individuals   homologous recombination  another sequence type recombinants   recognize  easily  chimeras  two variant sequence  user  flag  read  recombinants  program  outline   red  assign  mate pair    relevant strain automatic generation  read group strainer include  algorithm  reconstruct  possible variant sequence  consider  legitimate linkage pathways read  overlap sequence pattern  link  form  extend strain sequence type  long  overlap exceed  userspecified threshold  case  alternative variant paths  possible    overlap sequence subsequently diverge  two   paths fig   potential paths  generate  algorithm   execute   choose gene  every gene   annotation    user define segment   genome  variants   output   fasta list  nucleotide  amino acid sequence strainer  also use  algorithm  automatically group read   display  strain type since variants  determine  explore   possible ways  link read  single read   associate  multiple variant sequence  instance  read   assign  multiple group read  place   largest group group generate automatically   manually curated  resolve complicate regions   conflict read placements due  recombination group sequence  read list strainer allow  user  select  series  read  strain fragment  export  composite sequence   fasta file  either nucleotides  amino acids regions contain gap  sequence coverage  either  fill    reference sequence  mark  '  '  amino acid sequence  addition nucleotide  amino acid sequence   strain variant group   genes   output also  list  read contain  strain fragment   output   text file  use   applications edit  consensus sequence assembly  closely relate sequence  generate  composite sequence    mosaic  strain type    actually find   environment  composite may also take   sequence   less abundant variant therefore   important    ability  alter  composite sequence  strain analysis strainer  alter  reference sequence  match  select strain read  single base pair  update reference sequence   export   fasta file  orf search   applications obtain strainer strainer  develop  java  enable seamless execution  almost  compute environment   available  download   selfcontained application see  additionally  source code   detail documentation  available online  program interface api  provide  describe   online documentation see   allow custom algorithms   new cluster methods   implement  desire",-0.2181611170117343,0.24579158689439734,0.12797644510787787,0.10710231141677247,0.04934566517082881,-0.003534554876712032,-0.09963774777998076,0.0331561998050077,0.0240547613947566,0.11377682786207036,-0.014139001952891287,-0.03574888375195102,0.2125969097938227,-0.12919755441920872,0.17325444814668767,0.046516998911015434,0.07978112648867265,0.17568259826908192,-0.03576465100891979,0.04459488570729974,-0.04130014847253943,-0.23815726620784455,0.1033798330026566,-0.028242730673827283,0.036887383186357925,-0.19288938699816646,0.11427070228537795,-0.15009995940793416,-0.07051763323257619,-0.08507172876534566,0.02492830808970728,0.3051007452178658,-0.17623898408606853,-0.07692688964157987,0.2521018779072983,0.04508276065801007,0.04215677293994178,0.012239661052377315,-0.062237973476211475,-0.12040741189334304,-0.07402243147669979,-0.2031464350247419,-0.1155074009853758,-0.1018387831071369,-0.19109446550329545,-0.003872840758468381,0.0846094376913044,-0.10305448348972407,-0.2226604375448476,-0.3519523752399227,0.1544349005605114,0.05849088983128746,0.030701989585211868,0.6367139559639033,0.028361465360785695,-1.2596540167931058,0.04487405422670687,-0.2321876433645895,1.0781114542346075,0.2319950785081681,-0.19229620263126188,0.4178457404572557,-0.04579632292084635,0.05931298046229316,0.6849439541130126,0.0370773850650374,0.04887456589958005,-0.002795476097538359,0.21411331214003526,-0.1873156276373624,-0.04797706003554726,-0.00421734836014461,0.13806613503303822,-0.1896800074688736,0.22274825887117453,-0.040132483218590816,-0.13007054961924694,-0.14906087288723688,-0.3638864846406792,-0.07645242717565033,0.19416793089497156,-0.05695053095657781,-0.3970976389559913,-0.04884663984196641,-0.88702558898096,0.0864895052835677,0.2533661479842705,-0.13679528246537478,-0.07605322530645779,-0.034384446871199265,-0.1908283133071907,0.10614995210516684,-0.15609063324228153,-0.09160007561242868,-0.13323568797937424,-0.08439820790480858,-0.13641748298581738,-0.3884362906965288,0.3639307181774517,0.0876935730254689,Visualization,11
212,212,"interactive metagenomic visualization   web browser
 critical output  metagenomic study   estimation  abundances  taxonomical  functional group  inherent uncertainty  assignments   group make  important  consider   hierarchical contexts   prediction confidence  current tool  visualize metagenomic data however omit  distort quantitative hierarchical relationships  lack  facility  display secondary variables   present krona  new visualization tool  allow intuitive exploration  relative abundances  confidences within  complex hierarchies  metagenomic classifications krona combine  variant  radial spacefilling display  parametric color  interactive polarcoordinate zoom  html5  javascript implementation enable fully interactive chart    explore   modern web browser without  need  instal software  plugins  webbased architecture also allow  chart    independent document make  easy  share via email  post   standard web server  illustrate krona' utility  describe  application  various metagenomic data set   compatibility  popular metagenomic analysis tool krona    powerful metagenomic visualization tool   demonstration   potential  html5  highly accessible bioinformatic visualizations  rich  interactive display facilitate  inform interpretations  metagenomic analyse   implementation   browserbased application make  extremely portable  easily adopt  exist analysis packages
architecture thank  technologies   html5  javascript modern web browsers  capable  render fully feature graphical user interfaces   web sit  local applications krona' architecture take  hybrid approach   data  store locally   interface code  host   internet  allow  krona chart   contain   single file make  easy  view share  integrate  exist websites   requirements  view   internet connection   recent version   major web browser though local chart    require  internet connection  also  create  view   krona installation modularity  achieve  embed xml chart data   xhtml document  link   external javascript implementation   interface figure    web browser render  xhtml document  javascript load chart data   embed xml  render  chart   html5 canvas tag host  javascript   internet avoid installation requirements  allow seamless automatic update  krona evolve  allow krona   use   wide variety  applications utilities  create krona chart  separate   view engine  package   call kronatools comprise perl script  import data  several popular bioinformatics tool  generic file type figure  figure1  krona architecture xml within  xhtml document  use  store chart data within  web page xml tag nest  use  describe  hierarchy  attribute  use  store magnitude   information   node krona display  attribute  html elements allow hyperlinks  supplemental page   node  could  either page create   krona chart   blast result  exist web page   ncbi taxonomy page   taxonomy ids   nod  krona interface javascript  link   chart either via  web  locally full size image hierarchical classifications   directly import   rdp classifier phymmphymmbl mgrast  taxonomic  functional   webbased bioinformatics platform galaxy  sequence  also  taxonomically classify  blast result download  ncbi     metarep metagenomic repository  classification  raw blast result  perform  find  lowest common ancestor   highest score alignments  approach similar    megan  data  map   taxonomy tree automatically download  index   ncbi taxonomy database   import classifications  rdp  phymmbl  color gradient   use  represent  average report confidence  assignments   node  mgrast metarep  raw blast result  nod   color  average log  evalue  average percent identity also since phymmphymmbl  blast classifications   perform either  read  assemble contigs  script  import   tool allow  optional specification  magnitudes   classify sequence  script  also provide  generate magnitudes base  read per contig  assemblies   common ace file format  type  classifications   import  basic text file   excel template detail lineage  magnitude finally  xml file   import  gain complete control   chart include custom attribute  color   node since node attribute  contain html  hyperlinks xml import allow krona   deploy   custom data browse  extraction platform  addition   visualization tool visual design  krona display resemble  pie chart    subdivide separate class  sectors    embed hierarchy  sector  overlay  smaller sectors represent  children   squeeze toward  outside   chart  give  parent room  label    cause distortion     pie chart magnitudes  represent   angle   sector rather   area  example figure  show  oceanic metagenome  import  metarep  taxon ""gammaproteobacteria""  select   angle   highlight sector indicate  relative magnitude   node   case  classify sequence read  show   upper right corner  sector also surround smaller sectors  represent constituents  gammaproteobacteria   case  sum   constituent angle equal  angle   parent indicate   assignments  make directly  gammaproteobacteria  assignments   make   internal node  angular sweep would  wider   sum   children' clearly show   summary   assign amount  relation    figure  figure2  krona rsf display  bacterioplankton metagenome   vertical profile   north pacific subtropical gyre   import  metarep  display use krona taxonomy nod  show  nest sectors arrange   top level   hierarchy   center  progress outward navigational control    top leave  detail   select node    top right  chart  zoom  place  domain ""bacteria""   root   taxon ""gammaproteobacteria""  show select  interactive version   chart  available   krona website full size image  common criticism  rsf display   difficulty  compare similarly size nod  make comparisons easier krona sort nod  decrease magnitude  respect   siblings  addition  nod   color use  novel algorithm  work   sort  visually emphasize  hierarchy  quantity  algorithm   enable  default use  huesaturationlightness hsl color model  allow procedural color   adapt  different datasets first  hue spectrum  divide among  immediate children   current root node    children  turn subdivide  hue range among  children use  magnitudes  weight color  sort node   minimum   hue range cause recursive inheritance  node hue   largest child   generation  result  visual consistency  lineages   quantitatively skew toward particular branch  distinguish  generation without disrupt  consistency  lightness aspect   hsl model  increase  relative hierarchical depth  saturation remain constant spatial efficiency metagenomic hierarchies  easily become  complex   nod   discernibly apportion  label   computer screen although krona ameliorate  problem  interactive zoom  also offer several modifications  rsf display  maximize  amount  information contain   view first radixtree compression  use  collapse linear subgraphs   hierarchy simplify  chart without remove quantitative relationships linear subgraphs  represent multiple rank    classification occur  taxonomic classifications   sample  map onto  full taxonomy tree  example  homo sapiens    representative species   class mammalia  would typically  redundantly classify  primates hominids   rank  allow  classifications   view collapse   dynamically toggle  animation depict  transition  additional simplification  complex tree  taxonomy   prune  summarize  data   specify depth figure   example show  ncbi taxonomy summarize   maximum depth   level   linear subgraphs collapse second since deeper taxonomical level  often   interest  genus  species classifications krona allow significant quantities   level   view  direct relation   root   hierarchy   accomplish  dynamically reduce  label area  intermediate classifications remove  label  necessary compression  increase move outward   center  ensure   highest level   current view  also  label  intermediate level    compress  always  see  clearly  zoom finally krona' label algorithms greatly increase textual information density compare   rsf implementations space  use efficiently  orient leaf node label along radii  internal node label along tangents internal label use stepwise position  collisionbased shorten  display  much text  possible  avoid overlap polarcoordinate zoom  radial spacefilling display recursively subdivide angle  shape   nod approach rectangles  hierarchical depth increase   node magnitudes decrease thus zoom small nod  simply scale  entire figure  cartesian coordinate space would result   loss   angular aspect  make rsf display intuitive  spaceefficient  increase  capacity   display without cause  problem krona use  polar coordinate space  zoom   accomplish  increase  angular sweep  radius   zoom node   occupy   circle   original overview  angular sweep  surround nod  decrease simultaneously create  animate ""fisheye"" effect  animation ensure user cognition   change  context   final zoom view retain  entire capacity   original zoom    repeat   node  children provide informative view  even  deepest level   complex hierarchy zoom   traverse   hierarchy   accomplish similarly  click ancestral nod   show   center   plot   summary pie chart next   plot  trigger  reverse   fisheye animation compress  current node  reveal  position   new broader context multidimensional data  visualize secondary attribute  addition  magnitude individual nod  krona may  color  variable  categorical variables users may define  color  every node   xml  quantitative variables  gradient may  define   color  node  value  example    show  figure    node  color   quantitative redgreen gradient represent classification confidence figure  figure3 color  classification confidence human gut sample mh0072   metahit project   classify use phymmbl  display use krona abundance   simultaneously visualize   accessory attribute  link   hue   example hue  use  display classification confidence  report  phymmbl  average confidence value   node  color  low red  high green distinguish uncertain  certain classifications  interactive version   chart  available   krona website full size image additionally metagenomic data  often generate  discrete point across multiple locations  time krona  able  store  data  multiple sample   single document individual sample may   step    zoom level use  navigation interface   top leave  example  figure  krona  display one  seven depth sample   oceanic water column advance   sample progress  sample  greater  greater depths  transition  sample  animate use  polar ""tween"" effect emphasize  difference  sample  result   style  navigation   series  move picture   taxa dynamically grow  shrink  sample  samplein  case  sample descend  water column  approach  eyecatching    sample  direct comparison  many sample simultaneously  difficult  radial chart analysis across many sample  better leave  traditional heatmap  differential barchart visualizations",-0.23315033070864286,0.252536233656902,0.1573848096474013,0.13308334790273052,0.054276114303258065,0.01107232673520267,-0.1444949155265931,-0.014347424227720418,0.03919241306442155,0.12872458110947788,0.022394121224052682,-0.09959790767377803,0.16353973855340684,-0.13303829229549244,0.16517327319943684,-0.01573941561796906,0.06851750943673797,0.18642023481705308,-0.02801663647800499,0.0804302322778736,-0.03671787033209973,-0.21394272935967448,0.08174617943477144,-0.002451865973305085,0.0630107152830209,-0.22299224184188124,0.0826669629441063,-0.10477015282958746,-0.07847837245691612,-0.08002266147118524,0.034526590593374484,0.26527029304599314,-0.21584452463438325,-0.08876803086036801,0.22963189376889506,0.14530323345608026,0.05051715918840547,0.009758351475720205,-0.0564306909688876,-0.130153375767767,-0.08660057369766723,-0.1728616807803307,-0.11510840231055962,-0.07074563753650019,-0.15006215438876247,0.061148298152783026,0.14213322959362004,-0.05482147680745023,-0.12144605431877945,-0.29531318174949395,0.14453038524314327,0.043061313476668236,0.026165144760317127,0.586532581716374,0.06999484301753636,-1.1678476739197985,0.10936166404510056,-0.2068354821066637,1.0468233238868991,0.17367005469225985,-0.15398530435323998,0.3601455038253135,-0.0970663066781688,0.06352101233881527,0.6117602013815385,0.00955169333670486,0.04342703451223078,-0.052616048840492764,0.265440968300849,-0.20162351358616531,-0.06827213734843647,-0.03720142150597569,0.1383925794430132,-0.17858814235261564,0.1628851485424691,-0.04649139226000431,-0.117027732119449,-0.1290914720348529,-0.3285798172238884,-0.07410226531947171,0.14842488128121895,-0.06531550002297105,-0.3556700786327246,-0.0005177992639950738,-0.8181672938094692,0.10048485600249203,0.21825908764003546,-0.1538333443602649,-0.06992472325460045,-0.07331817803224859,-0.15073789826439604,0.1324357007918118,-0.10050322091689713,-0.110457715597514,-0.03500684678570681,-0.103440938476985,-0.15421958891427692,-0.3754581296190537,0.3954457556659417,0.12231173253162088,Visualization,11
213,213,"interactive tree  life itol  online tool  phylogenetic tree display  annotation 
interactive tree  life itol   webbased tool   display manipulation  annotation  phylogenetic tree tree   interactively prune  rerooted various type  data   genome size  protein domain repertoires   map onto  tree export  several bitmap  vector graphics format  supported
itol' function provide  easy way  manipulate  create customize graphical representations  phylogenetic tree   standard new hampshire  newick format  addition   standard tree representation tree   display   circular radial mode fig    particularly useful   visualization  midsized tree   several thousand leave circular tree   rotate  display  userdefined arc size fig  itol' user interface  example tree  interface   tree  life ciccarelli    annotate  genome size blue bar  show several branch  collapse  display  triangles popup windows give detail information  branchesleaves   bootstrap value  taxonomical categories    species tree display   ° arc   stack bar dataset   protein kinases tree display without branch length information  annotate  predict site count  various families open  new tabdownload slide itol' user interface  example tree  interface   tree  life ciccarelli    annotate  genome size blue bar  show several branch  collapse  display  triangles popup windows give detail information  branchesleaves   bootstrap value  taxonomical categories    species tree display   ° arc   stack bar dataset   protein kinases tree display without branch length information  annotate  predict site count  various families several function  available  allow users  customize  tree display  various ways branch   prune  collapse   node   use  reroot  tree color   assign  various leaf group simplify  navigation around  tree  tree whose leaf ids  base  ncbi taxonomy wheeler    itol  automatically determine taxonomic class   internal nod  assign proper scientific name   leaf internal node label  display  popup windows  appear  mouse pointer  position   correspond node fig   prune  collapse branch prune   process  select one  several branch   original tree  create  new smaller tree subbranches  individual leave   easily add  remove branch whose detail structure   need   collapse collapse branch  display  triangles total branch lengths   closest   farthest leaf  use  calculate  lengths   triangle' side  display external data   tree itol  display several type  data directly   tree fig    five datasets   upload   tree datasets  contain  plain text file   line correspond  one leaf   tree support dataset type  binary data simple bar  stack bar multiple value associate   leaf itol   first visualization tool  support  display  horizontal gene transfer hgts annotate directly   original newick tree file hgt information  encode   ids  tree nod therefore  addition  standard leaf ids  tree must  unique ids assign   internal nod detail explanation  example tree  datasets  available   itol online help page  export tree   format  tree display  itol either default  customize   export  several graphical format  bitmap  vector base currently support format  scalable vector graphics svg portable network graphics png encapsulate postscript eps postscript   portable document format pdf  addition prune tree   export  newick plain text file  implementation itol   wwwbased tool accessible use  modern web browser   cod  shockwave flash  javascript  flash object  display  tree  provide interactivity  create dynamically   server use  set  perl script   ming library author webpage flash plugin version   higher  require  full functionality tree export     intermediary svg file   convert   format use  inkscape graphics package author webpage useruploaded tree  data  store locally   server  available   least one year  original submission",-0.25935134029175905,0.2511133167411648,0.08892369685060701,0.012378842319620338,0.17264478553152166,0.12239878108142363,-0.10496196144830748,-0.010359445177552001,0.07424677077410045,0.10339729943300396,0.11778147814647676,-0.10707699318338464,0.1994799586913768,-0.1518960059584541,0.1493036497849971,0.08752641031859107,0.17514203371078038,0.18542038040678732,0.026112496926724123,0.1054626577036324,-0.15212043573349582,-0.20092927864629628,0.11098807937150723,0.058511111729405,0.1159158026315436,-0.227046544226666,0.09200912118696562,-0.04875827849009751,-0.09770806828136287,-0.06641272183544605,0.11530025802770145,0.4009319258779944,-0.22329191736146675,-0.057090024915134076,0.281109177932094,0.13627499870808246,-0.02302356825891209,-0.005402039624196744,0.006264082933335036,-0.19306443499027864,-0.0286785837137607,-0.200276650819609,-0.1077854597732314,-0.07863019490850441,-0.17195962380801455,0.05375311896999855,0.03927142096330547,-0.1134011667941816,-0.09242401412628706,-0.1880394651837614,0.12848609434066358,0.06188139348139059,0.06376739534434539,0.5292037235683709,-0.0006295286512847514,-1.1434495870394752,0.030006806054337167,-0.1871746627620056,1.060047340830624,0.19413651836962165,-0.16985739249785306,0.3719119607226816,-0.04857442761558038,0.13347202862958046,0.6121126386185181,-0.003032221515265002,0.04122821585478319,0.050046321049759306,0.2225012811462883,-0.1819219488316187,-0.10774342289505312,0.06248369951099609,0.2228639618763372,-0.248246696897647,0.1587368376626908,0.004782439429017547,-0.08932664658410662,-0.03358890787115739,-0.3234783395883996,-0.09730092341865984,0.15479568803492147,-0.11491142586860828,-0.3745579058316609,-0.006436658093381657,-0.7556715943103878,0.15855908709309485,0.27674237559990555,-0.1750363991862483,0.01379720896219892,-0.03110180058596565,-0.1440021550295144,0.2016332520439704,-0.0312539411766151,-0.08082080645833394,0.003207110487207225,-0.16938896844007634,-0.1279321724783818,-0.3755016134362586,0.4196364477867597,0.08655202539334082,Visualization,11
214,214,"reapr  universal tool  genome assembly evaluation
methods  reliably assess  accuracy  genome sequence data  lack currently completeness   describe qualitatively  misassemblies  overlook   present reapr  tool  precisely identify errors  genome assemblies without  need   reference sequence   validate reapr  complete genomes   novo assemblies  bacteria malaria  caenorhabditis elegans  demonstrate       human  mouse reference genomes  errorfree respectively  apply   ongoing genome project reapr provide correct assembly statistics allow  quantitative comparison  multiple assemblies
read map  read mapper smalt   use   examples  map sequence read  assemblies  entire command line use  give  additional file    note    option  always use    read   mate pair  independently map thereby avoid  false placement   read near   mate instead  elsewhere   better alignment   option  also always use  randomly place read  map repetitively  prevent  repetitive regions   reference sequence   zero read coverage  map duplicate readpairs  mark use  markduplicates function  picard version   reapr pipeline  assembly analysis algorithm  implement   tool call reapr 'recognition  errors  assembly use pair reads'  pipeline  simple  run require  input  assembly  fasta format  read pair  fastq format alternatively  user  map  read   assembly  provide  bam file   step   pipeline  outline  figure ​figure11  describe  see additional file   full detail   stage initially input   reapr pipeline must  generate start   unique  perfectly align read coverage   high quality set  pair read  small genomes     calculate use  extremely fast  high memory tool snpomatic   large genomes  coverage  extract   bam file  read map use smalt  perfect  unique map information together   bam file   larger insert size read map   genome  use  input   reapr pipeline reapr version   use   case   default parameters  pipeline begin   preprocessing step  estimate various statistics   average fragment length  depth  coverage use  sample   genome  particular  bias  account   calculate  expect fragment coverage   give value   content  correction   fragment coverage  apply  subsequent stag   pipeline  method use   take  low line   scatter plot  fragment coverage versus  content see additional file  figure s3d  next stage calculate statistics   base   assembly use  information   input bam file   perfect  uniquely map read depth  statistics  use  call errors   assembly   score  base   assembly  shall use 'inner fragment'  mean  inner mate pair distance  equivalently  fragment without include  read see additional file  figure s2a  metrics calculate  read depth  type  read coverage inner fragment coverage error  inner fragment coverage correct   content fcd error  amount  soft clip  metrics  explain   detail    additional file  recall   fcd error   base   assembly  take    area   observe  ideal fragment coverage distributions see figure ​figure1c1c   normalize   fragment depth  mean insert size   result  comparable  data  different libraries  correction  make   presence   nearest gap   lie within one insert size   base  interest see additional file    base  zero fragment coverage   metric cannot  use   assumption    assembly  incorrect  exception      gap  length longer  half  average insert size   case   impossible  determine   scaffold  correct  therefore   analysis  perform  addition   absolute count  read coverage  type  read coverage  consider   base    strand  proportion  read   follow type  calculate proper read pair define     correct orientation  insert size      majority   genome  correct orphan read whereby  read' mate  either unmapped  map   different chromosome read   correct orientation  wrong insert size  read pair   incorrect orientation  read map tool  capable  softclipping read     read  align   genome    base  either end   read   match   case  read  still report  map   mismatch base   consider  part   alignment  designate  softclipped additional file  figure s2c   base  number  alignments  count  start  end   base due   softclipped read  order  call assembly errors   give metric  minimum window length  consider  appropriate minimum  maximum value  region  length  smaller   window length    least    base fall outside  acceptable range  report  example  collapse repeat  call   relative error  fragment coverage   least two     base   stretch   least 100bp  default choice  parameter   metric  describe   additional file    actual implementation  user  choose  parameters  describe earlier  base score one    cover   least five perfect  uniquely map read   fcd error  acceptable  either   test fail   score  set   number  test  pass consider  perbase metrics scale  zero  one    base score zero  every test fail  fcd error cutoff  choose  sample windows   genome    window  cutoff  fcd error need  call  window   error  calculate   word   window  find  value       value   window  greater    proportion  fail windows   function  cutoff value  plot figure ​figure2  cutoff value   fcd error  choose    first value find work  largest  smallest    magnitude   first  second derivatives normalize    maximum magnitude     plot    least  reapr output reapr report assembly errors  warn   gff file compatible   genome viewers   artemis  regions   high fcd error  low fragment coverage  report   error whereas regions  fail   test  output  warn  manual inspection  summary spreadsheet  produce contain error count break     type  error   contig    whole assembly reapr also produce  new assembly base   error call  break  genome wherever  error  call   gap error regions within contigs  replace   enable    accurately reassemble locally   gap close tool   second run  reapr   perform  gap close  verify  new sequence add   assembly reapr also generate plot file compatible  artemis    statistics examine   base  easy visualisation see additional file  figure    example  novo assemblies   novo assemblies   aureus   falciparum  produce use similar methods see additional file   full detail short insert illumina read  assemble use velvet  version   assemblies  scaffold iteratively  sspace  version  use  short insert read follow   round  scaffold  larger insert read  available assembly analysis manual comparison    novo assemblies  reference genomes   aureus   falciparum  perform use act  blast hit   sequence  generate  view  act use blastall version    settings  blastn          count scaffold error call   aureus  velvet assembly  find  contain three problematic regions  many gap  errors due  repetitive sequence    regions  count  one scaffold error   purpose  calculate reapr' performance  error call  read set use   falciparum assemblies  illumina 500bp insert illumina   insert     insert read  short insert illumina read  use  generate perfect  uniquely map read depth  also  call collapse repeat   errors  identify use   read perfectly map  unique read depth  generate    elegans genome ws228 use three illumina lanes combine   larger insert size dataset comprise four combine illumina lanes prior  map  latter read inner adaptor sequence  remove use inhouse script base  ssaha2  retain read pair   mate   pair   length   least 35bp pcr primers  design  amplify  top  fcd error regions use aceprimer   high coverage illumina data   use  analyse  human  mouse reference genomes   organism  dataset comprise short insert data    one   insert 'jumping' library  short insert data  use  compute  perfect  uniquely map read depth   3kb libraries  combine  obtain enough coverage  analysis  reapr",-0.2135301062970464,0.2143058572705466,0.15241071507133044,0.14000233574165394,-0.05628160907632703,0.03010807148400288,-0.0907189954207291,0.11873295249668282,-0.02837934895672804,0.13294068867037576,0.045108109219745285,-0.009074765694171209,0.17304204723655964,-0.055693891563995436,0.16327444119672255,-0.03234614065806736,0.06061951893203332,0.21642688899655432,-0.09014901120565204,0.08045126998193901,0.02562924675225449,-0.21407757293250534,0.051619291047388716,-0.04475951260854087,0.006580494206736055,-0.19012146716047654,0.022270469359956985,-0.13032097018949002,-0.04033595597772649,-0.08396525220246374,0.04339238525468495,0.2301168052206232,-0.15825380979430784,-0.06861985856546278,0.22065151378390468,0.07690099471070244,0.045589957027231634,-0.007931756272452475,-0.07928953978298428,-0.13653641454374366,-0.09741145214527293,-0.12560361937185938,-0.051194179203487164,-0.1003670076423464,-0.13563385020420224,-0.040423842912094964,0.14196079066695635,-0.20202413345185985,-0.2378078662595416,-0.3782941089228671,0.16670351503374115,0.04036554832865785,0.061122821080052285,0.6453717824296532,-0.030162160955656693,-1.304155810811897,0.01401192118997962,-0.1848735216900516,1.0618672247443182,0.19172675077686716,-0.1869990119773661,0.3575534529979721,-0.08146201760821005,0.06985740083101111,0.6124715789158894,0.032554796985179435,0.050873638282278234,0.02090580602423374,0.15314524029344906,-0.19016359499615945,-0.07617064226670853,-0.013580807385381966,0.09804468034195844,-0.125011061813213,0.25210353577499744,-0.005997199471673276,-0.1511759934555788,-0.1108592873270528,-0.3596699097941769,-0.07841470075240774,0.2381654338079463,-0.014631241001815138,-0.4140985901239484,-0.06597704487349203,-0.8861224739625928,0.048593738550513375,0.2437409926988087,-0.13268426188550098,-0.0753898677314397,-0.03801197487104066,-0.1559083284092138,0.09369236393220566,-0.09367977422228196,-0.11140661254119412,-0.13743561989349115,-0.0739604479928435,-0.09470792733294173,-0.2984082963161189,0.3214939997764915,0.07442126714678242,AssemblyEvaluation,12
215,215,"versatile genome assembly evaluation  quastlg
 emergence  highthroughput sequence technologies revolutionize genomics  early   next revolution come   era  longread sequence  technological advance along  novel computational approach become  next step towards  automatic pipelines capable  assemble nearly complete mammaliansize genomes   manuscript  demonstrate performance   stateoftheart genome assembly software  six eukaryotic datasets sequence use different technologies  evaluate  result  develop quastlg— tool  compare large genomic  novo assemblies  reference sequence  compute relevant quality metrics since genomes generally cannot  reconstruct completely due  complex repeat pattern  low coverage regions  introduce  concept  upper bind assembly   give genome  set  read  compute theoretical limit  assembly correctness  completeness use quastlg  show  close  assemblies    theoretical optimum   far  optimum    finish reference
upper bind assembly construction  construct upper bind assembly base   reference genome   give set  read  first  construction algorithm map  read   reference genome  detect zerocoverage regions fig   use minimap2    align long errorprone read pacbio  nanopore  bwamem    short illumina read pairedends  matepairs fig  upper bind assembly construction   available read brown  long read orange  matepairs  yellow  pairedends  map   reference gray  compute zerocoverage genomic regions repeat sequence red  detect use repeat finder software nonrepetitive cover fragment  report  upper bind contigs   overlap   contigs green  either long  matepair read  detect  contigs   join  form upper bind scaffold   gap  adjacent contigs within  scaffold  fill either  reference sequence  cover regions   stretch   nucleotides  coverage gap unresolved repeat  add  separate sequence open  new tabdownload slide upper bind assembly construction   available read brown  long read orange  matepairs  yellow  pairedends  map   reference gray  compute zerocoverage genomic regions repeat sequence red  detect use repeat finder software nonrepetitive cover fragment  report  upper bind contigs   overlap   contigs green  either long  matepair read  detect  contigs   join  form upper bind scaffold   gap  adjacent contigs within  scaffold  fill either  reference sequence  cover regions   stretch   nucleotides  coverage gap unresolved repeat  add  separate sequence    lightweight red girgis   novo repeat finder  use  mark long genomic repeat   reference fig   call  repeat long   length exceed  median insert size   pairedend library  several pairedend libraries  available  maximum median value  use among  detect repeat sequence  select    occur  least twice  remote part   genome  long repeat cause ambiguities   assembly  may  resolve   long read  matepairs  long regions mark  red appear   short tandem repeat  multiple copy    genomic loci   best   knowledge  tandem repeat   cause ambiguities    approximately resolve   assemblers without use longrange information  use  bruijn graph topology miller    split  reference sequence  coverage gap  long repeat result   set  unique genomic fragment refer   upper bind contigs  however   reflect  best possible assembly   entire dataset  achieve   realistic upper bind  detect  contigs   connect  long read  matepairs   join   upper bind scaffold   number  connections exceed  small threshold  fig    study  use     long read      matepairs  say   long read connect two contigs   simply overlap   contigs  pair  read connect contigs   leave read overlap   first contig   right read overlap   second contig   analysis  ignore read pair  map inconsistently   abnormal insert size   first   last decile  enable efficient overlap detection  read  upper bind contigs  sort  read accord   map position thus  scaffold construction algorithm require onlogn time  read sort   time  find overlap     total number  long  matepair read use  scaffold  upper bind contigs  join  scaffold  gap  adjacent contigs  fill   correspond genomic sequence   reference genome — case  coverage gaps— stretch   fig  remain unresolved repeat  add   final upper bind assembly  separate sequence  adaption  conventional metrics  large genomes  key characteristics   assembly quality   assembly completeness  fraction   genome  assemble correctness  many errors  assembly contain  contiguity  many fragment  assembly consist    long    completeness  correctness   accurately measure  quastlg    highquality reference genome  available  contiguity statistics    wellknown n50 metric   require  reference however   estimate   genome size  know   suitable analogues   compute namely ng50   reference sequence  available  provide even  relevant insight  compute nga50like statistics gurevich     contiguity measure base  errorfree align assembly fragment rather   initial contigsscaffolds  alignment   reference genome appear     time consume step   assembly evaluation especially  large genomes  address  bottleneck  replace  accurate  slow nucmer aligner  mummer  package kurtz    use  original quast   faster minimap2 aligner    recently release mummer  package marcais     also outperform  minimap2   benchmark experiment albeit  speed increase   case    substantial   minimap2s improvement   previous mummer version   thoroughly choose minimap2 options  order  maintain  alignment speedaccuracy ratio  different scenarios  standard mode quastlg run alignment   parameters enable accuracy comparable  nucmer   suitable  small genomes  ‐‐large mode quastlg configure minimap2  achieve adequate run time  large  complex input  assembly correctness  usually characterize   number  large assembly errors socalled misassemblies gurevich    define  misassembly breakpoint   position   assemble contig   flank sequence align  opposite strand inversion   different chromosomes translocation   inconsistency size   gap   overlap   alignments   leave  right flank sequence   reference     predefined breakpoint threshold  relocation  alignments    strand    chromosome     consider  small errors  classify  local misassembly eukaryotic genomes usually contain  lot  transposable elements tes  may cause discrepancies   reference genome   genome actually  assemble  short variations result   huge number  false positive misassemblies  compute accord   definition give   distinguish  true misassemblies   ones cause  tes quastlg perform  additional check   relocation  inversion  identify possible tes fig   identification procedure depend   size   breakpoint threshold   optimal value  slightly exceed  length   largest    genome  process  tandem  insertions  deletions    scope   paper  optimal value thus depend   subject organism   allow users  set  manually   sake  consistency  use         benchmark experiment   study see supplementary methods  detail   value choice   also  default value  quastlg  contrast  regular quast  use     fig  detection  discrepancies cause  tes   subfigure  plot  reference genome  top  contig  bottom  match fragment blue  green bar   position     respectively  locations  tes violet bar cause discrepancies   map  inconsistencies   alignments  show  arrows   character    present    miss   since    equal   tes length  specifically choose breakpoint threshold  transform classification   discrepancy   relocation   local misassembly     locate inside    position    significantly away   rest   mappings  could also  locate   opposite strand original quast would treat  situation  two misassembly breakpoints relocations  inversions      usually much higher    contrast quastlg classify  pattern  possible  since  compute δδ2δ1    equal   tes length  could  prevail  appropriate      first   last alignment fragment     location    large distance  away   neighbor  fragment quastlg cannot reliably distinguish  situation   real relocationinversion  would need   able  recognize  base   genomic sequence     scope   paper open  new tabdownload slide detection  discrepancies cause  tes   subfigure  plot  reference genome  top  contig  bottom  match fragment blue  green bar   position     respectively  locations  tes violet bar cause discrepancies   map  inconsistencies   alignments  show  arrows   character    present    miss   since    equal   tes length  specifically choose breakpoint threshold  transform classification   discrepancy   relocation   local misassembly ⁠⁠    locate inside    position    significantly away   rest   mappings  could also  locate   opposite strand original quast would treat  situation  two misassembly breakpoints relocations  inversions      usually much higher    contrast quastlg classify  pattern  possible  since  compute δδ2δ1⁠    equal   tes length  could  prevail  appropriate      first   last alignment fragment     location    large distance  away   neighbor  fragment quastlg cannot reliably distinguish  situation   real relocationinversion  would need   able  recognize  base   genomic sequence     scope   paper  best set  alignments selection long contigs  rarely map   reference perfectly   single unambiguous alignment  alignment software typically report multiple alignment fragment  different locations   genome  may happen due   presence  genomic repeat  tes   reference genome    case   algorithmic issue   assembly orand alignment software quastlg attempt  accurately assess  contig  select  set  nonoverlapping alignments  maximize  total alignment score   define   function   alignment lengths map qualities  side  side inconsistencies misassemblies  problem  know   collinear chain problem myers  miller     usually solve  sequence aligners   lowlevel chain   join short match seed  larger alignment fragment  example mummer kurtz    combine maximal unique match  minimap2   chain minimizers roberts      implement  dynamic program algorithm call bestsetselection   highlevel chain   combine alignment fragment see supplementary methods  algorithm  conceptually similar  deltafilter utility  mummer package kurtz      approach include  comprehensive set  penalties  various misassembly events  feature allow bestsetselection  correctly resolve many complex set  alignments   typical  eukaryotic assemblies  produce   accurate chain  deltafilter   benchmark experiment bestsetselection   quadratic algorithm  respect   number  fragment alignments per contig   usually fine since  number  generally small    however  may cause  significant slowdown  case  large genomes evaluation   number  alignments may reach dozens  thousands   contigs although   chain algorithms  subquadratic time complexity abouelhoda  ohlebusch     applicable   gap cost function  associate   large constant instead   implement  simple heuristic  always find  best alignment set  one   several set  maximize  score supplementary methods  even though  heuristic idea   guarantee  speed   theory  significantly drop  run time   six benchmark dataset evaluations  kmerbased quality metrics  show   presence  many tes   specific feature  eukaryotic genomes significantly complicate assembly evaluation although quastlg adjustment   conventional completeness  correctness measure improve  assessment  may still   good enough  form  complete picture  eukaryote assembly quality   propose  assess assemblies use  completely different strategy inspire   evaluation procedures  putnam     chapman     generalize   arbitrary genome analysis  quastlg  strategy  base   analysis  unique kmers nonrepeated sequence  length     reference genome    assembly   value  sufficiently large quastlg use mers  default unique kmers appear   widespread across  genome  instance  fruit fly genome contain  millions unique mers    millions total mers  existence   position   kmers   assembly describe  completeness  correctness  use kmc  kokot     detect  unique kmers   reference genome  percentage   kmers detect   assembly  report   kmer completeness compare   genome fraction completeness measure  kmerbased value account  perbase quality   assembly   usually highly important   downstream analysis   genome annotation  benchmarking  show  assemblies    similar genome fraction may  completely different kmer completeness due   high mismatch  indel error rat  kmerbased correctness  calculate base   small uniformly distribute subset   unique kmers  order  speed   computation  select  subset   way   two kmers   subset   least   apart      reference genome   subset  provide  kmc   identify contigs   least two kmers  contig position   detect kmer  examine   refer   consecutive list  kmers k1k2…  ≥⁠   contig    marker    ∈  distance          equivalent within  small error    distance    default   process contigs   least two markers  check whether  relative position  adjacent markers    correlate   locations   quastlg report  kmerbased translocation breakpoint      originate  different chromosomes   kmerbased relocation   markers     chromosome   inconsistency   position      larger   predefined threshold  use   threshold  default   refer  kmerbased translocations  relocations  kmerbased misjoins  exclude confusion  regular quast misassemblies kmerbased misjoins  essentially similar   regular misassembly metrics except    focus    critical assembly errors  key benefit   measure    tolerance  inconsistencies cause  tes since tes mostly correspond  genomic repeat  thus lack unique kmers  example kmerbased relocations  successfully resolve  situations   contig start  end     cause  ambiguity   regular misassembly detection algorithm fig   evaluation without  reference genome   real assembly project  reference genome sequence   available   assembly quality assessment must rely   source  information  primary purpose  quastlg   referencebased analysis   also include    novo eukaryotetargeted completeness measure  make  tool useful   wider set  applications quastlg  supply  genemarkes lomsadze    software   novo gene prediction  eukaryotic genomes however despite  relevance   gene find  assess downstream analysis perspectives  heuristic nature may result   mislead output   experiment  instance  assembly may contain multiple copy  one gene    report several time  counter   additionally use busco simao     find  number  assemble conserve genes   present nearly universally  eukaryotes   single copy  demonstrate  busco completeness correlate   accurate referencebased quality metrics  add  computation    benchmark experiment note  referencefree correctness metrics    scope  quastlg   recommend use specialize  novo evaluation tool   scenario  instance reapr hunt    identify likely assembly  scaffold errors base  pair read map another example  kat mapleson     compare  kmer spectrum   assembly   kmer spectrum   read   quite useful  identify miss sequence collapse repeat  expand sequence   assembly",-0.1796633119098055,0.19198276844522036,0.12877949234462566,0.1421996838173061,-0.0072729475925573045,-0.024861598444634543,-0.08577637996940679,0.03724852071424432,-0.01905565965244421,0.09286801254774657,-0.006785296377974944,-0.00926263936975565,0.15994519130870627,-0.08360939825930908,0.1443492583301048,-0.04070384824737405,0.038035061550712866,0.1991493977823186,-0.04403890211103995,0.06713760904282774,0.035558937126293294,-0.18068233586523316,0.041013157816552036,-0.035698122180217125,0.013108215737530049,-0.17225463006423905,0.046890576568002926,-0.17964311209266806,-0.08522256107920531,-0.062205039076518025,-0.013825238970635206,0.21394946407005688,-0.1400070618040563,-0.09832813011170642,0.17926458896110264,0.10657826093308256,0.04423963059474465,0.02350982351604622,-0.09540137527986024,-0.08311845383183092,-0.08131885601551757,-0.1462394106144212,-0.07340163374316029,-0.08831466220086805,-0.13450099867854212,-0.027588549209202975,0.15444217097667068,-0.11356625672745342,-0.20232549981951586,-0.3595673037472098,0.16635327767132574,0.004374177067557711,0.04531426665929535,0.5979639088446406,0.04937316467970936,-1.1640444017978784,0.07375552730652297,-0.18802065822220784,0.9378849020752844,0.1841785359981212,-0.1872175729982296,0.3487385495260492,-0.06684669639575637,0.06761860710443747,0.583688543112555,0.01330655442746808,0.04897457017053716,0.011786932838298758,0.17048633538962835,-0.17665352317927616,-0.04332587551545091,-0.02321156997638805,0.08326354807242567,-0.10982526592212162,0.2065843328864916,-0.03773853481664863,-0.11607574254415742,-0.1234470973363735,-0.3351400921749591,-0.04483618079679437,0.21626018355932566,-0.00975148868250605,-0.37448992368639744,-0.03604794228183476,-0.8533255018944982,0.052723760545637786,0.18411369087901086,-0.10765889479777067,-0.1385618577797275,-0.053600364710132214,-0.16393340441907708,0.05927905166235276,-0.13887947141344978,-0.10663746969216156,-0.16285346506264772,-0.04647488411295874,-0.1112593262199843,-0.2902392499751509,0.28361630760365003,0.10275394244229563,AssemblyEvaluation,12
216,216,"ale  generic assembly likelihood evaluation framework  assess  accuracy  genome  metagenome assemblies
researchers need general purpose methods  objectively evaluate  accuracy  single  metagenome assemblies   automatically detect  errors  may contain current methods   fully meet  need   require  reference  consider one   many aspects  assembly quality  lack statistical justification  none  design  evaluate metagenome assemblies   article  present  assembly likelihood evaluation ale framework  overcome  limitations systematically evaluate  accuracy   assembly   referenceindependent manner use rigorous statistical methods  framework  comprehensive  integrate read quality mate pair orientation  insert length  pairedend read sequence coverage read alignment  kmer frequency ale pinpoint synthetic errors   single  metagenomic assemblies include singlebase errors insertionsdeletions genome rearrangements  chimeric assemblies present  metagenomes   genome level  realworld data ale identify three large misassemblies   spirochaeta smaragdinae finish genome    independently validate  pacific biosciences sequence   singlebase level  illumina data ale recover     single nucleotide variants   train set   gcrich rhodobacter sphaeroides genome use real pacific biosciences data ale identify    synthetic errors   lambda phage genome surpass even pacific biosciences  variant caller evicons  summary  ale framework provide  comprehensive referenceindependent  statistically rigorous measure  single genome  metagenome assembly accuracy    use  identify misassemblies   optimize  assembly process
 ale score   likelihood   assembly  ale framework  found   statistical model  describe two probabilities  bayesian prior probability distribution forumla describe  likelihood   assembly forumla without  read information   probability forumla describe  likelihood   set  read forumla⁠  generate   assembly forumla⁠  prior forumla   compute use  kmer distribution   assembly whereas  likelihood forumla  calculate  information  read quality agreement   map read   propose assembly mate pair orientation insert length pairedend read  sequence depth  detail description   likelihood  prior probability  give   follow  ale score except   proportionality constant  depend   read     assembly   logarithm   probability   assembly  correct forumla⁠ accord  bay rule  probability  formula   forumla   proportionality constant ensure forumla   probability distribution   typical  largescale applications  bayesian statistics compute forumla exactly  intractable  ale score  compute  replace forumla   approximation describe   supplementary materials   take  logarithm   result approximation  forumla⁠  ale score   use  compare two different assemblies    genome forumla  forumla⁠ call forumla⁠  ale score   first assembly  forumla⁠  ale score   second  generate    set  read forumla⁠  difference   score   give   equation formula   assembly   higher ale score  also  one   larger probability   correct moreover  difference  two assemblies ale score describe  relative probabilities  correctness   refer   ale score  precisely   total ale score  differentiate    subscores describe later   text use  construct  although  ale score   report   standalone value   make possible   facilitate comparisons   assemblies    genome  emphasize   ale score   comparative measure     use  judge  quality   single assembly  isolation  errors  estimate forumla may cause  large difference   ale score  forumla⁠  also emphasize   ale score    use  compare different assemblies    genome    ale score   calculate use   set  read figure  show  pipeline use  compute  total ale score give  set  read   propose assembly ale first take  input  alignments   read onto  assembly   form   sam  bam file        produce   thirdparty alignment algorithm   bowtie langmead     bwa     ale  determine  probabilistic placement   read   correspond placement subscore   map base  describe  well  read agree   assembly   case  pairedend read ale also calculate  insert subscore   map base   assembly   read pair  describe  well  distance   map read match  distribution  lengths   would expect   sequence library  insert subscore  similar   compressionexpansion  statistic  zimin     detail give   supplementary materials ale also calculate  depth subscore  measure  evenness   sequence depth account    bias prevalent   ngs techniques  placement insert  depth subscores together determine forumla⁠ independently    assembly    read ale calculate  kmer subscore   prior forumla⁠  subscore  calculate   scaffold  contig within  assembly independently allow  genome variations commonly find  metagenomes   contigscaffold  likely   different species   different kmer profile  four subscores   combine  form  total ale score  constituent calculations   pipeline  describe   supplementary material fig   components   total ale score ale take  propose assembly   alignment  read  input four score  kmer placement depth  insert subscores  compute use  model describe  section    four score  total ale score  calculate  report   text file ale   text file   use  input   supply plotter  generate  pdf file  visualization open  new tabdownload slide  components   total ale score ale take  propose assembly   alignment  read  input four score  kmer placement depth  insert subscores  compute use  model describe  section    four score  total ale score  calculate  report   text file ale   text file   use  input   supply plotter  generate  pdf file  visualization  contributions   four subscores  report  ale   function  position within  assembly    visualize   include plot package  export  genome viewers include  integrative genomics viewer nicol      ucsc genome browser kent     detail   probabilistic ingredients   ale score   describe  four subscores placement insert depth  kmer   role  play within  ale framework  first three   subscores appear   likelihood forumla⁠ ale compute forumla use  probabilistic model   way   read  generate   assembly   whole genome shotgun sequence process  model make independence assumptions  decompose  probability   product  three term formula   term   separate subscore   explain later   text  detail  placement quantify  well  sequence   read agree   assembly assume  every pair read forumla  generate independently   assembly  probability   set  read forumla give  assembly forumla  forumlaforumla⁠  forumla    product  two independent probability distributions forumla⁠  forumla describe  well  read match  subsection   assembly    map  forumla describe whether  mate pair   orientation   consistent   library   describe  detail   two probabilities  compute begin  forumla⁠ assume   base forumla   read  correctly call   sequencer independently   probability equal   base quality score forumla⁠   forumla⁠  forumla   base forumla correctly match  assembly  forumla      expression follow   model assumption   four possible errors   sequencer could  report three different substitutions  deletion  equally likely   read   match  sequence   assembly   unknown base denote   set forumla⁠ model  lack  information   correct base   location   ambiguity code  report   sequencer   aforementioned expression  modify  account   distribution   possible base encode   code  read may   place   single position   assembly   aligner place  particular read    one position  choose one position  random weight  forumla⁠  allow  repeat regions   properly represent   correct number  read  expectation  orientation likelihood forumla⁠  calculate  first count  number  time   orientation occur   library   map information  likelihood forumla    empirical frequency   observe orientation   read forumla   library   forumla belong  likelihood  also  override  userspecified value  also derive perbase placement subscores   position   assembly  placement subscore   particular position   geometric mean forumla⁠   product    read forumla cover  give position  forumla   number   read  insert describe  well  mate pair insert lengths match   would expect   compute  forumla⁠  insert likelihood forumla⁠  determine  first observe  insert lengths   mappings   read  calculate  population mean forumla⁠  variance forumla⁠   lengths  mean  variance  also  set   user    know  step  need      complete  calculate  insert likelihood   read pair forumla  assume   observe insert length forumla  distribute normally   mean  variance forumla    placement subscore  calculate  insert subscore   position   geometric mean   forumla   read forumla cover  position   identify areas  constriction  expansion within  propose assembly  insert subscore  similar    statistics  zimin       show  describe  similarity  first write  insert subscore  forumlaforumla   products  sum  forumla    read cover  give position  forumla   number   read   use  fact  forumla⁠  forumla   sample mean   imply insert lengths  forumla   sample variance   statistic  zimin     forumla⁠  imply forumla⁠  forumla grow large   statistic  asymptotically normal owe   central limit theorem  log   insert subscore    write forumla⁠  insert subscore  decrease  forumla⁠   term involve   statistic dominate  forumla  large thus  forumla  large  position  lowest insert subscore   position whose  statistic  furthest  forumla⁠  flag  regions  low insertsub score  similar   rule recommend  zimin     flag  regions  forumla larger   fix cutoff value  depth describe  well  depth   location agree   depth   would expect give   content   location    product   depth subscore   position   assembly forumla⁠  forumla   depth  position forumla⁠  depth forumla  ideally poissondistributed lander  waterman  however  nextgeneration sequencers  library preparation techniques  bias gcrich areas   genome aird     bias affect  observe depth  specific areas  model  depths  poisson distribute   mean draw   independent gamma distribution center   expect depth   position give   content  model  uncertainty   mean   poisson distribution arise   dependence   expect depth       content   position include hard stop    content  nearby position  result   infinite mixture  poissons   equivalent   negative binomial distribution  first calculate     follow  range   content   forumla⁠   average observe depth  position   assembly whose  content calculate    content within  average read length  within  range let forumla   average observe depth    content range   forumla fall  forumla    content percentage average across  read  map   placement step   position   forumla fall   minimum value  forumla⁠  use  minimum value instead  discount regions  exceptionally low average depth    give position forumla⁠  depth subscore  forumlaforumlaforumlaxi  kmer describe  likelihood   assembly forumla⁠   absence   read information within  prior probability distribution  encode  belief  within  single genome  kmer  permutation   base pair     fix user define number initially set     unique kmer frequency  forumla dimensional vector give  frequency   kmer  conserve across  genome   help determine  two different genomes   mistakenly combine teeling    woyke    let forumla   set   possible unique kmers  forumla⁠    forumla  forumla let forumla   number  time  kmer appear   contig   assembly   frequency forumla   particular kmer forumla within  contig  forumla⁠  kmer score   product   frequency   kmer appear   contig   assembly forumla⁠    write  forumla⁠   equivalent  assume  kmer   assembly  draw independently   common multinomial distribution  probabilities empirically estimate   assembly  prior distribution   account  horizontal gene transfer   phages  thus may inappropriately flag  regions   misassembled  kmer subscore   base   give position   assembly   geometric average  forumla   kmers  cover  position  calculate  average   first base   genome   one contribute kmer  second  two    contribute kmers  forumla base",-0.1847678974840424,0.21337117634097272,0.1370777678808476,0.1855322397033368,-0.060209127677028726,0.006861305447305962,-0.07381443985767484,0.054108069569857815,-0.02642036344643981,0.1198299292289968,-0.02796870875863533,-0.020520333133650374,0.17037498992004071,-0.08503462789745495,0.15550900868817866,-0.017228146566464732,0.04069933564252486,0.23223799627008446,-0.04087955978008852,0.05406909156070989,-0.00917058635968715,-0.22048792153684968,0.07100394333987682,-0.0006967988649973579,-0.06349966625332724,-0.18811099469166948,0.1086950346748381,-0.1722920290390643,-0.06329255004473973,-0.09373006606814928,0.01221061640795337,0.2379832186021044,-0.1875947153141949,-0.08129688905033358,0.16481202873709272,0.08529012100240964,0.07761320184311314,0.03233032820181896,-0.07728887374832992,-0.15380107701119933,-0.1075470555897482,-0.13420560235879614,-0.07861176153437555,-0.11241794785954493,-0.18026182790423004,-0.01927311676997436,0.14703747938578512,-0.16928820136204845,-0.2766004716517533,-0.3582414556551937,0.1948530998696307,0.036783525823596265,0.08010940629485827,0.595093937800162,0.01930578567602684,-1.1048564675781694,0.07446936552904455,-0.21285497914115176,0.9529152955157251,0.19711595472373186,-0.16251544416192182,0.2925921370531017,-0.08205158339998367,0.04040572515421965,0.6178393367335957,0.039698222501231485,0.02740161660403828,0.0018841363045274712,0.1813772274326766,-0.17328645458668948,-0.09905395553278952,-0.02320453742186146,0.1236351581057014,-0.11072246209888753,0.2215309617159704,-0.03934540574300627,-0.10026739723642616,-0.16984632515907702,-0.3896575210622229,-0.07606966252595677,0.16247709215547598,-0.05303061241284013,-0.4202443695820485,-0.058694319708592964,-0.831520903038836,0.028720540710050306,0.21641201300891616,-0.13816279778718255,-0.09601748598200288,-0.08701382914828823,-0.2236146929779872,0.10224962872936363,-0.14497447498927482,-0.11538902370167695,-0.088270041364532,-0.09345139540606136,-0.10647115422242287,-0.3216470115309806,0.2802837556914061,0.09369312731749753,AssemblyEvaluation,12
217,217,"cgal compute genome assembly likelihoods
assembly algorithms   extensively benchmarked use simulate data   result   compare  grind truth however   novo assembly  crude metrics   contig number  size  typically use  evaluate assembly quality  present cgal  novel likelihoodbased approach  assembly assessment   absence   grind truth  show  likelihood   accurate   metrics currently use  evaluate assemblies  describe  application   optimization  comparison  assembly algorithms
mapping read  first step  compute  likelihood  map read   assembly  number  tool  available     bowtie  maq  bwa   bfast   present implementation  use either bfast  bowtie   map read   support map  indels  report multiple alignments   way  give   require information without access  assembly sequence   tool  report multiple alignments  read  allow  insertions  deletions   use   minor modifications however exist tool   usually map  read    likelihood computation   necessary  assign probabilities  read   unmapped  find  map tool  unable  map  large fraction  read   experiment one option   assign probabilities   read assume   could   generate   site use  number  type  errors  handle   map tool     often  case  unmapped read  deem  probable  map ones   believe  anomalous furthermore   analyse  determine   result probabilities  inaccurate result  show therefore  choose  directly align  read  map  bfast  bowtie  use  adaptation   smithwaterman algorithm  adapt  strip implementation   smithwaterman algorithm  farrar   step  time consume   align   random subset  read   number specify   user  approximate probabilities use  learn distributions  compute  likelihood  map read  need  learn  distribution  fragment lengths  distribution across  genome  error characteristics since  differ  library preparation methods  sequence instrument  choose  learn   sequence data generate   experiment     map read   assembly  use read  map uniquely however    easily extend  take  account  read  use  expectationmaximization  algorithm   expense   iterations  explain  distribution   detail  fragment length distribution  distribution  fragment lengths depend   method use  size selection  may   approximate well  common distributions    use  empirical distribution distribution  fragment along genome   implementation  assume  fragment  distribute uniformly across  genome  leave incorporate sequence bias  future work error model   error model use  present   make  assumption  sequence errors  independent  one another  learn  error rate   position   read since error rat  know   different across position  read   also learn separate error rat   type  base  substitution type although errors  know  depend  sequence context    ignore    sake  simplicity  account  vary indel rat across position  read  learn  insertion rate   deletion rate   position   read since short indels   likely  longer ones  also count  number  insertions  deletions  length implementation  mention earlier  use bfast  bowtie   map read  assemblies  parameters  set    report  alignments   read find  remain code  compute likelihood  write     consist  three part convert  convert  output generate  bfast  bowtie    internal format  also separate read   end  one end map  read  end map  different scaffold  need separate  module also allow   support  map tool  write  conversion routine align  align  read  map   map tool  adapt  strip implementation   smithwaterman algorithm  farrar    step  time consume  align  random subset  read   number determine   user  step  multithreaded  speed   process cgal  learn  fragment length distribution  parameters   error model use uniquely map read   use   compute  likelihood value assemble genomes  assemble read  vary  kmer length use  construct   bruijn graph  obtain different assemblies   assembly tool   parameters  default value  value suggest  manuals  use data analysis likelihoods  compute  run cgal   default parameters  align     randomly choose read  map   map tool use  run time  cgal  approximately    time take  map read use bowtie   compute  difference   assembly   reference  align  assembly   reference use nucmer   difference refer   number  base   reference   either  cover   assembly  differ   reference  assembly contigs  generate  split scaffold  sit     ' character represent  base",-0.2661474073266095,0.21420234157456125,0.11367447868068803,0.13632120482891086,-0.032948220717879215,0.047135552803383884,-0.10190243582647453,0.1027918737183543,0.010401120396489476,0.12792768986063435,0.04684715599138686,0.0007454494197674571,0.20652931904608499,-0.08384760595422157,0.15351408863876095,-0.04202850876435479,0.05745979000695368,0.2663109756164015,-0.06068188535703465,0.11060316731033727,0.005062858818812257,-0.25655408299607324,0.06927417008245879,-0.03477182248409124,-0.05558062276228312,-0.2492320189510096,0.08243414605472316,-0.16177470614697706,-0.05417490455302152,-0.062075647736584985,-0.009712364673218194,0.2769535272481277,-0.2403410812423743,-0.10940136396118064,0.2245479500789364,0.15242998020703644,0.055820513624658286,0.013545646518468856,-0.0816295320693245,-0.18170026329276648,-0.1242428154278388,-0.09427681503677493,-0.09990427782585684,-0.11460107503052645,-0.24474983402983624,-0.053005295728848496,0.13285912159097166,-0.22933459701016545,-0.2267377497514393,-0.3569247545798289,0.2329290887737211,0.08147828667523696,0.10670930883460776,0.6847532971702674,0.009884004603001349,-1.2281741046683583,0.057385063954093984,-0.2331522372794001,1.0696430294695212,0.2280248073920449,-0.17755507042574534,0.348071855743059,-0.03858430912282239,0.060870362497232065,0.7321430738856818,-0.00019494224478431205,0.047629300948787236,0.007763278675504788,0.1471704574866577,-0.18726823979077187,-0.10940431092627052,-0.005522953219553257,0.12869829190387191,-0.12426199820833875,0.21484017425731936,-0.06284829513665209,-0.12708545163313442,-0.10510656731698582,-0.4105356751193114,-0.07839887977151716,0.20688091635733766,-0.014844226794307457,-0.4470308687825231,-0.09221895609665266,-1.004912305781816,0.05140533774962371,0.2645519111295567,-0.19499487858439024,-0.13200257646063582,-0.09051580649362184,-0.2314928814610268,0.09095102447999066,-0.08977542579411826,-0.09597793236434303,-0.0998526503054544,-0.10116888651614414,-0.10348344923472626,-0.3497045247639688,0.33272706420022125,0.10666286712859142,AssemblyEvaluation,12
218,218,"baapl  tool  evaluate  novo genome assemblies  rna transcripts
assessing  correctness  genome assemblies   important step   genome project several methods exist    computationally intensive    case inappropriate   present baapl  fast  easytouse program  use transcript data  evaluate genomic assemblies  simulations use human chromosome   show  baapl excel  detect level  miss sequence  contiguity
baapl require   set  rna transcripts  first align   genome use  freely available program blat   output   program  well   fasta file   rna  transcripts use  input  blat    require input  baapl  output consist  four measure explain  table   ratio  transcripts   blat entry table   determine  divide  number  transcripts   blat alignment   total number  transcripts  algorithm group  set  subalignments   blat file  query transcript  score   blat subalignment  determine use  algorithm implement  jam kent  author  blat   ucsc genome browser  start   highest score subalignment  position   query transcript  align  mark  “covered” use  array  size   query sequence  successive subalignment sort  decrease score   consider   subalignment contribute    position   default     coverage   query   subalignment  consider   contribute   coverage   target sequence   contribute subalignment   previously contribute   “coverage”   number  target sequence  contigs contribute   alignment  incremented  calculations  use  determine  number  transcripts map   single target sequence table    average number  target sequence per map transcript table   array  cover position   analyze      consecutive position   default     cover  position count   total coverage   query  calculation  use  determine total percent coverage   transcript nucleotides table  baapl  fast compare   assembly assessment methods  time   analysis  determine   long  take  align  set  transcripts   genome  blat align transcripts   assembly  decidedly faster  align  sequence read   alignment  predict highly conserve genes  run  baapl    blat output file usually take less   second   reasonably size data set   modern computer  illustrate  effectiveness  baapl  produce several semirandom permute versions  human chromosome   align mrnas   genes locate    chromosome permutations  chromosome  include break   fragment  random position  delete random chunk  sequence position     axis   figure   figure  show    perfect case scenario  every gene align almost perfectly   target sequence  sequence  metrics reflect  ideal alignments   transcripts   genome  test  sensitivity  baapl  contiguity  generate versions  chromosome     divide  random position  fragment sequence    frequencies       level  fragmentation  inversely analogous   level  contiguity   genome assembly  result figure  show  two metrics   form   “number  transcripts map   single sequence”   “average number  sequence per map mrna” diverge     manner proportional   number  break introduce  result show   two metrics  appropriate  assess level  contiguity   metrics   breakage analyse remain mostly unchanged  test  sensitivity  baapl  miss sequence data  introduce random sequence deletions   nucleotides  random position  chromosome     frequencies      number  introduce deletions  analogous   amount  miss data   genome assembly   case  deletions table   metrics “total percent coverage   mrna nucleotides”  “ratio  mrnas   blat entry” tend  decrease   sequence  delete  result show   two metrics  appropriate  assess level  completeness   metrics   breakage analyse remain mostly unchanged discussion genome sequence  become  routine task  biology generate highquality genome assemblies however  remain difficult one   major difficulties   process   assembly algorithms  parameter settings   algorithms perform differently depend   nature   genome   sequence    reason   important  run multiple assemblers  multiple set  parameters   integrate robust assessment methods   genomesequencing pipeline exist tool offer metrics    use  compare assemblies methods  use alignments  sequence read use  construct  assemblies  powerful    mislead   underlie assumption  uniform coverage  sequence read  violate  assumption   certainly violate  case  use dna amplification— technique critical  sequence  genomes  microorganisms methods  predict highly conserve genes   assembly  compare  count   genes  assemblies avoid  issue   invaluable however  methods consider    hundred genes  therefore offer limit resolution  use  baapl  evaluate alignments  rna transcripts offer several advantage   methods rna transcripts  independently generate      affect   artifacts introduce   genomic sequence use  generate  alignment  addition  eukaryotes contain tens  thousands  genes  current rna sequence methods recover   vast majority   transcripts  number offer  much higher resolution   small set  highly conserve genes   metrics  baapl offer  add advantage  provide  rough assessment   extent    particular genome assembly encapsulate  entire transcriptome   species  well   measure   often transcripts occur   single sequence  important measure  determine  extent   gene predictions   effective lastly  analysis involve baapl   straightforward  considerably faster   assessment algorithms baapl use evidence  alignments  rna transcript data   genome assembly  generate metrics     compare across multiple assemblies  generate use different program andor different set  parameters  metrics  intuitive  offer clue    nature  differences  assemblies  contiguity  completeness  program   requirements outside  blat  perl  include  straightforward installation  program speed easeofuse  intuitive nature make   ideal tool  genome assembly assessment",-0.2357664656080388,0.22294368820886915,0.1490344553589393,0.16954417329803176,-0.03187767561819641,0.0051814116094945906,-0.08267063187853213,0.04407103602999045,-0.05456333598961178,0.13260136897323568,0.017051903056244072,-0.005562877897897164,0.17495014006282242,-0.13322678975010818,0.13424776949684872,-0.029554842456240637,-0.025313182803061742,0.22527781010822595,-0.028230477228218545,0.08612644873837555,0.022451449340281763,-0.223793839780752,0.11318085916001387,-0.02311388153275113,-0.03709332244108717,-0.23657231424464564,0.05569765135383006,-0.11537947448307005,-0.06758537500201603,-0.050991417887635435,-0.010890382425958295,0.22005763575854276,-0.18940901437995614,-0.0912980583908576,0.21477942151240034,0.07561120956102814,0.03839775682558625,-0.008998305627306127,-0.11657374751895612,-0.11170047427471662,-0.10834695649244444,-0.13390837616817622,-0.13038893886977582,-0.0532924247483555,-0.19005009315413496,-0.05051363888155511,0.17637715018897354,-0.16315272179112994,-0.2737727866568948,-0.3939232810420172,0.18906823856025512,0.004824846651398514,0.07451359006245506,0.5971717903145355,0.01506185015501428,-1.1617717862445136,0.04433198042572624,-0.22922096061709504,1.0033089962060642,0.23552582506604605,-0.19556224194461028,0.38671784222047023,-0.016275290952659748,0.04323882968806705,0.6059122540915628,0.04938935671929704,0.04875077759392902,0.01073914423400648,0.2425347564235172,-0.20043005520751855,-0.012949723090130408,-0.033762161759824195,0.1523673611632614,-0.09490808603426197,0.2135059225254498,-0.04666666175212461,-0.18033591299221108,-0.16320040804340566,-0.374703183195919,-0.0393142674505783,0.24850912328254984,-0.0007155878525293126,-0.4145428877387216,-0.05234678807670856,-0.9366040713480401,0.0859124328837855,0.26688628505698203,-0.15034296805805827,-0.1527702826658978,-0.08262182612088509,-0.16410066389113453,0.12009427220356575,-0.13432922680321718,-0.09924776399057267,-0.1296425126065161,-0.06325472564833047,-0.10057734746844656,-0.3329907639228571,0.3145724064188182,0.09574708551318176,AssemblyEvaluation,12
219,219,"quast quality assessment tool  genome assemblies
limitations  genome sequence techniques  lead  dozens  assembly algorithms none    perfect  number  methods  compare assemblers   develop  none  yet  recognize benchmark   exist methods  compare assemblies   applicable  new assemblies  finish genomes  problem  evaluate assemblies  previously unsequenced species    adequately consider   present quast— quality assessment tool  evaluate  compare genome assemblies  tool improve  lead assembly comparison software  new ideas  quality metrics quast  evaluate assemblies    reference genome  well  without  reference quast produce many report summary table  plot  help scientists   research    publications   study  use quast  compare several genome assemblers  three datasets 
metrics quast aggregate methods  quality metrics  exist software   plantagora gage genemarkhmm lukashin  borodovsky   glimmerhmm majoros      extend   new metrics  example  wellknown n50 statistic   artificially increase  concatenate contigs   expense  increase  number  misassemblies quast introduce  new statistic na50  counter  quast use  nucmer aligner  mummer  kurtz     align assemblies   reference genome  evaluate metrics depend  alignments quast also compute metrics   useful  assess assemblies  previously unsequenced species whereas   assembly assessment software require  reference genome   split  metrics evaluate  quast  several group    use  previous study    new  quast  contig size  follow metrics except  ngx   evaluate   without  reference genome  also provide filter versions   restrict  contigs  length   specify minimum size  exclude short contigs  may    much use   contigs  total number  contigs   assembly largest contig  length   largest contig   assembly total length  total number  base   assembly    external file  hold  picture illustration etc object name  btt086i1jpg  largest contig length    use contigs  length  external file  hold  picture illustration etc object name  btt086i2jpg account   least    base   assembly ngx genome   contig length   use equal  longer length contigs produce    length   reference genome rather     assembly length  misassemblies  structural variations  follow metrics describe structural errors   contigs quast  evaluate    respect   know reference genome   reference genome exactly match  dataset  assemble differences may  attribute  misassemblies   software   sequence errors   chimeric read sometimes one use  reference genome   relate   different   dataset  sequence   case  differences may still  misassemblies   may also  true structural variations   rearrangements large indels different repeat copy number   forth   misassemblies  number  misassemblies use plantagoras definition plantagora define  misassembly breakpoint   position   assemble contigs   leave flank sequence align    away   right flank sequence   reference   overlap      flank sequence align  opposite strand  different chromosomes quast also generate  report   number  misassemblies      reason see  supplementary methods  detail   misassembled contigs  number  contigs  contain misassembly breakpoints misassembled contigs length  total number  base contain   contigs   one   misassemblies   unaligned contigs  number  contigs    alignment   reference sequence   ambiguously map contigs  number  contigs   highscoring reference alignments  equal quality  multiple locations   reference genome  addition   summary statistics quast also generate report  detail information   contig include whether  contig  unaligned ambiguously map misassembled  correct  genome representation   functional elements  section list metrics evaluate genome representation  contigs   number  assemble functional elements   genes  operons    require  reference genome genome fraction   total number  align base   reference divide   genome size  base   reference genome  count  align   least one contig   least one alignment   base contigs  repeat regions may map  multiple place  thus may  count multiple time   quantity duplication ratio  total number  align base   assembly  total length minus unaligned contigs length divide   total number  align base   reference see  genome fraction  metric   assembly contain many contigs  cover   regions   reference  duplication ratio may  much   may occur due  overestimate repeat multiplicities  due  small overlap  contigs among  reason    total number     nucleotides   assembly divide   total length   assembly  metric   compute without  reference genome   mismatch per    average number  mismatch per   align base quast also generate   detail report   coordinate  mismatch  metric   distinguish  singlenucleotide polymorphisms   true differences   assemble genome versus  reference genome  singlenucleotide errors   due  errors  read  errors   assembly algorithm   indels per    average number  single nucleotide insertions  deletions per   align base  detail report  coordinate  indels   assemblies  also available   genes  number  genes   assembly complete  partial base   userprovided annotate list  gene position   reference genome  gene  partially cover   assembly contain  least     gene    whole gene quast also report  list   completely cover genes   assembly   annotate list  gene position   available  metric cannot  compute   number  predict genes see later   text   use instead   operons complete  partial operons  count   similar fashion  genes use  userprovided annotate list  operon position   reference genome   predict genes  number  genes   assembly predict  quasts genefinding module   base  genemarkhmm lukashin  borodovsky   prokaryotes  glimmerhmm majoros     eukaryotes  genemarkhmm author  kindly allow use   software inside quast  glimmerhmm   opensource tool   user provide  reference genome   annotate list  genes  use  number  genes statistic instead otherwise quast count  number  genes annotate  genemarkhmm  glimmerhmm   filter   count    lengths  one   specify minimum thresholds  variations  n50 base  align block  follow metrics  quast  new    similarities  gag correct  salzberg    assemblathons contig path   alignment graph earl      normalize n50 makinen    metric   give short descriptions   metrics see  supplementary methods   detail information nax  stand  align  range      combination   wellknown  metric  plantagoras number  misassemblies metric   compute  two step first  break  contigs  align block   contig  misassembly breakpoints per  previous definition  plantagora   break  multiple block   breakpoints additionally    unaligned regions within  contig  regions  remove   contig  split  block next  compute  ordinary  statistic   block instead    original contigs ngax  break contigs  align block  describe  nax    compute  ngx statistic instead     block   nax  ngax metrics require  reference genome   reference genome  different   sample  assemble  breakpoints  indels may represent true structural differences  visualization quast present  number  statistics  graphical form  support svg png  pdf format sample plot  present   supplementary material  plot  divide  several group nxlike plot  show  trend   ngx nax  ngax metrics   vary    informative   use n50 cumulative plot contigs  order  largest  smallest  number  base    type  cumulative plot consider  cumulative length plot show  number  base   first  contigs   vary  zero   number  contigs  cumulative number  complete genes  cumulative number  complete operons plot  compute similarly  content plot  show  distribution   content   contigs   value show  per cent         value show  number  nonoverlapping   windows whose  content    distribution  often gaussian bohlin    however    contaminants   different  content   often   superposition  multiple gaussians contig alignment plot fig   show alignment  contigs   reference genome   position  misassemblies   contigs colour cod indicate  block boundaries  share  multiple assemblies   show misassembled block  optional track show  read coverage along  reference genome  external file  hold  picture illustration etc object name  btt086f1pjpg fig  alignment  singlecell ecoli assemblies   reference genome   track  xaxis  genome position top track read coverage   logarithmic scale  red curve show coverage bin    windows blue position   xaxis  zero coverage even   bin   coverage coverage  highly nonuniform range    near     track comparison  position  align contigs contigs  align correctly  colour blue   boundaries agree within     side   least half   assemblies  green otherwise contigs  misassemblies  break  block  colour orange   boundaries agree   least half   assemblies  red otherwise contigs  stagger vertically   show  different shade   colour  distinguish  separate contigs include small ones quast also make comparative histograms  several metrics  number  complete genes  number  complete operons   genome fraction  histograms   metrics   add  well  compare assemblers   study  evaluate several   lead genome assemblers  three datasets escherichia coli  singlecell sample homo sapiens chromosome   bombus impatiens  bumble bee   publication time     finish assembly  ecoli dataset     assemblies  take  chitsaz     spade  idbaud assemblies  new  assemblies  hsapiens  bimpatiens   datasets  take  salzberg      article  present   quasts comparison statistics   sample plot compare ecoli assemblies see supplementary figure s3s29  supplementary table s2s8   plot  extend table  ecoli   comparisons  assemblers    two datasets  comparison  ecoli assemblies  reference genome  ecoli str  substr mg1655 blattner    available   ncbi website gene annotations  take    include several wellknown assemblers design  culture bacterial datasets eulersr pevzner    velvet zerbino  birney   soapdenovo      also include several recently introduce assemblers    adapt  design  scratch  handle singlecell datasets velvetsc  euler  velvetsc chitsaz     assembler spade bankevich     idbaud peng    table  show  spade  idbaud   best result  almost  metrics idbaud assemble  largest contig       smallest number  contigs   spade   larger nga50  idbaud   versus     assemble  higher percentage   genome  versus  spade also assemble  highest number  complete genes     idbaud  close second  however  spade  idbaud   misassemblies   three velvetbased assemblers table  comparison  assemblies   singlecell sample  ecoli  contigs  external file  hold  picture illustration etc object name  btt086i3jpg  assembler          contigs        nga50         largest         total         genome fraction           misassemblies          complete genes eulersr                                                             evsc                                                             idbaud                                                             soapdenovo                                                             spade                                                             velvet                                                             velvetsc                                                              best value   column  indicate  bold figure  show   contigs align   reference genome  reveal high similarity     assemblies evsc velvet  velvetsc generate assemblies  dozens  similar contigs   natural     assemblers  modifications  velvet  top track show  read coverage along  genome velvet   able  assemble lowcoverage regions   genome whereas  assemblers design  singlecell datasets velvetsc evsc spade  idbaud  much better although  course none    assemble  regions  literally  zero coverage",-0.21193250021182888,0.21429477258537769,0.11065542507633587,0.10082110489602199,-0.0047519202576950205,0.032716684571807333,-0.0647978950627889,0.02589854583175937,-0.02097509893885052,0.07424970047167417,0.018159891049038958,-0.02888116895532717,0.1822213227736608,-0.042599347595718096,0.15221088611817155,0.038106415786156006,0.04818265689060685,0.1590987734597134,-0.025476644895388745,0.06277927377946484,0.05633915299338035,-0.15934520771657348,0.07089475582311232,0.014256319870632566,0.04326350329449104,-0.19799533626646731,0.09169758011610776,-0.16289509162306787,-0.050915925021730465,-0.0687349822307376,0.06156271886853078,0.2279928080293096,-0.13693780809513886,-0.092334773923027,0.1693056776231308,0.10856973232188136,0.046233543414961206,0.027554740808872418,-0.11014718295469224,-0.10085025844627207,-0.05712267941410325,-0.1482063296969665,-0.08692700952828587,-0.0759836568595016,-0.1270639812313179,-0.026726574217239184,0.0941185481764726,-0.12636568208254176,-0.21507441040408928,-0.303262108359261,0.1804289873906369,0.01562209633729336,0.07428423403074373,0.5521909466309642,-0.018619526138354558,-1.0730574284823058,0.023552772322330964,-0.1631250801546478,0.8791823059291346,0.2033436570376084,-0.1675401499582883,0.35351591967125634,-0.07746266050803984,0.06585911076558246,0.5806525908910606,0.02810088633969744,0.07478616278961206,0.027319466323718768,0.1922291514848687,-0.1737963749974204,-0.07107079225295987,0.01700820853518301,0.10600488734344253,-0.10229567440851084,0.18541387227490885,-0.013807847890050405,-0.12046636411105285,-0.12892130280273373,-0.309387391618326,-0.03522367989194622,0.1374555864451064,-0.071542994099648,-0.3339491167123593,-0.0585700181500711,-0.7670659266528673,0.01639017502126411,0.16972088208527894,-0.15561641935531625,-0.07145347617227922,-0.002041920472865141,-0.17099844901134598,0.04145670916557058,-0.11599844353252345,-0.12631067744355692,-0.14230471027589042,-0.09308136724205476,-0.14843995760549494,-0.32303949799653225,0.29086895205652,0.05850437692146939,AssemblyEvaluation,12
220,220,"versatile genome assembly evaluation  quastlg
 emergence  highthroughput sequence technologies revolutionize genomics  early   next revolution come   era  longread sequence  technological advance along  novel computational approach become  next step towards  automatic pipelines capable  assemble nearly complete mammaliansize genomes   manuscript  demonstrate performance   stateoftheart genome assembly software  six eukaryotic datasets sequence use different technologies  evaluate  result  develop quastlg  tool  compare large genomic  novo assemblies  reference sequence  compute relevant quality metrics since genomes generally cannot  reconstruct completely due  complex repeat pattern  low coverage regions  introduce  concept  upper bind assembly   give genome  set  read  compute theoretical limit  assembly correctness  completeness use quastlg  show  close  assemblies    theoretical optimum   far  optimum    finish reference
upper bind assembly construction  construct upper bind assembly base   reference genome   give set  read  first  construction algorithm map  read   reference genome  detect zerocoverage regions fig   use minimap2    align long errorprone read pacbio  nanopore  bwamem    short illumina read pairedends  matepairs  external file  hold  picture illustration etc object name  bty266f1jpg fig  upper bind assembly construction   available read brown  long read orange  matepairs  yellow  pairedends  map   reference gray  compute zerocoverage genomic regions repeat sequence red  detect use repeat finder software nonrepetitive cover fragment  report  upper bind contigs   overlap   contigs green  either long  matepair read  detect  contigs   join  form upper bind scaffold   gap  adjacent contigs within  scaffold  fill either  reference sequence  cover regions   stretch   nucleotides  coverage gap unresolved repeat  add  separate sequence    lightweight red girgis   novo repeat finder  use  mark long genomic repeat   reference fig   call  repeat long   length exceed  median insert size   pairedend library  several pairedend libraries  available  maximum median value  use among  detect repeat sequence  select    occur  least twice  remote part   genome  long repeat cause ambiguities   assembly  may  resolve   long read  matepairs  long regions mark  red appear   short tandem repeat  multiple copy    genomic loci   best   knowledge  tandem repeat   cause ambiguities    approximately resolve   assemblers without use longrange information  use  bruijn graph topology miller    split  reference sequence  coverage gap  long repeat result   set  unique genomic fragment refer   upper bind contigs  however   reflect  best possible assembly   entire dataset  achieve   realistic upper bind  detect  contigs   connect  long read  matepairs   join   upper bind scaffold   number  connections exceed  small threshold  fig    study  use     long read      matepairs  say   long read connect two contigs   simply overlap   contigs  pair  read connect contigs   leave read overlap   first contig   right read overlap   second contig   analysis  ignore read pair  map inconsistently   abnormal insert size   first   last decile  enable efficient overlap detection  read  upper bind contigs  sort  read accord   map position thus  scaffold construction algorithm require  log ⁡ time  read sort   time  find overlap     total number  long  matepair read use  scaffold  upper bind contigs  join  scaffold  gap  adjacent contigs  fill   correspond genomic sequence   reference genome — case  coverage gaps— stretch   fig  remain unresolved repeat  add   final upper bind assembly  separate sequence  adaption  conventional metrics  large genomes  key characteristics   assembly quality   assembly completeness  fraction   genome  assemble correctness  many errors  assembly contain  contiguity  many fragment  assembly consist    long    completeness  correctness   accurately measure  quastlg    highquality reference genome  available  contiguity statistics    wellknown n50 metric   require  reference however   estimate   genome size  know   suitable analogues   compute namely ng50   reference sequence  available  provide even  relevant insight  compute nga50like statistics gurevich     contiguity measure base  errorfree align assembly fragment rather   initial contigsscaffolds  alignment   reference genome appear     time consume step   assembly evaluation especially  large genomes  address  bottleneck  replace  accurate  slow nucmer aligner  mummer  package kurtz    use  original quast   faster minimap2 aligner    recently release mummer  package marcais     also outperform  minimap2   benchmark experiment albeit  speed increase   case    substantial   minimap2s improvement   previous mummer version   thoroughly choose minimap2 options  order  maintain  alignment speedaccuracy ratio  different scenarios  standard mode quastlg run alignment   parameters enable accuracy comparable  nucmer   suitable  small genomes  ‐‐large mode quastlg configure minimap2  achieve adequate run time  large  complex input  assembly correctness  usually characterize   number  large assembly errors socalled misassemblies gurevich    define  misassembly breakpoint   position   assemble contig   flank sequence align  opposite strand inversion   different chromosomes translocation   inconsistency size   gap   overlap   alignments   leave  right flank sequence   reference     predefined breakpoint threshold  relocation  alignments    strand    chromosome       consider  small errors  classify  local misassembly eukaryotic genomes usually contain  lot  transposable elements tes  may cause discrepancies   reference genome   genome actually  assemble  short variations result   huge number  false positive misassemblies  compute accord   definition give   distinguish  true misassemblies   ones cause  tes quastlg perform  additional check   relocation  inversion  identify possible tes fig   identification procedure depend   size   breakpoint threshold   optimal value  slightly exceed  length   largest    genome  process  tandem  insertions  deletions    scope   paper  optimal value thus depend   subject organism   allow users  set  manually   sake  consistency  use         benchmark experiment   study see supplementary methods  detail   value choice   also  default value  quastlg  contrast  regular quast  use      external file  hold  picture illustration etc object name  bty266f2jpg fig  detection  discrepancies cause  tes   subfigure  plot  reference genome  top  contig  bottom  match fragment blue  green bar   position     respectively  locations  tes violet bar cause discrepancies   map  inconsistencies   alignments  show  arrows   character    present    miss   since    equal   tes length  specifically choose breakpoint threshold  transform classification   discrepancy   relocation   local misassembly       locate inside    position    significantly away   rest   mappings  could also  locate   opposite strand original quast would treat  situation  two misassembly breakpoints relocations  inversions      usually much higher    contrast quastlg classify  pattern  possible  since  compute         equal   tes length  could  prevail  appropriate      first   last alignment fragment     location    large distance  away   neighbor  fragment quastlg cannot reliably distinguish  situation   real relocationinversion  would need   able  recognize  base   genomic sequence     scope   paper  best set  alignments selection long contigs  rarely map   reference perfectly   single unambiguous alignment  alignment software typically report multiple alignment fragment  different locations   genome  may happen due   presence  genomic repeat  tes   reference genome    case   algorithmic issue   assembly orand alignment software quastlg attempt  accurately assess  contig  select  set  nonoverlapping alignments  maximize  total alignment score   define   function   alignment lengths map qualities  side  side inconsistencies misassemblies  problem  know   collinear chain problem myers  miller     usually solve  sequence aligners   lowlevel chain   join short match seed  larger alignment fragment  example mummer kurtz    combine maximal unique match  minimap2   chain minimizers roberts      implement  dynamic program algorithm call bestsetselection   highlevel chain   combine alignment fragment see supplementary methods  algorithm  conceptually similar  deltafilter utility  mummer package kurtz      approach include  comprehensive set  penalties  various misassembly events  feature allow bestsetselection  correctly resolve many complex set  alignments   typical  eukaryotic assemblies  produce   accurate chain  deltafilter   benchmark experiment bestsetselection   quadratic algorithm  respect   number  fragment alignments per contig   usually fine since  number  generally small    however  may cause  significant slowdown  case  large genomes evaluation   number  alignments may reach dozens  thousands   contigs although   chain algorithms  subquadratic time complexity abouelhoda  ohlebusch     applicable   gap cost function  associate   large constant instead   implement  simple heuristic  always find  best alignment set  one   several set  maximize  score supplementary methods  even though  heuristic idea   guarantee  speed   theory  significantly drop  run time   six benchmark dataset evaluations  kmerbased quality metrics  show   presence  many tes   specific feature  eukaryotic genomes significantly complicate assembly evaluation although quastlg adjustment   conventional completeness  correctness measure improve  assessment  may still   good enough  form  complete picture  eukaryote assembly quality   propose  assess assemblies use  completely different strategy inspire   evaluation procedures  putnam     chapman     generalize   arbitrary genome analysis  quastlg  strategy  base   analysis  unique kmers nonrepeated sequence  length     reference genome    assembly   value  sufficiently large quastlg use mers  default unique kmers appear   widespread across  genome  instance  fruit fly genome contain  millions unique mers    millions total mers  existence   position   kmers   assembly describe  completeness  correctness  use kmc  kokot     detect  unique kmers   reference genome  percentage   kmers detect   assembly  report   kmer completeness compare   genome fraction completeness measure  kmerbased value account  perbase quality   assembly   usually highly important   downstream analysis   genome annotation  benchmarking  show  assemblies    similar genome fraction may  completely different kmer completeness due   high mismatch  indel error rat  kmerbased correctness  calculate base   small uniformly distribute subset   unique kmers  order  speed   computation  select  subset   way   two kmers   subset   least   apart      reference genome   subset  provide  kmc   identify contigs   least two kmers  contig position   detect kmer  examine   refer   consecutive list  kmers   …    ≥    contig    marker     ∈      distance          equivalent within  small error    distance    default   process contigs   least two markers  check whether  relative position  adjacent markers    correlate   locations   quastlg report  kmerbased translocation breakpoint      originate  different chromosomes   kmerbased relocation   markers     chromosome   inconsistency   position      larger   predefined threshold  use   threshold  default   refer  kmerbased translocations  relocations  kmerbased misjoins  exclude confusion  regular quast misassemblies kmerbased misjoins  essentially similar   regular misassembly metrics except    focus    critical assembly errors  key benefit   measure    tolerance  inconsistencies cause  tes since tes mostly correspond  genomic repeat  thus lack unique kmers  example kmerbased relocations  successfully resolve  situations   contig start  end     cause  ambiguity   regular misassembly detection algorithm fig   evaluation without  reference genome   real assembly project  reference genome sequence   available   assembly quality assessment must rely   source  information  primary purpose  quastlg   referencebased analysis   also include    novo eukaryotetargeted completeness measure  make  tool useful   wider set  applications quastlg  supply  genemarkes lomsadze    software   novo gene prediction  eukaryotic genomes however despite  relevance   gene find  assess downstream analysis perspectives  heuristic nature may result   mislead output   experiment  instance  assembly may contain multiple copy  one gene    report several time  counter   additionally use busco simao     find  number  assemble conserve genes   present nearly universally  eukaryotes   single copy  demonstrate  busco completeness correlate   accurate referencebased quality metrics  add  computation    benchmark experiment note  referencefree correctness metrics    scope  quastlg   recommend use specialize  novo evaluation tool   scenario  instance reapr hunt    identify likely assembly  scaffold errors base  pair read map another example  kat mapleson     compare  kmer spectrum   assembly   kmer spectrum   read   quite useful  identify miss sequence collapse repeat  expand sequence   assembly  ",-0.18257042394652676,0.19394850781372952,0.12901401109820654,0.14204607958618,-0.008675113291064917,-0.020579849048658616,-0.08938674503788206,0.034511004400201266,-0.01373837262945017,0.09426364223581914,-0.0036232459161283257,-0.011708233737658702,0.16412662075931622,-0.08008635380847409,0.14357448438649953,-0.041137504692233054,0.0411712068329507,0.2013505471685221,-0.04419793662950724,0.07020358245790702,0.03159768716441249,-0.18395558692586747,0.0387311841907831,-0.03623359237099066,0.011116244936101794,-0.17347313851496438,0.04775821639168498,-0.1762258983857464,-0.08280655713529086,-0.06369052026811914,-0.011739434956416515,0.21786898051595927,-0.1424015961751593,-0.09748028742601493,0.17981556463678314,0.10623830589356656,0.045159108864754674,0.024964601877400128,-0.09236328713677723,-0.08584141938636095,-0.0804120218450862,-0.1452656458489173,-0.07285024689899729,-0.09034344095143752,-0.1378099237087554,-0.0312196452119224,0.15353775667684316,-0.11118556110941427,-0.20558415062296265,-0.3578797126468999,0.17153368028393742,0.008431677168800887,0.04791636419131464,0.6037740121391835,0.04835390343796462,-1.164573722674686,0.07483262801906676,-0.18945649618890456,0.9416860225823256,0.18473081954398368,-0.18769134237650176,0.3517027861158567,-0.07226874319312629,0.06815659364774547,0.5904088654817314,0.012215984740942076,0.05059700044598685,0.01200959395928294,0.17314253642603036,-0.17575126045348952,-0.04449676639183053,-0.02251037220194121,0.08717487583048751,-0.11121243274574226,0.2094818386100087,-0.03747440426759567,-0.11809200076131672,-0.12603322475388268,-0.3395176857903607,-0.046928330629327775,0.21320974424936595,-0.012699351972469231,-0.3745330643557964,-0.04012293614050577,-0.8578233684236694,0.05424548075925486,0.18356563193101466,-0.1106442964908183,-0.13533559392380995,-0.0543158601926109,-0.16539934281263413,0.060982524986866335,-0.13546897687497222,-0.10666117363398372,-0.1576896064927496,-0.04803064674670168,-0.11156757569187904,-0.2957425215394324,0.2846859305511316,0.10049060192886827,AssemblyEvaluation,12
221,221,"busco assess genome assembly  annotation completeness  singlecopy orthologs
genomics  revolutionize biological research  quality assessment   result assemble sequence  complicate  remain mostly limit  technical measure like n50  propose  measure  quantitative assessment  genome assembly  annotation completeness base  evolutionarily inform expectations  gene content  implement  assessment procedure  opensource software  set  benchmarking universal singlecopy orthologs name busco
genomics data acquisition continue  accelerate however  short lengths  sequence read make  assembly  fulllength chromosomes extremely challenge  gauge potential limitations  implement improvements   thus important  assess  quality   result data propose measure clark    gurevich    hunt    simpson  reflect methodologies  perbase error rat insert size distributions  genome bias  kmer distributions  fragment contig length distributions  n50  summarize assembly contiguity   single number half  genome  assemble  contigs  length n50  longer however  measure   assess assembly completeness  term  gene content  important consideration  also affect data interpretation  help  guide improve assembly  annotation strategies   grow number  available sequence genomes knowledge   gene content  consolidate    use  develop  evolutionary measure  genome completeness   revisit  idea  use know genes  measure genome assembly  annotation completeness mende    parra     introduce  citable notation  welldefined measure compile  comprehensive datasets  support  assessments  offer    offtheshelf software  propose previously waterhouse    benchmarking universal singlecopy orthologs busco  ideal   quantifications  completeness   expectations   genes   find   genome    find   singlecopy  evolutionarily sound  use  orthodb database  orthologs wwworthodborg  define busco set  six major phylogenetic clades sample hundreds  genomes orthologous group  singlecopy orthologs    species  select importantly  threshold accommodate  fact  even wellconserved genes   lose   lineages  well  allow  incomplete gene annotations  rare gene duplications subsequent filter   sequence uniqueness  conservation level see supplementary online material som  detail result  busco set represent  genes  vertebrates   arthropods   metazoans   fungi    eukaryotes  also adopt  universal marker genes propose   assessment  prokaryotic genomes mende     clades span many phyla offer comprehensive coverage   tree  life    narrowly define clades provide  much greater resolution  much larger busco set   applicable     assessment  genome assemblies  also  annotate gene set  well  assemble transcriptomes fig  additionally  nearuniversal singlecopy markers  recover genes  ideal  species phylogeny reconstructions fig  busco assessment workflow  relative runtimes open  new tabdownload slide busco assessment workflow  relative runtimes  propose intuitive metrics  describe genome gene set  transcriptome completeness  busco notation  ccomplete dduplicated ffragmented mmissing nnumber  genes use fig   recover genes  classify  complete   lengths  within two standard deviations   busco group mean length  within  expectation supplementary fig  complete genes find    one copy  classify  duplicate    rare  buscos  evolve  singlecopy control waterhouse      recovery  many duplicate may therefore indicate erroneous assembly  haplotypes genes  partially recover  classify  fragment  genes  recover  classify  miss finally  number  genes use indicate  resolution  hence  informative   confidence   assessments use hmmer  eddy  hide markov model hmm profile  amino acid alignments  core   analysis workflow fig  assess whether busco gene match  orthologous    satisfy busco groupspecific bitscore cutoffs detail  som  classify positive match  complete  fragment  core analysis     assess genomes transcriptomes  gene set however additional analyse  require  first annotate genes  transcriptomes  genomes  simple longest open read frame approach perform well  transcriptomes  genomes gene annotation  perform  augustus keller    guide  amino acid busco group blockprofiles  genomic loci detect  tblastn search use busco group consensus sequence detail  som although  gene prediction approach may   limitations  bias   consistent across different species make  fair comparisons conveniently  thousands  confident busco gene model provide  excellent gene predictor train set  use  part  genome annotation pipelines table  report busco notation assessments  five diverse species    genome assemblies   annotate gene set assess  genomes  gene set   transcriptomes reveal substantial variability  completeness supplementary table  poor correlation  scaffold n50 supplementary fig  highlight  completeness provide important complementary information  quality assessment nevertheless  fact   genome assemblies appear less complete   correspond gene set   sapienstable  reveal limitations   busco gene prediction step    hand  reversal   trend   nidulanstable  suggest   annotate gene set may  miss  busco gene match    fact present   genome thus    note   busco assessments aim  robustly estimate completeness   datasets technical limitations particularly gene prediction may inflate proportion  fragment  miss buscos especially  large genomes  miss buscos may also  report  species   highly derive  respect   assessment clade—even  highquality genomes   eleganstable —reflecting  organisms evolutionary history rather   incomplete assembly table  assessment  fruitfly  mela nematode worm  eleg human  sapi owl limpet  giga  fungus  nidu genome assemblies upper row  gene set lower row  busco notation ccomplete dduplicated ffragmented mmissing  gene number graphic open  new tab compare genome  gene set completeness   species use  busco eukaryotic subset reveal generally consistent assessments across highly divergent lineages  fungi  human fig  employ   genes   core eukaryotic gene map approach cegma parra      likeforlike comparison  implement gene set assessments use cegma hmms see som  detail appear somewhat less consistent fig  busco linear regression  closer   diagonal additionally  comparable busco  cegma assessments busco runtimes  substantially faster   small genomes    large genomes   course  higher resolutions achievable   thousands  vertebrate arthropod  fungal busco set  require longer runtimes supplementary table  runtimes  generally proportional   size   busco set use   size   genomes  assess    cpu core      memory   mbp fruit fly genome run       mbp human genome run      metazoan   arthropod   vertebrate buscos respectively supplementary table  fig  buscos eukaryotic subset  cegma cegs recover   representative genome assemblies   respective gene set inset number  genes   busco set   cegma cegs open  new tabdownload slide buscos eukaryotic subset  cegma cegs recover   representative genome assemblies   respective gene set inset number  genes   busco set   cegma cegs busco quality assessments provide highresolution quantifications citeable   simple cdfmn notation  genomes gene set  transcriptomes  facilitate informative comparisons   newly sequence draft genome assemblies    goldstandard model   quantify iterative improvements  assemblies  annotations busco assessments therefore offer intuitive metrics base  evolutionarily inform expectations  gene content  hundreds  species  gauge completeness  rapidly accumulate genomic data  satisfy  iberians quest  quality—busco calidadqualidade",-0.2000083608404857,0.21751049742318893,0.09894402819029584,0.1083881494926353,-0.02243468428995194,-0.048856843820435585,-0.09672602629283296,-0.027121123119161046,-0.03050953695198448,0.051619753580462426,-0.04392988182572198,0.0035914513098966017,0.17697268877974984,-0.13534706669602672,0.15240477233199834,0.054583273538998486,0.029459609845630237,0.18172890076435544,-0.005605161282649089,0.09639829231266694,-0.0249251706916793,-0.17534280520189424,0.04836148735057801,0.02181109709331417,-0.007005702980605913,-0.165510304129308,0.05069572086613155,-0.13386601855028696,-0.10493476858101336,-0.018553314017552856,-0.0033778493590155448,0.16114485157161793,-0.15194387481492838,-0.08538695555375292,0.21035760030555573,0.09157821837338972,0.035497736634246164,0.03721683879963265,-0.10891616877955224,-0.0850018890078304,-0.11593853302567787,-0.13423728458743928,-0.09237642830846776,-0.07509374689124983,-0.1829602572831252,-0.010844778469098466,0.16295667252785198,-0.07322342836715537,-0.252535859584376,-0.30912466696291485,0.16023036925663506,-0.0148808848985363,0.05863757066289881,0.4840764032419899,0.03929181035399882,-0.9661543413244298,0.0630168011893743,-0.21971608031617956,0.8074253716112086,0.15155555727311554,-0.19262522128902396,0.3291150629405721,-0.03679510215819203,0.07857989968965404,0.5318211540350406,0.05410482718900599,-0.012902584374226226,0.02999407348849265,0.2297669052825369,-0.2108696361394654,0.004658732638382376,0.006802977597813485,0.11828491552507794,-0.15080072486422166,0.13885517437423905,-0.0673693771427612,-0.14171181088129947,-0.14399752278440614,-0.35246119271216025,-0.0852073736200935,0.13013856182892214,0.013997948356030116,-0.3304270706185383,-0.006192695958914896,-0.7477700728601937,0.06039743976102078,0.20652634789823127,-0.1657032013367265,-0.16172456665634374,-0.0294015133733204,-0.13793422122086801,0.034843130844067136,-0.09907655051985086,-0.0924108563463566,-0.12389026898712956,-0.06913686319933332,-0.1506615590087363,-0.3562005162405382,0.2543734377535379,0.11176600085062163,AssemblyEvaluation,12
222,222,"dnaqet  framework  compute  consolidate metric  benchmarking quality   novo assemblies
accurate  novo genome assembly  become reality   advancements  sequence technology   everincreasing number   novo genome assembly tool assess  quality  assemblies  become  great importance  genome research although many quality metrics   propose  software tool  calculate  metrics   develop  exist tool   produce  unify measure  reflect  overall quality   assembly  address  issue  develop   novo assembly quality evaluation tool dnaqet  generate  unify metric  benchmarking  quality assessment  assemblies  framework first calculate individual quality score   scaffoldscontigs   assembly  align    reference genome next  compute  quality score   assembly use  overall reference genome coverage  quality score distribution   scaffold   redundancy identify   use synthetic assemblies randomly generate   latest human genome build various build   reference genomes  five organisms  six  novo assemblies  sample na24385  test dnaqet  assess  capability  benchmarking quality evaluation  genome assemblies  synthetic data  quality score increase  decrease number  misassemblies  redundancy  increase average contig length  coverage  expect  genome build dnaqet quality score calculate    recent reference genome  better   score   older version  compare      frequently use measure   quality measure  calculate  quality score  dnaqet  find   better    measure  term  consistency   know quality   reference genomes indicate  dnaqet  reliable  benchmarking quality assessment   novo genome assemblies  dnaqet   scalable framework design  evaluate   novo genome assembly base   aggregate quality   scaffold  contigs  result demonstrate  dnaqet quality score  reliable  benchmarking quality assessment  genome assemblies  dnqaet  help researchers  identify   suitable assembly tool   select high quality assemblies generated
 dnaqet framework comprise  two main step  align assemble scaffold contigs   trust reference genome    calculate quality score   scaffold   whole assembly   alignment step dnaqet provide two separate alignment tool  users  choose  first one   nucmer pipeline   mummer4 package  whose predecessor  mummer3 package     widely use general purpose alignment tool  map long dna sequence   recently release mummer4 package contain  much faster  memory efficient nucmer version   handle large genomes   recent version   nucmer  use  dnaqet  second option  alignment  dnaqet offer   minimap2 aligner    also   fast pairwise aligner  nucleotide sequence  enhance  computational performance  alignment process  break   three substeps  partition   reference genome   assembly file  smaller chunk  align  partition   assembly   partition   reference genome  parallel  finally  filter  redundant  overlap alignments   scaffold  filter  remain alignments  use  compute  quality score scalable alignment  scaffold   reference genome  dnaqet handle alignment  scaffold   reference genome   parallelize manner  partition  assembly file  multiple approximatelyequal size file   reference genome  multiple reference file  contain  single chromosome additional file  figure  enable  method   scalable  handle assemblies  large genomes  total number  partition file   assembly   determine   user   default value  set  one  tool distribute  scaffold   user specify number  file    way   total number  base pair contain   file would  similar across  partition  partition  genome dnaqet distribute  chromosomes   reference genome  multiple file    assembly partition   align   single chromosome independently   highperformance compute hpc   multithreaded compute environment compute quality score  scaffold  dnaqet parse  alignment result   scaffold  filter   redundant  ambiguous alignments  obtain  longest consistent match   scaffold   reference   purpose  adapt  underlie algorithm  deltafilter utility   mummer package  implement   approach  dnaqet   alignment step  complete either use nucmer  minimap2  alignment result  scan use appropriate parsers specifically design  parse data   correspond alignment format    convert   internal alignment format   filter use  filter algorithm note   filter step  independent   choose alignment tool   apply   alignment result  matter  tool  use  generate    compute  quality score   individual contig use  set  best alignments base   total number  align base pair   scaffold reward  total number  misassembly determine   scaffold penalty   length   scaffold length scale coefficient  reward   scaffold  suppose   directly proportional   total number  base   align   reference genome   alignment tool base   assumption dnaqet assign  reward value denote     scaffold    equivalent   ratio   total number  align base   total number  base   without  scaffold gap 𝑅𝑠𝑇𝑜𝑡𝑎𝑙 𝑛𝑢𝑚𝑏𝑒𝑟  𝑎𝑙𝑖𝑔𝑛𝑒𝑑 𝑏𝑎𝑠𝑒 𝑝𝑎𝑖𝑟𝑠  𝑠𝑇𝑜𝑡𝑎𝑙 𝑛𝑢𝑚𝑏𝑒𝑟  𝑏𝑎𝑠𝑒 𝑝𝑎𝑖𝑟𝑠  𝑠𝑇𝑜𝑡𝑎𝑙 𝑛𝑢𝑚𝑏𝑒𝑟  𝑏𝑎𝑠𝑒 𝑝𝑎𝑖𝑟𝑠  𝑡ℎ𝑒 𝑠𝑐𝑎𝑓𝑓𝑜𝑙𝑑𝑖𝑛𝑔 𝑔𝑎𝑝𝑠    formulation  total number  ambiguous base pair   detect   scaffold gap  subtract   total size   scaffold see  denominator    formula  avoid improper reduction   reward   scaffold  penalty assign   scaffold  directly relate   misassembly   basically summarize   inconsistencies   flank alignments   scaffold   reference  dnaqet  consider three type  misassembly   also consistent   type  definitions   misassembly report  previous literature   misassembly type fig   describe  detail  fig  figure1 illustration  misassembly type  green  blue bar indicate two flank sequence   scaffold   white bar represent regions   reference genome  relocations   distance    overlap   mark  white  yellow bar   reference bar respectively translocation  denote  two chromosomes   arrows depict  directions  strand  red  show  inversion  full size image relocation  type  misassembly   scaffold  happen  two case two consecutive sequence segment   scaffold  align    chromosome   separation distance     base pair fig     align    chromosome   overlap     base pair fig   relocation threshold    base pair  default    adjust   user  distance  overlap   alignments   flank sequence smaller     consider   relocation translocation   type  misassembly   observe   two flank sequence   scaffold  align  two different chromosomes   reference genome fig  inversion   type  misassembly  occur  case   two flank sequence   scaffold  align   opposite strand    chromosome fig   theory one would expect  perfect alignment   reference chromosome scaffold back   however due  gap ambiguous sequence repetitive sequence   reference genome  limitations  alignment algorithms   still possible  observe misalignment  two identical long fragment sequence      consider  artifact  mummer  minimap2 thus dnaqet consider  fact   artifacts   expect even though  scaffold  assemble perfectly   artifacts   correlate   length  assemble scaffold   longer  scaffold    artifacts   expect  dnaqet process  scaffold  compute  penalty  need  decide   misassembly detect   scaffold compare   artifact expect   scaffold   size    give relocation threshold   dnaqet use  regression model  find  expect artifact give  scaffold  size    relocation threshold    use  decide  relocation type  misassembly   reference chromosome dnaqet first randomly create  set  artificial contigsscaffolds  cover  whole chromosome   depth  coverage   contigs along   original reference chromosome sequence  align back   whole reference genome  last  total number  misassembly  compute   contigscaffold    relocation threshold    range      base pair increments  compute artifact  fit   follow model 𝜀𝛼𝑐𝑙𝛽𝑐𝑡𝑘𝑐 via leastsquares regression     artifact     model parameters     intercept   model obtain  chromosome   determine  model parameters   intercept dnaqet fit  observe artifact     chromosomes scaffold   give reference genome    model additional file  table s1s5 provide  compute value   coefficients   chromosomes   latest build  human chimpanzee mouse rat  zebrafish genome assemblies  university  california santa cruz ucsc genome browser web site    model parameters   chromosome   reference  identify dnaqet compute  expect misassembly    scaffold   follow {𝛼𝑐𝑙𝑠𝛽𝑐𝑡𝑢𝑘𝑐𝑖𝑓 𝛼𝑐𝑙𝑠𝛽𝑐𝑡𝑢𝑘𝑐00𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒   denote  length   scaffold    relocation threshold set   user       model coefficients compute  chromosome   contain    alignments  scaffold  finally  penalty assign  scaffold   dnaqet denote    compute  follow {log100 𝑚𝑠𝜀𝑠𝑖𝑓 𝑚𝑠𝜀𝑠 0𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒   represent  total number  misassembly  dnaqet detect   scaffold    difference   observe misassembly    expect artifact    scaffold   specify relocation threshold  less   equal  one    penalty assign   scaffold otherwise  logarithmic value   difference   base    use   penalty  scaffold   length   scaffold   important indication  assembly quality  wellassembled  highquality scaffold   equal   longer   shortest chromosome   trust reference genome    quality  compute  length   shortest chromosome  reference genome   call length scale factor    denote     use   benchmarking value  assess  quality   scaffold    novo assembly thus dnaqet incorporate  coefficient call length scale coefficient   scaffold    quality score calculation formulation   denote    coefficient  compute  respect   shortest reference chromosome length  use  follow equation ⎧⎩⎨⎪⎪1𝑖𝑓 ≥θ𝐺1log10𝑙𝑠θ𝐺 𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒   scaffold  larger   equal   shortest chromosome   reference  length scale coefficient  set    guarantee   contigs  scaffold longer   shortest chromosome   punish   scaffold shorter   shortest chromosome  coefficient value increase   scaffold get longer finally reach one    equal   instead  take  simple ratio   length   scaffold   length   shortest chromosome dnaqet use   function   penalize  small  medium size scaffold  harshly  reward penalty  length scale coefficient  calculate dnaqet integrate    overall quality score  scaffold   use  equation 𝑄𝑠𝐿𝑠𝑅𝑠𝑃𝑠  case dnaqet identify  misassembly   scaffold   misassembly  negligible  quality score  basically equal   alignment ratio   scaffold multiply   length scale coefficient    hand  quality   scaffold decrease   increase number  misassembly detect   scaffold compute quality score  assembly  quality score  individual scaffold  contigs  calculate dnaqet compute  quality score   whole  novo assembly use  individual quality score   redundancy observe   assembly   three factor  dnaqet consider  quality score computation  distribution   quality score  scaffold   assembly   reference genome coverage provide   scaffold  different quality thresholds    redundancy   scaffold   assembly  dnaqet framework use  quality score distribution   scaffold    novo assembly   component   final quality score  utilize  information  ratio   total number  base pair   scaffold  quality score higher  certain quality thresholds   whole assembly size  first plot   correspond quality thresholds       increments   curve see additional file  figure s2a   example  area   curve   calculate   denote     represent  assembly   ideal case   scaffold   assembly   perfect quality score    area   curve  equal  one         always possible  obtain perfectly score scaffold  practice  curve may reach  maximum ratio     lower quality threshold   case   case  would  much lower  one   respect  value directly reflect  quality distribution   scaffold    novo assembly like  cumulative scaffold quality distribution graph  plot  cumulative reference genome coverages   scaffold  meet certain quality thresholds  curve present  crucial information  two perspectives   much reference genome coverage   reach   scaffoldscontigs   assembly     reference coverage change  quality distribution   scaffold   assembly  example  cumulative reference genome coverage graph  give  additional file  figure s2b  dnaqet framework use  area   cumulative genome coverage ratio curve   denote     assembly   another component   overall quality score function  evaluate  assembly  case  whole reference genome  fully cover  perfect scaffold  scaffold   quality score      novo assembly    equal     coverage  less     high coverage  achieve  low quality scaffold dnaqet would reflect  less  ideal case   overall quality score   assembly  assign  much lower value    summary  incorporate    quality score scheme  distinguish two assemblies say      assemblies cover   amount   reference genome  different quality scaffold    case  one  high quality scaffold    larger area   cumulative genome coverage curve hence  higher  value thus  component  incorporate   final quality score formulation   use  distinguish     term   quality  last component  dnaqets assembly quality score scheme   invert redundancy identify   assembly  redundancy   assembly  define   unnecessarily repeatedly assemble sequence    novo assembly    compare   reference genome  example  give  additional file  figure   two scaffold     align   reference genome  alignments    respectively  total cover reference genome  denote    overlap   alignments  denote     share     redundantly   total invert redundancy ratio    novo assembly   set  scaffold   { … }  denote    compute  π𝐴φ𝐴∑∈𝐴𝜆𝑖   represent  total align base pair  scaffold    represent  total cover reference genome size   scaffold  assembly   invert redundancy ratio  always  value        novo assembly   optimal case     redundant alignments  invert redundancy would  equal     ratio get smaller  redundancy   assembly increase  make  assembly less desirable therefore   essential  include   component  measure redundancy   assembly   quality score computation   reason  consider  inverse   redundancy value   assembly  denote    incorporate    formula  dnaqet framework compute  final quality score   assembly  use  equation 𝑄𝐴δ𝐴ω𝐴π𝐴‾‾‾‾‾‾‾‾‾√  final quality score   geometric mean   area   cumulative distribution curve  quality score  scaffold  area   cumulative curve  genome coverage   invert redundancy    novo assembly   three components represent three aspects   desirable assembly  scaffold   high individual quality score  reference genome   mostly cover  high quality scaffold  iii redundancy   assembly   minimal note    three value  define    real value     guarantee   quality value obtain  take  geometric mean would always   real value    interval performance evaluation  dnaqet  evaluate  performance  dnaqets quality score  compare    currently wellestablished metrics three type  data  use  insilico scaffold data generate   latest human reference genome build  hg38  various genome coverages number  misassemblies per scaffold  mean scaffold lengths  various build  whole genome assemblies  five different organisms human mouse rat chimpanzee  zebrafish obtain  ucsc genome browser website   iii six  novo assemblies   sample  national institute  standards  technology nist  hg002  coriell  na24385   genome   bottle giab project   insilico performance analysis  generate four type  synthetic assembly datasets  human reference build hg38     datasets  design  analyze  different aspect   quality computation process  follow  mean scaffold length dataset  generate scaffold  randomly choose coordinate cover hg38   depth  coverage  lengths   scaffold  draw  normal distributions  mean lengths      base pair  standard deviations       respectively  misassembly dataset  randomly create assemblies  contain scaffold                   misassemblies per scaffold  hg38  lengths   scaffold  draw   normal distribution   mean    standard deviation    assembly   total genome coverage   iii coverage dataset assemblies  cover      increments     hg38 build  create randomly  didnt induce  artificial misassemblies   scaffold  lengths   scaffold  draw   normal distribution   mean  standard deviation    redundancy dataset  create assemblies  cover  hg38   twice  three time  four time   finally five time     artificially induce misassemblies   scaffold lengths  normally distribute   mean value    standard deviation   note      describe synthetic datasets  create five different assemblies   value   parameter     analyze  test dnaqet  human reference data  use fifteen build  reference genome assemblies  specifically hg4 hg5 hg6 hg7 hg8 hg10 hg11 hg12 hg13 hg15 hg16 hg17 hg18 hg19  hg38  dnaqet  use  evaluate    genome build   hg38 build since hg38    recent reference genome   expect    best among   build note     reference build   hg1 hg2 hg3 hg9 hg14  miss   study due   unavailability  download  ucsc genome browser data repository similarly   ten available build mm1  mm10  mouse reference genome six build rn1  rn6  rat reference genome six build pantro1  pantro6  chimpanzee reference genome  nine build danrer1 danrer2 danrer3 danrer4 danrer5 danrer6 danrer7 danrer10  danrer11  zebrafish genome  use  latest build mm10 rn6 pantro6  danrer11   reference  mouse rat chimpanzee  zebrafish respectively    rest   build  evaluate  dnaqet  calculate  quality score   chromosome   build    whole reference assemblies two restrictions  impose   datasets    primary chromosomes   build  include   analysis   sake  simplicity    fairly evaluate human mouse  rat genome build    exclude  chromosome   analysis due   lack  availability   chromosome     earlier build  use different build  reference genomes  evaluate dnaqets score  hypothesis    quality score   chromosomes    recent build   reference genome   organism   better     older build   reference genome    organism moreover  overall quality score  dnaqet   older build   lower     later build    organisms use   work  test dnaqet  real genome assemblies  use two  novo assemblies  giab data repository  sample na24385  first assembly  create use celera assembler    available  giab ftp site   second assembly  generate use falcon    available  giab ftp site    four assemblies  generate inhouse use  mecat assembler    pacbio data  four different depth  coverages namely      note   pacbio data  produce   giab consortium   freely available  giab ftp site  quality analysis  synthetic data  first analyze  dnaqets quality score change   mean scaffold length   assemblies increase use  first synthetic dataset  demonstrate  fig   quality score   assemblies increase   average size   scaffold get longer initially  quality score   assemblies  mean scaffold size   base pair concentrate around   quality value monotonically increase  assemblies  larger scaffold finally become slightly larger     assemblies   average   million base pair scaffold   sense  dnaqets quality score  concordant   general assumption   assembly  larger scaffold   better  quality   assembly  shorter scaffold give   assemblies   total length fig  figure2  dnaqet quality score  synthetic datasets  yaxis indicate  quality score  dnaqet compute   synthetic datasets  vary mean scaffold length  number  misassemblies per scaffold  genome coverage   redundancy  full size image use  second dataset  investigate  effect   increase number  misassemblies   dnaqets quality score formulation  show  fig   quality score   assemblies   artificially induce misassembly  slightly larger      introduction   misassemblies per scaffold   assembly  observe  quality score drop     trend  decrease  quality score continue   increase misassembly number  finally quality score settle      assemblies   misassemblies per scaffold  result  concordant   expectation   assembly  lower number  misassemblies    higher quality   one   misassemblies   respect  quality score formulation correctly characterize  effect  misassemblies   quality   assembly  fig   present  effect  increase genome coverage  dnaqets quality score  expect  quality   assembly  higher genome coverage  consistently higher     assembly  lower coverage  highest quality score  obtain  assemblies   coverage whereas  lowest quality score  around    coverage assemblies  result demonstrate  dnaqets quality score behave  expect  change genome coverage value finally  investigate  effect   redundancy   quality score formulation  present  fig   compute  quality score  datasets        genome coverages   coverages    correspond  redundant assemblies  present  fig   quality score   assemblies decrease   redundancy increase  result  concordant   hypothesis  assemblies  unnecessary repeat scaffold    lower quality  concise assemblies overall  result  obtain use synthetic data reflect  capability  dnaqets quality score  capture  combine different aspects  quality evaluation   single formula quality  reference genome build  five organisms  quality score distribution  chromosomes  different build  reference genomes   five organisms  give  fig   segregation  reference genome build  clear   five organisms  term   quality score  chromosomes calculate  dnaqet  example  quality score distributions  human reference genome build fig  reveal  approximately    chromosomes   earlier versions  human reference genome  build hg4  hg6  quality score   range      contrast  quality score   chromosomes   newer build hg7  hg12  improve   range      include      chromosomes   worst case  shift   quality score towards  higher quality bin continue  reach  point       chromosomes  hg13  quality score     majority   chromosomes  build hg15  hg16  quality score   range     whereas  majority   hg17 hg18  hg19 chromosomes  quality score     finally  percentage   highquality chromosomes  chromosomes  quality score higher   reach    build hg38 fig  figure3 heatmaps  quality score  chromosomes  scaffold   reference genome build  five organisms    novo assemblies  na24385  xaxis depict  build  assemblies  yaxis indicate  ten quality score bin      color give   legend show  percentage   chromosomes  scaffold  fall   quality bin indicate   yaxis  quality score heatmaps   human  mouse  rat  chimpanzee   zebrafish  reference chromosomes  specify build   scaffold   novo assemblies  sample na24385   six different assemblies note     quality interval bin divide    range  nine equal size leftclosed rightopen intervals   single close interval     full size image similarly  find     clear segregation   quality score  chromosomes   earlier    recent versions   mouse reference genomes  present  fig    earlier versions    build mm2  mm6  quality score  chromosomes  concentrate     interval however majority   chromosomes  build mm7  quality score     bin    hand  ratio  medium  high quality chromosomes  chromosomes   quality higher    less   gradually increase  build mm8  mm9 finally      chromosomes   latest build mm10  quality score higher   overall   five organisms  chromosome quality score  dnaqet  higher   recent build  result  concordant   hypothesis  evidently demonstrate  dnaqet could  use  fairly evaluate quality  scaffold  contigs additionally  present  individual quality score   chromosomes   genome build   consider organisms  additional file  figure   final quality score compute  dnaqet   reference genome build   five organisms    novo assemblies  na24385  plot  fig   quality score    recent versions   genome build  consistently higher   older build except one case  quality score   zebrafish reference genome build danrer6   slightly smaller quality score   older build danrer5 examine  quality score  human reference genome build fig   observe   quality score almost monotonically increase    hg4     hg13   quality score  hg15 jump      quality score stabilize  around     recent build   hg19  keep  slow increase rate finally  quality score reach   hg38  dramatic quality shift  hg13  hg15  concurrent   introduction   first finish human genome assembly date april    result clearly show   later versions   human reference genome build  higher quality score  dnaqet    consistent   expectation   build quality increase   newly introduce build fig  figure4 quality score  reference genome build   novo assemblies  na24385  xaxis depict  build  assemblies  yaxis indicate quality score  dnaqet compute   reference genome build  human  mouse  rat  chimpanzee  zebrafish     novo assemblies  na24385   yellow bar show  final quality score   line give  area   cumulative scaffold quality score distribution curve  blue  area   cumulative genome coverage curve  light brown   invert duplication ratio  grey full size image   interest  note  dnaqet give  quality score    hg38 instead   perfect score   since hg38  score      possible  compute  perfect score  hg38 even    compare back   due   ambiguous base pair  contain    genome   misassembly observe due   repetitive sequence  may  cause misalignment since dnaqet take  artifacts due  alignment tool  consideration  compute  nearly perfect score  hg38 assembly   also important  note   quality score   latest build  rat chimpanzee  zebrafish genomes  remarkably higher     predecessor build  strike quality shift   rat build rn5  rn6 could  attribute   introduction  additional pacbio data   coverage   assembly process  similarly  zebrafish reference build danrer11   significantly higher quality score  danrer10 due  additional assemblies wgs29 caak00000000  wgs32 czqb00000000 add  necessary  fill  gap  finally  quality score   recently introduce chimpanzee genome build pantro6  much higher    pantro5    high depth  coverage  data use   assembly   threestage progressive assembly methodology  incorporate data  multiple platforms  since     tool   literature  could report  single quality score  unify multiple measure    novo assembly  could  directly compare  quality score  dnaqet compute   assembly build   tool consequently  decide  compare  rank   dnaqet quality score   rank  quastlg metrics   build quastlg could provide  quality metrics  compare multiple assemblies  except benchmarking universal singlecopy orthologs busco completeness  kmerbased completeness  metrics require  read use  generate  assemblies  remain  quastlg quality metrics  calculate  almost   reference genome build except metrics   na75 ng75 nga50 nga75 etc  could   compute     earlier build  zebrafish  mouse   consistent   comparison across multiple organisms metrics    report   reference build   organisms  discard result  metrics   report   reference genome build  quastlg  provide  clear rank   build without  tie see additional file  table s6s10  detail  next compute pearson correlation coefficients   rank provide     quality metrics   rank   build  hypothesis  determine  rank   build   recent  build   better   quality  thus  higher rank    result give  table  show   rank   dnaqet quality score always   highest pearson correlation coefficients   consistent   inherent rank dictate   hypothesis  result demonstrate   dnaqet quality score reflect  quality   genome build better      metrics due   sophisticate design  combine different aspects   assembly   single value table   pearson correlation coefficients   rank  quality score yield  dnaqet  quastlg   rank   reference genome build  hypothesis full size table although  genome fraction   quastlg achieve   performance   dnaqet quality score  term   rank  genome build  human mouse rat  chimpanzee dnaqet quality score outperform  genome fraction  metric  rank   build  zebrafish genome like  genome fraction  metric  single metric  quastlg table    able  reliably rank  genome build compare  dnaqet quality score  thus   suitable  assess quality   novo assemblies   whole  metrics focus   one side   assemblies  evaluate   examine    single perspective  instance  genome fraction   report  much   reference genome  cover    novo assembly without consider  quality   individual scaffold   reference genome build  total genome fraction  increase almost every time    recent build   may    case    novo assemblies  example one assembly might   slightly higher genome fraction   lower n50  na50 value  higher number  misassemblies  another assembly  another case  genome fraction   multiple assemblies may indicate  reverse rank   assemblies    rank  respect  another metric another example  demonstrate  inconsistency   metrics   poor performance  metrics   number  indels per 100kbp number  mismatch per 100kbp na50 la50    use  rank  chimpanzee genome build although  metrics rank  high pearson correlation coefficients  use  human mouse rat  zebrafish data  considerably fail  correctly rank chimpanzee genome build therefore assess  quality   assembly use one metric  quastlg could  provide sufficient information   overall quality  see  clear need   quality metric  unify  multiple crucial metrics   single quality value    use  reliably assess  quality   assembly  need  meet   meticulously design quality score formulation  dnaqet  unite multiple metrics   single metric quality  six na24385 assemblies  quality score distributions   contigs   six assemblies  plot   fig  none   six assemblies   contigs   quality score higher    mecat assemblies generate     coverage data  contigs  quality score higher     percentage   contigs      perspective none   real data assemblies   outstanding performance  term   contig quality score   interest  note   best perform assemblies  generate  mecat   data      coverages      contigs   assemblies  quality score higher    contrast  mecat falcon  celera assemblies       contigs  quality score higher   respectively  overall quality score compute  dnaqet   six  novo assemblies  present  fig   assemblies generate  mecat assembler  high coverage data      best quality score   celera assembly also   quality score     slightly lower   score   lead assemblies  assembly generate  mecat use  coverage   quality score    follow   assembly  falcon  quality score    lowest quality score    obtain  mecat assembly create   coverage data    surprise    generate    low coverage data  also evaluate  assemblies use quastlg  compute quality metrics  present  additional file  table s11  mention     metrics produce multiple rank   assemblies  contradict     instance use na50 metric  assemblies  rank  mecat70x mecat50x falcon celera mecat25x  mecat5x   decrease order  higher  na50 better  assembly however  rank  completely change  celera falcon mecat50x mecat70x mecat25x  finally mecat5x  genome fraction   use   rank metric   decrease order  number  misassemblies metric  use  order   rank  mecat5x mecat25x mecat70x mecat50x celera  falcon   increase number  misassemblies  lower  misassembly better  assembly thus   evident   result     need  consolidate  metrics   single value    dnaqet  fairly evaluate  overall quality   assemblies since    inherent rank   real data assemblies available  compare  rank  quastlg metrics    dnaqet score  use  approach propose    infer  reliable rank  would  consider closest   grind truth   study  author calculate  zscores   metric   assemblies  consideration  sum  score  finally rank  assemblies base   sum zscores   call  zscorebased rank  obtain  grind truth rank   assemblies  apply  similar approach   metrics  give  clear rank   assemblies without  tie   commonly report   assemblies compute  quastlg  calculate  zscore   metric  sum  zscores   assembly  present  additional file  table s11 accord   zscorebased rank  rank   assemblies  mecat70x mecat50x mecat25x celera falcon  mecat5x  decrease order  higher  zscore better  assembly  pearson correlation coefficient  dnaqet quality score rank   assemblies   zscorebased rank   whereas  quastlg metrics namely largest contig n50 ng50 n75 l50 lg50 l75 largest alignment nga50  na75 provide  secondhigh correlation coefficient value     result indicate  dnaqets quality score outperform   metrics base   zscorebased rank runtime  peak memory usage  compare  runtime  memory performances  dnaqet    quastlg use  human reference genome build   six  novo assemblies  sample na24385   benchmarking test     server   gigabytes  memory run  core  intel xeon   50ghz cpus   able  fairly evaluate  performance  dnaqet  quastlg  partition neither  reference genome   input genome build   evaluate  dnaqet  quastlg  run use  thread   single server  minimap2  use   alignment tool  runtime  peak memory usage  dnaqet  quastlg   human reference genome build    novo assemblies  present  fig  clearly  runtime  dnaqet   stable across   human reference genome build   take     worst case  dnaqet  process  human reference genome build    hand quastlg perform poorly   earlier build fig   example quastlg take approximately    finish process build hg4 quastlg perform better    recent build   runtime  decrease  approximately      recent build   six na24385 assemblies dnaqet  faster  quastlg  process  assemblies fig   take    dnaqet  process  celera assembly    slowest performance  dnaqet   assemblies    hand quastlgs best runtime     mecat5x assembly fig  figure5 runtime  peak memory usage  dnaqet blue bar  quastlg orange bar runtimes  process  human reference genome build    six assemblies  na24385   plot   bar leave yaxis  peak memory usages  gigabytes  plot   line right yaxis  dnaqet gray line  quastlg yellow line full size image  term   peak memory usage  tool use    gigabytes  memory  analyze  human reference build  dnaqets memory usage increase  hg8  hg10 reach   gigabytes  average  stabilize   number   later build however quastlg   steady peak memory usage   gigabytes  build hg4  hg13  start  hg15  peak memory usage go  reach  gigabytes  hg38  na24385 assemblies  peak memory usage  dnaqet stay stable  around  gigabytes whereas quastlgs memory usage  stable  around  gigabytes  result demonstrate dnaqet outperform quastlg  term  execution time   tool  comparable peak memory usage",-0.15059355960392504,0.19401785037964284,0.109356036162729,0.13416199196332798,-0.020650878820401074,-0.013064684882340638,-0.08908969277732515,0.04746372086019742,-0.032191864224288234,0.0943897083166272,0.01292635977275665,-0.014363291632462959,0.14721602470051126,-0.09054749653669507,0.12171003082659736,-0.05979174513081875,0.02353679918479873,0.17805019360843835,-0.04659199189535184,0.06586149228544308,0.044230199194150124,-0.17882544736562325,0.048008328299111454,0.00028797785200517705,0.0010347530096288208,-0.15592512498259758,0.015842703420909116,-0.1755876334688081,-0.05377468163051487,-0.07581764542042199,0.013201584363915256,0.2358467719419705,-0.1489575777964198,-0.0788151163631892,0.1643535784153376,0.12149608158671125,0.061902171757215685,0.025250833137315985,-0.09370411330294767,-0.10464682098112796,-0.08220847021322411,-0.13992496073280153,-0.06372778935800108,-0.07968403276317806,-0.12826570058575126,-0.03015971258541124,0.16530634223366247,-0.13321892667335813,-0.1844715150575776,-0.38007850906749213,0.14510567199071092,-0.028539278667738317,0.058304427418360075,0.5760350877059415,0.017609345455749045,-1.1007850744652987,0.0519318433199536,-0.15319343582901138,0.9048675206463512,0.16237675411425367,-0.1561517100172993,0.2782083372042777,-0.1139728183068427,0.05066155222717668,0.5131352645279736,0.036110731102544806,0.03991808248451693,0.020945535028774147,0.1818521666691494,-0.1461869394877779,-0.029741859452635612,-0.015459088755394637,0.09374114324231053,-0.0954157496525575,0.18669330620815167,-0.04326283560735305,-0.10581666277163074,-0.13763673661284145,-0.30019332610871435,-0.0760912322558103,0.17586750520691738,-0.014605900631361022,-0.3520030397935404,-0.028397542333966668,-0.7903834631412232,0.028222721850663893,0.15777229873574056,-0.11296194827190956,-0.0888006243427905,-0.0601344140863884,-0.17325479734691074,0.06335354430803189,-0.13954566257843562,-0.09607808574544996,-0.14504600116076435,-0.07850011332913646,-0.0971999737329523,-0.2441839200778444,0.2824740001249762,0.0871158236403449,AssemblyEvaluation,12
223,223,"laser large genome assembly evaluator
genome assembly   fundamental problem  multiple applications current technological limitations   allow assemble  entire genomes  many program   design  produce longer   reliable contigs assess  quality   assemblies  compare  produce  different tool  essential  choose  best ones  quast program  become  current stateoftheart  quality assessment  genome assemblies   drawback  quast  high time  memory usage  large genomes    days     ram   single human genome assembly  introduce laser  new tool  assembly evaluation  improve greatly  speed  memory requirements  quast   human genome assembly laser   time faster  quast  use  half  memory one human genome assembly  evaluate   hours instead   days  code  laser  base    quast  therefore inherit   feature genome assembly evaluation   essential step  assess  quality   assembly    often  improperly  part due  significant resource consumption   introduction  laser proper evaluation   perform efficiently
  time consume stage  quast   far  maximal exact match mem computation step   alignment process perform use  nucmer aligner  mummer    recent emem tool  clearly outperform   mummer  also  currently best tool  mem computation  large genomes    therefore  natural choice  replace mummer besides use emem  perform  number   improvements  well  large number  redundant string copy operations  large string   showsnp utility program   mummer toolkit   avoid  memory  performance  python code  improve  replace class object  tuples  rest  quast code   reuse  laser mummer  glimmerhmm   open source   author  genemarks   kindly allow   use  code  laser   result  mention   feature  quast   preserve  laser   design   use exactly   way  quast   laser produce exactly   output  advantage  laser consist  greatly increase speed  reduce memory usage  prove  claim   compare laser  quast  several datasets present  table     interest  improvement   really matter    large genomes  datasets  human    produce  illumina hiseq2000 machine  datasets  assemble use soapdenovo2   use soapdenovo2    good speed  kmer size produce  best assembly  indicate   align n50 size  use               datasets  assemblies  available  download   website  laser table   datasets use  comparison accession number  include   datasets    correspond reference genomes dataset        organism        accession number        read length        number  read        total         depth  coverage        reference genome        genome length         homo sapiens        srr1302280                                        build                  homo sapiens        err194146                                        build                  homo sapiens        err194147                                        build                  homo sapiens        err324433                                        build                  homo sapiens        erx069505                                        build          open   separate window  test  perform   dell poweredge r620 computer   core intel xeon  'ghz     ram run linux red hat centos  figure  give  time  memory comparison  quast  laser   soapdenovo2 assemblies produce   datasets  table  laser   time faster  quast  use half  memory  external file  hold  picture illustration etc object name  13104_2015_1682_fig1_htmljpg fig  comparison visual comparison   time leave plot  memory right plot  quast  laser   conclusions  hope   improvement  genome assembly evaluation provide  laser   boost  use  thorough quality evaluation n50  still use    important parameter n50   length     sum   lengths   contigs  length      least half   total length   contigs  aggressive assembler  produce  high n50    cost  many misassemblies thus lower  overall quality therefore  combination  parameters  provide  quast  laser give  much better evaluation   actual assembly quality",-0.1980608836787849,0.26742182683238785,0.15512649041870488,0.06973095864894527,0.0028703584925849628,-0.07885542470191059,-0.09708433271213114,0.04453603775505928,-0.041156806490295725,0.1261405170441541,0.028639653589223223,-0.06493893544719523,0.19009993478100332,-0.1189448842357298,0.07746652695490851,-0.10581394934882248,0.08815742259371448,0.2283826959655612,-0.04036111734729212,0.1355639890961325,-0.03319322270469676,-0.20130016628034605,0.034323293091488426,0.021931986348575044,0.015312543229183887,-0.13663326838085876,-0.0066588402207406906,-0.17559966916150158,-0.04898676106501531,-0.02500494697295804,0.0014006357909991116,0.28400673620966826,-0.18852713668381726,-0.06348192871443863,0.19978756424210714,0.14461406784690115,0.008731599300015911,0.04182402291365273,-0.1024565442215856,-0.15084917383200233,-0.0832251755777618,-0.17953087322680875,0.0017742729446738317,-0.06927087866241546,-0.11603458996075365,-0.040370406666248713,0.14457821287937647,-0.1901680159167756,-0.15913892213399686,-0.39186449191966577,0.14858737441004607,0.00422786032893406,0.0363489871634901,0.6402500238237453,0.013223660666222587,-1.3358066083686748,0.0280995343025003,-0.179904190710533,1.1325709439562193,0.1612958121936415,-0.12277946035552804,0.3287614816478614,-0.11816833699262573,0.12084175349747088,0.583648848155682,0.009994160781357566,0.06295781963854097,0.018115781116899474,0.2342655326255822,-0.13576092027179928,0.020966412632019614,-0.002372510117029065,0.11292190974726793,-0.1317778378830428,0.2072607610085658,0.009194167213442187,-0.119870181446333,-0.08792522731578331,-0.3692797894392901,-0.06532313956659923,0.2670855921929489,-0.03721658680949296,-0.35249152240455794,-0.04819297071060583,-0.9742436008161568,0.07401983073791127,0.17618806410885962,-0.16769524552138795,-0.11205333226173717,-0.053510928381001584,-0.12023323915240453,0.06504503035303688,-0.05424733314129267,-0.06686161171066864,-0.1601714667641349,-0.09524327442892988,-0.09926466242980277,-0.3473600599541457,0.4321097441134043,0.10016924943067416,AssemblyEvaluation,12
